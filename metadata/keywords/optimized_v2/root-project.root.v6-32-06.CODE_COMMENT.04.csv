quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability,"/// Consider the following situation when coalescing the copy between; /// %31 and %45 at 800. (The vertical lines represent live range segments.); ///; /// Main range Subrange 0004 (sub2); /// %31 %45 %31 %45; /// 544 %45 = COPY %28 + +; /// | v1 | v1; /// 560B bb.1: + +; /// 624 = %45.sub2 | v2 | v2; /// 800 %31 = COPY %45 + + + +; /// | v0 | v0; /// 816 %31.sub1 = ... + |; /// 880 %30 = COPY %31 | v1 +; /// 928 %45 = COPY %30 | + +; /// | | v0 | v0 <--+; /// 992B ; backedge -> bb.1 | + + |; /// 1040 = %31.sub0 + |; /// This value must remain; /// live-out!; ///; /// Assuming that %31 is coalesced into %45, the copy at 928 becomes; /// redundant, since it copies the value from %45 back into it. The; /// conflict resolution for the main range determines that %45.v0 is; /// to be erased, which is ok since %31.v1 is identical to it.; /// The problem happens with the subrange for sub2: it has to be live; /// on exit from the block, but since 928 was actually a point of; /// definition of %45.sub2, %45.sub2 was not live immediately prior; /// to that definition. As a result, when 928 was erased, the value v0; /// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an; /// IMPLICIT_DEF was inserted as a ""backedge"" definition for %45.sub2,; /// providing an incorrect value to the use at 624.; ///; /// Since the main-range values %31.v1 and %45.v0 were proved to be; /// identical, the corresponding values in subranges must also be the; /// same. A redundant copy is removed because it's not needed, and not; /// because it copied an undefined value, so any liveness that originated; /// from that copy cannot disappear. When pruning a value that started; /// at the removed copy, the corresponding identical value must be; /// extended to replace it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:646,redundant,redundant,646,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,2,['redundant'],['redundant']
Availability,"/// Consider the pressure increase caused by traversing this instruction; /// top-down. Find the pressure set with the most change beyond its pressure; /// limit based on the tracker's current pressure, and record the number of; /// excess register units of that pressure set introduced by this instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:82,down,down,82,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,1,['down'],['down']
Availability,"/// Consider the pressure increase caused by traversing this instruction; /// top-down. Find the register class with the most change in its pressure limit; /// based on the tracker's current pressure, and return the number of excess; /// register units of that pressure set introduced by this instruction.; ///; /// This assumes that the current LiveIn set is sufficient.; ///; /// This is expensive for an on-the-fly query because it calls; /// bumpDownwardPressure to recompute the pressure sets based on current; /// liveness. We don't yet have a fast version of downward pressure tracking; /// analogous to getUpwardPressureDelta.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:82,down,down,82,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,2,['down'],"['down', 'downward']"
Availability,"/// Constant fold a zext, sext or trunc, depending on IsSigned and whether the; /// DestTy is wider or narrower than C. Returns nullptr on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:139,failure,failure,139,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,1,['failure'],['failure']
Availability,"/// Construct SSA form, materializing a value that is live in the; /// middle of the specified block.; ///; /// \c GetValueInMiddleOfBlock is the same as \c GetValueAtEndOfBlock except; /// in one important case: if there is a definition of the rewritten value; /// after the 'use' in BB. Consider code like this:; ///; /// \code; /// X1 = ...; /// SomeBB:; /// use(X); /// X2 = ...; /// br Cond, SomeBB, OutBB; /// \endcode; ///; /// In this case, there are two values (X1 and X2) added to the AvailableVals; /// set by the client of the rewriter, and those values are both live out of; /// their respective blocks. However, the use of X happens in the *middle* of; /// a block. Because of this, we need to insert a new PHI node in SomeBB to; /// merge the appropriate values, and this value isn't live out of the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:495,Avail,AvailableVals,495,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,1,['Avail'],['AvailableVals']
Availability,"/// Construct a FormatStyle based on ``StyleName``.; ///; /// ``StyleName`` can take several forms:; /// * ""{<key>: <value>, ...}"" - Set specic style parameters.; /// * ""<style name>"" - One of the style names supported by; /// getPredefinedStyle().; /// * ""file"" - Load style configuration from a file called ``.clang-format``; /// located in one of the parent directories of ``FileName`` or the current; /// directory if ``FileName`` is empty.; /// * ""file:<format_file_path>"" to explicitly specify the configuration file to; /// use.; ///; /// \param[in] StyleName Style name to interpret according to the description; /// above.; /// \param[in] FileName Path to start search for .clang-format if ``StyleName``; /// == ""file"".; /// \param[in] FallbackStyle The name of a predefined style used to fallback to; /// in case \p StyleName is ""file"" and no file can be found.; /// \param[in] Code The actual code to be formatted. Used to determine the; /// language if the filename isn't sufficient.; /// \param[in] FS The underlying file system, in which the file resides. By; /// default, the file system is the real file system.; /// \param[in] AllowUnknownOptions If true, unknown format options only; /// emit a warning. If false, errors are emitted on unknown format; /// options.; ///; /// \returns FormatStyle as specified by ``StyleName``. If ``StyleName`` is; /// ""file"" and no file is found, returns ``FallbackStyle``. If no style could be; /// determined, returns an Error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:1232,error,errors,1232,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,2,"['Error', 'error']","['Error', 'errors']"
Availability,/// Construct a GsymReader from a buffer.; ///; /// \param Bytes A set of bytes that will be copied and owned by the; /// returned object on success.; /// \returns An expected GsymReader that contains the object or an error; /// object that indicates reason for failing to read the GSYM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:218,error,error,218,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,1,['error'],['error']
Availability,/// Construct a GsymReader from a file on disk.; ///; /// \param Path The file path the GSYM file to read.; /// \returns An expected GsymReader that contains the object or an error; /// object that indicates reason for failing to read the GSYM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:175,error,error,175,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,1,['error'],['error']
Availability,/// Construct a InProcessJITCompileCallbackManager.; /// @param ErrorHandlerAddress The address of an error handler in the target; /// process to be used if a compile callback fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h:64,Error,ErrorHandlerAddress,64,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h,2,"['Error', 'error']","['ErrorHandlerAddress', 'error']"
Availability,/// Construct a VPPredInstPHIRecipe given \p PredInst whose value needs a phi; /// nodes after merging back from a Branch-on-Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:125,Mask,Mask,125,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['Mask'],['Mask']
Availability,"/// Construct a fallible iterator that *cannot* be used as an end-of-range; /// value.; ///; /// A value created by this method can be dereferenced, incremented,; /// decremented and compared, providing the underlying type supports it.; ///; /// The error that is passed in will be initially marked as checked, so if the; /// iterator is not used at all the Error need not be checked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:250,error,error,250,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// Construct a matcher from the registry and bind it.; ///; /// Similar the \c constructMatcher() above, but it then tries to bind the; /// matcher to the specified \c BindID.; /// If the matcher is not bindable, it sets an error in \c Error and returns; /// a null matcher.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Registry.h:225,error,error,225,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Registry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Registry.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// Construct a matcher from the registry.; ///; /// \param Ctor The matcher constructor to instantiate.; ///; /// \param NameRange The location of the name in the matcher source.; /// Useful for error reporting.; ///; /// \param Args The argument list for the matcher. The number and types of the; /// values must be valid for the matcher requested. Otherwise, the function; /// will return an error.; ///; /// \return The matcher object constructed if no error was found.; /// A null matcher if the number of arguments or argument types do not match; /// the signature. In that case \c Error will contain the description of; /// the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Registry.h:196,error,error,196,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Registry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Registry.h,5,"['Error', 'error']","['Error', 'error']"
Availability,"/// Construct a new MinidumpFile object from the given memory buffer. Returns; /// an error if this file cannot be identified as a minidump file, or if its; /// contents are badly corrupted (i.e. we cannot read the stream directory).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h:86,error,error,86,interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,1,['error'],['error']
Availability,/// Construct a parsed source location from a string; the Filename is empty on; /// error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CommandLineSourceLoc.h:84,error,error,84,interpreter/llvm-project/clang/include/clang/Frontend/CommandLineSourceLoc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CommandLineSourceLoc.h,1,['error'],['error']
Availability,"/// Construct a pool using the hardware strategy \p S for mapping hardware; /// execution resources (threads, cores, CPUs); /// Defaults to using the maximum execution resources in the system, but; /// accounting for the affinity mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h:230,mask,mask,230,interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,1,['mask'],['mask']
Availability,"/// Construct an APInt from a string representation.; ///; /// This constructor interprets the string \p str in the given radix. The; /// interpretation stops when the first character that is not suitable for the; /// radix is encountered, or the end of the string. Acceptable radix values; /// are 2, 8, 10, 16, and 36. It is an error for the value implied by the; /// string to require more bits than numBits.; ///; /// \param numBits the bit width of the constructed APInt; /// \param str the string to be interpreted; /// \param radix the radix to use for the conversion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:330,error,error,330,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['error'],['error']
Availability,"/// Constructing a TestAST parses the virtual file.; ///; /// To keep tests terse, critical errors (e.g. invalid flags) are reported as; /// unit test failures with ADD_FAILURE() and produce an empty ASTContext,; /// Sema etc. This frees the test code from handling these explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:92,error,errors,92,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,2,"['error', 'failure']","['errors', 'failures']"
Availability,/// Constructor for availability attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:20,avail,availability,20,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['avail'],['availability']
Availability,"/// Constructor overload that's only available for a 1-dimensional histogram,; /// also passing the histogram title.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:37,avail,available,37,hist/histv7/inc/ROOT/RHist.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx,1,['avail'],['available']
Availability,"/// Constructor overload that's only available for a 1-dimensional histogram.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:37,avail,available,37,hist/histv7/inc/ROOT/RHist.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx,1,['avail'],['available']
Availability,"/// Constructor overload that's only available for a 2-dimensional histogram,; /// also passing the histogram title.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:37,avail,available,37,hist/histv7/inc/ROOT/RHist.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx,1,['avail'],['available']
Availability,"/// Constructor overload that's only available for a 2-dimensional histogram.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:37,avail,available,37,hist/histv7/inc/ROOT/RHist.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx,1,['avail'],['available']
Availability,"/// Constructor overload that's only available for a 3-dimensional histogram,; /// also passing the histogram title.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:37,avail,available,37,hist/histv7/inc/ROOT/RHist.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx,1,['avail'],['available']
Availability,"/// Constructor overload that's only available for a 3-dimensional histogram.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:37,avail,available,37,hist/histv7/inc/ROOT/RHist.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx,1,['avail'],['available']
Availability,"/// Constructor that takes the argument to be replaced, the types of; /// the replacement arguments, as well as callbacks to repair the call sites; /// and new function after the replacement happened.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:125,repair,repair,125,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['repair'],['repair']
Availability,"/// Constructor with only parameter values, edm and nfcn, but without errors (covariance).; /// The resulting state it will be considered valid, since it contains the parameter values,; /// although it has not the error matrix (MinimumError) and HasCovariance() returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MinimumState.h:70,error,errors,70,math/minuit2/inc/Minuit2/MinimumState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MinimumState.h,2,['error'],"['error', 'errors']"
Availability,"/// Constructor with parameters values, errors and gradient",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MinimumState.h:40,error,errors,40,math/minuit2/inc/Minuit2/MinimumState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MinimumState.h,1,['error'],['errors']
Availability,/// Constructs an error related to a new replacement and an existing; /// replacement in a set of replacements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:18,error,error,18,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,1,['error'],['error']
Availability,/// Constructs an error related to an existing replacement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:18,error,error,18,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,1,['error'],['error']
Availability,"/// Consume a Error without doing anything. This method should be used; /// only where an error can be considered a reasonable and expected return; /// value.; ///; /// Uses of this method are potentially indicative of design problems: If it's; /// legitimate to do nothing while processing an ""error"", the error-producer; /// might be more clearly refactored to return an std::optional<T>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:14,Error,Error,14,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,4,"['Error', 'error']","['Error', 'error', 'error-producer']"
Availability,"/// Consume an Error and return the raw enum value contained within it, and; /// the optional error message. The Error must either be a success value, or; /// contain a single InstrProfError.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:15,Error,Error,15,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,3,"['Error', 'error']","['Error', 'error']"
Availability,/// Consume the next token and error if it is not \a TK.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h:31,error,error,31,interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h,1,['error'],['error']
Availability,/// Consume tokens and store them in the passed token container until; /// we've passed the try keyword and constructor initializers and have consumed; /// the opening brace of the function body. The opening brace will be consumed; /// if and only if there was no error.; ///; /// \return True on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:264,error,error,264,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,2,['error'],['error']
Availability,"/// ConsumeAnyToken - Dispatch to the right Consume* method based on the; /// current token type. This should only be used in cases where the type of; /// the token really isn't known, e.g. in error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:193,error,error,193,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,2,"['error', 'recover']","['error', 'recovery']"
Availability,"/// Contains parsed binary for each path, or parsing error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h:53,error,error,53,interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,1,['error'],['error']
Availability,/// Contains the combination of the lane masks of all subregisters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h:41,mask,masks,41,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,1,['mask'],['masks']
Availability,"/// Contains the information about the kind of vectorization; /// available.; ///; /// This object in independent on the paradigm used to; /// represent vector functions. in particular, it is not attached to; /// any target-specific ABI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h:66,avail,available,66,interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h,1,['avail'],['available']
Availability,"/// Context for overloaded matcher construction.; ///; /// This context will take care of merging all errors that happen within it; /// as ""candidate"" overloads for the same matcher.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h:102,error,errors,102,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,1,['error'],['errors']
Availability,"/// Context to temporarily change the error logging mode as long as the context is alive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:38,error,error,38,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,2,"['alive', 'error']","['alive', 'error']"
Availability,/// Controls whether otherwise-unmapped extension diagnostics are; /// mapped onto ignore/warning/error.; ///; /// This corresponds to the GCC -pedantic and -pedantic-errors option.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:98,error,error,98,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,2,['error'],"['error', 'errors']"
Availability,/// Convenience function for setting multiple fast-math flags.; /// FMF is a mask of the bits to set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Operator.h:77,mask,mask,77,interpreter/llvm-project/llvm/include/llvm/IR/Operator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Operator.h,1,['mask'],['mask']
Availability,"/// Convenience method for printing ""error: "" to stderr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h:37,error,error,37,interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h,1,['error'],['error']
Availability,"/// Convenience method for printing ""error: "" to the given stream.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h:37,error,error,37,interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h,1,['error'],['error']
Availability,/// Convenience wrapper to make a fallible_iterator value from an instance; /// of an underlying iterator and an Error reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:113,Error,Error,113,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,1,['Error'],['Error']
Availability,/// Conversion from Error to LLVMErrorRef for C error bindings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:20,Error,Error,20,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,2,"['Error', 'error']","['Error', 'error']"
Availability,/// Conversion from LLVMErrorRef to Error for C error bindings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:36,Error,Error,36,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// Conversion of StreamingDiagnostic to bool always returns \c true.; ///; /// This allows is to be used in boolean error contexts (where \c true is; /// used to indicate that an error has occurred), like:; /// \code; /// return Diag(...);; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:117,error,error,117,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,2,['error'],['error']
Availability,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 128-bit vector of [4 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:64,mask,mask,64,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,4,['mask'],['mask']
Availability,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 256-bit vector of [8 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:64,mask,mask,64,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,4,['mask'],['mask']
Availability,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 512-bit vector of [16 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 16-bit mask.; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \returns A 512-bit vector of [16 x float] come from conversion of __A,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:64,mask,mask,64,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,3,['mask'],['mask']
Availability,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 16-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \returns A 512-bit vector of [16 x float] come from conversion of __A,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:64,mask,mask,64,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,3,['mask'],['mask']
Availability,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:64,mask,mask,64,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,3,['mask'],['mask']
Availability,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:64,mask,mask,64,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,3,['mask'],['mask']
Availability,"/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [4 x float].; /// \param __U; /// A 4-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element is zero.; /// \returns A 128-bit vector of [8 x bfloat] whose lower 64 bits come from; /// conversion of __A, and higher 64 bits are 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:257,mask,mask,257,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,1,['mask'],['mask']
Availability,"/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [4 x float].; /// \param __W; /// A 128-bit vector of [8 x bfloat].; /// \param __U; /// A 4-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element from __W.; /// \returns A 128-bit vector of [8 x bfloat] whose lower 64 bits come from; /// conversion of __A, and higher 64 bits are 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:312,mask,mask,312,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,1,['mask'],['mask']
Availability,/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [8 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element is zero.; /// \returns A 128-bit vector of [8 x bfloat] comes from conversion of __A.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:257,mask,mask,257,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,1,['mask'],['mask']
Availability,/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [8 x float].; /// \param __W; /// A 256-bit vector of [8 x bfloat].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element from __W.; /// \returns A 128-bit vector of [8 x bfloat] comes from conversion of __A.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:312,mask,mask,312,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,1,['mask'],['mask']
Availability,/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 512-bit vector of [16 x float].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element is zero.; /// \returns A 256-bit vector of [16 x bfloat] come from conversion of __A.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:259,mask,mask,259,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,1,['mask'],['mask']
Availability,/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 512-bit vector of [16 x float].; /// \param __W; /// A 256-bit vector of [16 x bfloat].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element from __W.; /// \returns A 256-bit vector of [16 x bfloat] come from conversion of __A.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:315,mask,mask,315,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,1,['mask'],['mask']
Availability,/// Convert Regex string error to an error object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkCounter.h:25,error,error,25,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkCounter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkCounter.h,2,['error'],['error']
Availability,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [4 x float].; /// \param __B; /// A 128-bit vector of [4 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element is zero.; /// \returns A 128-bit vector of [8 x bfloat] whose lower 64 bits come from; /// conversion of __B, and higher 64 bits come from conversion of __A.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:320,mask,mask,320,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,1,['mask'],['mask']
Availability,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [4 x float].; /// \param __B; /// A 128-bit vector of [4 x float].; /// \param __W; /// A 128-bit vector of [8 x bfloat].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element from __W.; /// \returns A 128-bit vector of [8 x bfloat] whose lower 64 bits come from; /// conversion of __B, and higher 64 bits come from conversion of __A.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:375,mask,mask,375,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,1,['mask'],['mask']
Availability,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [8 x float].; /// \param __B; /// A 256-bit vector of [8 x float].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element is zero.; /// \returns A 256-bit vector of [16 x bfloat] whose lower 128 bits come from; /// conversion of __B, and higher 128 bits come from conversion of __A.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:321,mask,mask,321,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,1,['mask'],['mask']
Availability,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [8 x float].; /// \param __B; /// A 256-bit vector of [8 x float].; /// \param __W; /// A 256-bit vector of [16 x bfloat].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element from __W.; /// \returns A 256-bit vector of [16 x bfloat] whose lower 128 bits come from; /// conversion of __B, and higher 128 bits come from conversion of __A.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:377,mask,mask,377,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,1,['mask'],['mask']
Availability,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 512-bit vector of [16 x float].; /// \param __B; /// A 512-bit vector of [16 x float].; /// \param __U; /// A 32-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element is zero.; /// \returns A 512-bit vector of [32 x bfloat] whose lower 256 bits come from; /// conversion of __B, and higher 256 bits come from conversion of __A.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:323,mask,mask,323,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,1,['mask'],['mask']
Availability,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 512-bit vector of [16 x float].; /// \param __B; /// A 512-bit vector of [16 x float].; /// \param __W; /// A 512-bit vector of [32 x bfloat].; /// \param __U; /// A 32-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element from __W.; /// \returns A 512-bit vector of [32 x bfloat] whose lower 256 bits come from; /// conversion of __B, and higher 256 bits come from conversion of __A.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:379,mask,mask,379,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,1,['mask'],['mask']
Availability,/// Convert a resource mask into a valid llvm processor resource identifier.; ///; /// Only the most significant bit of the Mask is used by this method to; /// identify the processor resource.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:23,mask,mask,23,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Convert a string from a record into an std::string, return true on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:71,failure,failure,71,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['failure'],['failure']
Availability,"/// Convert a table lookup to shufflevector if the mask is constant.; /// This could benefit tbl1 if the mask is { 7,6,5,4,3,2,1,0 }, in; /// which case we could lower the shufflevector with rev64 instructions; /// as it's actually a byte reverse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,2,['mask'],['mask']
Availability,/// Convert an ErrorOr<T> to an Expected<T>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:15,Error,ErrorOr,15,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['ErrorOr']
Availability,"/// Convert an Expected to an Optional without doing anything. This method; /// should be used only where an error can be considered a reasonable and; /// expected return value.; ///; /// Uses of this method are potentially indicative of problems: perhaps the; /// error should be propagated further, or the error-producer should just; /// return an Optional in the first place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:109,error,error,109,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,3,['error'],"['error', 'error-producer']"
Availability,/// Convert an Expected<T> to an ErrorOr<T>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:33,Error,ErrorOr,33,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['ErrorOr']
Availability,"/// Convert an analysis of a masked ICmp into its equivalent if all boolean; /// operations had the opposite sense. Since each ""NotXXX"" flag (recording !=); /// is adjacent to the corresponding normal flag (recording ==), this just; /// involves swapping those bits over.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:29,mask,masked,29,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['masked']
Availability,/// Convert the input shuffle mask operand to a vector of integers. Undefined; /// elements of the mask are returned as PoisonMaskElem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:30,mask,mask,30,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['mask'],['mask']
Availability,/// Convert the integer literal in the current token into an uint64.; ///; /// Return true if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:97,error,error,97,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['error'],['error']
Availability,/// Convert the integer literal in the current token into an unsigned integer.; ///; /// Return true if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:107,error,error,107,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['error'],['error']
Availability,/// Convert the x86 XMM integer vector mask to a vector of bools based on; /// each element's most significant bit (the sign bit).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:39,mask,mask,39,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['mask']
Availability,/// Convert this error to a std::error_code.; ///; /// This is a temporary crutch to enable interaction with code still; /// using std::error_code. It will be removed in the future.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:17,error,error,17,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['error'],['error']
Availability,"/// Convert to StringRef. This is only allowed when it is known this object is; /// representing a StringRef, not a hash code. Calling this function on a hash; /// code is considered an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h:186,error,error,186,interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h,1,['error'],['error']
Availability,"/// Convert to a decimal representation in a string.; ///; /// Convert to a string. Uses scientific notation for very large/small; /// numbers. Scientific notation is used roughly for numbers outside of the; /// range 2^-64 through 2^64.; ///; /// \c Precision indicates the number of decimal digits of precision to use;; /// 0 requests the maximum available.; ///; /// As a special case to make debugging easier, if the number is small enough; /// to convert without scientific notation and has more than \c Precision; /// digits before the decimal place, it's printed accurately to the first; /// digit past zero. E.g., assuming 10 digits of precision:; ///; /// 98765432198.7654... => 98765432198.8; /// 8765432198.7654... => 8765432198.8; /// 765432198.7654... => 765432198.8; /// 65432198.7654... => 65432198.77; /// 5432198.7654... => 5432198.765",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ScaledNumber.h:349,avail,available,349,interpreter/llvm-project/llvm/include/llvm/Support/ScaledNumber.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ScaledNumber.h,1,['avail'],['available']
Availability,"/// Convertible to bool: True if we immediately emitted an error, false if; /// we didn't emit an error or we created a deferred error.; ///; /// Example usage:; ///; /// if (SemaDiagnosticBuilder(...) << foo << bar); /// return ExprError();; ///; /// But see CUDADiagIfDeviceCode() and CUDADiagIfHostCode() -- you probably; /// want to use these instead of creating a SemaDiagnosticBuilder yourself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:59,error,error,59,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,3,['error'],['error']
Availability,"/// Converts a 128-bit vector containing 32-bit float values into a; /// 128-bit vector containing 16-bit half-precision float values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cvtps_ph(__m128 a, const int imm);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCVTPS2PH </c> instruction.; ///; /// \param a; /// A 128-bit vector containing 32-bit float values.; /// \param imm; /// An immediate value controlling rounding using bits [2:0]: \n; /// 000: Nearest \n; /// 001: Down \n; /// 010: Up \n; /// 011: Truncate \n; /// 1XX: Use MXCSR.RC for rounding; /// \returns A 128-bit vector containing converted 16-bit half-precision float; /// values. The lower 64 bits are used to store the converted 16-bit; /// half-precision floating-point values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h:515,Down,Down,515,interpreter/llvm-project/clang/lib/Headers/f16cintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h,1,['Down'],['Down']
Availability,"/// Converts a 256-bit vector of [8 x float] into a 128-bit vector; /// containing 16-bit half-precision float values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm256_cvtps_ph(__m256 a, const int imm);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCVTPS2PH </c> instruction.; ///; /// \param a; /// A 256-bit vector containing 32-bit single-precision float values to be; /// converted to 16-bit half-precision float values.; /// \param imm; /// An immediate value controlling rounding using bits [2:0]: \n; /// 000: Nearest \n; /// 001: Down \n; /// 010: Up \n; /// 011: Truncate \n; /// 1XX: Use MXCSR.RC for rounding; /// \returns A 128-bit vector containing the converted 16-bit half-precision; /// float values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h:578,Down,Down,578,interpreter/llvm-project/clang/lib/Headers/f16cintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h,1,['Down'],['Down']
Availability,"/// Converts a 32-bit single-precision float value to a 16-bit; /// half-precision float value.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned short _cvtss_sh(float a, const int imm);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCVTPS2PH </c> instruction.; ///; /// \param a; /// A 32-bit single-precision float value to be converted to a 16-bit; /// half-precision float value.; /// \param imm; /// An immediate value controlling rounding using bits [2:0]: \n; /// 000: Nearest \n; /// 001: Down \n; /// 010: Up \n; /// 011: Truncate \n; /// 1XX: Use MXCSR.RC for rounding; /// \returns The converted 16-bit half-precision float value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h:529,Down,Down,529,interpreter/llvm-project/clang/lib/Headers/f16cintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h,1,['Down'],['Down']
Availability,"/// Converts a set of \c Edit into a \c AtomicChange per file modified.; /// Returns an error if the edits fail to compose, e.g. overlapping edits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:88,error,error,88,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,1,['error'],['error']
Availability,/// Converts a type specifier (DeclSpec::TST) into a tag type kind.; /// It is an error to provide a type specifier which *isn't* a tag kind here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:82,error,error,82,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['error'],['error']
Availability,"/// Converts alignment exponent (i.e. power of two (or zero)) to the; /// corresponding alignment to use. If alignment is too large, returns; /// a corresponding error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:162,error,error,162,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['error'],['error']
Availability,/// Converts an elaborated type keyword into a TagTypeKind.; /// It is an error to provide an elaborated type keyword; /// which *isn't* a tag kind here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:74,error,error,74,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['error'],['error']
Availability,"/// Converts this value into a decimal string.; ///; /// \param FormatPrecision The maximum number of digits of; /// precision to output. If there are fewer digits available,; /// zero padding will not be used unless the value is; /// integral and small enough to be expressed in; /// FormatPrecision digits. 0 means to use the natural; /// precision of the number.; /// \param FormatMaxPadding The maximum number of zeros to; /// consider inserting before falling back to scientific; /// notation. 0 means to always use scientific notation.; ///; /// \param TruncateZero Indicate whether to remove the trailing zero in; /// fraction part or not. Also setting this parameter to false forcing; /// producing of output more similar to default printf behavior.; /// Specifically the lower e is used as exponent delimiter and exponent; /// always contains no less than two digits.; ///; /// Number Precision MaxPadding Result; /// ------ --------- ---------- ------; /// 1.01E+4 5 2 10100; /// 1.01E+4 4 2 1.01E+4; /// 1.01E+4 5 1 1.01E+4; /// 1.01E-2 5 2 0.0101; /// 1.01E-2 4 2 0.0101; /// 1.01E-2 4 1 1.01E-2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:164,avail,available,164,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,1,['avail'],['available']
Availability,"/// Cope with a name conflict when importing a declaration into the; /// given context.; ///; /// This routine is invoked whenever there is a name conflict while; /// importing a declaration. The returned name will become the name of the; /// imported declaration. By default, the returned name is the same as the; /// original name, leaving the conflict unresolve such that name lookup; /// for this name is likely to find an ambiguity later.; ///; /// Subclasses may override this routine to resolve the conflict, e.g., by; /// renaming the declaration being imported.; ///; /// \param Name the name of the declaration being imported, which conflicts; /// with other declarations.; ///; /// \param DC the declaration context (in the ""to"" AST context) in which; /// the name is being imported.; ///; /// \param IDNS the identifier namespace in which the name will be found.; ///; /// \param Decls the set of declarations with the same name as the; /// declaration being imported.; ///; /// \param NumDecls the number of conflicting declarations in \p Decls.; ///; /// \returns the name that the newly-imported declaration should have. Or; /// an error if we can't handle the name conflict.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:1147,error,error,1147,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Copies the upper element of the first 128-bit vector operand to the; /// corresponding upper element of the 128-bit result vector of [2 x double].; /// Rounds down the lower element of the second 128-bit vector operand to an; /// integer and copies it to the lower element of the 128-bit result vector; /// of [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_floor_sd(__m128d X, __m128d Y);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSD / ROUNDSD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double]. The value stored in bits [127:64] is; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [2 x double]. The value stored in bits [63:0] is; /// rounded down to the nearest integer and copied to the corresponding bits; /// of the result.; /// \returns A 128-bit vector of [2 x double] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:163,down,down,163,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['down'],['down']
Availability,"/// Copies the upper element of the first 128-bit vector operand to the; /// corresponding upper element of the 128-bit result vector of [2 x double].; /// Rounds the lower element of the second 128-bit vector operand to an; /// integer value according to the rounding control specified by the third; /// argument and copies it to the lower element of the 128-bit result vector; /// of [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_round_sd(__m128d X, __m128d Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSD / ROUNDSD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double]. The value stored in bits [127:64] is; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [2 x double]. The value stored in bits [63:0] is; /// rounded to the nearest integer using the specified rounding control and; /// copied to the corresponding bits of the result.; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [2 x double] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1430,Down,Downward,1430,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['Down'],['Downward']
Availability,"/// Copies three upper elements of the first 128-bit vector operand to; /// the corresponding three upper elements of the 128-bit result vector of; /// [4 x float]. Rounds down the lowest element of the second 128-bit vector; /// operand to an integer and copies it to the lowest element of the 128-bit; /// result vector of [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_floor_ss(__m128 X, __m128 Y);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSS / ROUNDSS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float]. The values stored in bits [127:32] are; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [4 x float]. The value stored in bits [31:0] is; /// rounded down to the nearest integer and copied to the corresponding bits; /// of the result.; /// \returns A 128-bit vector of [4 x float] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:172,down,down,172,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['down'],['down']
Availability,"/// Copies three upper elements of the first 128-bit vector operand to; /// the corresponding three upper elements of the 128-bit result vector of; /// [4 x float]. Rounds the lowest element of the second 128-bit vector; /// operand to an integer value according to the rounding control specified; /// by the third argument and copies it to the lowest element of the 128-bit; /// result vector of [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_round_ss(__m128 X, __m128 Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSS / ROUNDSS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float]. The values stored in bits [127:32] are; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [4 x float]. The value stored in bits [31:0] is; /// rounded to the nearest integer using the specified rounding control and; /// copied to the corresponding bits of the result.; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [4 x float] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1437,Down,Downward,1437,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['Down'],['Downward']
Availability,"/// Copy the underlying value.; ///; /// This should get optimized down to a simple copy. We need to actually; /// construct the value, rather than calling memcpy, to satisfy strict; /// aliasing rules.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:67,down,down,67,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,1,['down'],['down']
Availability,/// CopyFromReg - This node indicates that the input value is a virtual or; /// physical register that is defined outside of the scope of this; /// SelectionDAG. The register is available from the RegisterSDNode object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:178,avail,available,178,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['avail'],['available']
Availability,"/// Corrects the low-level LLVM type for a given constraint and ""usual""; /// type.; ///; /// \returns A pointer to a new LLVM type, possibly the same as the original; /// on success; 0 on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h:188,failure,failure,188,interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,1,['failure'],['failure']
Availability,"/// Cost multiplier is a way to limit potentially exponential behavior; /// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch; /// candidates available. Also accounting for the number of ""sibling"" loops with; /// the idea to account for previous unswitches that already happened on this; /// cluster of loops. There was an attempt to keep this formula simple,; /// just enough to limit the worst case behavior. Even if it is not that simple; /// now it is still not an attempt to provide a detailed heuristic size; /// prediction.; ///; /// TODO: Make a proper accounting of ""explosion"" effect for all kinds of; /// unswitch candidates, making adequate predictions instead of wild guesses.; /// That requires knowing not just the number of ""remaining"" candidates but; /// also costs of unswitching for each of these candidates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:166,avail,available,166,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['avail'],['available']
Availability,"/// Counts for DiagnosticErrorTrap to check whether an error occurred; /// during a parsing section, e.g. during parsing a function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:55,error,error,55,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['error']
Availability,"/// Crash recovery helper object.; ///; /// This class implements support for running operations in a safe context so; /// that crashes (memory errors, stack overflow, assertion violations) can be; /// detected and control restored to the crashing thread. Crash detection is; /// purely ""best effort"", the exact set of failures which can be recovered from; /// is platform dependent.; ///; /// Clients make use of this code by first calling; /// CrashRecoveryContext::Enable(), and then executing unsafe operations via a; /// CrashRecoveryContext object. For example:; ///; /// \code; /// void actual_work(void *);; ///; /// void foo() {; /// CrashRecoveryContext CRC;; ///; /// if (!CRC.RunSafely(actual_work, 0)) {; /// ... a crash was detected, report error to user ...; /// }; ///; /// ... no crash was detected ...; /// }; /// \endcode; ///; /// To assist recovery the class allows specifying set of actions that will be; /// executed in any case, whether crash occurs or not. These actions may be used; /// to reclaim resources in the case of crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:10,recover,recovery,10,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,6,"['error', 'failure', 'recover']","['error', 'errors', 'failures', 'recovered', 'recovery']"
Availability,/// Create a ASTUnit from an AST file.; ///; /// \param Filename - The AST file to load.; ///; /// \param PCHContainerRdr - The PCHContainerOperations to use for loading and; /// creating modules.; /// \param Diags - The diagnostics engine to use for reporting errors; its; /// lifetime is expected to extend past that of the returned ASTUnit.; ///; /// \returns - The initialized ASTUnit or null if the AST failed to load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:261,error,errors,261,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['error'],['errors']
Availability,/// Create a BitMaskClassIterator that visits all the register classes; /// represented by \p Mask.; ///; /// \pre \p Mask != nullptr,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:94,Mask,Mask,94,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,2,['Mask'],['Mask']
Availability,"/// Create a CXString object for an NULL string.; ///; /// A NULL string should be used as an ""invalid"" value in case of errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.h:121,error,errors,121,interpreter/llvm-project/clang/tools/libclang/CXString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.h,1,['error'],['errors']
Availability,/// Create a DIExpression representing the constant corresponding; /// to the specified 'Val'. Returns nullptr on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:114,failure,failure,114,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['failure'],['failure']
Availability,"/// Create a DiagnosticsEngine object with a the TextDiagnosticPrinter.; ///; /// If no diagnostic client is provided, this creates a; /// DiagnosticConsumer that is owned by the returned diagnostic; /// object, if using directly the caller is responsible for; /// releasing the returned DiagnosticsEngine's client eventually.; ///; /// \param Opts - The diagnostic options; note that the created text; /// diagnostic object contains a reference to these options.; ///; /// \param Client If non-NULL, a diagnostic client that will be; /// attached to (and, then, owned by) the returned DiagnosticsEngine; /// object.; ///; /// \param CodeGenOpts If non-NULL, the code gen options in use, which may be; /// used by some diagnostics printers (for logging purposes only).; ///; /// \return The new object on success, or null on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:825,failure,failure,825,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,1,['failure'],['failure']
Availability,"/// Create a GSYM from a memory buffer.; ///; /// Called by both openFile() and copyBuffer(), this function does all of the; /// work of parsing the GSYM file and returning an error.; ///; /// \param MemBuffer A memory buffer that will transfer ownership into the; /// GsymReader.; /// \returns An expected GsymReader that contains the object or an error; /// object that indicates reason for failing to read the GSYM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:176,error,error,176,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,2,['error'],['error']
Availability,/// Create a JITSymbol representing an error in the symbol lookup; /// process (e.g. a network failure during a remote lookup).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h:39,error,error,39,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Create a LineEditor object.; ///; /// \param ProgName The name of the current program. Used to form a default; /// prompt.; /// \param HistoryPath Path to the file in which to store history data, if; /// possible.; /// \param In The input stream used by the editor.; /// \param Out The output stream used by the editor.; /// \param Err The error stream used by the editor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LineEditor/LineEditor.h:344,error,error,344,interpreter/llvm-project/llvm/include/llvm/LineEditor/LineEditor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LineEditor/LineEditor.h,1,['error'],['error']
Availability,"/// Create a LiveRangeEdit for breaking down parent into smaller pieces.; /// @param parent The register being spilled or split.; /// @param newRegs List to receive any new registers created. This needn't be; /// empty initially, any existing registers are ignored.; /// @param MF The MachineFunction the live range edit is taking place in.; /// @param lis The collection of all live intervals in this function.; /// @param vrm Map of virtual registers to physical registers for this; /// function. If NULL, no virtual register map updates will; /// be done. This could be the case if called before Regalloc.; /// @param deadRemats The collection of all the instructions defining an; /// original reg and are dead after remat.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:40,down,down,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,1,['down'],['down']
Availability,"/// Create a LocIdx for an untracked register ID. Initialize it to either an; /// mphi value representing a live-in, or a recent register mask clobber.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:138,mask,mask,138,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['mask'],['mask']
Availability,"/// Create a REG_SEQUENCE instruction using the registers in \p Regs.; /// Helper function for functions like createDTuple and createQTuple.; ///; /// \p RegClassIDs - The list of register class IDs available for some tuple of; /// a scalar class. E.g. QQRegClassID, QQQRegClassID, QQQQRegClassID. This is; /// expected to contain between 2 and 4 tuple classes.; ///; /// \p SubRegs - The list of subregister classes associated with each register; /// class ID in \p RegClassIDs. E.g., QQRegClassID should use the qsub0; /// subregister class. The index of each subregister class is expected to; /// correspond with the index of each register class.; ///; /// \returns Either the destination register of REG_SEQUENCE instruction that; /// was created, or the 0th element of \p Regs if \p Regs contains a single; /// element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:199,avail,available,199,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['avail'],['available']
Availability,"/// Create a YAMLParseError error from an existing error generated by the YAML; /// parser.; /// If there is no error, this returns Success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.h:28,error,error,28,interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.h,3,['error'],['error']
Availability,/// Create a YAMLParseError error referencing a specific node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.h:28,error,error,28,interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.h,1,['error'],['error']
Availability,/// Create a call to Masked Compress Store intrinsic,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:21,Mask,Masked,21,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['Mask'],['Masked']
Availability,"/// Create a call to Masked Compress Store intrinsic; /// \p Val - data to be stored,; /// \p Ptr - base pointer for the store; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:21,Mask,Masked,21,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,2,['Mask'],"['Mask', 'Masked']"
Availability,/// Create a call to Masked Expand Load intrinsic,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:21,Mask,Masked,21,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['Mask'],['Masked']
Availability,/// Create a call to Masked Expand Load intrinsic; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:21,Mask,Masked,21,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,3,"['Mask', 'mask']","['Mask', 'Masked', 'masked-off']"
Availability,/// Create a call to Masked Gather intrinsic,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:21,Mask,Masked,21,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['Mask'],['Masked']
Availability,/// Create a call to Masked Load intrinsic,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:21,Mask,Masked,21,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['Mask'],['Masked']
Availability,/// Create a call to Masked Scatter intrinsic,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:21,Mask,Masked,21,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['Mask'],['Masked']
Availability,/// Create a call to Masked Store intrinsic,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:21,Mask,Masked,21,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['Mask'],['Masked']
Availability,/// Create a call to a Masked Gather intrinsic.; /// \p Ty - vector type to gather; /// \p Ptrs - vector of pointers for loading; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:23,Mask,Masked,23,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,3,"['Mask', 'mask']","['Mask', 'Masked', 'masked-off']"
Availability,/// Create a call to a Masked Load intrinsic.; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Alignment - alignment of the source location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:23,Mask,Masked,23,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,3,"['Mask', 'mask']","['Mask', 'Masked', 'masked-off']"
Availability,"/// Create a call to a Masked Scatter intrinsic.; /// \p Data - data to be stored,; /// \p Ptrs - the vector of pointers, where the \p Data elements should be; /// stored; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:23,Mask,Masked,23,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,2,['Mask'],"['Mask', 'Masked']"
Availability,"/// Create a call to a Masked Store intrinsic.; /// \p Val - data to be stored,; /// \p Ptr - base pointer for the store; /// \p Alignment - alignment of the destination location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:23,Mask,Masked,23,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,2,['Mask'],"['Mask', 'Masked']"
Availability,"/// Create a call to a Masked intrinsic, with given intrinsic Id,; /// an array of operands - Ops, and an array of overloaded types -; /// OverloadedTypes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:23,Mask,Masked,23,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,1,['Mask'],['Masked']
Availability,/// Create a call to a masked intrinsic with given Id.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:23,mask,masked,23,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['mask'],['masked']
Availability,"/// Create a clone of the blocks in a loop and connect them together. A new; /// loop will be created including all cloned blocks, and the iterator of the; /// new loop switched to count NewIter down to 0.; /// The cloned blocks should be inserted between InsertTop and InsertBot.; /// InsertTop should be new preheader, InsertBot new loop exit.; /// Returns the new cloned loop that is created.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:195,down,down,195,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,1,['down'],['down']
Availability,"/// Create a combined index file from the input IR files and write it.; ///; /// This is meant to enable testing of ThinLTO combined index generation,; /// currently available via the gold plugin via -thinlto.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:166,avail,available,166,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,1,['avail'],['available']
Availability,"/// Create a conditional 'br Cond, TrueDest, FalseDest'; /// instruction. Copy branch meta data if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:99,avail,available,99,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['avail'],['available']
Availability,"/// Create a hard link from \a from to \a to, or return an error.; ///; /// @param to The path to hard link to.; /// @param from The path to hard link from. This is created.; /// @returns errc::success if the link was created, otherwise a platform; /// specific error_code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:59,error,error,59,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['error'],['error']
Availability,"/// Create a local compile callback manager.; ///; /// The given target triple will determine the ABI, and the given; /// ErrorHandlerAddress will be used by the resulting compile callback; /// manager if a compile callback fails.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h:122,Error,ErrorHandlerAddress,122,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h,1,['Error'],['ErrorHandlerAddress']
Availability,"/// Create a local file system cache which uses the given cache name, temporary; /// file prefix, cache directory and file callback. This function does not; /// immediately create the cache directory if it does not yet exist; this is; /// done lazily the first time a file is added. The cache name appears in error; /// messages for errors during caching. The temporary file prefix is used in the; /// temporary file naming scheme used when writing files atomically.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h:309,error,error,309,interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,2,['error'],"['error', 'errors']"
Availability,/// Create a location where the value is undefined and not available. This can; /// happen when a register is volatile and can't be recovered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h:59,avail,available,59,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,2,"['avail', 'recover']","['available', 'recovered']"
Availability,"/// Create a macro definition record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSRForMacro(StringRef Name,; /// SourceLocation SL, const SourceManager &SM) is a helper method to generate; /// the USR for the macro and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:147,alive,alive,147,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:13,mask,mask,13,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,6,"['Mask', 'mask']","['Mask', 'mask']"
Availability,/// Create a mask with a bit enabled at position Pos.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h:13,mask,mask,13,interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,1,['mask'],['mask']
Availability,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:13,mask,mask,13,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,5,['mask'],['mask']
Availability,"/// Create a new API notes reader from the given member buffer, which; /// contains the contents of a binary API notes file.; ///; /// \returns the new API notes reader, or null if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesReader.h:184,error,error,184,interpreter/llvm-project/clang/include/clang/APINotes/APINotesReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesReader.h,1,['error'],['error']
Availability,"/// Create a new `MSFBuilder`.; ///; /// \param BlockSize The internal block size used by the PDB file. See; /// isValidBlockSize() for a list of valid block sizes.; ///; /// \param MinBlockCount Causes the builder to reserve up front space for; /// at least `MinBlockCount` blocks. This is useful when using `MSFBuilder`; /// to read an existing MSF that you want to write back out later. The; /// original MSF file's SuperBlock contains the exact number of blocks used; /// by the file, so is a good hint as to how many blocks the new MSF file; /// will contain. Furthermore, it is actually necessary in this case. To; /// preserve stability of the file's layout, it is helpful to try to keep; /// all streams mapped to their original block numbers. To ensure that this; /// is possible, space for all blocks must be allocated beforehand so that; /// streams can be assigned to them.; ///; /// \param CanGrow If true, any operation which results in an attempt to; /// locate a free block when all available blocks have been exhausted will; /// allocate a new block, thereby growing the size of the final MSF file.; /// When false, any such attempt will result in an error. This is especially; /// useful in testing scenarios when you know your test isn't going to do; /// anything to increase the size of the file, so having an Error returned if; /// it were to happen would catch a programming error; ///; /// \returns an llvm::Error representing whether the operation succeeded or; /// failed. Currently the only way this can fail is if an invalid block size; /// is specified, or `MinBlockCount` does not leave enough room for the; /// mandatory reserved blocks required by an MSF file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h:999,avail,available,999,interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,5,"['Error', 'avail', 'error']","['Error', 'available', 'error']"
Availability,"/// Create a new basic block that will be the predecessor of BB and successor of; /// all blocks in Preds. When profile data is available, update the frequency of; /// this new block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:128,avail,available,128,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['avail'],['available']
Availability,"/// Create a new output file, optionally deriving the output path name, and; /// add it to the list of tracked output files.; ///; /// \return - Null on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:153,error,error,153,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,1,['error'],['error']
Availability,"/// Create a new verifying diagnostic client, which will issue errors to; /// the currently-attached diagnostic client when a diagnostic does not match; /// what is expected (as indicated in the source file).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/VerifyDiagnosticConsumer.h:63,error,errors,63,interpreter/llvm-project/clang/include/clang/Frontend/VerifyDiagnosticConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/VerifyDiagnosticConsumer.h,1,['error'],['errors']
Availability,/// Create a register mask and initialize it with the registers from the; /// register live set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,1,['mask'],['mask']
Availability,/// Create a register mask and initialize it with the registers from; /// the register live set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,1,['mask'],['mask']
Availability,/// Create a repairing placement for the \p OpIdx-th operand of; /// \p MI. \p TRI is used to make some checks on the register aliases; /// if the machine operand is a physical register. \p P is used to; /// to update liveness information and such when materializing the; /// points.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:13,repair,repairing,13,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,1,['repair'],['repairing']
Availability,/// Create a sample profile file writer based on the specified format.; ///; /// \param Filename The file to create.; ///; /// \param Format Encoding format for the profile file.; ///; /// \returns an error code indicating the status of the created writer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp:201,error,error,201,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp,1,['error'],['error']
Availability,/// Create a sample profile reader based on the format of the input data.; ///; /// \param B The memory buffer to create the reader from (assumes ownership).; ///; /// \param C The LLVM context to use to emit diagnostics.; ///; /// \param P The FSDiscriminatorPass.; ///; /// \param RemapFilename The file used for profile remapping.; ///; /// \returns an error code indicating the status of the created reader.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp:356,error,error,356,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,1,['error'],['error']
Availability,/// Create a sample profile reader based on the format of the input file.; ///; /// \param Filename The file to open.; ///; /// \param C The LLVM context to use to emit diagnostics.; ///; /// \param P The FSDiscriminatorPass.; ///; /// \param RemapFilename The file used for profile remapping.; ///; /// \returns an error code indicating the status of the created reader.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp:316,error,error,316,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,1,['error'],['error']
Availability,"/// Create a sample profile remapper from the given input, to remap the; /// function names in the given profile data.; ///; /// \param B The memory buffer to create the reader from (assumes ownership).; ///; /// \param C The LLVM context to use to emit diagnostics.; ///; /// \param Reader The profile reader the remapper is going to be applied to.; ///; /// \returns an error code indicating the status of the created reader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp:372,error,error,372,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,1,['error'],['error']
Availability,"/// Create a sample profile remapper from the given input, to remap the; /// function names in the given profile data.; ///; /// \param Filename The file to open.; ///; /// \param Reader The profile reader the remapper is going to be applied to.; ///; /// \param C The LLVM context to use to emit diagnostics.; ///; /// \returns an error code indicating the status of the created reader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp:332,error,error,332,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,1,['error'],['error']
Availability,/// Create a sample profile stream writer based on the specified format.; ///; /// \param OS The output stream to store the profile data to.; ///; /// \param Format Encoding format for the profile file.; ///; /// \returns an error code indicating the status of the created writer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp:225,error,error,225,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp,1,['error'],['error']
Availability,"/// Create a segmented GSYM creator starting with function info index; /// \a FuncIdx.; ///; /// This function will create a GsymCreator object that will encode into; /// roughly \a SegmentSize bytes and return it. It is used by the private; /// saveSegments(...) function and also is used by the GSYM unit tests to test; /// segmenting of GSYM files. The returned GsymCreator can be finalized and; /// encoded.; ///; /// \param [in] SegmentSize The size in bytes to roughly segment the GSYM file; /// into.; /// \param [in,out] FuncIdx The index of the first function info to encode; /// into the returned GsymCreator. This index will be updated so it can be; /// used in subsequent calls to this function to allow more segments to be; /// created.; /// \returns An expected unique pointer to a GsymCreator or an error. The; /// returned unique pointer can be NULL if there are no more functions to; /// encode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:814,error,error,814,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,1,['error'],['error']
Availability,"/// Create a sequential shuffle mask.; ///; /// This function creates shuffle mask whose elements are sequential and begin; /// at \p Start. The mask contains \p NumInts integers and is padded with \p; /// NumUndefs undef values. The mask is of the form:; ///; /// <Start, Start + 1, ... Start + NumInts - 1, undef_1, ... undef_NumUndefs>; ///; /// For example, the mask for Start = 0, NumInsts = 4, and NumUndefs = 4 is:; ///; /// <0, 1, 2, 3, undef, undef, undef, undef>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,5,['mask'],['mask']
Availability,"/// Create a shuffle mask that matches the PACKSS/PACKUS truncation.; /// A multi-stage pack shuffle mask is created by specifying NumStages > 1.; /// Note: This ignores saturation, so inputs must be checked first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"/// Create a stride shuffle mask.; ///; /// This function creates a shuffle mask whose elements begin at \p Start and; /// are incremented by \p Stride. The mask can be used to deinterleave an; /// interleaved vector into separate vectors of vectorization factor \p VF. The; /// mask is of the form:; ///; /// <Start, Start + Stride, ..., Start + Stride * (VF - 1)>; ///; /// For example, the mask for Start = 0, Stride = 2, and VF = 4 is:; ///; /// <0, 2, 4, 6>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:28,mask,mask,28,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,5,['mask'],['mask']
Availability,/// Create a success value. Prefer using 'Error::success()' for readability,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:42,Error,Error,42,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['Error']
Availability,"/// Create a typedef record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:138,alive,alive,138,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create a vector-predicated logical NOT operation as (VP_XOR Val,; /// BooleanOne, Mask, EVL).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:86,Mask,Mask,86,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['Mask'],['Mask']
Availability,"/// Create a verifier pass.; ///; /// Check a module or function for validity. This is essentially a pass wrapped; /// around the above verifyFunction and verifyModule routines and; /// functionality. When the pass detects a verification error it is always; /// printed to stderr, and by default they are fatal. You can override that by; /// passing \c false to \p FatalErrors.; ///; /// Note that this creates a pass suitable for the legacy pass manager. It has; /// nothing to do with \c VerifierPass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h:238,error,error,238,interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,1,['error'],['error']
Availability,"/// Create all the non-existent directories in path.; ///; /// @param path Directories to create.; /// @returns errc::success if is_directory(path), otherwise a platform; /// specific error_code. If IgnoreExisting is false, also returns; /// error if the directory already existed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:242,error,error,242,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['error'],['error']
Availability,"/// Create an ASTUnit from a source file, via a CompilerInvocation; /// object, by invoking the optionally provided ASTFrontendAction.; ///; /// \param CI - The compiler invocation to use; it must have exactly one input; /// source file. The ASTUnit takes ownership of the CompilerInvocation object.; ///; /// \param PCHContainerOps - The PCHContainerOperations to use for loading and; /// creating modules.; ///; /// \param Diags - The diagnostics engine to use for reporting errors; its; /// lifetime is expected to extend past that of the returned ASTUnit.; ///; /// \param Action - The ASTFrontendAction to invoke. Its ownership is not; /// transferred.; ///; /// \param Unit - optionally an already created ASTUnit. Its ownership is not; /// transferred.; ///; /// \param Persistent - if true the returned ASTUnit will be complete.; /// false means the caller is only interested in getting info through the; /// provided \see Action.; ///; /// \param ErrAST - If non-null and parsing failed without any AST to return; /// (e.g. because the PCH could not be loaded), this accepts the ASTUnit; /// mainly to allow the caller to see the diagnostics.; /// This will only receive an ASTUnit if a new one was created. If an already; /// created ASTUnit was passed in \p Unit then the caller can check that.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:477,error,errors,477,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['error'],['errors']
Availability,/// Create an Expected<T> error value from the given Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:26,error,error,26,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// Create an UnwindTable from a Common Information Entry (CIE).; ///; /// \param Cie The Common Information Entry to extract the table from. The; /// CFIProgram is retrieved from the \a Cie object and used to create the; /// UnwindTable.; ///; /// \returns An error if the DWARF Call Frame Information opcodes have state; /// machine errors, or a valid UnwindTable otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h:261,error,error,261,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,2,['error'],"['error', 'errors']"
Availability,"/// Create an UnwindTable from a Frame Descriptor Entry (FDE).; ///; /// \param Fde The Frame Descriptor Entry to extract the table from. The; /// CFIProgram is retrieved from the \a Fde object and used to create the; /// UnwindTable.; ///; /// \returns An error if the DWARF Call Frame Information opcodes have state; /// machine errors, or a valid UnwindTable otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h:257,error,error,257,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,2,['error'],"['error', 'errors']"
Availability,/// Create an analysis pass wrapper around a TTI object.; ///; /// This analysis pass just holds the TTI instance and makes it available to; /// clients.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:127,avail,available,127,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['avail'],['available']
Availability,/// Create an argument counter. If the provided \p Arguments represent a regex; /// vector then we need to check that the provided regular expressions are; /// valid if not we return an Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkCounter.h:186,Error,Error,186,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkCounter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkCounter.h,1,['Error'],['Error']
Availability,/// Create an error on exit helper.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:14,error,error,14,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['error'],['error']
Availability,"/// Create an error value. Prefer using the 'make_error' function, but; /// this constructor can be useful when ""re-throwing"" errors from handlers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:14,error,error,14,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,2,['error'],"['error', 'errors']"
Availability,"/// Create an external AST source to read a PCH file.; ///; /// \return - The new object on success, or null on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:112,failure,failure,112,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,1,['failure'],['failure']
Availability,"/// Create an implicit import of the given module at the given; /// source location, for error recovery, if possible.; ///; /// This routine is typically used when an entity found by name lookup; /// is actually hidden within a module that we know about but the user; /// has forgotten to import.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:89,error,error,89,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['error', 'recover']","['error', 'recovery']"
Availability,"/// Create an interleave shuffle mask.; ///; /// This function creates a shuffle mask for interleaving \p NumVecs vectors of; /// vectorization factor \p VF into a single wide vector. The mask is of the; /// form:; ///; /// <0, VF, VF * 2, ..., VF * (NumVecs - 1), 1, VF + 1, VF * 2 + 1, ...>; ///; /// For example, the mask for VF = 4 and NumVecs = 2 is:; ///; /// <0, 4, 1, 5, 2, 6, 3, 7>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:33,mask,mask,33,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,4,['mask'],['mask']
Availability,/// Create an out of range error for the given edge in the given block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:27,error,error,27,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['error'],['error']
Availability,/// Create an out-of-band error by copying the given string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:26,error,error,26,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,2,['error'],['error']
Availability,"/// Create and add a function record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:147,alive,alive,147,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create and add a global variable record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:154,alive,alive,154,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create and add a record field record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:151,alive,alive,151,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create and add a record record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:145,alive,alive,145,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create and add an Objective-C category record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:160,alive,alive,160,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create and add an Objective-C instance variable record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:169,alive,alive,169,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create and add an Objective-C interface record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:161,alive,alive,161,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create and add an Objective-C method record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:158,alive,alive,158,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create and add an Objective-C property record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:160,alive,alive,160,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create and add an Objective-C protocol record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:160,alive,alive,160,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create and add an enum constant record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:153,alive,alive,153,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create and add an enum record into the API set.; ///; /// Note: the caller is responsible for keeping the StringRef \p Name and; /// \p USR alive. APISet::copyString provides a way to copy strings into; /// APISet itself, and APISet::recordUSR(const Decl *D) is a helper method; /// to generate the USR for \c D and keep it alive in APISet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h:144,alive,alive,144,interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/API.h,2,['alive'],['alive']
Availability,"/// Create the AST consumer object for this action, if supported.; ///; /// This routine is called as part of BeginSourceFile(), which will; /// fail if the AST consumer cannot be created. This will not be called if the; /// action has indicated that it only uses the preprocessor.; ///; /// \param CI - The current compiler instance, provided as a convenience, see; /// getCompilerInstance().; ///; /// \param InFile - The current input file, provided as a convenience, see; /// getCurrentFile().; ///; /// \return The new AST consumer, or null on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:549,failure,failure,549,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['failure'],['failure']
Availability,"/// Create the default output file (from the invocation's options) and add it; /// to the list of tracked output files.; ///; /// The files created by this are usually removed on signal, and, depending; /// on FrontendOptions, may also use a temporary file (that is, the data is; /// written to a temporary file which will atomically replace the target; /// output on success).; ///; /// \return - Null on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:406,error,error,406,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,1,['error'],['error']
Availability,"/// Create the directory in path.; ///; /// @param path Directory to create.; /// @returns errc::success if is_directory(path), otherwise a platform; /// specific error_code. If IgnoreExisting is false, also returns; /// error if the directory already existed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:221,error,error,221,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['error'],['error']
Availability,"/// Create the file manager and replace any existing one with it.; ///; /// \return The new file manager on success, or null on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:128,failure,failure,128,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,1,['failure'],['failure']
Availability,"/// Create the initialization, compare, and increment steps for; /// the range-based for loop expression.; /// This function does not handle array-based for loops,; /// which are created in Sema::BuildCXXForRangeStmt.; ///; /// \returns a ForRangeStatus indicating success or what kind of error occurred.; /// BeginExpr and EndExpr are set and FRS_Success is returned on success;; /// CandidateSet and BEF are set and some non-success value is returned on; /// failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:289,error,error,289,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,/// Create the mask for the vector loop header block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,1,['mask'],['mask']
Availability,"/// CreateRegMask - Creates a register mask operand referencing Mask. The; /// operand does not take ownership of the memory referenced by Mask, it; /// must remain valid for the lifetime of the operand.; ///; /// A RegMask operand represents a set of non-clobbered physical registers; /// on an instruction that clobbers many registers, typically a call. The; /// bit mask has a bit set for each physreg that is preserved by this; /// instruction, as described in the documentation for; /// TargetRegisterInfo::getCallPreservedMask().; ///; /// Any physreg with a 0 bit in the mask is clobbered by the instruction.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:39,mask,mask,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,5,"['Mask', 'mask']","['Mask', 'mask']"
Availability,/// Creates a 32-bit integer mask from the most significant bit of each byte; /// in the 256-bit integer vector in \a __a and returns the result.; ///; /// \code{.operation}; /// FOR i := 0 TO 31; /// j := i*8; /// result[i] := __a[j+7]; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMOVMSKB instruction.; ///; /// \param __a; /// A 256-bit integer vector containing the source bytes.; /// \returns The 32-bit integer mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:29,mask,mask,29,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['mask'],['mask']
Availability,"/// Creates a FixedCompilationDatabase from the arguments after ""--"".; ///; /// Parses the given command line for ""--"". If ""--"" is found, the rest of; /// the arguments will make up the command line in the returned; /// FixedCompilationDatabase.; /// The arguments after ""--"" must not include positional parameters or the; /// argv[0] of the tool. Those will be added by the FixedCompilationDatabase; /// when a CompileCommand is requested. The argv[0] of the returned command; /// line will be ""clang-tool"".; ///; /// Returns NULL in case ""--"" is not found.; ///; /// The argument list is meant to be compatible with normal llvm command line; /// parsing in main methods.; /// int main(int argc, char **argv) {; /// std::unique_ptr<FixedCompilationDatabase> Compilations(; /// FixedCompilationDatabase::loadFromCommandLine(argc, argv));; /// cl::ParseCommandLineOptions(argc, argv);; /// ...; /// }; ///; /// \param Argc The number of command line arguments - will be changed to; /// the number of arguments before ""--"", if ""--"" was found in the argument; /// list.; /// \param Argv Points to the command line arguments.; /// \param ErrorMsg Contains error text if the function returns null pointer.; /// \param Directory The base directory used in the FixedCompilationDatabase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:1134,Error,ErrorMsg,1134,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,2,"['Error', 'error']","['ErrorMsg', 'error']"
Availability,"/// Creates a LocalTrampolinePool with the given RunCallback function.; /// Returns an error if this function is unable to correctly allocate, write; /// and protect the resolver code block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h:87,error,error,87,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h,1,['error'],['error']
Availability,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see _blsmsk_u64",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:14,mask,mask,14,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,3,['mask'],['mask']
Availability,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see _blsmsk_u32",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:14,mask,mask,14,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,3,['mask'],['mask']
Availability,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsmsk_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see __blsmsk_u32",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:14,mask,mask,14,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,3,['mask'],['mask']
Availability,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsmsk_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see __blsmsk_u64",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:14,mask,mask,14,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,3,['mask'],['mask']
Availability,"/// Creates a new refactoring action rule that constructs and invokes the; /// \c RuleType rule when all of the requirements are satisfied.; ///; /// This function takes in a list of values whose type derives from; /// \c RefactoringActionRuleRequirement. These values describe the initiation; /// requirements that have to be satisfied by the refactoring engine before; /// the provided action rule can be constructed and invoked. The engine; /// verifies that the requirements are satisfied by evaluating them (using the; /// 'evaluate' member function) and checking that the results don't contain; /// any errors. Once all requirements are satisfied, the provided refactoring; /// rule is constructed by passing in the values returned by the requirements'; /// evaluate functions as arguments to the constructor. The rule is then invoked; /// immediately after construction.; ///; /// The separation of requirements, their evaluation and the invocation of the; /// refactoring action rule allows the refactoring clients to:; /// - Disable refactoring action rules whose requirements are not supported.; /// - Gather the set of options and define a command-line / visual interface; /// that allows users to input these options without ever invoking the; /// action.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:609,error,errors,609,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,1,['error'],['errors']
Availability,"/// Creates an AST with the provided CompilerInvocation but with these; /// changes:; /// -if a PCH/PTH is set, the original header is used instead; /// -Automatic Reference Counting mode is enabled; ///; /// It then checks the AST and produces errors/warning for ARC migration issues; /// that the user needs to handle manually.; ///; /// \param emitPremigrationARCErrors if true all ARC errors will get emitted; /// even if the migrator can fix them, but the function will still return false; /// if all ARC errors can be fixed.; ///; /// \param plistOut if non-empty, it is the file path to store the plist with; /// the pre-migration ARC diagnostics.; ///; /// \returns false if no error is produced, true otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ARCMigrate/ARCMT.h:245,error,errors,245,interpreter/llvm-project/clang/include/clang/ARCMigrate/ARCMT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ARCMigrate/ARCMT.h,4,['error'],"['error', 'errors']"
Availability,"/// Creates an SAH evaluator object, used by top-down builders to determine where to split.; /// The two parameters are the log of the size of primitive clusters in base 2, and the ratio of; /// the cost of intersecting a node (a ray-box intersection) over the cost of intersecting a; /// primitive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/split_heuristic.h:49,down,down,49,geom/geom/inc/bvh/v2/split_heuristic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/split_heuristic.h,1,['down'],['down']
Availability,"/// Creates an SDNode for a predicated scalar operation.; /// \returns (X86vselect \p Mask, \p Op, \p PreservedSrc).; /// The mask is coming as MVT::i8 and it should be transformed; /// to MVT::v1i1 while lowering masking intrinsics.; /// The main difference between ScalarMaskingNode and VectorMaskingNode is using; /// ""X86select"" instead of ""vselect"". We just can't create the ""vselect"" node; /// for a scalar instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:86,Mask,Mask,86,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,"['Mask', 'mask']","['Mask', 'mask', 'masking']"
Availability,"/// Creates an SUnit for each real instruction, numbered in top-down; /// topological order. The instruction order A < B, implies that no edge exists; /// from B to A.; ///; /// Map each real instruction to its SUnit.; ///; /// After initSUnits, the SUnits vector cannot be resized and the scheduler may; /// hang onto SUnit pointers. We may relax this in the future by using SUnit IDs; /// instead of pointers.; ///; /// MachineScheduler relies on initSUnits numbering the nodes by their order in; /// the original instruction list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:64,down,down,64,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['down'],['down']
Availability,/// Creates an all ones mask suitable for masking a vector of type VecTy with; /// vector length VL. .,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],"['mask', 'masking']"
Availability,/// Creates an entry without contents: either a filesystem error or; /// a directory with stat value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:59,error,error,59,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['error'],['error']
Availability,"/// Creates an error that signals that a `MatchConsumer` expected a certain node; /// to be bound by AST matchers, but it was not actually bound.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h:15,error,error,15,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h,1,['error'],['error']
Availability,/// Creates an llvm::Error value that contains a diagnostic.; ///; /// The errors should not outlive the context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h:21,Error,Error,21,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h,2,"['Error', 'error']","['Error', 'errors']"
Availability,"/// Creates binary descriptor for the given device images. Binary descriptor; /// is an object that is passed to the offloading runtime at program startup; /// and it describes all device images available in the executable or shared; /// library. It is defined as follows; ///; /// __attribute__((visibility(""hidden""))); /// extern __tgt_offload_entry *__start_omp_offloading_entries;; /// __attribute__((visibility(""hidden""))); /// extern __tgt_offload_entry *__stop_omp_offloading_entries;; ///; /// static const char Image0[] = { <Bufs.front() contents> };; /// ...; /// static const char ImageN[] = { <Bufs.back() contents> };; ///; /// static const __tgt_device_image Images[] = {; /// {; /// Image0, /*ImageStart*/; /// Image0 + sizeof(Image0), /*ImageEnd*/; /// __start_omp_offloading_entries, /*EntriesBegin*/; /// __stop_omp_offloading_entries /*EntriesEnd*/; /// },; /// ...; /// {; /// ImageN, /*ImageStart*/; /// ImageN + sizeof(ImageN), /*ImageEnd*/; /// __start_omp_offloading_entries, /*EntriesBegin*/; /// __stop_omp_offloading_entries /*EntriesEnd*/; /// }; /// };; ///; /// static const __tgt_bin_desc BinDesc = {; /// sizeof(Images) / sizeof(Images[0]), /*NumDeviceImages*/; /// Images, /*DeviceImages*/; /// __start_omp_offloading_entries, /*HostEntriesBegin*/; /// __stop_omp_offloading_entries /*HostEntriesEnd*/; /// };; ///; /// Global variable that represents BinDesc is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:195,avail,available,195,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,1,['avail'],['available']
Availability,/// Creates cleanup handler.; /// \param x Pointer to the resource recovered by this handler.; /// \return New handler or null if the method was called outside a recovery; /// context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:67,recover,recovered,67,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,2,['recover'],"['recovered', 'recovery']"
Availability,"/// Creates file to write the PCH into and returns a stream to write it; /// into. On error, returns null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendActions.h:86,error,error,86,interpreter/llvm-project/clang/include/clang/Frontend/FrontendActions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendActions.h,1,['error'],['error']
Availability,"/// Creates permutation of the single vector operand with the given mask, if; /// it is not identity mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:68,mask,mask,68,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['mask'],['mask']
Availability,/// Creates shufflevector for the 2 operands with the given mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,mask,mask,60,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,/// Current chunk of the Mask we are traversing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:25,Mask,Mask,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['Mask'],['Mask']
Availability,/// Current optimization remark emitter. Used to report failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h:56,failure,failures,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,2,['failure'],['failures']
Availability,/// Current optimization remark emitter.; /// Used to report things like combines and FastISel failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:95,failure,failures,95,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,1,['failure'],['failures']
Availability,/// Current target configuration. Controls how the pass handles errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h:64,error,errors,64,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,2,['error'],['errors']
Availability,"/// Currently only scheduling top-down, so this method is empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:34,down,down,34,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['down'],['down']
Availability,/// Custom deleter to allow FunctionScopeInfos to be kept alive for a short; /// time after they've been popped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:58,alive,alive,58,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['alive'],['alive']
Availability,/// Custom lowers floating point to integer conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,avail,available,97,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avail'],['available']
Availability,/// Custom lowers integer to floating point conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:97,avail,available,97,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avail'],['available']
Availability,/// DELETED_NODE - This is an illegal value that is used to catch; /// errors. This opcode is not a legal opcode for any node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:71,error,errors,71,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['error'],['errors']
Availability,/// DIE is available for ODR type deduplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:11,avail,available,11,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,1,['avail'],['available']
Availability,/// Data about each block. This is used downstream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:40,down,downstream,40,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,1,['down'],['downstream']
Availability,"/// Data structure to hold cached (LLVM-IR) information.; ///; /// All attributes are given an InformationCache object at creation time to; /// avoid inspection of the IR by all of them individually. This default; /// InformationCache will hold information required by 'default' attributes,; /// thus the ones deduced when Attributor::identifyDefaultAbstractAttributes(..); /// is called.; ///; /// If custom abstract attributes, registered manually through; /// Attributor::registerAA(...), need more information, especially if it is not; /// reusable, it is advised to inherit from the InformationCache and cast the; /// instance down in the abstract attributes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:632,down,down,632,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['down'],['down']
Availability,"/// Debug value substitutions: a collection of DebugSubstitution objects,; /// recording changes in where a value is defined. For example, when one; /// instruction is substituted for another. Keeping a record allows recovery; /// of variable locations after compilation finishes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:217,recover,recovery,217,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['recover'],['recovery']
Availability,"/// Debug version of getVal(), which is slow and does error checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:54,error,error,54,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['error'],['error']
Availability,/// Debugging aid that dumps the template argument to standard error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h:63,error,error,63,interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,1,['error'],['error']
Availability,/// Debugging aid that dumps the template name to standard; /// error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h:64,error,error,64,interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,1,['error'],['error']
Availability,"/// Declare code in the interpreter via the TInterpreter::Declare method, throw in case of errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:91,error,errors,91,tree/dataframe/inc/ROOT/RDF/Utils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx,1,['error'],['errors']
Availability,/// Decode a 128-bit INSERTPS instruction as a v4f32 shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:61,mask,mask,61,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,/// Decode a BLEND immediate mask into a shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,2,['mask'],['mask']
Availability,"/// Decode a MOVHLPS instruction as a v2f64/v4f32 shuffle mask.; /// i.e. <3,1> or <6,7,2,3>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,"/// Decode a MOVLHPS instruction as a v2f64/v4f32 shuffle mask.; /// i.e. <0,2> or <0,1,4,5>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,/// Decode a PSHUFB mask from a raw array of constants such as from; /// BUILD_VECTOR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,/// Decode a PSHUFB mask from an IR-level vector constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.h:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.h,1,['mask'],['mask']
Availability,/// Decode a SSE4A EXTRQ instruction as a shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:50,mask,mask,50,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,/// Decode a SSE4A INSERTQ instruction as a shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:52,mask,mask,52,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,/// Decode a VPERM W/D/Q/PS/PD mask from a raw array of constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,/// Decode a VPERMIL2PD/VPERMIL2PS variable mask from a raw array of constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:44,mask,mask,44,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,/// Decode a VPERMILP variable mask from an IR-level vector constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.h:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.h,1,['mask'],['mask']
Availability,/// Decode a VPERMILP2 variable mask from an IR-level vector constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.h:32,mask,mask,32,interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.h,1,['mask'],['mask']
Availability,/// Decode a VPERMILPD/VPERMILPS variable mask from a raw array of constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:42,mask,mask,42,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,/// Decode a VPERMT2 W/D/Q/PS/PD mask from a raw array of constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:33,mask,mask,33,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,"/// Decode a VPPERM mask from a raw array of constants such as from; /// BUILD_VECTOR.; /// This can only basic masks (permutes + zeros), not any of the other; /// operations that VPPERM can perform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,2,['mask'],"['mask', 'masks']"
Availability,/// Decode a VPPERM variable mask from an IR-level vector constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.h:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.h,1,['mask'],['mask']
Availability,/// Decode a move lower and zero upper instruction as a shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:64,mask,mask,64,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,/// Decode a scalar float move instruction as a shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:56,mask,mask,56,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,/// Decode a shuffle packed values at 128-bit granularity; /// (SHUFF32x4/SHUFF64x2/SHUFI32x4/SHUFI64x2); /// immediate mask into a shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:120,mask,mask,120,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,2,['mask'],['mask']
Availability,/// Decode a target shuffle mask and inputs and see if any values are; /// known to be undef or zero from their inputs.; /// Returns true if the target shuffle mask was decoded.; /// FIXME: Merge this with computeZeroableShuffleElements?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,/// Decode a zero extension instruction as a shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:53,mask,mask,53,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['mask']
Availability,/// Decode an InlineInfo in Data at the specified offset.; ///; /// A local helper function to decode InlineInfo objects. This function is; /// called recursively when parsing child InlineInfo objects.; ///; /// \param Data The data extractor to decode from.; /// \param Offset The offset within \a Data to decode from.; /// \param BaseAddr The base address to use when decoding address ranges.; /// \returns An InlineInfo or an error describing the issue that was; /// encountered during decoding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp:429,error,error,429,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp,1,['error'],['error']
Availability,"/// Decode an InlineInfo object from a binary data stream.; ///; /// \param Data The binary stream to read the data from. This object must; /// have the data for the InlineInfo object starting at offset zero. The data; /// can contain more data than needed.; ///; /// \param BaseAddr The base address to use when decoding all address ranges.; /// This will be the FunctionInfo's start address if this object is directly; /// contained in a FunctionInfo object, or the start address of the first; /// address range in an InlineInfo object of this object is a child of; /// another InlineInfo object.; /// \returns An InlineInfo or an error describing the issue that was; /// encountered during decoding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/InlineInfo.h:633,error,error,633,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/InlineInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/InlineInfo.h,1,['error'],['error']
Availability,/// Decode an LineTable object from a binary data stream.; ///; /// \param Data The binary stream to read the data from. This object must; /// have the data for the LineTable object starting at offset zero. The data; /// can contain more data than needed.; ///; /// \param BaseAddr The base address to use when decoding the line table.; /// This will be the FunctionInfo's start address and will be used to; /// initialize the line table row prior to parsing any opcodes.; ///; /// \returns An LineTable or an error describing the issue that was; /// encountered during decoding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/LineTable.h:510,error,error,510,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/LineTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/LineTable.h,1,['error'],['error']
Availability,/// Decode an object from a binary data stream.; ///; /// \param Data The binary stream to read the data from. This object must; /// have the data for the object starting at offset zero. The data; /// can contain more data than needed.; ///; /// \param BaseAddr The FunctionInfo's start address and will be used as the; /// base address when decoding any contained information like the line table; /// and the inline info.; ///; /// \returns An FunctionInfo or an error describing the issue that was; /// encountered during decoding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h:464,error,error,464,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h,1,['error'],['error']
Availability,/// Decode an object from a binary data stream.; ///; /// \param Data The binary stream to read the data from. This object must; /// have the data for the object starting at offset zero. The data; /// can contain more data than needed.; ///; /// \returns A Header or an error describing the issue that was; /// encountered during decoding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/Header.h:270,error,error,270,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/Header.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/Header.h,1,['error'],['error']
Availability,"/// DecodePPCMMATypeFromStr - This decodes one PPC MMA type descriptor from Str,; /// advancing the pointer over the consumed characters. The decoded type is; /// returned. If the decoded type represents a constant integer with a; /// constraint on its value then Mask is set to that value. The type descriptors; /// used in Str are specific to PPC MMA builtins and are documented in the file; /// defining the PPC builtins.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:264,Mask,Mask,264,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Mask'],['Mask']
Availability,/// Decodes the shuffle masks for VPERMQ/VPERMPD.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:24,mask,masks,24,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['masks']
Availability,/// Decodes the shuffle masks for pshufd/pshufw/vpermilpd/vpermilps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:24,mask,masks,24,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['masks']
Availability,/// Decodes the shuffle masks for pshufhw.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:24,mask,masks,24,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['masks']
Availability,/// Decodes the shuffle masks for pshuflw.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:24,mask,masks,24,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['masks']
Availability,/// Decodes the shuffle masks for shufp*.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:24,mask,masks,24,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['masks']
Availability,/// Decodes the shuffle masks for unpckhps/unpckhpd and punpckh*.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:24,mask,masks,24,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['masks']
Availability,/// Decodes the shuffle masks for unpcklps/unpcklpd and punpckl*.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:24,mask,masks,24,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['mask'],['masks']
Availability,/// Decompose an icmp into the form ((X & Mask) pred 0) if possible. The; /// returned predicate is either == or !=. Returns false if decomposition; /// fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h:42,Mask,Mask,42,interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,1,['Mask'],['Mask']
Availability,"/// Decrement the fallible iterator.; ///; /// If the underlying 'dec' operation fails, this will set the Error value; /// and update this iterator value to point to end-of-range.; ///; /// The Error value is marked as needing checking, regardless of whether the; /// 'dec' operation succeeds or fails.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:106,Error,Error,106,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,2,['Error'],['Error']
Availability,"/// Decrements our count of the number of times we've seen a pragma forcing; /// functions to be __host__ __device__. Returns false if the count is 0; /// before incrementing, so you can emit an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:195,error,error,195,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// DefMaxInstsToScan - the default number of maximum instructions; /// to scan in the block, used by FindAvailableLoadedValue().; /// FindAvailableLoadedValue() was introduced in r60148, to improve jump; /// threading in part by eliminating partially redundant loads.; /// At that point, the value of MaxInstsToScan was already set to '6'; /// without documented explanation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:252,redundant,redundant,252,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['redundant'],['redundant']
Availability,/// Default constructor available to create invalid positions implicitly. All; /// other positions need to be created explicitly through the appropriate; /// static member function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:24,avail,available,24,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['avail'],['available']
Availability,"/// Default options when address sanitizer starts up in ROOT executables.; /// This is relevant when ROOT's build option `asan` is on.; /// These can be overridden / augmented by the ASAN_OPTIONS environment variable.; /// Using ASAN_OPTIONS=help=1 and starting an instrumented ROOT exectuable, available options will be printed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/SanitizerSetup.cxx:295,avail,available,295,core/sanitizer/SanitizerSetup.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/SanitizerSetup.cxx,1,['avail'],['available']
Availability,"/// Default options when leak sanitizer starts up in ROOT exectuables.; /// This is relevant when ROOT's build options `asan` is on.; /// These can be overridden / augmented by the LSAN_OPTIONS environment variable.; /// Using LSAN_OPTIONS=help=1 and starting an instrumented ROOT exectuable, available options will be printed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/SanitizerSetup.cxx:293,avail,available,293,core/sanitizer/SanitizerSetup.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/SanitizerSetup.cxx,1,['avail'],['available']
Availability,"/// Define all symbols provided by the materialization unit to be part of this; /// JITDylib.; ///; /// If RT is not specified then the default resource tracker will be used.; ///; /// This overload always takes ownership of the MaterializationUnit. If any; /// errors occur, the MaterializationUnit consumed.; ///; /// It is illegal to call this method on a defunct JITDylib and the client; /// is responsible for ensuring that they do not do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:262,error,errors,262,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['error'],['errors']
Availability,"/// Define all symbols provided by the materialization unit to be part of this; /// JITDylib.; ///; /// This overload only takes ownership of the MaterializationUnit no error is; /// generated. If an error occurs, ownership remains with the caller. This; /// may allow the caller to modify the MaterializationUnit to correct the; /// issue, then re-call define.; ///; /// It is illegal to call this method on a defunct JITDylib and the client; /// is responsible for ensuring that they do not do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:169,error,error,169,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,2,['error'],['error']
Availability,"/// Define how a function affects the system variable 'errno'.; /// This works together with the \c ErrnoModeling and \c ErrnoChecker classes.; /// Currently 3 use cases exist: success, failure, irrelevant.; /// In the future the failure case can be customized to set \c errno to a; /// more specific constraint (for example > 0), or new case can be added; /// for functions which require check of \c errno in both success and failure; /// case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:186,failure,failure,186,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,3,['failure'],['failure']
Availability,/// Define the kind of action this repairing needs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:35,repair,repairing,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,1,['repair'],['repairing']
Availability,"/// DefineBB - Define the specified basic block, which is either named or; /// unnamed. If there is an error, this returns null otherwise it returns; /// the block being defined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:103,error,error,103,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,1,['error'],['error']
Availability,"/// Defines string and numeric variables from definitions given on the; /// command line, passed as a vector of [#]VAR=VAL strings in; /// \p CmdlineDefines. \returns an error list containing diagnostics against; /// \p SM for all definition parsing failures, if any, or Success otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:170,error,error,170,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,2,"['error', 'failure']","['error', 'failures']"
Availability,/// Defines the possible values of the branch boundary alignment mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h:65,mask,mask,65,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,1,['mask'],['mask']
Availability,"/// DelayForLiveRegsBottomUp - Returns true if it is necessary to delay; /// scheduling of the given node to satisfy live physical register dependencies.; /// If the specific node is the last one that's available to schedule, do; /// whatever is necessary (i.e. backtracking or cloning) to make it possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:203,avail,available,203,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,2,['avail'],['available']
Availability,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:77,avail,available,77,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,2,['avail'],['available']
Availability,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:77,avail,available,77,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,2,['avail'],['available']
Availability,"/// DeltaAlgorithm - Implements the delta debugging algorithm (A. Zeller '99); /// for minimizing arbitrary sets using a predicate function.; ///; /// The result of the algorithm is a subset of the input change set which is; /// guaranteed to satisfy the predicate, assuming that the input set did. For; /// well formed predicates, the result set is guaranteed to be such that; /// removing any single element would falsify the predicate.; ///; /// For best results the predicate function *should* (but need not) satisfy; /// certain properties, in particular:; /// (1) The predicate should return false on an empty set and true on the full; /// set.; /// (2) If the predicate returns true for a set of changes, it should return; /// true for all supersets of that set.; ///; /// It is not an error to provide a predicate that does not satisfy these; /// requirements, and the algorithm will generally produce reasonable; /// results. However, it may run substantially more tests than with a good; /// predicate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:793,error,error,793,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,1,['error'],['error']
Availability,"/// Demangle into an AST. Subsequent calls to the rest of the member functions; /// implicitly operate on the AST this produces.; /// \return true on error, false otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/Demangle.h:150,error,error,150,interpreter/llvm-project/llvm/include/llvm/Demangle/Demangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/Demangle.h,1,['error'],['error']
Availability,"/// Demangles the Microsoft symbol pointed at by mangled_name and returns it.; /// Returns a pointer to the start of a null-terminated demangled string on; /// success, or nullptr on error.; /// If n_read is non-null and demangling was successful, it receives how many; /// bytes of the input string were consumed.; /// status receives one of the demangle_ enum entries above if it's not nullptr.; /// Flags controls various details of the demangled representation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/Demangle.h:183,error,error,183,interpreter/llvm-project/llvm/include/llvm/Demangle/Demangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/Demangle.h,1,['error'],['error']
Availability,"/// Deposit (scatter) low-order bits from the unsigned 32-bit integer \a __X; /// into the 32-bit result, according to the mask in the unsigned 32-bit; /// integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 31; /// IF __Y[m] == 1; /// result[m] := __X[i]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PDEP instruction.; ///; /// \param __X; /// The 32-bit source value to copy.; /// \param __Y; /// The 32-bit mask specifying where to deposit source bits.; /// \returns The 32-bit result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:123,mask,mask,123,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,2,['mask'],['mask']
Availability,"/// Deposit (scatter) low-order bits from the unsigned 64-bit integer \a __X; /// into the 64-bit result, according to the mask in the unsigned 64-bit; /// integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 63; /// IF __Y[m] == 1; /// result[m] := __X[i]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PDEP instruction.; ///; /// \param __X; /// The 64-bit source value to copy.; /// \param __Y; /// The 64-bit mask specifying where to deposit source bits.; /// \returns The 64-bit result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:123,mask,mask,123,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,2,['mask'],['mask']
Availability,"/// Derived classes should implement low-level reading without buffering. Short reads indicate the end of the file,; /// therefore derived classes should return nbytes bytes if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RRawFile.hxx:177,avail,available,177,io/io/inc/ROOT/RRawFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RRawFile.hxx,1,['avail'],['available']
Availability,"/// Descends any type down to ""elementary"" components,; /// discovering the smallest addressable one.; /// If zero is returned, declaration will not be modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:22,down,down,22,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,1,['down'],['down']
Availability,"/// Describes the kind of merge to perform for availability; /// attributes (including ""deprecated"", ""unavailable"", and ""availability"").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:47,avail,availability,47,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['avail'],['availability']
Availability,"/// Describes the kind of priority given to an availability attribute.; ///; /// The sum of priorities deteremines the final priority of the attribute.; /// The final priority determines how the attribute will be merged.; /// An attribute with a lower priority will always remove higher priority; /// attributes for the specified platform when it is being applied. An; /// attribute with a higher priority will not be applied if the declaration; /// already has an availability attribute with a lower priority for the; /// specified platform. The final prirority values are not expected to match; /// the values in this enumeration, but instead should be treated as a plain; /// integer value. This enumeration just names the priority weights that are; /// used to calculate that final vaue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:47,avail,availability,47,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['avail'],['availability']
Availability,"/// Describes the result of template argument deduction.; ///; /// The TemplateDeductionResult enumeration describes the result of; /// template argument deduction, as returned from; /// DeduceTemplateArguments(). The separate TemplateDeductionInfo; /// structure provides additional information about the results of; /// template argument deduction, e.g., the deduced template argument; /// list (if successful) or the specific template parameters or; /// deduced arguments that were involved in the failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:501,failure,failure,501,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['failure'],['failure']
Availability,/// Describes the trailing object for Availability attribute in ParsedAttr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:38,Avail,Availability,38,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['Avail'],['Availability']
Availability,/// Describes two clones that reference their variables in a different pattern; /// which could indicate a programming error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CloneDetection.h:119,error,error,119,interpreter/llvm-project/clang/include/clang/Analysis/CloneDetection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CloneDetection.h,1,['error'],['error']
Availability,/// Destroy a Error. Fails with a call to abort() if the error is; /// unchecked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:14,Error,Error,14,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// Destroy the underlying value.; ///; /// This should get optimized down to a no-op. We could skip it if we could; /// add a static assert on \a std::is_trivially_copyable(), but we currently; /// support versions of GCC that don't understand that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:70,down,down,70,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,1,['down'],['down']
Availability,/// Destruct a MaterializationResponsibility instance. In debug mode; /// this asserts that all symbols being tracked have been either; /// emitted or notified of an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:166,error,error,166,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['error'],['error']
Availability,"/// Destructs resources that are taken by using the default error handler.; /// This function is called during the destruction of gROOT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/TErrorDefaultHandler.hxx:60,error,error,60,core/base/inc/ROOT/TErrorDefaultHandler.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/TErrorDefaultHandler.hxx,1,['error'],['error']
Availability,"/// Determine if \p A and \p B are equivalent internal linkage declarations; /// from different modules, and thus an ambiguity error can be downgraded to; /// an extension warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:127,error,error,127,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['down', 'error']","['downgraded', 'error']"
Availability,/// Determine if import failure of a child does not cause import failure of; /// its parent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:24,failure,failure,24,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,['failure'],['failure']
Availability,/// Determine if the explicit specifier is invalid.; /// This state occurs after a substitution failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:96,failure,failures,96,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['failure'],['failures']
Availability,"/// Determine if the target supports unaligned memory accesses.; ///; /// This function returns true if the target allows unaligned memory accesses; /// of the specified type in the given address space. If true, it also returns; /// a relative speed of the unaligned memory access in the last argument by; /// reference. The higher the speed number the faster the operation comparing; /// to a number returned by another such call. This is used, for example, in; /// situations where an array copy/move/set is converted to a sequence of; /// store operations. Its use helps to ensure that such replacements don't; /// generate code that causes an alignment error (trap) on the target machine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:657,error,error,657,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['error'],['error']
Availability,"/// Determine if the target supports unaligned memory accesses.; ///; /// This function returns true if the target allows unaligned memory accesses; /// of the specified type in the given address space. If true, it also returns; /// whether the unaligned memory access is ""fast"" in the last argument by; /// reference. This is used, for example, in situations where an array; /// copy/move/set is converted to a sequence of store operations. Its use; /// helps to ensure that such replacements don't generate code that causes an; /// alignment error (trap) on the target machine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:544,error,error,544,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['error'],['error']
Availability,/// Determine if this AvailabilityInfo represents the default availability.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/AvailabilityInfo.h:22,Avail,AvailabilityInfo,22,interpreter/llvm-project/clang/include/clang/ExtractAPI/AvailabilityInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/AvailabilityInfo.h,2,"['Avail', 'avail']","['AvailabilityInfo', 'availability']"
Availability,/// Determine if this is an equals/not equals predicate.; /// This is a static version that you can use without an instruction; /// available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:132,avail,available,132,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['avail'],['available']
Availability,"/// Determine the availability of the given declaration based on; /// the target platform.; ///; /// When it returns an availability result other than \c AR_Available,; /// if the \p Message parameter is non-NULL, it will be set to a; /// string describing why the entity is unavailable.; ///; /// FIXME: Make these strings localizable, since they end up in; /// diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:18,avail,availability,18,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,2,['avail'],['availability']
Availability,"/// Determine the availability of the given declaration.; ///; /// This routine will determine the most restrictive availability of; /// the given declaration (e.g., preferring 'unavailable' to; /// 'deprecated').; ///; /// \param Message If non-NULL and the result is not \c; /// AR_Available, will be set to a (possibly empty) message; /// describing why the declaration has not been introduced, is; /// deprecated, or is unavailable.; ///; /// \param EnclosingVersion The version to compare with. If empty, assume the; /// deployment target version.; ///; /// \param RealizedPlatform If non-NULL and the availability result is found; /// in an available attribute it will set to the platform which is written in; /// the available attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:18,avail,availability,18,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,5,['avail'],"['availability', 'available']"
Availability,/// Determine the index of a field in its parent record.; /// F should be a field (or indirect field) declaration.; /// \returns The index of the field in its parent context (starting from 0).; /// On error `std::nullopt` is returned (parent context is non-record).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:201,error,error,201,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,/// Determine the length of the longest redundant prefix of the paths in; /// \p Paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:40,redundant,redundant,40,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redundant'],['redundant']
Availability,"/// Determine the length of the longest redundant prefix of the substrs starts; /// from \p LCP in \p Paths. \p Paths can't be empty. If there's only one; /// element in \p Paths, the length of the substr is returned. Note this is; /// differnet from the behavior of the function above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:40,redundant,redundant,40,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redundant'],['redundant']
Availability,/// Determine what the most derived array's size is. Results in an assertion; /// failure if the most derived array lacks a size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:82,failure,failure,82,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['failure'],['failure']
Availability,"/// Determine whether an unrecoverable error has occurred within this; /// function. Note that this may return false even if the function body is; /// invalid, because the errors may be suppressed if they're caused by prior; /// invalid declarations.; ///; /// FIXME: Migrate the caller of this to use containsErrors() instead once; /// it's ready.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h:39,error,error,39,interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,2,['error'],"['error', 'errors']"
Availability,/// Determine whether any SFINAE errors have been trapped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:33,error,errors,33,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['errors']
Availability,/// Determine whether any errors have occurred since this; /// object instance was created.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:26,error,errors,26,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['errors']
Availability,/// Determine whether any errors occurred within this function/method/; /// block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:26,error,errors,26,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['error'],['errors']
Availability,/// Determine whether any kind of unrecoverable error has occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:48,error,error,48,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['error']
Availability,/// Determine whether any unrecoverable errors have occurred since this; /// object instance was created.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:40,error,errors,40,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['errors']
Availability,"/// Determine whether any unrecoverable errors have occurred within this; /// scope. Note that this may return false even if the scope contains invalid; /// declarations or statements, if the errors for those invalid constructs; /// were suppressed because some prior invalid construct was referenced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Scope.h:40,error,errors,40,interpreter/llvm-project/clang/include/clang/Sema/Scope.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Scope.h,2,['error'],['errors']
Availability,"/// Determine whether instruction 'To' is reachable from 'From', without passing; /// through any blocks in ExclusionSet, returning true if uncertain.; ///; /// Determine whether there is a path from From to To within a single function.; /// Returns false only if we can prove that once 'From' has been executed then; /// 'To' can not be executed. Conservatively returns true.; ///; /// This function is linear with respect to the number of blocks in the CFG,; /// walking down successors from From to reach To, with a fixed threshold.; /// Using DT or LI allows us to answer more quickly. LI reduces the cost of; /// an entire loop of any number of blocks to be the same as the cost of a; /// single block. DT reduces the cost by allowing the search to terminate when; /// we find a block that dominates the block containing 'To'. DT is most useful; /// on branchy code but not loops, and LI is most useful on code with loops but; /// does not help on branchy code outside loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:473,down,down,473,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,1,['down'],['down']
Availability,"/// Determine whether the given built-in diagnostic ID is for an; /// extension of some sort, and whether it is enabled by default.; ///; /// This also returns EnabledByDefault, which is set to indicate whether the; /// diagnostic is ignored by default (in which case -pedantic enables it) or; /// treated as a warning/error by default.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h:319,error,error,319,interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,1,['error'],['error']
Availability,"/// Determine whether the next set of tokens contains a type-id.; ///; /// The context parameter states what context we're parsing right; /// now, which affects how this routine copes with the token; /// following the type-id. If the context is TypeIdInParens, we have; /// already parsed the '(' and we will cease lookahead when we hit; /// the corresponding ')'. If the context is; /// TypeIdAsTemplateArgument, we've already parsed the '<' or ','; /// before this template argument, and will cease lookahead when we; /// hit a '>', '>>' (in C++0x), or ','; or, in C++0x, an ellipsis immediately; /// preceding such. Returns true for a type-id and false for an expression.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; ///; /// type-id:; /// type-specifier-seq abstract-declarator[opt]; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:727,error,error,727,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['error'],['error']
Availability,/// Determine whether the two declarations are structurally; /// equivalent.; /// Implementation functions (all static functions in; /// ASTStructuralEquivalence.cpp) must never call this function because that; /// will wreak havoc the internal state (\c DeclsToCheck and; /// \c VisitedDecls members) and can cause faulty equivalent results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h:316,fault,faulty,316,interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,1,['fault'],['faulty']
Availability,/// Determine whether the two statements are structurally equivalent.; /// Implementation functions (all static functions in; /// ASTStructuralEquivalence.cpp) must never call this function because that; /// will wreak havoc the internal state (\c DeclsToCheck and; /// \c VisitedDecls members) and can cause faulty equivalent results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h:309,fault,faulty,309,interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,1,['fault'],['faulty']
Availability,/// Determine whether the two types are structurally equivalent.; /// Implementation functions (all static functions in; /// ASTStructuralEquivalence.cpp) must never call this function because that; /// will wreak havoc the internal state (\c DeclsToCheck and; /// \c VisitedDecls members) and can cause faulty equivalent results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h:304,fault,faulty,304,interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,1,['fault'],['faulty']
Availability,"/// Determine whether the use of this declaration is valid, and; /// emit any corresponding diagnostics.; ///; /// This routine diagnoses various problems with referencing; /// declarations that can occur when using a declaration. For example,; /// it might warn if a deprecated or unavailable declaration is being; /// used, or produce an error (and return true) if a C++0x deleted; /// function is being used.; ///; /// \returns true if there was an error (this declaration cannot be; /// referenced), false otherwise.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:340,error,error,340,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['error'],['error']
Availability,"/// Determine whether there is a template argument to be used for; /// deduction.; ///; /// This routine ""expands"" argument packs in-place, overriding its input; /// parameters so that \c Args[ArgIdx] will be the available template argument.; ///; /// \returns true if there is another template argument (which will be at; /// \c Args[ArgIdx]), false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:213,avail,available,213,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['avail'],['available']
Availability,/// Determine whether this availability change is valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:27,avail,availability,27,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['avail'],['availability']
Availability,"/// Determine whether this is a weak-imported symbol.; ///; /// Weak-imported symbols are typically marked with the; /// 'weak_import' attribute, but may also be marked with an; /// 'availability' attribute where we're targing a platform prior to; /// the introduction of this feature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:183,avail,availability,183,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['avail'],['availability']
Availability,/// Determine whether this module is available for use within the; /// current translation unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h:37,avail,available,37,interpreter/llvm-project/clang/include/clang/Basic/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h,1,['avail'],['available']
Availability,"/// Determine whether this module is available for use within the; /// current translation unit.; ///; /// \param LangOpts The language options used for the current; /// translation unit.; ///; /// \param Target The target options used for the current translation unit.; ///; /// \param Req If this module is unavailable because of a missing requirement,; /// this parameter will be set to one of the requirements that is not met for; /// use of this module.; ///; /// \param MissingHeader If this module is unavailable because of a missing; /// header, this parameter will be set to one of the missing headers.; ///; /// \param ShadowingModule If this module is unavailable because it is; /// shadowed, this parameter will be set to the shadowing module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h:37,avail,available,37,interpreter/llvm-project/clang/include/clang/Basic/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h,1,['avail'],['available']
Availability,"/// Determine whether we could expand a pack expansion with the; /// given set of parameter packs into separate arguments by repeatedly; /// transforming the pattern.; ///; /// \param EllipsisLoc The location of the ellipsis that identifies the; /// pack expansion.; ///; /// \param PatternRange The source range that covers the entire pattern of; /// the pack expansion.; ///; /// \param Unexpanded The set of unexpanded parameter packs within the; /// pattern.; ///; /// \param ShouldExpand Will be set to \c true if the transformer should; /// expand the corresponding pack expansions into separate arguments. When; /// set, \c NumExpansions must also be set.; ///; /// \param RetainExpansion Whether the caller should add an unexpanded; /// pack expansion after all of the expanded arguments. This is used; /// when extending explicitly-specified template argument packs per; /// C++0x [temp.arg.explicit]p9.; ///; /// \param NumExpansions The number of separate arguments that will be in; /// the expanded form of the corresponding pack expansion. This is both an; /// input and an output parameter, which can be set by the caller if the; /// number of expansions is known a priori (e.g., due to a prior substitution); /// and will be set by the callee when the number of expansions is known.; /// The callee must set this value when \c ShouldExpand is \c true; it may; /// set this value in other cases.; ///; /// \returns true if an error occurred (e.g., because the parameter packs; /// are to be instantiated with arguments of different lengths), false; /// otherwise. If false, \c ShouldExpand (and possibly \c NumExpansions); /// must be set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:1440,error,error,1440,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// Determine whether we should expand a pack expansion with the; /// given set of parameter packs into separate arguments by repeatedly; /// transforming the pattern.; ///; /// By default, the transformer never tries to expand pack expansions.; /// Subclasses can override this routine to provide different behavior.; ///; /// \param EllipsisLoc The location of the ellipsis that identifies the; /// pack expansion.; ///; /// \param PatternRange The source range that covers the entire pattern of; /// the pack expansion.; ///; /// \param Unexpanded The set of unexpanded parameter packs within the; /// pattern.; ///; /// \param ShouldExpand Will be set to \c true if the transformer should; /// expand the corresponding pack expansions into separate arguments. When; /// set, \c NumExpansions must also be set.; ///; /// \param RetainExpansion Whether the caller should add an unexpanded; /// pack expansion after all of the expanded arguments. This is used; /// when extending explicitly-specified template argument packs per; /// C++0x [temp.arg.explicit]p9.; ///; /// \param NumExpansions The number of separate arguments that will be in; /// the expanded form of the corresponding pack expansion. This is both an; /// input and an output parameter, which can be set by the caller if the; /// number of expansions is known a priori (e.g., due to a prior substitution); /// and will be set by the callee when the number of expansions is known.; /// The callee must set this value when \c ShouldExpand is \c true; it may; /// set this value in other cases.; ///; /// \returns true if an error occurred (e.g., because the parameter packs; /// are to be instantiated with arguments of different lengths), false; /// otherwise. If false, \c ShouldExpand (and possibly \c NumExpansions); /// must be set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:1591,error,error,1591,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['error'],['error']
Availability,"/// Determine whether we will definitely emit this variable with a constant; /// initializer, either because the language semantics demand it or because; /// we know that the initializer is a constant.; // For weak definitions, any initializer available in the current translation; // is not necessarily reflective of the initializer used; such initializers; // are ignored unless if InspectInitForWeakDef is true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:244,avail,available,244,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,1,['avail'],['available']
Availability,"/// Determine whether we're looking at something that might be a declarator; /// in a simple-declaration. If it can't possibly be a declarator, maybe; /// diagnose a missing semicolon after a prior tag definition in the decl; /// specifier.; ///; /// \return \c true if an error occurred and this can't be any kind of; /// declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:273,error,error,273,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"/// Determine which floating-point classes are valid for \p V, and return them; /// in KnownFPClass bit sets.; ///; /// This function is defined on values with floating-point type, values vectors; /// of floating-point type, and arrays of floating-point type.; /// \p InterestedClasses is a compile time optimization hint for which floating; /// point classes should be queried. Queries not specified in \p; /// InterestedClasses should be reliable if they are determined during the; /// query.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:440,reliab,reliable,440,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['reliab'],['reliable']
Availability,/// Determine which of the bits specified in Mask are known to be either zero or; /// one and return them in the Known.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:45,Mask,Mask,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Mask'],['Mask']
Availability,/// Determine which of the bits specified in Mask are known to be either zero; /// or one and return them in the KnownZero/KnownOne bitsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h:45,Mask,Mask,45,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,1,['Mask'],['Mask']
Availability,/// Determine which of the bits specified in Mask are known to be either zero; /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts; /// argument allows us to only collect the known bits that are shared by the; /// requested vector elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:45,Mask,Mask,45,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Mask'],['Mask']
Availability,/// Determine which of the bits specified in Mask are known to be either zero; /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts; /// argument allows us to only collect the known bits that are shared by the; /// requested vector elements. This is for GISel.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:45,Mask,Mask,45,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Mask'],['Mask']
Availability,/// Determine which of the bits specified in Mask are known to be either; /// zero or one and return them in the KnownZero/KnownOne bitsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:45,Mask,Mask,45,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,2,['Mask'],['Mask']
Availability,/// Determine which of the bits specified in \p Mask are known to be; /// either zero or one and return them in the \p KnownZero and \p KnownOne; /// bitsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h:48,Mask,Mask,48,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,1,['Mask'],['Mask']
Availability,"/// Determines how the Merge function behaves upon merging errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx:59,error,errors,59,tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,1,['error'],['errors']
Availability,"/// Determines if Phi may have been type-promoted. If Phi has a single user; /// that ANDs the Phi with a type mask, return the user. RT is updated to; /// account for the narrower bit width represented by the mask, and the AND; /// instruction is added to CI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:111,mask,mask,111,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,2,['mask'],['mask']
Availability,/// Determines if \p M is a shuffle vector mask for a TRN of \p NumElts.; /// Whether or not G_TRN1 or G_TRN2 should be used is stored in \p WhichResult.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,1,['mask'],['mask']
Availability,/// Determines if \p M is a shuffle vector mask for a UZP of \p NumElts.; /// Whether or not G_UZP1 or G_UZP2 should be used is stored in \p WhichResult.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,1,['mask'],['mask']
Availability,"/// Determines if this is a sizeless type supported by the; /// 'riscv_rvv_vector_bits' type attribute, which can be applied to a single; /// RVV vector or mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:156,mask,mask,156,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['mask'],['mask']
Availability,"/// Determines if this is an ""acceptable"" loose mismatch in the global; /// method pool. This exists mostly as a hack to get around certain; /// global mismatches which we can't afford to make warnings / errors.; /// Really, what we want is a way to take a method out of the global; /// method pool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:204,error,errors,204,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['error'],['errors']
Availability,"/// Determines the constraint code and constraint type to use for the specific; /// AsmOperandInfo, setting OpInfo.ConstraintCode and OpInfo.ConstraintType.; /// If the actual operand being passed in is available, it can be passed in as; /// Op, otherwise an empty SDValue can be passed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:203,avail,available,203,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['avail'],['available']
Availability,"/// Determines whether ChainElem can be moved up (if IsLoad) or down (if; /// !IsLoad) to ChainBegin -- i.e. there are no intervening may-alias; /// instructions.; ///; /// The map ChainElemOffsets must contain all of the elements in; /// [ChainBegin, ChainElem] and their offsets from some arbitrary base; /// address. It's ok if it contains additional entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:64,down,down,64,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['down'],['down']
Availability,"/// Determines whether a given calling convention is valid for the; /// target. A calling convention can either be accepted, produce a warning; /// and be substituted with the default calling convention, or (someday); /// produce an error (such as using thiscall on a non-instance function).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:233,error,error,233,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['error'],['error']
Availability,"/// Determines whether the given built-in diagnostic ID is; /// for an error that is suppressed if it occurs during C++ template; /// argument deduction.; ///; /// When an error is suppressed due to SFINAE, the template argument; /// deduction fails but no diagnostic is emitted. Certain classes of; /// errors, such as those errors that involve C++ access control,; /// are not SFINAE errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h:71,error,error,71,interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,5,['error'],"['error', 'errors']"
Availability,"/// Determines whether the type of this expression depends on; /// - a template parameter (C++ [temp.dep.expr], which means that its type; /// could change from one template instantiation to the next); /// - or an error; ///; /// For example, the expressions ""x"" and ""x + y"" are type-dependent in; /// the following code, but ""y"" is not type-dependent:; /// @code; /// template<typename T>; /// void add(T x, int y) {; /// x + y;; /// }; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:214,error,error,214,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['error'],['error']
Availability,"/// Determines whether the value of this expression depends on; /// - a template parameter (C++ [temp.dep.constexpr]); /// - or an error, whose resolution is unknown; ///; /// For example, the array bound of ""Chars"" in the following example is; /// value-dependent.; /// @code; /// template<int Size, char (&Chars)[Size]> struct meta_string;; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:131,error,error,131,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['error'],['error']
Availability,"/// Determines whether we are currently in a context where; /// template argument substitution failures are not considered; /// errors.; ///; /// \returns An empty \c Optional if we're not in a SFINAE context.; /// Otherwise, contains a pointer that, if non-NULL, contains the nearest; /// template-deduction context object, which can be used to capture; /// diagnostics that will be suppressed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:95,failure,failures,95,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['error', 'failure']","['errors', 'failures']"
Availability,"/// Diagnose a declaration whose declarator-id has the given; /// nested-name-specifier.; ///; /// \param SS The nested-name-specifier of the declarator-id.; ///; /// \param DC The declaration context to which the nested-name-specifier; /// resolves.; ///; /// \param Name The name of the entity being declared.; ///; /// \param Loc The location of the name of the entity being declared.; ///; /// \param IsTemplateId Whether the name is a (simple-)template-id, and thus; /// we're declaring an explicit / partial specialization / instantiation.; ///; /// \returns true if we cannot safely recover from this error, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:590,recover,recover,590,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:70,error,error,70,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,4,"['error', 'recover']","['error', 'recover', 'recovery']"
Availability,/// Diagnose a reference to a field with no object available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:51,avail,available,51,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['avail'],['available']
Availability,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:502,Error,ErrorRecovery,502,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,3,"['Error', 'error', 'recover']","['ErrorRecovery', 'error', 'recover']"
Availability,/// Diagnose a template argument deduction failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:43,failure,failure,43,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,/// Diagnose a template argument deduction failure.; /// We are treating these failures as overload failures due to bad; /// deductions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:43,failure,failure,43,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,3,['failure'],"['failure', 'failures']"
Availability,"/// Diagnose cases where we have an explicit template specialization; /// before/after an explicit template instantiation, producing diagnostics; /// for those cases where they are required and determining whether the; /// new specialization/instantiation will have any effect.; ///; /// \param NewLoc the location of the new explicit specialization or; /// instantiation.; ///; /// \param NewTSK the kind of the new explicit specialization or instantiation.; ///; /// \param PrevDecl the previous declaration of the entity.; ///; /// \param PrevTSK the kind of the old explicit specialization or instantiatin.; ///; /// \param PrevPointOfInstantiation if valid, indicates where the previous; /// declaration was instantiated (either implicitly or explicitly).; ///; /// \param HasNoEffect will be set to true to indicate that the new; /// specialization or instantiation has no effect and should be ignored.; ///; /// \returns true if there was an error that should prevent the introduction of; /// the new declaration into the AST, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:949,error,error,949,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['error'],['error']
Availability,/// Diagnose if arithmetic on the given ObjC pointer is illegal.; ///; /// \return true on error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,error,error,91,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,/// Diagnose redundant or conflicting nullability information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:13,redundant,redundant,13,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['redundant'],['redundant']
Availability,"/// Diagnose unexpanded parameter packs.; ///; /// \param Loc The location at which we should emit the diagnostic.; ///; /// \param UPPC The context in which we are diagnosing unexpanded; /// parameter packs.; ///; /// \param Unexpanded the set of unexpanded parameter packs.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:306,error,error,306,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// DiagnoseTemplateParameterShadow - Produce a diagnostic complaining; /// that the template parameter 'PrevDecl' is being shadowed by a new; /// declaration at location Loc. Returns true to indicate that this is; /// an error, and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:222,error,error,222,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['error'],['error']
Availability,/// Diagnoses an error at L if we are not in an FPO prologue. Return true on; /// error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86WinCOFFTargetStreamer.cpp:17,error,error,17,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86WinCOFFTargetStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86WinCOFFTargetStreamer.cpp,2,['error'],['error']
Availability,"/// Diagnostic IDs for errors, warnings, and notes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceMgrAdapter.h:23,error,errors,23,interpreter/llvm-project/clang/include/clang/Basic/SourceMgrAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceMgrAdapter.h,1,['error'],['errors']
Availability,"/// Diagnostic handler that's installed for all google tests.; /// It will generate a test failure when a diagnostic message is issued.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/src/TestSupport.cxx:91,failure,failure,91,core/testsupport/src/TestSupport.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/src/TestSupport.cxx,1,['failure'],['failure']
Availability,/// Diagnostic information for optimization failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:44,failure,failures,44,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['failure'],['failures']
Availability,/// Diagnostic level. Can indicate either an error or a warning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h:45,error,error,45,interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,1,['error'],['error']
Availability,"/// DiffFilesWithTolerance - Compare the two files specified, returning 0 if the; /// files match, 1 if they are different, and 2 if there is a file error. This; /// function differs from DiffFiles in that you can specify an absolute and; /// relative FP error that is allowed to exist. If you specify a string to fill; /// in for the error option, it will set the string to an error message if an; /// error occurs, allowing the caller to distinguish between a failed diff and a; /// file system error.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp:149,error,error,149,interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,6,['error'],['error']
Availability,"/// DiffFilesWithTolerance - Compare the two files specified, returning 0 if; /// the files match, 1 if they are different, and 2 if there is a file error.; /// This function allows you to specify an absolute and relative FP error that; /// is allowed to exist. If you specify a string to fill in for the error; /// option, it will set the string to an error message if an error occurs, or; /// if the files are different.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileUtilities.h:149,error,error,149,interpreter/llvm-project/llvm/include/llvm/Support/FileUtilities.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileUtilities.h,5,['error'],['error']
Availability,/// Disable crash recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:18,recover,recovery,18,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,1,['recover'],['recovery']
Availability,"/// Disable the fast evaluation of the complex error function using look-up; /// tables (default is the ""slow"" CERNlib algorithm).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooVoigtian.h:47,error,error,47,roofit/roofit/inc/RooVoigtian.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooVoigtian.h,1,['error'],['error']
Availability,/// Disables the register from the list of CSRs.; /// I.e. the register will not appear as part of the CSR mask.; /// \see UpdatedCalleeSavedRegs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:107,mask,mask,107,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,1,['mask'],['mask']
Availability,"/// DisassemblerEmitter - Contains disassembler table emitters for various; /// architectures.; /// X86 Disassembler Emitter; ///; /// *** IF YOU'RE HERE TO RESOLVE A ""Primary decode conflict"", LOOK DOWN NEAR; /// THE END OF THIS COMMENT!; ///; /// The X86 disassembler emitter is part of the X86 Disassembler, which is; /// documented in lib/Target/X86/X86Disassembler.h.; ///; /// The emitter produces the tables that the disassembler uses to translate; /// instructions. The emitter generates the following tables:; ///; /// - One table (CONTEXTS_SYM) that contains a mapping of attribute masks to; /// instruction contexts. Although for each attribute there are cases where; /// that attribute determines decoding, in the majority of cases decoding is; /// the same whether or not an attribute is present. For example, a 64-bit; /// instruction with an OPSIZE prefix and an XS prefix decodes the same way in; /// all cases as a 64-bit instruction with only OPSIZE set. (The XS prefix; /// may have effects on its execution, but does not change the instruction; /// returned.) This allows considerable space savings in other tables.; /// - Six tables (ONEBYTE_SYM, TWOBYTE_SYM, THREEBYTE38_SYM, THREEBYTE3A_SYM,; /// THREEBYTEA6_SYM, and THREEBYTEA7_SYM contain the hierarchy that the; /// decoder traverses while decoding an instruction. At the lowest level of; /// this hierarchy are instruction UIDs, 16-bit integers that can be used to; /// uniquely identify the instruction and correspond exactly to its position; /// in the list of CodeGenInstructions for the target.; /// - One table (INSTRUCTIONS_SYM) contains information about the operands of; /// each instruction and how to decode them.; ///; /// During table generation, there may be conflicts between instructions that; /// occupy the same space in the decode tables. These conflicts are resolved as; /// follows in setTableFields() (X86DisassemblerTables.cpp); ///; /// - If the current context is the native context for one of the i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DisassemblerEmitter.cpp:199,DOWN,DOWN,199,interpreter/llvm-project/llvm/utils/TableGen/DisassemblerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DisassemblerEmitter.cpp,2,"['DOWN', 'mask']","['DOWN', 'masks']"
Availability,/// Disconnect from the target process.; ///; /// This should be called after the JIT session is shut down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h:102,down,down,102,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,1,['down'],['down']
Availability,"/// Discriminated union of Pass ID types.; ///; /// The PassConfig API prefers dealing with IDs because they are safer and more; /// efficient. IDs decouple configuration from instantiation. This way, when a; /// pass is overriden, it isn't unnecessarily instantiated. It is also unsafe to; /// refer to a Pass pointer after adding it to a pass manager, which deletes; /// redundant pass instances.; ///; /// However, it is convient to directly instantiate target passes with; /// non-default ctors. These often don't have a registered PassInfo. Rather than; /// force all target passes to implement the pass registry boilerplate, allow; /// the PassConfig API to handle either type.; ///; /// AnalysisID is sadly char*, so PointerIntPair won't work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:373,redundant,redundant,373,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,1,['redundant'],['redundant']
Availability,/// Dispatching routine to lower various 128-bit x86 vector shuffles.; ///; /// This routine breaks down the specific type of 128-bit shuffle and; /// dispatches to the lowering routines accordingly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:100,down,down,100,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,"/// Dithering mass distributer.; ///; /// This class splits up a single mass into portions by weight, dithering to; /// spread out error. No mass is lost. The dithering precision depends on the; /// precision of the product of \a BlockMass and \a BranchProbability.; ///; /// The distribution algorithm follows.; ///; /// 1. Initialize by saving the sum of the weights in \a RemWeight and the; /// mass to distribute in \a RemMass.; ///; /// 2. For each portion:; ///; /// 1. Construct a branch probability, P, as the portion's weight divided; /// by the current value of \a RemWeight.; /// 2. Calculate the portion's mass as \a RemMass times P.; /// 3. Update \a RemWeight and \a RemMass at each portion by subtracting; /// the current portion's weight and mass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:131,error,error,131,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,1,['error'],['error']
Availability,"/// Divide the first APFloat by the second, rounding ties to the nearest even.; /// No error checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:87,error,error,87,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,1,['error'],['error']
Availability,"/// Do last resort, unqualified lookup on a LookupResult that; /// Sema cannot find.; ///; /// \param R a LookupResult that is being recovered.; ///; /// \param S the Scope of the identifier occurrence.; ///; /// \return true to tell Sema to recover using the LookupResult.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h:133,recover,recovered,133,interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,4,['recover'],"['recover', 'recovered']"
Availability,"/// Does DstMask form a complementary pair with the mask provided by; /// BitsToBeInserted, suitable for use in a BFI instruction. Roughly speaking,; /// this asks whether DstMask zeroes precisely those bits that will be set by; /// the other half.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:52,mask,mask,52,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,/// Does not go down into the current directory_entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:16,down,down,16,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['down'],['down']
Availability,/// Does this marker indicate inclusion by -dump-input-filter=error?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/FileCheck/FileCheck.cpp:62,error,error,62,interpreter/llvm-project/llvm/utils/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/FileCheck/FileCheck.cpp,1,['error'],['error']
Availability,"/// Does this tool have ""good"" standardized diagnostics, or should the; /// driver add an additional ""command failed"" diagnostic on failures.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Tool.h:132,failure,failures,132,interpreter/llvm-project/clang/include/clang/Driver/Tool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Tool.h,1,['failure'],['failures']
Availability,"/// Does this tree qualify as an attempt to move a bitfield into position,; /// essentially ""(and (shl VAL, N), Mask)"" or (shl VAL, N).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:112,Mask,Mask,112,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['Mask'],['Mask']
Availability,/// Don't emit numeric info in dump if symbolic info is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h:56,avail,available,56,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h,1,['avail'],['available']
Availability,/// Don't merge availability attributes at all.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:16,avail,availability,16,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avail'],['availability']
Availability,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \param __B; /// A 128-bit vector of [8 x bfloat].; /// \param __D; /// A 128-bit vector of [4 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means 0.; /// \returns A 128-bit vector of [4 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:383,mask,mask,383,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,1,['mask'],['mask']
Availability,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \param __B; /// A 128-bit vector of [8 x bfloat].; /// \param __D; /// A 128-bit vector of [4 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means __D.; /// \returns A 128-bit vector of [4 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:383,mask,mask,383,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,1,['mask'],['mask']
Availability,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \param __B; /// A 256-bit vector of [16 x bfloat].; /// \param __D; /// A 256-bit vector of [8 x float].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means __D.; /// \returns A 256-bit vector of [8 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:386,mask,mask,386,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,1,['mask'],['mask']
Availability,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \param __B; /// A 256-bit vector of [16 x bfloat].; /// \param __D; /// A 256-bit vector of [8 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means 0.; /// \returns A 256-bit vector of [8 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:385,mask,mask,385,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,1,['mask'],['mask']
Availability,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 512-bit vector of [32 x bfloat].; /// \param __B; /// A 512-bit vector of [32 x bfloat].; /// \param __D; /// A 512-bit vector of [16 x float].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means 0.; /// \returns A 512-bit vector of [16 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:387,mask,mask,387,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,1,['mask'],['mask']
Availability,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 512-bit vector of [32 x bfloat].; /// \param __B; /// A 512-bit vector of [32 x bfloat].; /// \param __D; /// A 512-bit vector of [16 x float].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means __D.; /// \returns A 512-bit vector of [16 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h:387,mask,mask,387,interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512bf16intrin.h,1,['mask'],['mask']
Availability,"/// Downgrade the debug info in a module to contain only line table information.; ///; /// In order to convert debug info to what -gline-tables-only would have; /// created, this does the following:; /// 1) Delete all debug intrinsics.; /// 2) Delete all non-CU named metadata debug info nodes.; /// 3) Create new DebugLocs for each instruction.; /// 4) Create a new CU debug info, and similarly for every metadata node; /// that's reachable from the CU debug info.; /// All debug type metadata nodes are unreachable and garbage collected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfo.h:4,Down,Downgrade,4,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfo.h,1,['Down'],['Downgrade']
Availability,"/// Drill down the U-D chain one step to find the definition of V, and; /// try to break the definition into one or two addends.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:10,down,down,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['down'],['down']
Availability,/// Drill down to the storage of a field without walking into; /// reference types.; ///; /// The resulting address doesn't necessarily have the right type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:10,down,down,10,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['down'],['down']
Availability,/// Drop all updates applied by all available trees and delete BasicBlocks if; /// all available trees are up-to-date.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:36,avail,available,36,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,2,['avail'],['available']
Availability,"/// Dump a representation of the initialized entity to standard error,; /// for debugging purposes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:64,error,error,64,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['error'],['error']
Availability,"/// Dump a representation of this initialization sequence to; /// standard error, for debugging purposes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:75,error,error,75,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['error'],['error']
Availability,"/// Dump all the tokens in this stream to OS.; /// \returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h:81,error,error,81,interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h,1,['error'],['error']
Availability,/// Dump information about the AST reader to standard error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:54,error,error,54,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['error'],['error']
Availability,/// Dump the register mask on dbgs() stream.; /// The dump is verbose.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h:22,mask,mask,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h,1,['mask'],['mask']
Availability,/// Dumper used for error reporting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:20,error,error,20,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['error'],['error']
Availability,"/// Dumps one type record. Returns false if there was a type parsing error,; /// and true otherwise. This should be called in order, since the dumper; /// maintains state about previous records which are necessary for cross; /// type references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/SymbolDumper.h:69,error,error,69,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/SymbolDumper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/SymbolDumper.h,1,['error'],['error']
Availability,"/// Dumps the type records in Data. Returns false if there was a type stream; /// parse error, and true otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/SymbolDumper.h:88,error,error,88,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/SymbolDumper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/SymbolDumper.h,1,['error'],['error']
Availability,"/// During our initial pass over the program, we determine that things are; /// either alive or maybe alive. We don't mark anything explicitly dead (even; /// if we know they are), since anything not alive with no registered uses; /// (in Uses) will never be marked alive and will thus become dead in the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/DeadArgumentElimination.h:87,alive,alive,87,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/DeadArgumentElimination.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/DeadArgumentElimination.h,4,['alive'],['alive']
Availability,"/// During top-down matching, only consider nodes of at least this height.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h:15,down,down,15,interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h,1,['down'],['down']
Availability,"/// Dynamic (non-constant condition) vector blend where only the sign bits; /// of the condition elements are used. This is used to enforce that the; /// condition mask is not valid for generic VSELECT optimizations. This; /// is also used to implement the intrinsics.; /// Operands are in VSELECT order: MASK, TRUE, FALSE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:164,mask,mask,164,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,2,"['MASK', 'mask']","['MASK', 'mask']"
Availability,"/// Dynamically load a library and throw exception in case of failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/Initialisation.cxx:62,failure,failure,62,roofit/batchcompute/src/Initialisation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/Initialisation.cxx,1,['failure'],['failure']
Availability,"/// EVEX - Specifies that this instruction use EVEX form which provides; /// syntax support up to 32 512-bit register operands and up to 7 16-bit; /// mask operands as well as source operand data swizzling/memory operand; /// conversion, eviction hint, and rounding mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h:151,mask,mask,151,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,1,['mask'],['mask']
Availability,/// EVEX_K - Set if this instruction requires masking,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h:46,mask,masking,46,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,1,['mask'],['masking']
Availability,/// Each pass is responsible for assigning a pass manager to itself.; /// PMS is the stack of available pass manager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:94,avail,available,94,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,1,['avail'],['available']
Availability,/// Each processor resource is associated with a so-called processor resource; /// mask. This vector allows to correlate processor resource IDs with; /// processor resource masks. There is exactly one element per each processor; /// resource declared by the scheduling model.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:83,mask,mask,83,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,2,['mask'],"['mask', 'masks']"
Availability,"/// Efficiently reads \p Size bytes from \p Ref, and writes it to this stream.; /// This operation will not invoke any copies of the source data, regardless; /// of the source stream's implementation.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:230,error,error,230,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,2,['error'],['error']
Availability,"/// Efficiently reads all data from \p Ref, and writes it to this stream.; /// This operation will not invoke any copies of the source data, regardless; /// of the source stream's implementation.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:225,error,error,225,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,2,['error'],['error']
Availability,/// Either the filesystem error or status of the entry.; /// The filename is empty and only materialized by \c EntryRef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:26,error,error,26,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['error'],['error']
Availability,/// Eliminate redundant type cast between integer and float.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:14,redundant,redundant,14,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['redundant'],['redundant']
Availability,"/// Eliminates partially redundant \p Load, replacing it with \p; /// AvailableLoads (connected by Phis if needed).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:25,redundant,redundant,25,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,2,"['Avail', 'redundant']","['AvailableLoads', 'redundant']"
Availability,/// Emit ARC errors even if the migrator can fix them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h:13,error,errors,13,interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,1,['error'],['errors']
Availability,"/// Emit HSA Metadata; ///; /// When \p Strict is true, known metadata elements must already be; /// well-typed. When \p Strict is false, known types are inferred and; /// the \p HSAMetadata structure is updated with the correct types.; ///; /// \returns True on success, false on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUTargetStreamer.h:281,failure,failure,281,interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUTargetStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUTargetStreamer.h,1,['failure'],['failure']
Availability,"/// Emit IR to implement a masked version of a given atomicrmw; /// operation. (That is, only the bits under the Mask should be; /// affected by the operation)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:27,mask,masked,27,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,2,"['Mask', 'mask']","['Mask', 'masked']"
Availability,/// Emit Masked Truncating Store with signed or unsigned saturation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:9,Mask,Masked,9,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Masked']
Availability,"/// Emit SSE or AVX instructions to lower the select.; ///; /// Try to use SSE1/SSE2 instructions to simulate a select without branches.; /// This lowers fp selects into a CMP/AND/ANDN/OR sequence when the necessary; /// SSE instructions are available. If AVX is available, try to use a VBLENDV.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:242,avail,available,242,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,2,['avail'],['available']
Availability,/// Emit \p Size bytes worth of the value specified by \p FillValue.; ///; /// This is used to implement assembler directives such as .space or .skip.; ///; /// \param NumBytes - The number of bytes to emit.; /// \param FillValue - The value to use when filling bytes.; /// \param Loc - The location of the expression for error reporting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:322,error,error,322,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['error'],['error']
Availability,"/// Emit __kmpc_error call for error directive; /// extern void __kmpc_error(ident_t *loc, int severity, const char *message);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:31,error,error,31,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,1,['error'],['error']
Availability,/// Emit a .cprestore directive. If the offset is out of range then it will; /// be synthesized using the assembler temporary.; ///; /// GetATReg() is a callback that can be used to obtain the current assembler; /// temporary and is only called when the assembler temporary is required. It; /// must handle the case where no assembler temporary is available (typically; /// by reporting an error).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h:348,avail,available,348,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h,2,"['avail', 'error']","['available', 'error']"
Availability,"/// Emit a DW_OP_stack_value, if supported.; ///; /// The proper way to describe a constant value is DW_OP_constu <const>,; /// DW_OP_stack_value. Unfortunately, DW_OP_stack_value was not available; /// until DWARF 4, so we will continue to generate DW_OP_constu <const> for; /// DWARF 2 and DWARF 3. Technically, this is incorrect since DW_OP_const; /// <const> actually describes a value at a constant address, not a constant; /// value. However, in the past there was no better way to describe a; /// constant value, so the producers and consumers started to rely on; /// heuristics to disambiguate the value vs. location status of the; /// expression. See PR21176 for more details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:188,avail,available,188,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,1,['avail'],['available']
Availability,/// Emit a cross-DSO CFI failure handling function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:25,failure,failure,25,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['failure'],['failure']
Availability,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:815,Failure,Failure,815,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,"['Failure', 'failure']","['Failure', 'failures']"
Availability,/// Emit a dummy function that reference a CoreFoundation symbol when; /// @available is used on Darwin.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:76,avail,available,76,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['avail'],['available']
Availability,/// Emit a general error that something can't be done.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:19,error,error,19,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['error'],['error']
Availability,/// Emit a message about the specified location with the specified string.; ///; /// \param ShowColors Display colored messages if output is a terminal and; /// the default error handler is used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h:173,error,error,173,interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h,1,['error'],['error']
Availability,"/// Emit a remark signifying that the number of IR instructions in the module; /// changed.; /// \p F is optionally passed by passes which run on Functions, and thus; /// always know whether or not a non-empty function is available.; ///; /// \p FunctionToInstrCount maps the name of a \p Function to a pair. The; /// first member of the pair is the IR count of the \p Function before running; /// \p P, and the second member is the IR count of the \p Function after; /// running \p P.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:222,avail,available,222,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,1,['avail'],['available']
Availability,"/// Emit a series of CopyToReg nodes that copies the specified value into the; /// registers specified by this object. This uses Chain/Flag as the input and; /// updates them for the output Chain/Flag. If the Flag pointer is nullptr, no; /// flag is used. If V is not nullptr, then it is used in printing better; /// diagnostic messages on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h:340,error,error,340,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,1,['error'],['error']
Availability,/// Emit a store instruction with an offset. If the offset is out of range; /// then it will be synthesized using the assembler temporary.; ///; /// GetATReg() is a callback that can be used to obtain the current assembler; /// temporary and is only called when the assembler temporary is required. It; /// must handle the case where no assembler temporary is available (typically; /// by reporting an error).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h:360,avail,available,360,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h,2,"['avail', 'error']","['available', 'error']"
Availability,"/// Emit all available macro tables(DWARFv4 and DWARFv5).; /// Use \p UnitMacroMap to get compilation unit by macro table offset.; /// Side effects: Fill \p StringPool with macro strings, update; /// DW_AT_macro_info, DW_AT_macros attributes for corresponding compile; /// units.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h:13,avail,available,13,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,1,['avail'],['available']
Availability,"/// Emit an error at the location \p L, with the message \p Msg.; ///; /// \return The return value is always true, as an idiomatic convenience to; /// clients.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h:12,error,error,12,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,1,['error'],['error']
Availability,/// Emit an error for the case where a record we are trying to assign to has a; /// const-qualified field somewhere in its hierarchy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:12,error,error,12,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"/// Emit an error if Version does not support the given Arch.; ///; /// If either Version or Arch is unknown, does not emit an error. Emits at; /// most one error per Arch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:12,error,error,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,3,['error'],['error']
Availability,"/// Emit an error referring to the source location of this instruction.; /// This should only be used for inline assembly that is somehow; /// impossible to compile. Other errors should have been handled much; /// earlier.; ///; /// If this method returns, the caller should try to recover from the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:12,error,error,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,4,"['error', 'recover']","['error', 'errors', 'recover']"
Availability,/// Emit analyzer warnings as errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h:30,error,errors,30,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,1,['error'],['errors']
Availability,"/// Emit diagnostics for the diagnose_if attributes on Function, ignoring any; /// ArgDependent DiagnoseIfAttrs.; ///; /// Argument-independent diagnose_if attributes should be checked on every use; /// of a function.; ///; /// Returns true if any errors were emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:248,error,errors,248,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['errors']
Availability,"/// Emit diagnostics for the diagnose_if attributes on Function, ignoring any; /// non-ArgDependent DiagnoseIfAttrs.; ///; /// Argument-dependent diagnose_if attributes should be checked each time a; /// function is used as a direct callee of a function call.; ///; /// Returns true if any errors were emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:290,error,errors,290,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['errors']
Availability,/// Emit diagnostics for the user for potential configuration errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:62,error,errors,62,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['error'],['errors']
Availability,/// Emit error if Operand is incomplete pointer type; ///; /// \returns True if pointer has incomplete type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,error,error,9,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,/// Emit error when two pointers are incompatible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,error,error,9,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"/// Emit resource leak warnings for the given symbols.; /// Createn a non-fatal error node for these, and returns it (if any warnings; /// were generated). Return value is non-null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:80,error,error,80,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,"/// Emit something like "".long Hi-Lo"" where the size in bytes of the directive; /// is specified by Size and Hi/Lo specify the labels. This implicitly uses; /// .set if it is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:175,avail,available,175,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,1,['avail'],['available']
Availability,"/// Emit something like "".long Label+Offset"" where the size in bytes of the; /// directive is specified by Size and Label specifies the label. This; /// implicitly uses .set if it is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:183,avail,available,183,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,1,['avail'],['available']
Availability,"/// Emit the ""read-only variable not assignable"" error and print notes to give; /// more information about why the variable is not assignable, such as pointing; /// to the declaration of a const variable, showing that a method is const, or; /// that the function is returning a const reference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:49,error,error,49,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"/// Emit the build attributes that only depend on the hardware that we expect; // /to be available, and not on the ABI, or any source-language choices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp:89,avail,available,89,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,1,['avail'],['available']
Availability,"/// Emit the diagnostic immediately, and, if it's a warning or error, also; /// emit a call stack showing how this function can be reached by an a; /// priori known-emitted function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:63,error,error,63,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// Emit the encoded type for the function \p Decl into \p S.; ///; /// This is in the same format as Objective-C method encodings.; ///; /// \returns true if an error occurred (e.g., because one of the parameter; /// types is incomplete), false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:162,error,error,162,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['error'],['error']
Availability,"/// Emit the expression \p Value into the output as a native; /// integer of the given \p Size bytes.; ///; /// This is used to implement assembler directives such as .word, .quad,; /// etc.; ///; /// \param Value - The value to emit.; /// \param Size - The size of the integer (in bytes) to emit. This must; /// match a native machine width.; /// \param Loc - The location of the expression for error reporting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:396,error,error,396,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['error'],['error']
Availability,/// Emit the function to compute the list of available features given a; /// subtarget.; ///; /// This version is used for subtarget features defined using Predicate<>; /// and supports more than 64 feature bits.; ///; /// \param TargetName The name of the target as used in class prefixes (e.g.; /// <TargetName>Subtarget); /// \param ClassName The name of the class that will contain the generated; /// functions (including the target prefix.); /// \param FuncName The name of the function to emit.; /// \param SubtargetFeatures A map of TableGen records to the; /// SubtargetFeatureInfo equivalent.; /// \param ExtraParams Additional arguments to the generated function.; /// \param HwModes Map of HwMode conditions to check.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetFeatureInfo.h:45,avail,available,45,interpreter/llvm-project/llvm/utils/TableGen/SubtargetFeatureInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetFeatureInfo.h,1,['avail'],['available']
Availability,/// Emit the function to compute the list of available features given a; /// subtarget.; ///; /// This version is used for subtarget features defined using; /// AssemblerPredicate<> and supports up to 64 feature bits.; ///; /// \param TargetName The name of the target as used in class prefixes (e.g.; /// <TargetName>Subtarget); /// \param ClassName The name of the class (without the <Target> prefix); /// that will contain the generated functions.; /// \param FuncName The name of the function to emit.; /// \param SubtargetFeatures A map of TableGen records to the; /// SubtargetFeatureInfo equivalent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetFeatureInfo.h:45,avail,available,45,interpreter/llvm-project/llvm/utils/TableGen/SubtargetFeatureInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetFeatureInfo.h,1,['avail'],['available']
Availability,/// Emit the given code with all '${foo}' placeholders expanded to their; /// replacements.; ///; /// It's an error to use an undefined expansion and expansion-like output that; /// needs to be emitted verbatim can be escaped as '\${foo}'; ///; /// The emitted code can be given a custom indent to enable both indentation by; /// an arbitrary amount of whitespace and emission of the code as a comment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISel/CodeExpander.h:110,error,error,110,interpreter/llvm-project/llvm/utils/TableGen/GlobalISel/CodeExpander.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISel/CodeExpander.h,1,['error'],['error']
Availability,"/// Emit the language-specific data that __C_specific_handler expects. This; /// handler lives in the x64 Microsoft C runtime and allows catching or cleaning; /// up after faults with __try, __except, and __finally. The typeinfo values; /// are not really RTTI data, but pointers to filter functions that return an; /// integer (1, 0, or -1) indicating how to handle the exception. For __finally; /// blocks and other cleanups, the landing pad label is zero, and the filter; /// function is actually a cleanup handler with the same prototype. A catch-all; /// entry is modeled with a null filter function field and a non-zero landing; /// pad label.; ///; /// Possible filter function return values:; /// EXCEPTION_EXECUTE_HANDLER (1):; /// Jump to the landing pad label after cleanups.; /// EXCEPTION_CONTINUE_SEARCH (0):; /// Continue searching this table or continue unwinding.; /// EXCEPTION_CONTINUE_EXECUTION (-1):; /// Resume execution at the trapping PC.; ///; /// Inferred table structure:; /// struct Table {; /// int NumEntries;; /// struct Entry {; /// imagerel32 LabelStart; // Inclusive; /// imagerel32 LabelEnd; // Exclusive; /// imagerel32 FilterOrFinally; // One means catch-all.; /// imagerel32 LabelLPad; // Zero means __finally.; /// } Entries[NumEntries];; /// };",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:172,fault,faults,172,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,1,['fault'],['faults']
Availability,"/// Emit the target offloading code associated with \a D. The emitted; /// code attempts offloading the execution to the device, an the event of; /// a failure it executes the host version outlined in \a OutlinedFn.; /// \param D Directive to emit.; /// \param OutlinedFn Host version of the code to be offloaded.; /// \param OutlinedFnID ID of host version of the code to be offloaded.; /// \param IfCond Expression evaluated in if clause associated with the target; /// directive, or null if no if clause is used.; /// \param Device Expression evaluated in device clause associated with the; /// target directive, or null if no device clause is used and device modifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:152,failure,failure,152,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,1,['failure'],['failure']
Availability,"/// Emit the target offloading code associated with \a D. The emitted; /// code attempts offloading the execution to the device, an the event of; /// a failure it executes the host version outlined in \a OutlinedFn.; /// \param D Directive to emit.; /// \param OutlinedFn Host version of the code to be offloaded.; /// \param OutlinedFnID ID of host version of the code to be offloaded.; /// \param IfCond Expression evaluated in if clause associated with the target; /// directive, or null if no if clause is used.; /// \param Device Expression evaluated in device clause associated with the; /// target directive, or null if no device clause is used and device modifier.; /// \param SizeEmitter Callback to emit number of iterations for loop-based; /// directives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:152,failure,failure,152,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,1,['failure'],['failure']
Availability,/// Emit this directive in \p OutStream using the information available; /// in the given \p ObjWriter and \p Layout to get the address of the; /// arguments within the object file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h:62,avail,available,62,interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h,1,['avail'],['available']
Availability,"/// EmitLabelPlusOffset - Emit something like "".long Label+Offset""; /// where the size in bytes of the directive is specified by Size and Label; /// specifies the label. This implicitly uses .set if it is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:205,avail,available,205,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['avail'],['available']
Availability,/// EmitUnsupportedLValue - Emit a dummy l-value using the type of E and issue; /// an ErrorUnsupported style diagnostic (using the provided Name).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:87,Error,ErrorUnsupported,87,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['Error'],['ErrorUnsupported']
Availability,/// EmitUnsupportedRValue - Emit a dummy r-value using the type of E; /// and issue an ErrorUnsupported style diagnostic (using the; /// provided Name).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:87,Error,ErrorUnsupported,87,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['Error'],['ErrorUnsupported']
Availability,/// Emits a manually-constructed diagnostic to the given output stream.; ///; /// \param ShowColors Display colored messages if output is a terminal and; /// the default error handler is used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h:170,error,error,170,interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h,1,['error'],['error']
Availability,/// Emits a masked region.; /// \param MaskedOpGen Generator for the statement associated with the given; /// masked region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:12,mask,masked,12,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,6,"['Mask', 'mask']","['MaskedOpGen', 'masked']"
Availability,/// Emits a masked region.; /// \param MaskedOpGen Generator for the statement associated with the given; /// masked region.; /// Emits code for a taskyield directive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:12,mask,masked,12,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,3,"['Mask', 'mask']","['MaskedOpGen', 'masked']"
Availability,"/// Emits an error if the given method does not exist, or if the return; /// type is not an Objective-C object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:13,error,error,13,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['error'],['error']
Availability,"/// Emits an error if two values disagree, otherwise the resulting value is; /// that of the operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:13,error,error,13,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['error'],['error']
Availability,/// Emits an error through a DiagnosticsEngine about an invalid user supplied; /// checker option value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h:13,error,error,13,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h,1,['error'],['error']
Availability,"/// Emits atomic compare-and-exchange sequence.; /// \param Expected Expected value.; /// \param Desired Desired value.; /// \param Success Atomic ordering for success operation.; /// \param Failure Atomic ordering for failed operation.; /// \param IsWeak true if atomic operation is weak, false otherwise.; /// \returns Pair of values: previous value from storage (value type) and; /// boolean flag (i1 type) with true if success and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:191,Failure,Failure,191,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['Failure'],['Failure']
Availability,"/// Emits latency information in DC->CommentStream for \p Inst, based; /// on the information available in \p DC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:94,avail,available,94,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,1,['avail'],['available']
Availability,"/// Emits minimal diagnostics (report message + notes) for the 'none' output; /// type to the standard error, or to complement many others. Emits detailed; /// diagnostics in textual format for the 'text' output type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp:103,error,error,103,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/TextDiagnostics.cpp,1,['error'],['error']
Availability,"/// Emits the label used with llvm.eh.recoverfp, which is used by; /// outlined funclets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h:38,recover,recoverfp,38,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h,1,['recover'],['recoverfp']
Availability,/// Enable crash recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:17,recover,recovery,17,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,1,['recover'],['recovery']
Availability,/// Enable matching of interleaved access groups that contain predicated; /// accesses or gaps and therefore vectorized using masked; /// vector loads/stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:126,mask,masked,126,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['masked']
Availability,/// Enable or disable transcription. Transcription is only available if; /// TranscriptionTable was provided to the constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h:59,avail,available,59,interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h,1,['avail'],['available']
Availability,/// Enable spillage copy elimination in MachineCopyPropagation pass. This; /// helps removing redundant copies generated by register allocator when; /// handling complex eviction chains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:94,redundant,redundant,94,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['redundant'],['redundant']
Availability,"/// Enable the experimental new constant interpreter. If an expression is; /// not supported by the interpreter, an error is triggered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:116,error,error,116,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['error'],['error']
Availability,"/// Enable the fast evaluation of the complex error function using look-up; /// tables (default is the ""slow"" CERNlib algorithm).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooVoigtian.h:46,error,error,46,roofit/roofit/inc/RooVoigtian.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooVoigtian.h,1,['error'],['error']
Availability,"/// Encapsulates all of the information needed to generate a stack protector; /// check, and signals to isel when initialized that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point wer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:604,failure,failure,604,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,1,['failure'],['failure']
Availability,/// Encode a GSYM into the file writer stream at the current position.; ///; /// \param O The stream to save the binary data to; /// \returns An error object that indicates success or failure of the save.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:145,error,error,145,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Encode a icmp predicate into a three bit mask. These bits are carefully; /// arranged to allow folding of expressions such as:; ///; /// (A < B) | (A > B) --> (A != B); ///; /// Note that this is only valid if the first and second predicates have the; /// same sign. It is illegal to do: (A u< B) | (A s> B); ///; /// Three bits are used to represent the condition, as follows:; /// 0 A > B; /// 1 A == B; /// 2 A < B; ///; /// <=> Value Definition; /// 000 0 Always false; /// 001 1 A > B; /// 010 2 A == B; /// 011 3 A >= B; /// 100 4 A < B; /// 101 5 A != B; /// 110 6 A <= B; /// 111 7 Always true; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h:45,mask,mask,45,interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,1,['mask'],['mask']
Availability,"/// Encode information on a single operation to perform on a byte; /// sequence (e.g., an encoded instruction) which requires assemble- or run-; /// time patching.; ///; /// Fixups are used any time the target instruction encoder needs to represent; /// some value in an instruction which is not yet concrete. The encoder will; /// encode the instruction assuming the value is 0, and emit a fixup which; /// communicates to the assembler backend how it should rewrite the encoded; /// value.; ///; /// During the process of relaxation, the assembler will apply fixups as; /// symbolic values become concrete. When relaxation is complete, any remaining; /// fixups become relocations in the object file (or errors, if the fixup cannot; /// be encoded on the target).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFixup.h:706,error,errors,706,interpreter/llvm-project/llvm/include/llvm/MC/MCFixup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFixup.h,1,['error'],['errors']
Availability,"/// Encode this InlineInfo object into FileWriter stream.; ///; /// \param O The binary stream to write the data to at the current file; /// position.; ///; /// \param BaseAddr The base address to use when encoding all address ranges.; /// This will be the FunctionInfo's start address if this object is directly; /// contained in a FunctionInfo object, or the start address of the first; /// address range in an InlineInfo object of this object is a child of; /// another InlineInfo object.; ///; /// \returns An error object that indicates success or failure or the; /// encoding process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/InlineInfo.h:514,error,error,514,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/InlineInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/InlineInfo.h,2,"['error', 'failure']","['error', 'failure']"
Availability,/// Encode this LineTable object into FileWriter stream.; ///; /// \param O The binary stream to write the data to at the current file; /// position.; ///; /// \param BaseAddr The base address to use when decoding the line table.; /// This will be the FunctionInfo's start address.; ///; /// \returns An error object that indicates success or failure or the; /// encoding process.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/LineTable.h:304,error,error,304,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/LineTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/LineTable.h,2,"['error', 'failure']","['error', 'failure']"
Availability,/// Encode this object into FileWriter stream.; ///; /// \param O The binary stream to write the data to at the current file; /// position.; ///; /// \returns An error object that indicates failure or the offset of the; /// function info that was successfully written into the stream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h:162,error,error,162,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h,2,"['error', 'failure']","['error', 'failure']"
Availability,/// Encode this object into FileWriter stream.; ///; /// \param O The binary stream to write the data to at the current file; /// position.; ///; /// \returns An error object that indicates success or failure of the; /// encoding process.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/Header.h:162,error,error,162,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/Header.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/Header.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Encodes a location in the source. The SourceManager can decode this; /// to get at the full include stack, line and column information.; ///; /// Technically, a source location is simply an offset into the manager's view; /// of the input source, which is all input buffers (including macro; /// expansions) concatenated in an effectively arbitrary order. The manager; /// actually maintains two blocks of input buffers. One, starting at offset; /// 0 and growing upwards, contains all buffers from this module. The other,; /// starting at the highest possible offset and growing downwards, contains; /// buffers of loaded modules.; ///; /// In addition, one bit of SourceLocation is used for quick access to the; /// information whether the location is in a file or a macro expansion.; ///; /// It is important that this type remains small. It is currently 32 bits wide.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceLocation.h:584,down,downwards,584,interpreter/llvm-project/clang/include/clang/Basic/SourceLocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceLocation.h,1,['down'],['downwards']
Availability,"/// End part of this FunctionDecl's source range.; ///; /// We could compute the full range in getSourceRange(). However, when we're; /// dealing with a function definition deserialized from a PCH/AST file,; /// we can only compute the full range once the function body has been; /// de-serialized, so it's far better to have the (sometimes-redundant); /// EndRangeLoc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:341,redundant,redundant,341,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['redundant'],['redundant']
Availability,"/// Ensure that we have a valid section set in the streamer. Otherwise,; /// report an error and switch to .text.; /// \return - False on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h:87,error,error,87,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,1,['error'],['error']
Availability,"/// Ensures that the value has the required type, by inserting a bitcast if; /// required. This function lets us avoid inserting bitcasts that are; /// redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:152,redundant,redundant,152,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['redundant'],['redundant']
Availability,/// Enter the specified file. This returns true on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:51,failure,failure,51,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['failure'],['failure']
Availability,"/// Entry size name. Used for error reporting. If this field is empty, errors; /// will not mention the entry size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:30,error,error,30,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,2,['error'],"['error', 'errors']"
Availability,/// Enum of the availible Diverging Color Schemes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-color-helper.h:16,avail,availible,16,interpreter/llvm-project/llvm/tools/llvm-xray/xray-color-helper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-color-helper.h,1,['avail'],['availible']
Availability,/// Enum of the availible Sequential Color Schemes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-color-helper.h:16,avail,availible,16,interpreter/llvm-project/llvm/tools/llvm-xray/xray-color-helper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-color-helper.h,1,['avail'],['availible']
Availability,"/// Enum values that allow the client to map NOTEs, WARNINGs, and EXTENSIONs; /// to either Ignore (nothing), Remark (emit a remark), Warning; /// (emit a warning) or Error (emit as an error). It allows clients to; /// map ERRORs to Error or Fatal (stop emitting diagnostics after this one).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h:167,Error,Error,167,interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,4,"['ERROR', 'Error', 'error']","['ERRORs', 'Error', 'error']"
Availability,/// Enumeration of \c ilogb error results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:28,error,error,28,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,1,['error'],['error']
Availability,/// Enumeration of the kinds of inline extra info available. It is important; /// that the `MachineMemOperand` inline kind has a tag value of zero to make; /// it accessible as an `ArrayRef`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:50,avail,available,50,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['avail'],['available']
Availability,"/// Enumeration specifying type of statistics for bin errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TH1.h:54,error,errors,54,hist/hist/inc/TH1.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TH1.h,1,['error'],['errors']
Availability,"/// Equivalent to operator++, with an error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h:38,error,error,38,interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,2,['error'],['error']
Availability,"/// Error handler for gtests that generates failures for every received diagnostic > kInfo when this file is linked to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/src/TestSupport.cxx:4,Error,Error,4,core/testsupport/src/TestSupport.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/src/TestSupport.cxx,2,"['Error', 'failure']","['Error', 'failures']"
Availability,/// Error prefix. Used for error reporting to provide more information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:4,Error,Error,4,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,2,"['Error', 'error']","['Error', 'error']"
Availability,/// Error results for atomic update expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:4,Error,Error,4,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['Error'],['Error']
Availability,/// Error returned by NameIndex::getEntry to report it has reached the end of; /// the entry list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h:4,Error,Error,4,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h,1,['Error'],['Error']
Availability,/// Error thrown by the compiler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h:4,Error,Error,4,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h,1,['Error'],['Error']
Availability,"/// Error(""Interpolate"", ""Should not get to here"");; // may as well soldier on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx:4,Error,Error,4,hist/hist/src/TGraphDelaunay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx,1,['Error'],['Error']
Availability,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:4,Error,Error,4,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,14,"['Error', 'error']","['Error', 'error']"
Availability,/// ErrorUnsupported - Print out an error that codegen doesn't support the; /// specified decl yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:4,Error,ErrorUnsupported,4,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,2,"['Error', 'error']","['ErrorUnsupported', 'error']"
Availability,/// ErrorUnsupported - Print out an error that codegen doesn't support the; /// specified stmt yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:4,Error,ErrorUnsupported,4,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,6,"['Error', 'error']","['ErrorUnsupported', 'error']"
Availability,/// Errors of this type should be returned if a module contains definitions for; /// symbols that are not claimed by the module's associated; /// MaterializationResponsibility. If this error is returned it is indicative of; /// a broken transformation / compiler / object cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:4,Error,Errors,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,2,"['Error', 'error']","['Errors', 'error']"
Availability,/// Errors of this type should be returned if a module fails to include; /// definitions that are claimed by the module's associated; /// MaterializationResponsibility. If this error is returned it is indicative of; /// a broken transformation / compiler / object cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:4,Error,Errors,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,2,"['Error', 'error']","['Errors', 'error']"
Availability,"/// Errors that actually prevent compilation, not those that are; /// upgraded from a warning by -Werror.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:4,Error,Errors,4,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['Error'],['Errors']
Availability,"/// Estimate of lower limit error; ///function evaluates only a rough error on the lower limit. Be careful when using this estimation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverterResult.h:28,error,error,28,roofit/roostats/inc/RooStats/HypoTestInverterResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverterResult.h,2,['error'],['error']
Availability,"/// Evaluate a string of code. Returns nullptr on failure.; /// Returns a string representation of the expression (can be """") on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/Jupyter/Kernel.cpp:50,failure,failure,50,interpreter/cling/tools/Jupyter/Kernel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/Jupyter/Kernel.cpp,1,['failure'],['failure']
Availability,"/// Evaluate function \code int ErrnoTesterChecker_setErrnoCheckState(); /// \endcode. This function simulates the following:; /// - Return 0 and leave \c errno with undefined value.; /// This is the case of a successful standard function call.; /// For example if \c ftell returns not -1.; /// - Return 1 and sets \c errno to a specific error code (1).; /// This is the case of a failed standard function call.; /// The function indicates the failure by a special return value; /// that is returned only at failure.; /// \c errno can be checked but it is not required.; /// For example if \c ftell returns -1.; /// - Return 2 and may set errno to a value (actually it does not set it).; /// This is the case of a standard function call where the failure can only; /// be checked by reading from \c errno. The value of \c errno is changed by; /// the function only at failure, the user should set \c errno to 0 before; /// the call (\c ErrnoChecker does not check for this rule).; /// \c strtol is an example of this case, if it returns \c LONG_MIN (or; /// \c LONG_MAX). This case applies only if \c LONG_MIN or \c LONG_MAX is; /// returned, otherwise the first case in this list applies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:338,error,error,338,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,5,"['error', 'failure']","['error', 'failure']"
Availability,/// Evaluate function \code int ErrnoTesterChecker_setErrnoIfError() \endcode.; /// Simulate a standard library function tha returns 0 on success and 1 on; /// failure. On the success case \c errno is not allowed to be used (may be; /// undefined). On the failure case \c errno is set to a fixed value 11 and; /// is not needed to be checked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:160,failure,failure,160,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,2,['failure'],['failure']
Availability,/// Evaluate function \code int ErrnoTesterChecker_setErrnoIfErrorRange(); /// \endcode. Same as \c ErrnoTesterChecker_setErrnoIfError but \c errno is; /// set to a range (to be nonzero) at the failure case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp:194,failure,failure,194,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoTesterChecker.cpp,1,['failure'],['failure']
Availability,"/// Evaluate the result of an add between (conceptually) two MCValues.; ///; /// This routine conceptually attempts to construct an MCValue:; /// Result = (Result_A - Result_B + Result_Cst); /// from two MCValue's LHS and RHS where; /// Result = LHS + RHS; /// and; /// Result = (LHS_A - LHS_B + LHS_Cst) + (RHS_A - RHS_B + RHS_Cst).; ///; /// This routine attempts to aggressively fold the operands such that the result; /// is representable in an MCValue, but may not always succeed.; ///; /// \returns True on success, false if the result is not representable in an; /// MCValue.; /// NOTE: It is really important to have both the Asm and Layout arguments.; /// They might look redundant, but this function can be used before layout; /// is done (see the object streamer for example) and having the Asm argument; /// lets us avoid relaxations early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:681,redundant,redundant,681,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,1,['redundant'],['redundant']
Availability,"/// Evaluate the value of the alignment argument to __builtin_align_{up,down},; /// __builtin_is_aligned and __builtin_assume_aligned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:72,down,down,72,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['down'],['down']
Availability,"/// EvaluateValue - Evaluate the token PeekTok (and any others needed) and; /// return the computed value in Result. Return true if there was an error; /// parsing. This function also returns information about the form of the; /// expression in DT. See above for information on what DT means.; ///; /// If ValueLive is false, then this value is being evaluated in a context where; /// the result is not used. As such, avoid diagnostics that relate to; /// evaluation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:145,error,error,145,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,1,['error'],['error']
Availability,/// Evaluates and \returns the value of the expression represented by this; /// AST or an error if evaluation fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:90,error,error,90,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,/// Evaluates the computation and (potentially) updates the accumulator \c; /// Result. \c Result is undefined in the case of an error. `Result` is an; /// out parameter to optimize case where the computation involves composing; /// the result of sub-computation evaluations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h:129,error,error,129,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h,1,['error'],['error']
Availability,"/// Evaluates the value of the binary operation represented by this AST,; /// using EvalBinop on the result of recursively evaluating the operands.; /// \returns the expression value or an error if an undefined numeric; /// variable is used in one of the operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:189,error,error,189,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,"/// Every amd_*_code_t has the following properties, which are composed of; /// a number of bit fields. Every bit field has a mask (AMD_CODE_PROPERTY_*),; /// bit width (AMD_CODE_PROPERTY_*_WIDTH, and bit shift amount; /// (AMD_CODE_PROPERTY_*_SHIFT) for convenient access. Unused bits must be 0.; ///; /// (Note that bit fields cannot be used as their layout is; /// implementation defined in the C standard and so cannot be used to; /// specify an ABI)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:126,mask,mask,126,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['mask'],['mask']
Availability,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:716,down,down,716,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['down'],['down']
Availability,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:358,down,down,358,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,2,['down'],['down']
Availability,"/// ExecuteCompilation - Execute the compilation according to the command line; /// arguments and return an appropriate exit code.; ///; /// This routine handles additional processing that must be done in addition; /// to just running the subprocesses, for example reporting errors, setting; /// up response files, removing temporary files, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:275,error,errors,275,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['error'],['errors']
Availability,"/// ExecuteProgram - Run the specified bitcode file, emitting output to the; /// specified filename. This sets RetVal to the exit code of the program or; /// returns an Error if a problem was encountered that prevented execution of; /// the program.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:169,Error,Error,169,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,1,['Error'],['Error']
Availability,"/// Execution the given code ""safely"", using crash recovery or safety; /// threads when possible.; ///; /// \return False if a crash was detected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:51,recover,recovery,51,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h,1,['recover'],['recovery']
Availability,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:227,avail,available,227,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,1,['avail'],['available']
Availability,"/// ExpectAndConsume - The parser expects that 'ExpectedTok' is next in the; /// input. If so, it is consumed and false is returned.; ///; /// If a trivial punctuator misspelling is encountered, a FixIt error; /// diagnostic is issued and false is returned after recovery.; ///; /// If the input is malformed, this emits the specified diagnostic and true is; /// returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:203,error,error,203,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,2,"['error', 'recover']","['error', 'recovery']"
Availability,"/// Explicitly record a dependence from \p FromAA to \p ToAA, that is if; /// \p FromAA changes \p ToAA should be updated as well.; ///; /// This method should be used in conjunction with the `getAAFor` method and; /// with the DepClass enum passed to the method set to None. This can; /// be beneficial to avoid false dependences but it requires the users of; /// `getAAFor` to explicitly record true dependences through this method.; /// The \p DepClass flag indicates if the dependence is striclty necessary.; /// That means for required dependences, if \p FromAA changes to an invalid; /// state, \p ToAA can be moved to a pessimistic fixpoint because it required; /// information from \p FromAA but none are available anymore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:713,avail,available,713,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['avail'],['available']
Availability,"/// Explicitly trigger a crash recovery in the current process, and; /// return failure from RunSafely(). This function does not return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:31,recover,recovery,31,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,2,"['failure', 'recover']","['failure', 'recovery']"
Availability,/// ExportEntry encapsulates the current-state-of-the-walk used when doing a; /// non-recursive walk of the trie data structure. This allows you to iterate; /// across all exported symbols using:; /// Error Err = Error::success();; /// for (const llvm::object::ExportEntry &AnExport : Obj->exports(&Err)) {; /// }; /// if (Err) { report error ...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/MachO.h:201,Error,Error,201,interpreter/llvm-project/llvm/include/llvm/Object/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/MachO.h,3,"['Error', 'error']","['Error', 'error']"
Availability,/// Exports the given SimilarityGroups to a JSON file at \p FilePath.; ///; /// \param FilePath - The path to the output location.; /// \param SimSections - The similarity groups to process.; /// \param LLVMInstNum - The mapping of Instructions to their location in the; /// module represented by an unsigned integer.; /// \returns A nonzero error code if there was a failure creating the file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-sim/llvm-sim.cpp:342,error,error,342,interpreter/llvm-project/llvm/tools/llvm-sim/llvm-sim.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-sim/llvm-sim.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Extend the current definition as far as possible down.; ///; /// Stop when meeting an existing def or when leaving the live; /// range of VNI. End points where VNI is no longer live are added to Kills.; ///; /// We only propagate DBG_VALUES locally here. LiveDebugValues performs a; /// data-flow analysis to propagate them beyond basic block boundaries.; ///; /// \param Idx Starting point for the definition.; /// \param DbgValue value to propagate.; /// \param LiveIntervalInfo For each location number key in this map,; /// restricts liveness to where the LiveRange has the value equal to the\; /// VNInfo.; /// \param [out] Kills Append end points of VNI's live range to Kills.; /// \param LIS Live intervals analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:53,down,down,53,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['down'],['down']
Availability,/// Extend the generic MCELFStreamer class so that it can mask dangerous; /// instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,1,['mask'],['mask']
Availability,"/// Extend the live range of @p LR to reach all uses of Reg.; ///; /// If @p LR is a main range, or if @p LI is null, then all uses must be; /// jointly dominated by the definitions from @p LR. If @p LR is a subrange; /// of the live interval @p LI, corresponding to lane mask @p LaneMask,; /// all uses must be jointly dominated by the definitions from @p LR; /// together with definitions of other lanes where @p LR becomes undefined; /// (via <def,read-undef> operands).; /// If @p LR is a main range, the @p LaneMask should be set to ~0, i.e.; /// LaneBitmask::getAll().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h:272,mask,mask,272,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h,1,['mask'],['mask']
Availability,"/// Externally provided layout. Typically used when the AST source, such; /// as DWARF, lacks all the information that was available at compile time, such; /// as alignment attributes on fields and pragmas in effect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:123,avail,available,123,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['avail'],['available']
Availability,"/// Extra virtual files that are available to be #included.; /// Keys are plain filenames (""foo.h""), values are file content.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:33,avail,available,33,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,1,['avail'],['available']
Availability,"/// Extract (gather) bits from the unsigned 32-bit integer \a __X into the; /// low-order bits of the 32-bit result, according to the mask in the; /// unsigned 32-bit integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 31; /// IF __Y[m] == 1; /// result[i] := __X[m]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PEXT instruction.; ///; /// \param __X; /// The 32-bit source value to copy.; /// \param __Y; /// The 32-bit mask specifying which source bits to extract.; /// \returns The 32-bit result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:134,mask,mask,134,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,2,['mask'],['mask']
Availability,"/// Extract (gather) bits from the unsigned 64-bit integer \a __X into the; /// low-order bits of the 64-bit result, according to the mask in the; /// unsigned 64-bit integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 63; /// IF __Y[m] == 1; /// result[i] := __X[m]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PEXT instruction.; ///; /// \param __X; /// The 64-bit source value to copy.; /// \param __Y; /// The 64-bit mask specifying which source bits to extract.; /// \returns The 64-bit result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:134,mask,mask,134,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,2,['mask'],['mask']
Availability,"/// Extract \a Count uint8_t values from the location given by the cursor and; /// store them into the destination buffer. In case of an extraction error, or; /// if the cursor is already in an error state, a nullptr is returned and the; /// destination buffer is left unchanged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:148,error,error,148,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// Extract \a Count uint8_t values from the location given by the cursor and; /// store them into the destination vector. The vector is resized to fit the; /// extracted data. In case of an extraction error, or if the cursor is; /// already in an error state, the destination vector is left unchanged and; /// cursor is placed into an error state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:202,error,error,202,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,3,['error'],['error']
Availability,"/// Extract a 24-bit unsigned value from \a *offset_ptr and return it; /// in a uint32_t.; ///; /// Extract 3 bytes from the binary data at the offset pointed to by; /// \a offset_ptr, construct a uint32_t from them and update the offset; /// on success.; ///; /// @param[in,out] OffsetPtr; /// A pointer to an offset within the data that will be advanced; /// by the 3 bytes if the value is extracted correctly. If the offset; /// is out of bounds or there are not enough bytes to extract this value,; /// the offset will be left unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted 24-bit value represented in a uint32_t.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:593,Error,Error,593,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,4,"['Error', 'failure']","['Error', 'failure']"
Availability,"/// Extract a C string (as a StringRef) from the location given by the cursor.; /// In case of an extraction error, or if the cursor is already in an error; /// state, a default-initialized StringRef is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:109,error,error,109,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// Extract a C string from \a *offset_ptr.; ///; /// Returns a StringRef for the C String from the data at the offset; /// pointed to by \a offset_ptr. A variable length NULL terminated C; /// string will be extracted and the \a offset_ptr will be; /// updated with the offset of the byte that follows the NULL; /// terminator byte.; ///; /// \param[in,out] OffsetPtr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// \return; /// A StringRef for the C string value in the data. If the offset; /// pointed to by \a offset_ptr is out of bounds, or if the; /// offset plus the length of the C string is out of bounds,; /// a default-initialized StringRef will be returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:697,Error,Error,697,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,4,"['Error', 'failure']","['Error', 'failure']"
Availability,"/// Extract a C string from \a *offset_ptr.; ///; /// Returns a pointer to a C String from the data at the offset; /// pointed to by \a offset_ptr. A variable length NULL terminated C; /// string will be extracted and the \a offset_ptr will be; /// updated with the offset of the byte that follows the NULL; /// terminator byte.; ///; /// @param[in,out] OffsetPtr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// A pointer to the C string value in the data. If the offset; /// pointed to by \a offset_ptr is out of bounds, or if the; /// offset plus the length of the C string is out of bounds,; /// NULL will be returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:692,Error,Error,692,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,4,"['Error', 'failure']","['Error', 'failure']"
Availability,"/// Extract a C string from the location given by the cursor. In case of an; /// extraction error, or if the cursor is already in an error state, a; /// nullptr is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:92,error,error,92,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// Extract a fixed number of bytes from the location given by the cursor. In; /// case of an extraction error, or if the cursor is already in an error; /// state, a default-initialized StringRef is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:105,error,error,105,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// Extract a fixed number of bytes from the specified offset.; ///; /// Returns a StringRef for the bytes from the data at the offset; /// pointed to by \a OffsetPtr. A fixed length C string will be extracted; /// and the \a OffsetPtr will be advanced by \a Length bytes.; ///; /// \param[in,out] OffsetPtr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// \param[in] Length; /// The number of bytes to extract. If there are not enough bytes in the; /// data to extract all of the bytes, the offset will be left unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// \return; /// A StringRef for the extracted bytes. If the offset pointed to by; /// \a OffsetPtr is out of bounds, or if the offset plus the length; /// is out of bounds, a default-initialized StringRef will be returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:813,Error,Error,813,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,4,"['Error', 'failure']","['Error', 'failure']"
Availability,"/// Extract a pointer-sized unsigned integer from the location given by the; /// cursor. In case of an extraction error, or if the cursor is already in; /// an error state, zero is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:114,error,error,114,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// Extract a signed LEB128 value from \a *offset_ptr.; ///; /// Extracts an signed LEB128 number from this object's data; /// starting at the offset pointed to by \a offset_ptr. The offset; /// pointed to by \a offset_ptr will be updated with the offset of; /// the byte following the last extracted byte.; ///; /// @param[in,out] OffsetPtr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted signed integer value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:670,Error,Error,670,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,4,"['Error', 'failure']","['Error', 'failure']"
Availability,"/// Extract a single 24-bit unsigned value from the location given by the; /// cursor. In case of an extraction error, or if the cursor is already in an; /// error state, zero is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:112,error,error,112,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// Extract a single uint16_t value from the location given by the cursor. In; /// case of an extraction error, or if the cursor is already in an error; /// state, zero is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:105,error,error,105,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// Extract a single uint32_t value from the location given by the cursor. In; /// case of an extraction error, or if the cursor is already in an error; /// state, zero is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:105,error,error,105,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// Extract a single uint64_t value from the location given by the cursor. In; /// case of an extraction error, or if the cursor is already in an error; /// state, zero is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:105,error,error,105,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// Extract a single uint8_t value from the location given by the cursor. In; /// case of an extraction error, or if the cursor is already in an error; /// state, zero is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:104,error,error,104,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,/// Extract a test mask for disallowed floating-point value classes for the; /// parameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:19,mask,mask,19,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['mask'],['mask']
Availability,/// Extract a test mask for disallowed floating-point value classes for the; /// return value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:19,mask,mask,19,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['mask'],['mask']
Availability,"/// Extract a uint32_t value from \a *offset_ptr.; ///; /// Extract a single uint32_t from the binary data at the offset; /// pointed to by \a offset_ptr, and update the offset on success.; ///; /// @param[in,out] offset_ptr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted uint32_t value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:553,Error,Error,553,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,4,"['Error', 'failure']","['Error', 'failure']"
Availability,"/// Extract a uint64_t value from \a *offset_ptr.; ///; /// Extract a single uint64_t from the binary data at the offset; /// pointed to by \a offset_ptr, and update the offset on success.; ///; /// @param[in,out] offset_ptr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted uint64_t value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:553,Error,Error,553,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,4,"['Error', 'failure']","['Error', 'failure']"
Availability,"/// Extract a uint8_t value from \a *offset_ptr.; ///; /// Extract a single uint8_t from the binary data at the offset; /// pointed to by \a offset_ptr, and advance the offset on success.; ///; /// @param[in,out] offset_ptr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted uint8_t value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:552,Error,Error,552,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,4,"['Error', 'failure']","['Error', 'failure']"
Availability,"/// Extract a unsigned LEB128 value from \a *offset_ptr.; ///; /// Extracts an unsigned LEB128 number from this object's data; /// starting at the offset pointed to by \a offset_ptr. The offset; /// pointed to by \a offset_ptr will be updated with the offset of; /// the byte following the last extracted byte.; ///; /// @param[in,out] offset_ptr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted unsigned integer value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:675,Error,Error,675,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,4,"['Error', 'failure']","['Error', 'failure']"
Availability,"/// Extract an signed LEB128 value from the location given by the cursor.; /// In case of an extraction error, or if the cursor is already in an error; /// state, zero is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:104,error,error,104,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// Extract an signed integer of size \a byte_size from \a *offset_ptr.; ///; /// Extract a single signed integer value (sign extending if required); /// and update the offset pointed to by \a offset_ptr. The size of; /// the extracted integer is specified by the \a byte_size argument.; /// \a byte_size should have a value greater than or equal to one; /// and less than or equal to eight since the return value is 64; /// bits wide. Any \a byte_size values less than 1 or greater than; /// 8 will result in nothing being extracted, and zero being returned.; ///; /// @param[in,out] offset_ptr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in] size; /// The size in bytes of the integer to extract.; ///; /// @return; /// The sign extended signed integer value that was extracted,; /// or zero on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:1048,failure,failure,1048,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['failure'],['failure']
Availability,"/// Extract an unsigned LEB128 value from the location given by the cursor.; /// In case of an extraction error, or if the cursor is already in an error; /// state, zero is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:106,error,error,106,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// Extract an unsigned integer of size \a byte_size from \a; /// *offset_ptr.; ///; /// Extract a single unsigned integer value and update the offset; /// pointed to by \a offset_ptr. The size of the extracted integer; /// is specified by the \a byte_size argument. \a byte_size should; /// have a value greater than or equal to one and less than or equal; /// to eight since the return value is 64 bits wide. Any; /// \a byte_size values less than 1 or greater than 8 will result in; /// nothing being extracted, and zero being returned.; ///; /// @param[in,out] offset_ptr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in] byte_size; /// The size in byte of the integer to extract.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The unsigned integer value that was extracted, or zero on; /// failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:984,Error,Error,984,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,5,"['Error', 'failure']","['Error', 'failure']"
Availability,"/// Extract an unsigned integer of the given size from the location given by; /// the cursor. In case of an extraction error, or if the cursor is already in; /// an error state, zero is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:119,error,error,119,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// Extract and demangle a type from a given mangled symbol append it to; /// the output string.; ///; /// \param Mangled mangled symbol to be demangled.; ///; /// \return true on success, false on error.; ///; /// \see https://dlang.org/spec/abi.html#Type .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp:198,error,error,198,interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,1,['error'],['error']
Availability,/// Extract and demangle the mangled symbol and append it to the output; /// string.; ///; /// \param Demangled Output buffer to write the demangled name.; ///; /// \return The remaining string on success or nullptr on failure.; ///; /// \see https://dlang.org/spec/abi.html#name_mangling .; /// \see https://dlang.org/spec/abi.html#MangledName .,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp:219,failure,failure,219,interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,1,['failure'],['failure']
Availability,"/// Extract any object file data that is needed by the GsymCreator.; ///; /// The extracted information includes the UUID of the binary and converting; /// all function symbols from any symbol tables into FunctionInfo objects.; ///; /// \param Obj The object file that contains the DWARF debug info.; ///; /// \param Log The stream to log warnings and non fatal issues to. If NULL,; /// don't log.; ///; /// \param Gsym The GSYM creator to populate with the function information; /// from the debug info.; ///; /// \returns An error indicating any fatal issues that happen when parsing; /// the DWARF, or Error::success() if all goes well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/ObjectFileTransformer.h:527,error,error,527,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/ObjectFileTransformer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/ObjectFileTransformer.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// Extract bytes from the initializer of the constant array V, which need; /// not be a nul-terminated string. On success, store the bytes in Str and; /// return true. When TrimAtNul is set, Str will contain only the bytes up; /// to but not including the first nul. Return false on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:284,failure,failure,284,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['failure'],['failure']
Availability,"/// Extract one bit from mask vector, like v16i1 or v8i1.; /// AVX-512 feature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"/// Extract the DWARF from the supplied object file and convert it into the; /// Gsym format in the GsymCreator object that is passed in. Returns an; /// error if something fatal is encountered.; ///; /// \param NumThreads The number of threads that the conversion process can; /// use.; ///; /// \param OS The stream to log warnings and non fatal issues to. If NULL; /// then don't log.; ///; /// \returns An error indicating any fatal issues that happen when parsing; /// the DWARF, or Error::success() if all goes well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/DwarfTransformer.h:154,error,error,154,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/DwarfTransformer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/DwarfTransformer.h,3,"['Error', 'error']","['Error', 'error']"
Availability,"/// Extract the back reference position from a given string.; ///; /// \param Mangled string to extract the back reference position.; /// \param Ret assigned result value.; ///; /// \return true on success, false on error.; ///; /// \note Ret is always >= 0 on success, and unspecified on failure; ///; /// \see https://dlang.org/spec/abi.html#back_ref .; /// \see https://dlang.org/spec/abi.html#NumberBackRef .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp:216,error,error,216,interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,/// Extract the number from a given string.; ///; /// \param Mangled string to extract the number.; /// \param Ret assigned result value.; ///; /// \note Ret larger than UINT_MAX is considered a failure.; ///; /// \see https://dlang.org/spec/abi.html#Number .,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp:195,failure,failure,195,interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,1,['failure'],['failure']
Availability,"/// Extract the range list referenced by this compile unit from the; /// .debug_ranges section. If the extraction is unsuccessful, an error; /// is returned. Successful extraction requires that the compile unit; /// has already been extracted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h:134,error,error,134,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h,1,['error'],['error']
Availability,"/// Extract the symbol pointed by the back reference form a given string.; ///; /// \param Mangled string to extract the back reference position.; /// \param Ret assigned result value.; ///; /// \return true on success, false on error.; ///; /// \see https://dlang.org/spec/abi.html#back_ref .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp:229,error,error,229,interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,1,['error'],['error']
Availability,/// Extracts and returns the diagnostic payload from the given \c Error if; /// the error is a \c DiagnosticError. Returns std::nullopt if the given error; /// is not a \c DiagnosticError.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticError.h:66,Error,Error,66,interpreter/llvm-project/clang/include/clang/Basic/DiagnosticError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticError.h,3,"['Error', 'error']","['Error', 'error']"
Availability,"/// Extracts the DWARF ""initial length"" field, which can either be a 32-bit; /// value smaller than 0xfffffff0, or the value 0xffffffff followed by a; /// 64-bit length. Returns the actual length, and the DWARF format which is; /// encoded in the field. In case of errors, it returns {0, DWARF32} and; /// leaves the offset unchanged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDataExtractor.h:265,error,errors,265,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDataExtractor.h,1,['error'],['errors']
Availability,"/// Extracts the `<mask>` information from the mangled string, and; /// sets `IsMasked` accordingly. If successful, the <mask> token is removed; /// from the input string `MangledName`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,2,['mask'],['mask']
Availability,"/// Extracts the grouped selection ranges from the file that's specified in; /// the -selection=test:<filename> option.; ///; /// The grouped ranges are specified in comments using the following syntax:; /// ""range"" [ group-name ] ""="" [ ""+"" starting-column-offset ] [ ""->""; /// ""+"" ending-line-offset "":""; /// ending-column-position ]; ///; /// The selection range is then computed from this command by taking the ending; /// location of the comment, and adding 'starting-column-offset' to the column; /// for that location. That location in turns becomes the whole selection range,; /// unless 'ending-line-offset' and 'ending-column-position' are specified. If; /// they are specified, then the ending location of the selection range is; /// the starting location's line + 'ending-line-offset' and the; /// 'ending-column-position' column.; ///; /// All selection ranges in one group are expected to produce the same; /// refactoring result.; ///; /// When testing, zero is returned from clang-refactor even when a group; /// produces an initiation error, which is different from normal invocation; /// that returns a non-zero value. This is done on purpose, to ensure that group; /// consistency checks can return non-zero, but still print the output of; /// the group. So even if a test matches the output of group, it will still fail; /// because clang-refactor should return zero on exit when the group results are; /// consistent.; ///; /// \returns std::nullopt on failure (errors are emitted to stderr), or a set of; /// grouped source ranges in the given file otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h:1051,error,error,1051,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.h,3,"['error', 'failure']","['error', 'errors', 'failure']"
Availability,/// FS bits will only use the '1' bits in the Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRSampleProfile.h:46,Mask,Mask,46,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRSampleProfile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRSampleProfile.h,1,['Mask'],['Mask']
Availability,"/// Factory method to create an OutputBuffer object which manages a read/write; /// buffer of the specified size. When committed, the buffer will be written; /// to the file at the specified path.; ///; /// When F_modify is specified and \p FilePath refers to an existing on-disk; /// file \p Size may be set to -1, in which case the entire file is used.; /// Otherwise, the file shrinks or grows as necessary based on the value of; /// \p Size. It is an error to specify F_modify and Size=-1 if \p FilePath; /// does not exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileOutputBuffer.h:455,error,error,455,interpreter/llvm-project/llvm/include/llvm/Support/FileOutputBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileOutputBuffer.h,1,['error'],['error']
Availability,/// FailureKind - The reason why this candidate is not viable.; /// Actually an OverloadFailureKind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:4,Failure,FailureKind,4,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['Failure'],['FailureKind']
Availability,/// FaultMap section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCObjectFileInfo.h:4,Fault,FaultMap,4,interpreter/llvm-project/llvm/include/llvm/MC/MCObjectFileInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCObjectFileInfo.h,1,['Fault'],['FaultMap']
Availability,/// Figure out how many bits are really needed for this division. \p AtLeast is; /// an optimization hint to bypass the second ComputeNumSignBits call if we the; /// first one is insufficient. Returns -1 on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:207,failure,failure,207,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['failure'],['failure']
Availability,"/// Figure out if an expression could be turned into a call.; ///; /// Use this when trying to recover from an error where the programmer may have; /// written just the name of a function instead of actually calling it.; ///; /// \param E - The expression to examine.; /// \param ZeroArgCallReturnTy - If the expression can be turned into a call; /// with no arguments, this parameter is set to the type returned by such a; /// call; otherwise, it is set to an empty QualType.; /// \param OverloadSet - If the expression is an overloaded function; /// name, this parameter is populated with the decls of the various overloads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:95,recover,recover,95,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"/// Fill out Opts based on the options given in Args.; ///; /// Args must have been created from the OptTable returned by; /// createCC1OptTable().; ///; /// When errors are encountered, return false and, if Diags is non-null,; /// report the error(s).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h:163,error,errors,163,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,2,['error'],"['error', 'errors']"
Availability,"/// Filter out potentially dead comdat functions where other entries keep the; /// entire comdat group alive.; ///; /// This is designed for cases where functions appear to become dead but remain; /// alive due to other live entries in their comdat group.; ///; /// The \p DeadComdatFunctions container should only have pointers to; /// `Function`s which are members of a comdat group and are believed to be; /// dead.; ///; /// After this routine finishes, the only remaining `Function`s in \p; /// DeadComdatFunctions are those where every member of the comdat is listed; /// and thus removing them is safe (provided *all* are removed).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:103,alive,alive,103,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,2,['alive'],['alive']
Availability,"/// FilterChooser - FilterChooser chooses the best filter among a set of Filters; /// in order to perform the decoding of instructions at the current level.; ///; /// Decoding proceeds from the top down. Based on the well-known encoding bits; /// of instructions available, FilterChooser builds up the possible Filters that; /// can further the task of decoding by distinguishing among the remaining; /// candidate instructions.; ///; /// Once a filter has been chosen, it is called upon to divide the decoding task; /// into sub-tasks and delegates them to its inferior FilterChoosers for further; /// processings.; ///; /// It is useful to think of a Filter as governing the switch stmts of the; /// decoding tree. And each case is delegated to an inferior FilterChooser to; /// decide what further remaining bits to look at.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:198,down,down,198,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,2,"['avail', 'down']","['available', 'down']"
Availability,/// Finalize emission of the shuffles.; /// \param Action the action (if any) to be performed before final applying of; /// the \p ExtMask mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:139,mask,mask,139,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,"/// Finalize the data in the GSYM creator prior to saving the data out.; ///; /// Finalize must be called after all FunctionInfo objects have been added; /// and before GsymCreator::save() is called.; ///; /// \param OS Output stream to report duplicate function infos, overlapping; /// function infos, and function infos that were merged or removed.; /// \returns An error object that indicates success or failure of the; /// finalize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:368,error,error,368,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,2,"['error', 'failure']","['error', 'failure']"
Availability,/// Find a subrange corresponding to the exact lane mask @p LM in the live; /// interval @p LI. The interval @p LI is assumed to contain such a subrange.; /// This function is used to find corresponding subranges between the; /// original interval and the new intervals.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:52,mask,mask,52,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['mask'],['mask']
Availability,"/// Find a subrange corresponding to the lane mask @p LM, or a superset of it,; /// in the live interval @p LI. The interval @p LI is assumed to contain such; /// a subrange. This function is used to find corresponding subranges between; /// the original interval and the new intervals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['mask'],['mask']
Availability,"/// Find and instantiate the register allocation pass requested by this target; /// at the current optimization level. Different register allocators are; /// defined as separate passes because they may require different analysis.; ///; /// This helper ensures that the regalloc= option is always available,; /// even for targets that override the default allocator.; ///; /// FIXME: When MachinePassRegistry register pass IDs instead of function ptrs,; /// this can be folded into addPass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:296,avail,available,296,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['avail'],['available']
Availability,"/// Find the adjusted bin index (returning `kUnderflowBin` for underflow and; /// `kOverflowBin` for overflow) for the given coordinate.; /// \note Passing a bin border coordinate can either return the bin above or; /// below the bin border. I.e. don't do that for reliable results!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:265,reliab,reliable,265,hist/histv7/inc/ROOT/RAxis.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx,1,['reliab'],['reliable']
Availability,"/// Find the bin index (adjusted with under- and overflow) for the given coordinate `x`.; /// \note Passing a bin border coordinate can either return the bin above or; /// below the bin border. I.e. don't do that for reliable results!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:217,reliab,reliable,217,hist/histv7/inc/ROOT/RAxis.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx,1,['reliab'],['reliable']
Availability,"/// Find the first executable file \ExeName, either in the user's PATH or,; /// failing that, in the same directory as argv[0]. This allows us to find; /// another LLVM tool if it is built in the same directory. If no executable is; /// found, an error is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:247,error,error,247,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,1,['error'],['error']
Availability,"/// Find the first executable file \p Name in \p Paths.; ///; /// This does not perform hashing as a shell would but instead stats each PATH; /// entry individually so should generally be avoided. Core LLVM library; /// functions and options should instead require fully specified paths.; ///; /// \param Name name of the executable to find. If it contains any system; /// slashes, it will be returned as is.; /// \param Paths optional list of paths to search for \p Name. If empty it; /// will use the system PATH environment instead.; ///; /// \returns The fully qualified path to the first \p Name in \p Paths if it; /// exists. \p Name if \p Name has slashes in it. Otherwise an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:683,error,error,683,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,1,['error'],['error']
Availability,"/// Find the first index where a type appears in a list of types.; ///; /// FirstIndexOfType<T, Us...>::value is the first index of T in Us.; ///; /// Typically only meaningful when it is otherwise statically known that the; /// type pack has no duplicate types. This should be guaranteed explicitly with; /// static_assert(TypesAreDistinct<Us...>::value).; ///; /// It is a compile-time error to instantiate when T is not present in Us, i.e.; /// if is_one_of<T, Us...>::value is false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:388,error,error,388,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['error'],['error']
Availability,"/// Find the nearest instruction I that dominates both I1 and I2, in the sense; /// that a result produced before I will be available at both I1 and I2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Dominators.h:124,avail,available,124,interpreter/llvm-project/llvm/include/llvm/IR/Dominators.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Dominators.h,1,['avail'],['available']
Availability,/// Find the pressure set with the most change beyond its pressure limit after; /// traversing this instruction either upward or downward depending on the; /// closed end of the current region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:129,down,downward,129,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,1,['down'],['downward']
Availability,"/// Find the raw bin index (not adjusted) for the given coordinate `x`.; /// The resulting raw bin is 1-based.; /// \note Passing a bin border coordinate can either return the bin above or; /// below the bin border. I.e. don't do that for reliable results!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:239,reliab,reliable,239,hist/histv7/inc/ROOT/RAxis.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx,1,['reliab'],['reliable']
Availability,"/// Find the raw bin index (not adjusted) for the given coordinate.; /// The resulting raw bin is 0-based.; /// \note Passing a bin border coordinate can either return the bin above or; /// below the bin border. I.e. don't do that for reliable results!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:235,reliab,reliable,235,hist/histv7/inc/ROOT/RAxis.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx,1,['reliab'],['reliable']
Availability,"/// Find the shortest repeating sequence of values in the build vector.; ///; /// e.g. { u, X, u, X, u, u, X, u } -> { X }; /// { X, Y, u, Y, u, u, X, u } -> { X, Y }; ///; /// Currently this must be a power-of-2 build vector.; /// The DemandedElts mask indicates the elements that must be present,; /// undemanded elements in Sequence may be null (SDValue()). If passed a; /// non-null UndefElements bitvector, it will resize it to match the original; /// vector width and set the bits where elements are undef. If result is; /// false, Sequence will be empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:249,mask,mask,249,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['mask'],['mask']
Availability,"/// FindAvailableVal - If this block requires a PHI, first check if an; /// existing PHI matches the PHI placement and reaching definitions computed; /// earlier, and if not, create a new PHI. Visit all the block's; /// predecessors to calculate the available value for each one and fill in; /// the incoming values for a new PHI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:250,avail,available,250,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,1,['avail'],['available']
Availability,"/// FindHandler - Check to see if there is already a handler for the; /// specified name. If not, return the handler for the null name if it; /// exists, otherwise return null. If IgnoreNull is true (the default) then; /// the null handler isn't returned on failure to match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Pragma.h:258,failure,failure,258,interpreter/llvm-project/clang/include/clang/Lex/Pragma.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Pragma.h,1,['failure'],['failure']
Availability,"/// FindPatternInputsAndOutputs - Scan the specified TreePatternNode (which is; /// part of ""I"", the instruction), computing the set of inputs and outputs of; /// the pattern. Report errors if we see anything naughty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:183,error,errors,183,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['error'],['errors']
Availability,/// FindProtocolDeclaration - This routine looks up protocols and; /// issues an error if they are not declared. It returns list of; /// protocol declarations in its 'Protocols' argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:81,error,error,81,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['error'],['error']
Availability,"/// Finds and returns bitcode embedded in the given object file, or an; /// error code if not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/IRObjectFile.h:76,error,error,76,interpreter/llvm-project/llvm/include/llvm/Object/IRObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/IRObjectFile.h,1,['error'],['error']
Availability,"/// Finds and returns bitcode in the given memory buffer (which may; /// be either a bitcode file or a native object file with embedded bitcode),; /// or an error code if not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/IRObjectFile.h:157,error,error,157,interpreter/llvm-project/llvm/include/llvm/Object/IRObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/IRObjectFile.h,1,['error'],['error']
Availability,"/// Finds the closing sequence of a regex variable usage or definition.; ///; /// \p Str has to point in the beginning of the definition (right after the; /// opening sequence). \p SM holds the SourceMgr used for error reporting.; /// \returns the offset of the closing sequence within Str, or npos if it; /// was not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:213,error,error,213,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,"/// Finds the corresponding file in this trie.; ///; /// Returns file name stored in this trie that is equivalent to 'FileName'; /// according to 'Comparator', if it can be uniquely identified. If there; /// are no matches an empty \c StringRef is returned. If there are ambiguous; /// matches, an empty \c StringRef is returned and a corresponding message; /// written to 'Error'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h:374,Error,Error,374,interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,1,['Error'],['Error']
Availability,"/// Finds the first cycle in which a resource can be allocated.; ///; /// The function uses the \param IntervalBuider [*] to build a; /// resource interval [a, b[ out of the input parameters \param; /// CurrCycle, \param AcquireAtCycle and \param ReleaseAtCycle.; ///; /// The function then loops through the intervals in the ResourceSegments; /// and shifts the interval [a, b[ and the ReturnCycle to the; /// right until there is no intersection between the intervals of; /// the \ref ResourceSegments instance and the new shifted [a, b[. When; /// this condition is met, the ReturnCycle (which; /// correspond to the cycle in which the resource can be; /// allocated) is returned.; ///; /// c = CurrCycle in input; /// c 1 2 3 4 5 6 7 8 9 10 ... ---> (time; /// flow); /// ResourceSegments... [---) [-------) [-----------); /// c [1 3[ -> AcquireAtCycle=1, ReleaseAtCycle=3; /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3) ---> returns c; /// incremented by 5 (c+5); ///; ///; /// Notice that for bottom-up scheduling the diagram is slightly; /// different because the current cycle c is always on the right; /// of the interval [a, b) (see \ref; /// `getResourceIntervalBottom`). This is because the cycle; /// increments for bottom-up scheduling moved in the direction; /// opposite to the direction of time:; ///; /// --------> direction of time.; /// XXYZZZ (resource usage); /// --------> direction of top-down execution cycles.; /// <-------- direction of bottom-up execution cycles.; ///; /// Even though bottom-up scheduling moves against the flow of; /// time, the algorithm used to find the first free slot in between; /// intervals is the same as for top-down scheduling.; ///; /// [*] See \ref `getResourceIntervalTop` and; /// \ref `getResourceIntervalBottom` to see how such resource intervals; /// are built.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1440,down,down,1440,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['down'],['down']
Availability,"/// Finds the first non-end iterator, dereferences, and returns the resulting; /// reference.; ///; /// It is an error to call this with all iterators at the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:113,error,error,113,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['error'],['error']
Availability,/// Finds the instantiation of the given declaration context; /// within the current instantiation.; ///; /// \returns NULL if there was an error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:140,error,error,140,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['error'],['error']
Availability,"/// Finish - This does final analysis of the declspec, issuing diagnostics for; /// things like ""_Imaginary"" (lacking an FP type). After calling this method,; /// DeclSpec is guaranteed self-consistent, even if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h:214,error,error,214,interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,1,['error'],['error']
Availability,"/// Finish - This does final analysis of the declspec, rejecting things like; /// ""_Imaginary"" (lacking an FP type). After calling this method, DeclSpec is; /// guaranteed to be self-consistent, even if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:206,error,error,206,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,1,['error'],['error']
Availability,/// Finish building a variable declaration for a for-range statement.; /// \return true if an error occurs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:94,error,error,94,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['error'],['error']
Availability,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:860,error,errors,860,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,2,['error'],"['error', 'errors']"
Availability,/// First domain available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:17,avail,available,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,1,['avail'],['available']
Availability,"/// Fit a parabola, where parameters are set up such that negative function values are obtained.; /// The minimiser needs to recover from that.; /// Test also that when recovery with NaN packing is switched off, the minimiser fails to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:125,recover,recover,125,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,3,['recover'],"['recover', 'recovery']"
Availability,"/// Fix list of lists before merging (to avoid errors about duplicated objects)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMP.cxx:47,error,errors,47,tree/treeplayer/src/TTreeProcessorMP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMP.cxx,1,['error'],['errors']
Availability,"/// Flag indicating if Sema is building a recovery call expression.; ///; /// This flag is used to avoid building recovery call expressions; /// if Sema is already doing so, which would cause infinite recursions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:42,recover,recovery,42,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['recover'],['recovery']
Availability,/// Flag tracking whether any errors have been encountered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h:30,error,errors,30,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,1,['error'],['errors']
Availability,/// Flag used to trace errors in the builder.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:23,error,errors,23,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['error'],['errors']
Availability,"/// Flags that indicate what kind of AST loading failures the client; /// of the AST reader can directly handle.; ///; /// When a client states that it can handle a particular kind of failure,; /// the AST reader will not emit errors when producing that kind of failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:49,failure,failures,49,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,4,"['error', 'failure']","['errors', 'failure', 'failures']"
Availability,"/// Fold ""masked merge"" expressions like `(m & x) | (~m & y)` into the; /// equivalent `((x ^ y) & m) ^ y)` pattern.; /// This is typically a better representation for targets without a fused; /// ""and-not"" operation. This function is intended to be called from a; /// `TargetLowering::PerformDAGCombine` callback on `ISD::OR` nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,mask,masked,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masked']
Availability,"/// Fold the loop tail into the loop exit by speculating the loop tail; /// instructions. Typically, this is a single post-increment. In the case of a; /// simple 2-block loop, hoisting the increment can be much better than; /// duplicating the entire loop header. In the case of loops with early exits,; /// rotation will not work anyway, but simplifyLoopLatch will put the loop in; /// canonical form so downstream passes can handle it.; ///; /// I don't believe this invalidates SCEV.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:406,down,downstream,406,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['down'],['downstream']
Availability,"/// Following the use-def chain, get the next available source; /// for the tracked value.; /// \return A ValueTrackerResult containing a set of registers; /// and sub registers with tracked values. A ValueTrackerResult with; /// an empty set of registers means no source was found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:46,avail,available,46,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['avail'],['available']
Availability,/// For ARM targets returns a mask defining which coprocessors are configured; /// as Custom Datapath.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:30,mask,mask,30,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['mask'],['mask']
Availability,"/// For a given lane mask @p LaneMask, compute indexes at which the; /// lane is marked undefined by subregister <def,read-undef> definitions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:21,mask,mask,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,1,['mask'],['mask']
Availability,"/// For a given value or instruction, figure out what base ptr its derived from.; /// For gc objects, this is simply itself. On success, returns a value which is; /// the base pointer. (This is reliable and can be used for relocation.) On; /// failure, returns nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:194,reliab,reliable,194,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,2,"['failure', 'reliab']","['failure', 'reliable']"
Availability,"/// For a string attribute \p Kind, parse attribute as an integer.; ///; /// \returns \p Default if attribute is not present.; ///; /// \returns \p Default if there is an error parsing the attribute integer,; /// and error is emitted to the LLVMContext",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:171,error,error,171,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,2,['error'],['error']
Availability,"/// For a top-down sequence, the set of objc_retains or; /// objc_retainBlocks. For bottom-up, the set of objc_releases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:14,down,down,14,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,1,['down'],['down']
Availability,"/// For all PatFragPatterns, add a new entry in PatternAlternatives for each; /// PatternList it contains. This is multiplicative, so if we have 2; /// PatFrags with 3 alternatives each, we get 2*3 permutations added to; /// PermutationsToEmit. The ""MaxPermutations"" field controls how many; /// permutations are allowed before an error is emitted and this function; /// returns false. This is a simple safeguard to prevent combination of; /// PatFrags from generating enormous amounts of rules.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:331,error,error,331,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['error'],['error']
Availability,"/// For an expression `x == Foo && x == Bar`, this determines whether the; /// `Foo` and `Bar` are either of the same enumeration type, or both integer; /// literals.; ///; /// It's an error to pass this arguments that are not either IntegerLiterals; /// or DeclRefExprs (that have decls of type EnumConstantDecl)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:185,error,error,185,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['error'],['error']
Availability,"/// For an inline function definition in C, or for a gnu_inline function; /// in C++, determine whether the definition will be externally visible.; ///; /// Inline function definitions are always available for inlining optimizations.; /// However, depending on the language dialect, declaration specifiers, and; /// attributes, the definition of an inline function may or may not be; /// ""externally"" visible to other translation units in the program.; ///; /// In C99, inline definitions are not externally visible by default. However,; /// if even one of the global-scope declarations is marked ""extern inline"", the; /// inline definition becomes externally visible (C99 6.7.4p6).; ///; /// In GNU89 mode, or if the gnu_inline attribute is attached to the function; /// definition, we use the GNU semantics for inline, which are nearly the; /// opposite of C99 semantics. In particular, ""inline"" by itself will create; /// an externally visible symbol, but ""extern inline"" will not create an; /// externally visible symbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:196,avail,available,196,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['avail'],['available']
Availability,/// For available scheduling models FDIV + two independent FMULs are much; /// faster than two FDIVs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:8,avail,available,8,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['avail'],['available']
Availability,"/// For copy B = A in BB2, if A is defined by A = B in BB0 which is a; /// predecessor of BB2, and if B is not redefined on the way from A = B; /// in BB0 to B = A in BB2, B = A in BB2 is partially redundant if the; /// execution goes through the path from BB0 to BB2. We may move B = A; /// to the predecessor without such reversed copy.; /// So we will transform the program from:; /// BB0:; /// A = B; BB1:; /// ... ...; /// / \ /; /// BB2:; /// ...; /// B = A;; ///; /// to:; ///; /// BB0: BB1:; /// A = B; ...; /// ... B = A;; /// / \ /; /// BB2:; /// ...; ///; /// A special case is when BB0 and BB2 are the same BB which is the only; /// BB in a loop:; /// BB1:; /// ...; /// BB0/BB2: ----; /// B = A; |; /// ... |; /// A = B; |; /// |-------; /// |; /// We may hoist B = A from BB0/BB2 to BB1.; ///; /// The major preconditions for correctness to remove such partial; /// redundancy include:; /// 1. A in B = A in BB2 is defined by a PHI in BB2, and one operand of; /// the PHI is defined by the reversed copy A = B in BB0.; /// 2. No B is referenced from the start of BB2 to B = A.; /// 3. No B is defined from A = B to the end of BB0.; /// 4. BB1 has only one successor.; ///; /// 2 and 4 implicitly ensure B is not live at the end of BB1.; /// 4 guarantees BB2 is hotter than BB1, so we can only move a copy to a; /// colder place, which not only prevent endless loop, but also make sure; /// the movement of copy is beneficial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:198,redundant,redundant,198,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['redundant'],['redundant']
Availability,"/// For each (ExecutorAddr&, StringRef) pair, looks up the string in the; /// bootstrap symbols map and writes its address to the ExecutorAddr if; /// found. If any symbol is not found then the function returns an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h:214,error,error,214,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,1,['error'],['error']
Availability,"/// For each VNI in \p SR, check whether or not that value defines part; /// of the mask describe by \p LaneMask and if not, remove that value; /// from \p SR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:84,mask,mask,84,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,1,['mask'],['mask']
Availability,"/// For each basic block number, keep (begin, size) pairs indexing into the; /// RegMaskSlots and RegMaskBits arrays.; /// Note that basic block numbers may not be layout contiguous, that's why; /// we can't just keep track of the first register mask in each basic; /// block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:246,mask,mask,246,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,1,['mask'],['mask']
Availability,"/// For each indexed mode and each value type, keep a quad of LegalizeAction; /// that indicates how instruction selection should deal with the load /; /// store / maskedload / maskedstore.; ///; /// The first dimension is the value_type for the reference. The second; /// dimension represents the various modes for load store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:164,mask,maskedload,164,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['mask'],"['maskedload', 'maskedstore']"
Availability,"/// For each tag symbol name, associate the corresponding; /// AsyncHandlerWrapperFunction with the address of that symbol. The; /// handler becomes callable from the executor using the ORC runtime; /// __orc_rt_jit_dispatch function and the given tag.; ///; /// Tag symbols will be looked up in JD using LookupKind::Static,; /// JITDylibLookupFlags::MatchAllSymbols (hidden tags will be found), and; /// LookupFlags::WeaklyReferencedSymbol. Missing tag definitions will not; /// cause an error, the handler will simply be dropped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:489,error,error,489,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['error'],['error']
Availability,/// For errors and debugging output.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:8,error,errors,8,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['error'],['errors']
Availability,"/// For every block, the stages that are available. A stage can be available; /// but not produced (in the epilog) or produced but not available (in the; /// prolog).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:41,avail,available,41,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,3,['avail'],['available']
Availability,"/// For example, this is 0xFF for an 8 bit integer, 0xFFFF for i16, etc.; /// @returns a bit mask with ones set for all the bits of this type.; /// Get a bit mask for this type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h:93,mask,mask,93,interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,2,['mask'],['mask']
Availability,"/// For instructions with opcodes for which the M_REMATERIALIZABLE flag is; /// set, this hook lets the target specify whether the instruction is actually; /// trivially rematerializable, taking into consideration its operands. This; /// predicate must return false if the instruction has any side effects other; /// than producing a value, or if it requres any address registers that are; /// not always available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:405,avail,available,405,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['avail'],['available']
Availability,"/// For most targets, an LLVM type must be broken down into multiple; /// smaller types. Usually the halves are ordered according to the endianness; /// but for some platform that would break. So this method will default to; /// matching the endianness but can be overridden.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:50,down,down,50,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['down'],['down']
Availability,/// For pre-GFX12 FLAT instructions the offset must be positive;; /// MSB is ignored and forced to zero.; ///; /// \return The number of bits available for the signed offset field in flat; /// instructions. Note that some forms of the instruction disallow negative; /// offsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:142,avail,available,142,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['avail'],['available']
Availability,/// For reporting errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:18,error,errors,18,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['error'],['errors']
Availability,"/// For simple types, ignore the mask and memcopy the values into the destination",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:33,mask,mask,33,tree/ntuple/v7/src/RField.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx,1,['mask'],['mask']
Availability,"/// For some targets, an LLVM struct type must be broken down into multiple; /// simple types, but the calling convention specifies that the entire struct; /// must be passed in a block of consecutive registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:57,down,down,57,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['down'],['down']
Availability,"/// For spills with equal values, remove redundant spills and hoist those left; /// to less hot spots.; ///; /// Spills with equal values will be collected into the same set in; /// MergeableSpills when spill is inserted. These equal spills are originated; /// from the same defining instruction and are dominated by the instruction.; /// Before hoisting all the equal spills, redundant spills inside in the same; /// BB are first marked to be deleted. Then starting from the spills left, walk; /// up on the dominator tree towards the Root node where the define instruction; /// is located, mark the dominated spills to be deleted along the way and; /// collect the BB nodes on the path from non-dominated spills to the define; /// instruction into a WorkSet. The nodes in WorkSet are the candidate places; /// where we are considering to hoist the spills. We iterate the WorkSet in; /// bottom-up order, and for each node, we will decide whether to hoist spills; /// inside its subtree to that node. In this way, we can get benefit locally; /// even if hoisting all the equal spills to one cold place is impossible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:41,redundant,redundant,41,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,2,['redundant'],['redundant']
Availability,"/// For the given destination element of a shuffle, peek through shuffles to; /// match a root vector source operand that contains that element in the same; /// vector lane (ie, the same mask index), so we can eliminate the shuffle(s).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:187,mask,mask,187,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['mask'],['mask']
Availability,"/// Forbid to convert from Error::success() implicitly, this avoids having; /// Expected<T> foo() { return Error::success(); } which compiles otherwise; /// but triggers the assertion above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:27,Error,Error,27,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,2,['Error'],['Error']
Availability,/// Force driver to fail before toolchain is created. This is necessary when; /// error happens in action builder.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h:82,error,error,82,interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,1,['error'],['error']
Availability,"/// Force the emission of cleanups now, instead of waiting; /// until this object is destroyed.; /// \param ValuesToReload - A list of values that need to be available at; /// the insertion point after cleanup emission. If cleanup emission created; /// a shared cleanup block, these value pointers will be rewritten.; /// Otherwise, they not will be modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:158,avail,available,158,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['avail'],['available']
Availability,/// Forces a function to be marked as available and provide an alternate name; /// that must be used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:38,avail,available,38,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,1,['avail'],['available']
Availability,/// Forces a function to be marked as available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:38,avail,available,38,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,1,['avail'],['available']
Availability,"/// Form a G_UBFX from ""(a srl b) & mask"", where b and mask are constants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,2,['mask'],['mask']
Availability,/// FormSVEBuiltinResult - Returns the struct of scalable vectors as a wider; /// vector. It extracts the scalable vector from the struct and inserts into; /// the wider vector. This avoids the error when allocating space in llvm; /// for struct of scalable vectors if a function returns struct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:194,error,error,194,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['error'],['error']
Availability,"/// Forward to NodeTy::getParent().; ///; /// Note: do not use the name ""getParent()"". We want a compile error; /// (instead of recursion) when the subclass fails to implement \a; /// getParent().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:105,error,error,105,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,1,['error'],['error']
Availability,/// Forward to `HasherT::final()` if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h:37,avail,available,37,interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,1,['avail'],['available']
Availability,/// Forward to `HasherT::result()` if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h:38,avail,available,38,interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,1,['avail'],['available']
Availability,/// Frames modifying the state as defined in \c wasModifiedBeforeCallExit.; /// This visitor generates a note only if a function does *not* change the; /// state that way. This information is not immediately available; /// by looking at the node associated with the exit from the function; /// (usually the return statement). To avoid recomputing the same information; /// many times (going up the path for each node and checking whether the; /// region was written into) we instead lazily compute the stack frames; /// along the path.; // TODO: Can't we just use a map instead? This is likely not as cheap as it; // makes the code difficult to read.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h:208,avail,available,208,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h,1,['avail'],['available']
Availability,/// Free any memory associated with this deduction failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:51,failure,failure,51,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,"/// Frontend action to parse model files.; ///; /// This frontend action is responsible for parsing model files. Model files can; /// not be parsed on their own, they rely on type information that is available; /// in another translation unit. The parsing of model files is done by a; /// separate compiler instance that reuses the ASTContext and othen information; /// from the main translation unit that is being compiled. After a model file is; /// parsed, the function definitions will be collected into a StringMap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/FrontendActions.h:200,avail,available,200,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/FrontendActions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/FrontendActions.h,1,['avail'],['available']
Availability,"/// Frontend produces RecoveryExprs on semantic errors that prevent creating; /// other well-formed expressions. E.g. when type-checking of a binary operator; /// fails, we cannot produce a BinaryOperator expression. Instead, we can choose; /// to produce a recovery expression storing left and right operands.; ///; /// RecoveryExpr does not have any semantic meaning in C++, it is only useful to; /// preserve expressions in AST that would otherwise be dropped. It captures; /// subexpressions of some expression that we could not construct and source; /// range covered by the expression.; ///; /// By default, RecoveryExpr uses dependence-bits to take advantage of existing; /// machinery to deal with dependent code in C++, e.g. RecoveryExpr is preserved; /// in `decltype(<broken-expr>)` as part of the `DependentDecltypeType`. In; /// addition to that, clang does not report most errors on dependent; /// expressions, so we get rid of bogus errors for free. However, note that; /// unlike other dependent expressions, RecoveryExpr can be produced in; /// non-template contexts.; ///; /// We will preserve the type in RecoveryExpr when the type is known, e.g.; /// preserving the return type for a broken non-overloaded function call, a; /// overloaded call where all candidates have the same return type. In this; /// case, the expression is not type-dependent (unless the known type is itself; /// dependent); ///; /// One can also reliably suppress all bogus errors on expressions containing; /// recovery expressions by examining results of Expr::containsErrors().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:22,Recover,RecoveryExprs,22,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,13,"['Recover', 'error', 'recover', 'reliab']","['RecoveryExpr', 'RecoveryExprs', 'errors', 'recovery', 'reliably']"
Availability,/// Function for getting the dependency preprocessor directives of a file.; ///; /// These are directives derived from a special form of lexing where the; /// source input is scanned for the preprocessor directives that might have an; /// effect on the dependencies for a compilation unit.; ///; /// Enables a client to cache the directives for a file and provide them; /// across multiple compiler invocations.; /// FIXME: Allow returning an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:443,error,error,443,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,1,['error'],['error']
Availability,"/// Function to construct a VFInfo out of a mangled names in the; /// following format:; ///; /// <VFABI_name>{(<redirection>)}; ///; /// where <VFABI_name> is the name of the vector function, mangled according; /// to the rules described in the Vector Function ABI of the target vector; /// extension (or <isa> from now on). The <VFABI_name> is in the following; /// format:; ///; /// _ZGV<isa><mask><vlen><parameters>_<scalarname>[(<redirection>)]; ///; /// This methods support demangling rules for the following <isa>:; ///; /// * AArch64: https://developer.arm.com/docs/101129/latest; ///; /// * x86 (libmvec): https://sourceware.org/glibc/wiki/libmvec and; /// https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&do=view&target=VectorABI.txt; ///; /// \param MangledName -> input string in the format; /// _ZGV<isa><mask><vlen><parameters>_<scalarname>[(<redirection>)].; /// \param FTy -> FunctionType of the scalar function which we're trying to find; /// a vectorized variant for. This is required to determine the vectorization; /// factor for scalable vectors, since the mangled name doesn't encode that;; /// it needs to be derived from the widest element types of vector arguments; /// or return values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h:396,mask,mask,396,interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h,2,['mask'],['mask']
Availability,"/// Function type used by lookupInBases() to determine whether a; /// specific base class subobject matches the lookup criteria.; ///; /// \param Specifier the base-class specifier that describes the inheritance; /// from the base class we are trying to match.; ///; /// \param Path the current path, from the most-derived class down to the; /// base named by the \p Specifier.; ///; /// \returns true if this base matched the search criteria, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:329,down,down,329,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['down'],['down']
Availability,/// FunctionComparator - Compares two functions to determine whether or not; /// they will generate machine code with the same behaviour. DataLayout is; /// used if available. The comparator always fails conservatively (erring on the; /// side of claiming that two functions are different).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:165,avail,available,165,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,1,['avail'],['available']
Availability,/// Fuzzer friendly interface for the llvm bitcode parser.; ///; /// \param Data Bitcode we are going to parse; /// \param Size Size of the 'Data' in bytes; /// \return New module or nullptr in case of error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FuzzMutate/IRMutator.h:202,error,error,202,interpreter/llvm-project/llvm/include/llvm/FuzzMutate/IRMutator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FuzzMutate/IRMutator.h,1,['error'],['error']
Availability,"/// Gathers the individual index expressions from a GEP instruction.; ///; /// This function optimistically assumes the GEP references into a fixed size; /// array. If this is actually true, this function returns a list of array; /// subscript expressions in \p Subscripts and a list of integers describing; /// the size of the individual array dimensions in \p Sizes. Both lists have; /// either equal length or the size list is one element shorter in case there; /// is no known size available for the outermost array dimension. Returns true; /// if successful and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:486,avail,available,486,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,1,['avail'],['available']
Availability,"/// General pattern:; /// X & Y; ///; /// Where Y is checking that all the high bits (covered by a mask 4294967168); /// are uniform, i.e. %arg & 4294967168 can be either 4294967168 or 0; /// Pattern can be one of:; /// %t = add i32 %arg, 128; /// %r = icmp ult i32 %t, 256; /// Or; /// %t0 = shl i32 %arg, 24; /// %t1 = ashr i32 %t0, 24; /// %r = icmp eq i32 %t1, %arg; /// Or; /// %t0 = trunc i32 %arg to i8; /// %t1 = sext i8 %t0 to i32; /// %r = icmp eq i32 %t1, %arg; /// This pattern is a signed truncation check.; ///; /// And X is checking that some bit in that same mask is zero.; /// I.e. can be one of:; /// %r = icmp sgt i32 %arg, -1; /// Or; /// %t = and i32 %arg, 2147483648; /// %r = icmp eq i32 %t, 0; ///; /// Since we are checking that all the bits in that mask are the same,; /// and a particular bit is zero, what we are really checking is that all the; /// masked bits are zero.; /// So this should be transformed to:; /// %r = icmp ult i32 %arg, 128",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:99,mask,mask,99,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,4,['mask'],"['mask', 'masked']"
Availability,/// Generate (x & ~(y-1)) to align down or ((x+(y-1)) & ~(y-1)) to align up.; /// Note: For pointer types we can avoid ptrtoint/inttoptr pairs by using the; /// llvm.ptrmask intrinsic (with a GEP before in the align_up case).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:35,down,down,35,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['down'],['down']
Availability,"/// Generate a USR for a macro, including the USR prefix.; ///; /// \returns true on error, false on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h:85,error,error,85,interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h,1,['error'],['error']
Availability,"/// Generate a USR for a module, including the USR prefix.; /// \returns true on error, false on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h:81,error,error,81,interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h,1,['error'],['error']
Availability,"/// Generate a USR for a top-level module name, including the USR prefix.; /// \returns true on error, false on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h:96,error,error,96,interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h,1,['error'],['error']
Availability,"/// Generate a USR fragment for a module name.; /// \returns true on error, false on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h:69,error,error,69,interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h,1,['error'],['error']
Availability,"/// Generate a USR fragment for a module.; /// \returns true on error, false on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h:64,error,error,64,interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h,1,['error'],['error']
Availability,"/// Generate a sink node. Generating a sink stops exploration of the; /// given path. To create a sink node for the purpose of reporting an error,; /// checkers should use generateErrorNode() instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h:140,error,error,140,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h,1,['error'],['error']
Availability,"/// Generate a transition to a node that will be used to report; /// an error. This node will be a sink. That is, it will stop exploration of; /// the given path.; ///; /// @param State The state of the generated node.; /// @param Pred The transition will be generated from the specified Pred node; /// to the newly generated node.; /// @param Tag The tag to uniquely identify the creation site. If null,; /// the default tag for the checker will be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h:72,error,error,72,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h,1,['error'],['error']
Availability,"/// Generate a transition to a node that will be used to report; /// an error. This node will be a sink. That is, it will stop exploration of; /// the given path.; ///; /// @param State The state of the generated node.; /// @param Tag The tag to uniquely identify the creation site. If null,; /// the default tag for the checker will be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h:72,error,error,72,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h,1,['error'],['error']
Availability,"/// Generate a transition to a node that will be used to report; /// an error. This node will not be a sink. That is, exploration will; /// continue along this path.; ///; /// @param State The state of the generated node.; /// @param Pred The transition will be generated from the specified Pred node; /// to the newly generated node.; /// @param Tag The tag to uniquely identify the creation site. If null,; /// the default tag for the checker will be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h:72,error,error,72,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h,1,['error'],['error']
Availability,"/// Generate a transition to a node that will be used to report; /// an error. This node will not be a sink. That is, exploration will; /// continue along this path.; ///; /// @param State The state of the generated node.; /// @param Tag The tag to uniquely identify the creation site. If null,; /// the default tag for the checker will be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h:72,error,error,72,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h,1,['error'],['error']
Availability,/// Generate an action that adds a host dependence to a device action. The; /// results will be kept in this action builder. Return true if an error was; /// found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:143,error,error,143,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['error'],['error']
Availability,"/// Generate an action that adds device dependences (if any) to a host action.; /// If no device dependence actions exist, just return the host action \a; /// HostAction. If an error is found or if no builder requires the host action; /// to be generated, return nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:177,error,error,177,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['error'],['error']
Availability,"/// Generate diagnostics for an invalid function redeclaration.; ///; /// This routine handles generating the diagnostic messages for an invalid; /// function redeclaration, including finding possible similar declarations; /// or performing typo correction if there are no previous declarations with; /// the same name.; ///; /// Returns a NamedDecl iff typo correction was performed and substituting in; /// the new declaration name does not cause new errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:453,error,errors,453,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['errors']
Availability,/// Generate error diagnostics if any register used by CC has been marked; /// reserved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:13,error,error,13,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['error'],['error']
Availability,"/// Generate notes from all visitors.; /// Notes associated with @c ErrorNode are generated using; /// @c getEndPath, and the rest are generated with @c VisitNode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:68,Error,ErrorNode,68,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['Error'],['ErrorNode']
Availability,/// Generate the active lane mask phi of the vector loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['mask'],['mask']
Availability,/// Generate the extraction of the appropriate bit from the block mask and the; /// conditional branch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:66,mask,mask,66,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['mask'],['mask']
Availability,/// Generate the logical AND of \p ChecksToHoist and \p OldCondition and make; /// it available at InsertPt,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:86,avail,available,86,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,1,['avail'],['available']
Availability,/// Generate unpacklo/unpackhi shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:39,mask,mask,39,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['mask'],['mask']
Availability,"/// Generate warning about stream in EOF state.; /// There will be always a state transition into the passed State,; /// by the new non-fatal error node or (if failed) a normal transition,; /// to ensure uniform handling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:142,error,error,142,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,"/// Generates a 'note' diagnostic for an overload candidate. We've; /// already generated a primary error at the call site.; ///; /// It really does need to be a single diagnostic with its caret; /// pointed at the candidate declaration. Yes, this creates some; /// major challenges of technical writing. Yes, this makes pointing; /// out problems with specific arguments quite awkward. It's still; /// better than generating twenty screens of text for every failed; /// overload.; ///; /// It would be great to be able to express per-candidate problems; /// more richly for those diagnostic clients that cared, but we'd; /// still have to be just as careful with the default diagnostics.; /// \param CtorDestAS Addr space of object being constructed (for ctor; /// candidates only).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:100,error,error,100,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,"/// Generates a USR for a type.; ///; /// \return true on error, false on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h:58,error,error,58,interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/USRGeneration.h,1,['error'],['error']
Availability,"/// Generates an object of the field type and allocates new initialized memory according to the type.; /// Implemented at the end of this header because the implementation is using RField<T>::TypeName(); /// The returned object can be released with `delete`, i.e. it is valid to call; /// auto ptr = field->CreateObject();; /// delete ptr.release();; ///; /// Note that CreateObject<void> is supported. The returned unique_ptr has a custom deleter that reports an error; /// if it is called. The intended use of the returned unique_ptr<void> is to call `release()`. In this way, the; /// transfer of pointer ownership is explicit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:464,error,error,464,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['error'],['error']
Availability,"/// Generates code to check that an operand is a pointer to any address space.; ///; /// In SelectionDAG, the types did not describe pointers or address spaces. As a; /// result, iN is used to describe a pointer of N bits to any address space and; /// PatFrag predicates are typically used to constrain the address space.; /// There's no reliable means to derive the missing type information from the; /// pattern so imported rules must test the components of a pointer separately.; ///; /// If SizeInBits is zero, then the pointer size will be obtained from the; /// subtarget.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:338,reliab,reliable,338,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,1,['reliab'],['reliable']
Availability,"/// Generates the TargetMachine.; /// Leaves TM unchanged if it is unable to create the target machine.; /// Some of our clang tests specify triples which are not built; /// into clang. This is okay because these tests check the generated; /// IR, and they require DataLayout which depends on the triple.; /// In this case, we allow this method to fail and not report an error.; /// When MustCreateTM is used, we print an error if we are unable to load; /// the requested target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:371,error,error,371,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,2,['error'],['error']
Availability,/// Generator for '#omp masked'; ///; /// \param Loc The insert and source location description.; /// \param BodyGenCB Callback that will generate the region code.; /// \param FiniCB Callback to finialize variable copies.; ///; /// \returns The insertion position *after* the masked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:24,mask,masked,24,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,2,['mask'],['masked']
Availability,"/// Generator for the control flow structure of an OpenMP canonical loop.; ///; /// Instead of a logical iteration space, this allows specifying user-defined; /// loop counter values using increment, upper- and lower bounds. To; /// disambiguate the terminology when counting downwards, instead of lower; /// bounds we use \p Start for the loop counter value in the first body; /// iteration.; ///; /// Consider the following limitations:; ///; /// * A loop counter space over all integer values of its bit-width cannot be; /// represented. E.g using uint8_t, its loop trip count of 256 cannot be; /// stored into an 8 bit integer):; ///; /// DO I = 0, 255, 1; ///; /// * Unsigned wrapping is only supported when wrapping only ""once""; E.g.; /// effectively counting downwards:; ///; /// for (uint8_t i = 100u; i > 0; i += 127u); ///; ///; /// TODO: May need to add additional parameters to represent:; ///; /// * Allow representing downcounting with unsigned integers.; ///; /// * Sign of the step and the comparison operator might disagree:; ///; /// for (int i = 0; i < 42; i -= 1u); ///; //; /// \param Loc The insert and source location description.; /// \param BodyGenCB Callback that will generate the loop body code.; /// \param Start Value of the loop counter for the first iterations.; /// \param Stop Loop counter values past this will stop the loop.; /// \param Step Loop counter increment after each iteration; negative; /// means counting down.; /// \param IsSigned Whether Start, Stop and Step are signed integers.; /// \param InclusiveStop Whether \p Stop itself is a valid value for the loop; /// counter.; /// \param ComputeIP Insertion point for instructions computing the trip; /// count. Can be used to ensure the trip count is available; /// at the outermost loop of a loop nest. If not set,; /// defaults to the preheader of the generated loop.; /// \param Name Base name used to derive BB and instruction names.; ///; /// \returns An object representing the created control flow",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:276,down,downwards,276,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,3,['down'],"['downcounting', 'downwards']"
Availability,/// Generic binary error.; ///; /// For errors that don't require their own specific sub-error (most errors); /// this class can be used to describe the error via a string message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Error.h:19,error,error,19,interpreter/llvm-project/llvm/include/llvm/Object/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Error.h,5,['error'],"['error', 'errors']"
Availability,"/// Generic helper that updates a postorder sequence of SCCs for a potentially; /// cycle-introducing edge insertion.; ///; /// A postorder sequence of SCCs of a directed graph has one fundamental; /// property: all deges in the DAG of SCCs point ""up"" the sequence. That is,; /// all edges in the SCC DAG point to prior SCCs in the sequence.; ///; /// This routine both updates a postorder sequence and uses that sequence to; /// compute the set of SCCs connected into a cycle. It should only be called to; /// insert a ""downward"" edge which will require changing the sequence to; /// restore it to a postorder.; ///; /// When inserting an edge from an earlier SCC to a later SCC in some postorder; /// sequence, all of the SCCs which may be impacted are in the closed range of; /// those two within the postorder sequence. The algorithm used here to restore; /// the state is as follows:; ///; /// 1) Starting from the source SCC, construct a set of SCCs which reach the; /// source SCC consisting of just the source SCC. Then scan toward the; /// target SCC in postorder and for each SCC, if it has an edge to an SCC; /// in the set, add it to the set. Otherwise, the source SCC is not; /// a successor, move it in the postorder sequence to immediately before; /// the source SCC, shifting the source SCC and all SCCs in the set one; /// position toward the target SCC. Stop scanning after processing the; /// target SCC.; /// 2) If the source SCC is now past the target SCC in the postorder sequence,; /// and thus the new edge will flow toward the start, we are done.; /// 3) Otherwise, starting from the target SCC, walk all edges which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:521,down,downward,521,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['down'],['downward']
Availability,"/// Get PDB information from an executable. If the information is not present,; /// Info will be set to nullptr and PDBFileName will be empty. An error is; /// returned only on corrupt object files. Convenience accessor that can be; /// used if the debug directory is not already handy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/COFF.h:146,error,error,146,interpreter/llvm-project/llvm/include/llvm/Object/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/COFF.h,1,['error'],['error']
Availability,"/// Get a 4-lane 8-bit shuffle immediate for a mask.; ///; /// This helper function produces an 8-bit shuffle immediate corresponding to; /// the ubiquitous shuffle encoding scheme used in x86 instructions for; /// shuffling 4 lanes. It can be used with most of the PSHUF instructions for; /// example.; ///; /// NB: We rely heavily on ""undef"" masks preserving the input lane.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,mask,mask,47,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masks']"
Availability,"/// Get a DIE for the given DILexicalBlock.; /// Note that this function assumes that the DIE has been already created; /// and it's an error, if it hasn't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h:136,error,error,136,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h,1,['error'],['error']
Availability,"/// Get a FileEntryRef if it exists, without doing anything on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:63,error,error,63,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['error'],['error']
Availability,"/// Get a \c DirectoryEntryRef if it exists, without doing anything on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:71,error,error,71,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['error'],['error']
Availability,/// Get a pointer to a parsed line table corresponding to a compile unit.; /// Report any recoverable parsing problems using the handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFContext.h:90,recover,recoverable,90,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFContext.h,1,['recover'],['recoverable']
Availability,"/// Get a pointer to an object of type T from the underlying stream, as if by; /// memcpy, and store the result into \p Dest. It is up to the caller to; /// ensure that objects of type T can be safely treated in this manner.; /// Updates the stream's offset to point after the newly read object. Whether; /// a copy occurs depends upon the implementation of the underlying; /// stream.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:415,error,error,415,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,"/// Get a reference to a \p NumElements element array of objects of type T; /// from the underlying stream as if by memcpy, and store the resulting array; /// slice into \p array. It is up to the caller to ensure that objects of; /// type T can be safely treated in this manner. Updates the stream's offset; /// to point after the newly read object. Whether a copy occurs depends upon; /// the implementation of the underlying stream.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:464,error,error,464,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,"/// Get a reference to the ExecutionSession for this JITDylib.; ///; /// It is legal to call this method on a defunct JITDylib, however the result; /// will only usable if the ExecutionSession is still alive. If this JITDylib; /// is held by an error that may have torn down the JIT then the result; /// should not be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:202,alive,alive,202,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,3,"['alive', 'down', 'error']","['alive', 'down', 'error']"
Availability,"/// Get a single bit mask.; ///; /// \returns a uint64_t with only bit at ""whichBit(bitPosition)"" set; /// This method generates and returns a uint64_t (word) mask for a single; /// bit at a specific bit position. This is used to mask the bit in the; /// corresponding word.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:21,mask,mask,21,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,3,['mask'],['mask']
Availability,/// Get an available trampoline address.; /// Returns an error if no trampoline can be created.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h:11,avail,available,11,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h,2,"['avail', 'error']","['available', 'error']"
Availability,"/// Get an iterator over notes in a program header.; ///; /// The program header must be of type \c PT_NOTE.; ///; /// \param Phdr the program header to iterate over.; /// \param Err [out] an error to support fallible iteration, which should; /// be checked after iteration ends.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:192,error,error,192,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,1,['error'],['error']
Availability,"/// Get an iterator over notes in a section.; ///; /// The section must be of type \c SHT_NOTE.; ///; /// \param Shdr the section to iterate over.; /// \param Err [out] an error to support fallible iteration, which should; /// be checked after iteration ends.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:172,error,error,172,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,1,['error'],['error']
Availability,"/// Get an iterator range over notes of a program header.; ///; /// The program header must be of type \c PT_NOTE.; ///; /// \param Phdr the program header to iterate over.; /// \param Err [out] an error to support fallible iteration, which should; /// be checked after iteration ends.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:198,error,error,198,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,1,['error'],['error']
Availability,"/// Get an iterator range over notes of a section.; ///; /// The section must be of type \c SHT_NOTE.; ///; /// \param Shdr the section to iterate over.; /// \param Err [out] an error to support fallible iteration, which should; /// be checked after iteration ends.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:178,error,error,178,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,1,['error'],['error']
Availability,/// Get an unsigned integer representing the number of bits and convert it into; /// bytes. Error out of not a byte width multiple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:92,Error,Error,92,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,1,['Error'],['Error']
Availability,"/// Get an unsigned integer, including error checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:39,error,error,39,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,1,['error'],['error']
Availability,"/// Get disk space usage information.; ///; /// Note: Users must be careful about ""Time Of Check, Time Of Use"" kind of bug.; /// Note: Windows reports results according to the quota allocated to the user.; ///; /// @param Path Input path.; /// @returns a space_info structure filled with the capacity, free, and; /// available space on the device \a Path is on. A platform specific error_code; /// is returned on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:317,avail,available,317,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,2,"['avail', 'error']","['available', 'error']"
Availability,"/// Get error description",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:8,error,error,8,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['error'],['error']
Availability,"/// Get error message, or """" if there is no error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LockFileManager.h:8,error,error,8,interpreter/llvm-project/llvm/include/llvm/Support/LockFileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LockFileManager.h,2,['error'],['error']
Availability,/// Get file creation mode mask of the process.; ///; /// @returns Mask reported by umask(2); /// @note There is no umask on Windows. This function returns 0 always; /// on Windows. This function does not return an error_code because; /// umask(2) never fails. It is not thread safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:27,mask,mask,27,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,/// Get mutable content for this block.; ///; /// This block's content must already be mutable. It is a programmatic error; /// to call this on a block with immutable content -- consider using; /// getMutableContent instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:117,error,error,117,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['error'],['error']
Availability,"/// Get source location from where the error was thrown",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:39,error,error,39,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['error'],['error']
Availability,"/// Get the 'stat' information for the given \p Path.; ///; /// If the path is relative, it will be resolved against the WorkingDir of the; /// FileManager's FileSystemOptions.; ///; /// \returns a \c std::error_code describing an error, if there was one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:231,error,error,231,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['error'],['error']
Availability,"/// Get the DWARF discriminator.; ///; /// DWARF discriminators distinguish identical file locations between; /// instructions that are on different basic blocks.; ///; /// There are 3 components stored in discriminator, from lower bits:; ///; /// Base discriminator: assigned by AddDiscriminators pass to identify IRs; /// that are defined by the same source line, but; /// different basic blocks.; /// Duplication factor: assigned by optimizations that will scale down; /// the execution frequency of the original IR.; /// Copy Identifier: assigned by optimizations that clones the IR.; /// Each copy of the IR will be assigned an identifier.; ///; /// Encoding:; ///; /// The above 3 components are encoded into a 32bit unsigned integer in; /// order. If the lowest bit is 1, the current component is empty, and the; /// next component will start in the next bit. Otherwise, the current; /// component is non-empty, and its content starts in the next bit. The; /// value of each components is either 5 bit or 12 bit: if the 7th bit; /// is 0, the bit 2~6 (5 bits) are used to represent the component; if the; /// 7th bit is 1, the bit 2~6 (5 bits) and 8~14 (7 bits) are combined to; /// represent the component. Thus, the number of bits used for a component; /// is either 0 (if it and all the next components are empty); 1 - if it is; /// empty; 7 - if its value is up to and including 0x1f (lsb and msb are both; /// 0); or 14, if its value is up to and including 0x1ff. Note that the last; /// component is also capped at 0x1ff, even in the case when both first; /// components are 0, and we'd technically have 29 bits available.; ///; /// For precise control over the data being encoded in the discriminator,; /// use encodeDiscriminator/decodeDiscriminator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h:466,down,down,466,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,2,"['avail', 'down']","['available', 'down']"
Availability,"/// Get the File status, or error, from the underlying external file system.; /// This returns the status with the originally requested name, while looking; /// up the entry using the canonical path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h:28,error,error,28,interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,1,['error'],['error']
Availability,"/// Get the FileEntryRef for stdin, returning an error if stdin cannot be; /// read.; ///; /// This reads and caches stdin before returning. Subsequent calls return the; /// same file entry, and a reference to the cached input is returned by calls; /// to getBufferForFile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:49,error,error,49,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['error'],['error']
Availability,/// Get the PSHUF-style mask from PSHUF node.; ///; /// This is a very minor wrapper around getTargetShuffleMask to easy forming v4; /// PSHUF-style masks that can be reused with such instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masks']"
Availability,"/// Get the RegionNode for a BasicBlock; ///; /// @param BB The BasicBlock at which the RegionNode should start.; /// @return If available, the RegionNode that represents the subregion; /// starting at BB. If no subregion starts at BB, the RegionNode; /// representing BB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:129,avail,available,129,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,1,['avail'],['available']
Availability,/// Get the action definition builder for the given opcode. Use this to define; /// the action definitions.; ///; /// It is an error to request an opcode that has already been requested by the; /// multiple-opcode variant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:127,error,error,127,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['error'],['error']
Availability,"/// Get the action definition builder for the given set of opcodes. Use this; /// to define the action definitions for multiple opcodes at once. The first; /// opcode given will be considered the representative opcode and will hold; /// the definitions whereas the other opcodes will be configured to refer to; /// the representative opcode. This lowers memory requirements and very; /// slightly improves performance.; ///; /// It would be very easy to introduce unexpected side-effects as a result of; /// this aliasing if it were permitted to request different but intersecting; /// sets of opcodes but that is difficult to keep track of. It is therefore an; /// error to request the same opcode twice using this API, to request an; /// opcode that already has definitions, or to use the single-opcode API on an; /// opcode that has already been requested by this API.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:666,error,error,666,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['error'],['error']
Availability,/// Get the address ranges for this DIE.; ///; /// Get the hi/low PC range if both attributes are available or exrtracts the; /// non-contiguous address ranges from the DW_AT_ranges attribute.; ///; /// Extracts the range information from this DIE only. This call doesn't look; /// for the range in any DW_AT_specification or DW_AT_abstract_origin DIEs.; ///; /// \returns a address range vector that might be empty if no address range; /// information is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h:98,avail,available,98,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h,2,['avail'],['available']
Availability,"/// Get the bitmask the discriminators: For FS profiles, return the bit; /// mask for this pass. For non FS profiles, return (unsigned) -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h:77,mask,mask,77,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,1,['mask'],['mask']
Availability,/// Get the clobber mask for the end of the basic block.; /// \see getBeginClobberMask(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:20,mask,mask,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['mask'],['mask']
Availability,/// Get the clobber mask for the start of this basic block. Funclets use this; /// to prevent register allocation across funclet transitions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:20,mask,mask,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['mask'],['mask']
Availability,/// Get the current error location,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmLexer.h:20,error,error,20,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmLexer.h,1,['error'],['error']
Availability,/// Get the current error string,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmLexer.h:20,error,error,20,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmLexer.h,1,['error'],['error']
Availability,/// Get the current error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h:20,error,error,20,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,1,['error'],['error']
Availability,"/// Get the full function info for an address.; ///; /// This should be called when a client will store a copy of the complete; /// FunctionInfo for a given address. For one off lookups, use the lookup(); /// function below.; ///; /// Symbolication server processes might want to parse the entire function; /// info for a given address and cache it if the process stays around to; /// service many symbolication addresses, like for parsing profiling; /// information.; ///; /// \param Addr A virtual address from the orignal object file to lookup.; ///; /// \returns An expected FunctionInfo that contains the function info object; /// or an error object that indicates reason for failing to lookup the; /// address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:642,error,error,642,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,1,['error'],['error']
Availability,/// Get the full function info given an address index.; ///; /// \param AddrIdx A address index for an address in the address table.; ///; /// \returns An expected FunctionInfo that contains the function info object; /// or an error object that indicates reason for failing get the function; /// info object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:227,error,error,227,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,1,['error'],['error']
Availability,/// Get the function data and address given an address index.; ///; /// \param AddrIdx A address index from the address table.; ///; /// \returns An expected FunctionInfo that contains the function info object; /// or an error object that indicates reason for failing to lookup the; /// address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:221,error,error,221,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,1,['error'],['error']
Availability,/// Get the index ID for the loaded SourceLocation offset.; ///; /// \returns Invalid index ID (0) if an error occurred that prevented the; /// SLocEntry from being loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:105,error,error,105,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['error'],['error']
Availability,"/// Get the inline cost estimate.; /// It is an error to call this on an ""always"" or ""never"" InlineCost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:48,error,error,48,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,1,['error'],['error']
Availability,/// Get the instruction causing the pointer to escape.; /// \returns a pointer to the instruction which escapes the pointer if one; /// is available; otherwise returns null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:139,avail,available,139,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,1,['avail'],['available']
Availability,/// Get the instruction causing the visit to abort.; /// \returns a pointer to the instruction causing the abort if one is; /// available; otherwise returns null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:128,avail,available,128,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,1,['avail'],['available']
Availability,"/// Get the line number for the function header.; ///; /// This looks up function \p F in the current compilation unit and; /// retrieves the line number where the function is defined. This is; /// line 0 for all the samples read from the profile file. Every line; /// number is relative to this line.; ///; /// \param F Function object to query.; ///; /// \returns the line number where \p F is defined. If it returns 0,; /// it means that there is no debug information available for \p F.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:471,avail,available,471,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,1,['avail'],['available']
Availability,/// Get the main file name for use in error messages and debug; /// info. This can be set to ensure we've got the correct file name; /// after preprocessing or for -save-temps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h:38,error,error,38,interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,1,['error'],['error']
Availability,/// Get the maximum error permitted by this operation in ULPs. An accuracy of; /// 0.0 means that the operation should be performed with the default; /// precision.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Operator.h:20,error,error,20,interpreter/llvm-project/llvm/include/llvm/IR/Operator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Operator.h,1,['error'],['error']
Availability,"/// Get the next available kind ID for a plugin diagnostic.; /// Each time this function is called, it returns a different number.; /// Therefore, a plugin that wants to ""identify"" its own classes; /// with a dynamic identifier, just have to use this method to get a new ID; /// and assign it to each of its classes.; /// The returned ID will be greater than or equal to DK_FirstPluginKind.; /// Thus, the plugin identifiers will not conflict with the; /// DiagnosticKind values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:17,avail,available,17,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['avail'],['available']
Availability,"/// Get the next line table from the section. Report any issues via the; /// handlers.; ///; /// \param RecoverableErrorHandler - any issues that don't prevent further; /// parsing of the table will be reported through this handler.; /// \param UnrecoverableErrorHandler - any issues that prevent further; /// parsing of the table will be reported through this handler.; /// \param OS - if not null, the parser will print information about the; /// table as it parses it.; /// \param Verbose - if true, the parser will print verbose information when; /// printing to the output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h:104,Recover,RecoverableErrorHandler,104,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h,1,['Recover'],['RecoverableErrorHandler']
Availability,"/// Get the number of errors that the RLogDiagCount has emitted since construction of *this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx:22,error,errors,22,core/foundation/inc/ROOT/RLogger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx,2,['error'],['errors']
Availability,/// Get the number of redundant path components in each path in \p Paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:22,redundant,redundant,22,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redundant'],['redundant']
Availability,/// Get the pressure of each PSet after traversing this instruction top-down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:72,down,down,72,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,2,['down'],['down']
Availability,"/// Get the process's page size.; /// This may fail if the underlying syscall returns an error. In most cases,; /// page size information is used for optimization, and this error can be; /// safely discarded by calling consumeError, and an estimated page size; /// substituted instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h:89,error,error,89,interpreter/llvm-project/llvm/include/llvm/Support/Process.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h,2,['error'],['error']
Availability,/// Get the record type with the given non-redundant list of superclasses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h:43,redundant,redundant,43,interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h,1,['redundant'],['redundant']
Availability,/// Get the result of an analysis pass for a Function.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:109,avail,available,109,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,1,['avail'],['available']
Availability,/// Get the result of an analysis pass for a MachineFunction.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:116,avail,available,116,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,1,['avail'],['available']
Availability,/// Get the result of an analysis pass for a Module.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:107,avail,available,107,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,1,['avail'],['available']
Availability,/// Get the result of an analysis pass for a given IR unit.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:114,avail,available,114,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['avail'],['available']
Availability,"/// Get the set of file remappings from a list of files with remapping; /// info.; ///; /// \returns false if no error is produced, true otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ARCMigrate/ARCMT.h:113,error,error,113,interpreter/llvm-project/clang/include/clang/ARCMigrate/ARCMT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ARCMigrate/ARCMT.h,1,['error'],['error']
Availability,"/// Get the set of file remappings from the \p outputDir path that; /// migrateWithTemporaryFiles produced.; ///; /// \returns false if no error is produced, true otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ARCMigrate/ARCMT.h:139,error,error,139,interpreter/llvm-project/clang/include/clang/ARCMigrate/ARCMT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ARCMigrate/ARCMT.h,1,['error'],['error']
Availability,"/// Get the size of the test (eg. rate of Type I error)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/BayesianCalculator.h:49,error,error,49,roofit/roostats/inc/RooStats/BayesianCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/BayesianCalculator.h,6,['error'],['error']
Availability,"/// Get the specified node if it's already available, or else return NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:43,avail,available,43,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['avail'],['available']
Availability,"/// Get the subregion that starts at a BasicBlock; ///; /// @param BB The BasicBlock the subregion should start.; /// @return The Subregion if available, otherwise NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:143,avail,available,143,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,1,['avail'],['available']
Availability,/// Get the tentative definition that acts as the real definition in a TU.; /// Returns null if there is a proper definition available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:125,avail,available,125,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['avail'],['available']
Availability,/// Get the type constant to catch for the given ObjC pointer type.; /// This is used externally to implement catching ObjC types in C++.; /// Runtimes which don't support this should add the appropriate; /// error to Sema.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h:209,error,error,209,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,1,['error'],['error']
Availability,"/// Get the typical temporary directory for the system, e.g.,; /// ""/var/tmp"" or ""C:/TEMP""; ///; /// @param erasedOnReboot Whether to favor a path that is erased on reboot; /// rather than one that potentially persists longer. This parameter will be; /// ignored if the user or system has set the typical environment variable; /// (e.g., TEMP on Windows, TMPDIR on *nix) to specify a temporary directory.; ///; /// @param result Holds the resulting path name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Path.h:165,reboot,reboot,165,interpreter/llvm-project/llvm/include/llvm/Support/Path.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Path.h,1,['reboot'],['reboot']
Availability,/// Get the version of the linker known to be available for a particular; /// compiler invocation (via the `-mlinker-version=` arg).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h:46,avail,available,46,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h,1,['avail'],['available']
Availability,"/// Get the virtual root of the graph, all the functions available externally; /// are represented as callees of the node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CallGraph.h:57,avail,available,57,interpreter/llvm-project/clang/include/clang/Analysis/CallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CallGraph.h,1,['avail'],['available']
Availability,/// GetSuccessorNumber - Search for the specified successor of basic block BB; /// and return its position in the terminator instruction's list of; /// successors. It is an error to call this with a block that is not a; /// successor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:173,error,error,173,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,1,['error'],['error']
Availability,/// GetTemporaryPath - Return the pathname of a temporary file to use; /// as part of compilation; the file will have the given prefix and suffix.; ///; /// GCC goes to extra lengths here to be a bit more robust.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:205,robust,robust,205,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['robust'],['robust']
Availability,"/// GetTypeForDeclarator - Convert the type for the specified; /// declarator to Type instances.; ///; /// The result of this call will never be null, but the associated; /// type may be a null type if there's an unrecoverable error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:227,error,error,227,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['error'],['error']
Availability,"/// GetValue - Check to see if AvailableVals has an entry for the specified; /// BB and if so, return it. If not, construct SSA form by first; /// calculating the required placement of PHIs and then inserting new PHIs; /// where needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:31,Avail,AvailableVals,31,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,1,['Avail'],['AvailableVals']
Availability,"/// GetValueInMiddleOfBlock - Construct SSA form, materializing a value that; /// is live in the middle of the specified block. If ExistingValueOnly is; /// true then this will only return an existing value or $noreg; otherwise new; /// instructions may be inserted to materialize a value.; ///; /// GetValueInMiddleOfBlock is the same as GetValueAtEndOfBlock except in one; /// important case: if there is a definition of the rewritten value after the; /// 'use' in BB. Consider code like this:; ///; /// X1 = ...; /// SomeBB:; /// use(X); /// X2 = ...; /// br Cond, SomeBB, OutBB; ///; /// In this case, there are two values (X1 and X2) added to the AvailableVals; /// set by the client of the rewriter, and those values are both live out of; /// their respective blocks. However, the use of X happens in the *middle* of; /// a block. Because of this, we need to insert a new PHI node in SomeBB to; /// merge the appropriate values, and this value isn't live out of the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h:652,Avail,AvailableVals,652,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,2,['Avail'],['AvailableVals']
Availability,"/// Gets latency information for \p Inst from the itinerary; /// scheduling model, based on \p DC information.; /// \return The maximum expected latency over all the operands or -1; /// if no information is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:207,avail,available,207,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,1,['avail'],['available']
Availability,"/// Gets latency information for \p Inst, based on \p DC information.; /// \return The maximum expected latency over all the definitions or -1; /// if no information is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:169,avail,available,169,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,1,['avail'],['available']
Availability,"/// Gets the ""edit distance"" of the typo correction from the typo.; /// If Normalized is true, scale the distance down by the CharDistanceWeight; /// to return the edit distance in terms of single-character edits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TypoCorrection.h:114,down,down,114,interpreter/llvm-project/clang/include/clang/Sema/TypoCorrection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TypoCorrection.h,1,['down'],['down']
Availability,"/// Gets the number of positions a character is likely to occupy when output; /// on a terminal (""character width""). This depends on the implementation of the; /// terminal, and there's no standard definition of character width.; /// The implementation defines it in a way that is expected to be compatible; /// with a generic Unicode-capable terminal.; /// \return Character width:; /// * ErrorNonPrintableCharacter (-1) for non-printable characters (as; /// identified by isPrintable);; /// * 0 for non-spacing and enclosing combining marks;; /// * 2 for CJK characters excluding halfwidth forms;; /// * 1 for all remaining characters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Unicode.cpp:390,Error,ErrorNonPrintableCharacter,390,interpreter/llvm-project/llvm/lib/Support/Unicode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Unicode.cpp,1,['Error'],['ErrorNonPrintableCharacter']
Availability,"/// Gets the number of positions the UTF8-encoded \p Text is likely to occupy; /// when output on a terminal (""character width""). This depends on the; /// implementation of the terminal, and there's no standard definition of; /// character width.; ///; /// The implementation defines it in a way that is expected to be compatible; /// with a generic Unicode-capable terminal.; ///; /// \return Character width:; /// * ErrorNonPrintableCharacter (-1) if \p Text contains non-printable; /// characters (as identified by isPrintable);; /// * 0 for each non-spacing and enclosing combining mark;; /// * 2 for each CJK character excluding halfwidth forms;; /// * 1 for each of the remaining characters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Unicode.h:418,Error,ErrorNonPrintableCharacter,418,interpreter/llvm-project/llvm/include/llvm/Support/Unicode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Unicode.h,1,['Error'],['ErrorNonPrintableCharacter']
Availability,"/// Given EXTRACT_SUBVECTOR(VECTOR_SHUFFLE(Op0, Op1, Mask)),; /// try to produce VECTOR_SHUFFLE(EXTRACT_SUBVECTOR(Op?, ?),; /// EXTRACT_SUBVECTOR(Op?, ?),; /// Mask')); /// iff it is legal and profitable to do so. Notably, the trimmed mask; /// (containing only the elements that are extracted); /// must reference at most two subvectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,Mask,Mask,53,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Given a ""foo"" or \<foo> reference, look up the indicated file,; /// return null on failure.; ///; /// \returns If successful, this returns 'UsedDir', the DirectoryLookup member; /// the file was found in, or null if not applicable.; ///; /// \param IncludeLoc Used for diagnostics if valid.; ///; /// \param isAngled indicates whether the file reference is a <> reference.; ///; /// \param CurDir If non-null, the file was found in the specified directory; /// search location. This is used to implement \#include_next.; ///; /// \param Includers Indicates where the \#including file(s) are, in case; /// relative searches are needed. In reverse order of inclusion.; ///; /// \param SearchPath If non-null, will be set to the search path relative; /// to which the file was found. If the include path is absolute, SearchPath; /// will be set to an empty string.; ///; /// \param RelativePath If non-null, will be set to the path relative to; /// SearchPath at which the file was found. This only differs from the; /// Filename for framework includes.; ///; /// \param SuggestedModule If non-null, and the file found is semantically; /// part of a known module, this will be set to the module that should; /// be imported instead of preprocessing/parsing the file found.; ///; /// \param IsMapped If non-null, and the search involved header maps, set to; /// true.; ///; /// \param IsFrameworkFound If non-null, will be set to true if a framework is; /// found in any of searched SearchDirs. Will be set to false if a framework; /// is found only through header maps. Doesn't guarantee the requested file is; /// found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:87,failure,failure,87,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['failure'],['failure']
Availability,"/// Given a ""foo"" or \<foo> reference, look up the indicated file.; ///; /// Returns std::nullopt on failure. \p isAngled indicates whether the file; /// reference is for system \#include's or not (i.e. using <> instead of """").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:101,failure,failure,101,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['failure'],['failure']
Availability,"/// Given a Clang driver command-line for a translation unit, gather the; /// modular dependencies and return the information needed for explicit build.; ///; /// \param AlreadySeen This stores modules which have previously been; /// reported. Use the same instance for all calls to this; /// function for a single \c DependencyScanningTool in a; /// single build. Use a different one for different tools,; /// and clear it between builds.; /// \param LookupModuleOutput This function is called to fill in; /// ""-fmodule-file="", ""-o"" and other output; /// arguments for dependencies.; ///; /// \returns a \c StringError with the diagnostic output if clang errors; /// occurred, \c TranslationUnitDeps otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:656,error,errors,656,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,1,['error'],['errors']
Availability,"/// Given a SourceLocation object, return the spelling location; /// referenced by the ID.; ///; /// This is the first level down towards the place where the characters; /// that make up the lexed token can be found. This should not generally; /// be used by clients.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:125,down,down,125,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['down'],['down']
Availability,"/// Given a chain of or (||) or and (&&) comparison of a value against a; /// constant, this will try to recover the information required for a switch; /// structure.; /// It will depth-first traverse the chain of comparison, seeking for patterns; /// like %a == 12 or %a < 4 and combine them to produce a set of integer; /// representing the different cases for the switch.; /// Note that if the chain is composed of '||' it will build the set of elements; /// that matches the comparisons (i.e. any of this value validate the chain); /// while for a chain of '&&' it will build the set elements that make the test; /// fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:105,recover,recover,105,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['recover'],['recover']
Availability,"/// Given a constructor and the set of arguments provided for the; /// constructor, convert the arguments and add any required default arguments; /// to form a proper call to this constructor.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:223,error,error,223,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['error']
Availability,"/// Given a cursor at the start of an AST file, scan ahead and drop the; /// cursor into the start of the given block ID, returning false on success and; /// true on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:166,failure,failure,166,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['failure'],['failure']
Availability,"/// Given a implicit special member, infer its CUDA target from the; /// calls it needs to make to underlying base/field special members.; /// \param ClassDecl the class for which the member is being created.; /// \param CSM the kind of special member.; /// \param MemberDecl the special member itself.; /// \param ConstRHS true if this is a copy operation with a const object on; /// its RHS.; /// \param Diagnose true if this call should emit diagnostics.; /// \return true if there was an error inferring.; /// The result of this call is implicit CUDA target attribute(s) attached to; /// the member declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:492,error,error,492,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// Given a linear access function, tries to recover subscripts; /// for each dimension of the array element access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,recover,recover,45,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['recover'],['recover']
Availability,"/// Given a list of non-local dependencies, determine if a value is; /// available for the load in each specified block. If it is, add it to; /// ValuesPerBlock. If not, add it to UnavailableBlocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:73,avail,available,73,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,1,['avail'],['available']
Availability,"/// Given a list of possible callee implementation for a call site, select one; /// that fits the \p Threshold. If none are found, the Reason will give the last; /// reason for the failure (last, in the order of CalleeSummaryList entries).; ///; /// FIXME: select ""best"" instead of first that fits. But what is ""best""?; /// - The smallest: more likely to be inlined.; /// - The one with the least outgoing edges (already well optimized).; /// - One from a module already being imported from in order to reduce the; /// number of source modules parsed/linked.; /// - One that has PGO data attached.; /// - [insert you fancy metric here]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:181,failure,failure,181,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['failure'],['failure']
Availability,/// Given a local dependency (Def or Clobber) determine if a value is; /// available for the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:75,avail,available,75,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,1,['avail'],['available']
Availability,"/// Given a mask Mask, returns the larger vector into which Mask was widened.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h:12,mask,mask,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,3,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Given a mask \p DefinedLanes of lanes defined at operand \p OpNum; /// of COPY-like instruction, determine which lanes are defined at the output; /// operand \p Def.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:12,mask,mask,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,1,['mask'],['mask']
Availability,/// Given a mask \p UsedLanes used from the output of instruction \p MI; /// determine which lanes are used from operand \p MO of this instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:12,mask,mask,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,1,['mask'],['mask']
Availability,"/// Given a mask vector of i1, Return true if all of the elements of this; /// predicate mask are known to be false or undef. That is, return true if all; /// lanes can be assumed inactive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:12,mask,mask,12,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,2,['mask'],['mask']
Availability,"/// Given a mask vector of i1, Return true if all of the elements of this; /// predicate mask are known to be true or undef. That is, return true if all; /// lanes can be assumed active.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:12,mask,mask,12,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,2,['mask'],['mask']
Availability,"/// Given a mask vector of i1, Return true if any of the elements of this; /// predicate mask are known to be true or undef. That is, return true if at; /// least one lane can be assumed active.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:12,mask,mask,12,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,2,['mask'],['mask']
Availability,"/// Given a mask vector of the form <Y x i1>, return an APInt (of bitwidth Y); /// for each lane which may be active.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:12,mask,mask,12,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['mask'],['mask']
Availability,"/// Given a masked memory load/store operation, return true if it has one mask; /// bit set. If it has one mask bit set, then also return the memory address of; /// the scalar element to load/store, the vector index to insert/extract that; /// scalar element, and the alignment for the scalar memory access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,mask,masked,12,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['mask'],"['mask', 'masked']"
Availability,"/// Given a physical register constraint (e.g. {edx}), return the register; /// number and the register class for the register.; ///; /// Given a register class constraint, like 'r', if this corresponds directly; /// to an LLVM register class, return a register of 0 and the register class; /// pointer.; ///; /// This should only be used for C_Register constraints. On error, this; /// returns a register number of 0 and a null register class pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:370,error,error,370,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['error'],['error']
Availability,"/// Given a physical register constraint; /// (e.g. {edx}), return the register number and the register class for the; /// register. This should only be used for C_Register constraints. On; /// error, this returns a register number of 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:194,error,error,194,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['error'],['error']
Availability,"/// Given a power-of-two unit size, return the offset of the aligned unit; /// of that size which contains the given offset.; ///; /// In other words, round down to the nearest multiple of the unit size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:157,down,down,157,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,1,['down'],['down']
Availability,"/// Given a select instruction that was understood by; /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by; /// merging it with one of its operands. Returns NULL on failure.; ///; /// When successful, returns the new select instruction. The client is; /// responsible for deleting MI.; ///; /// If both sides of the select can be optimized, PreferFalse is used to pick; /// a side.; ///; /// @param MI Optimizable select instruction.; /// @param NewMIs Set that record all MIs in the basic block up to \p; /// MI. Has to be updated with any newly created MI or deleted ones.; /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.; /// @returns Optimized instruction or NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:190,failure,failure,190,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['failure'],['failure']
Availability,"/// Given a shuffle mask for a binary shuffle, create the equivalent shuffle; /// mask assuming both operands are identical. This assumes that the unary; /// shuffle will use elements from operand 0 (operand 1 will be unused).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:20,mask,mask,20,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,2,['mask'],['mask']
Availability,"/// Given a use regiser operand \p Use and a mask of defined lanes, check; /// if the operand belongs to a lowersToCopies() instruction, transfer the; /// mask to the def and put the instruction into the worklist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:45,mask,mask,45,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,2,['mask'],['mask']
Availability,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:717,avail,available,717,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,2,"['avail', 'down']","['available', 'down']"
Availability,"/// Given an Offset into this BinaryStreamRef, return a reference to the; /// largest buffer the stream could support without necessitating a copy.; ///; /// \returns a success error code if implementation could read the data,; /// and an appropriate error code otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h:177,error,error,177,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h,2,['error'],['error']
Availability,"/// Given an Offset into this StreamRef and a Size, return a reference to a; /// buffer owned by the stream.; ///; /// \returns a success error code if the entire range of data is within the; /// bounds of this BinaryStreamRef's view and the implementation could read; /// the data, and an appropriate error code otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h:138,error,error,138,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h,2,['error'],['error']
Availability,"/// Given an Offset into this WritableBinaryStreamRef and some input data,; /// writes the data to the underlying stream.; ///; /// \returns a success error code if the data could fit within the underlying; /// stream at the specified location and the implementation could write the; /// data, and an appropriate error code otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h:151,error,error,151,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h,2,['error'],['error']
Availability,"/// Given an RVA base and size, returns a valid array of bytes or an error; /// code if the RVA and size is not contained completely within a valid; /// section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/COFF.h:69,error,error,69,interpreter/llvm-project/llvm/include/llvm/Object/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/COFF.h,1,['error'],['error']
Availability,"/// Given an [N x Ty] block, it should be passed in a consecutive sequence of; /// registers. If no such sequence is available, mark the rest of the registers; /// of that type as used and place the argument on the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp:117,avail,available,117,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp,1,['avail'],['available']
Availability,"/// Given an address, find the address index.; ///; /// Binary search the address table and find the matching address index.; ///; /// \param Addr A virtual address that matches the original object file; /// to lookup.; /// \returns An index into the address table. This index can be used to; /// extract the FunctionInfo data's offset from the AddrInfoOffsets array.; /// Returns an error if the address isn't in the GSYM with details of why.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:384,error,error,384,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,1,['error'],['error']
Availability,"/// Given an address, find the correct function info data and function; /// address.; ///; /// Binary search the address table and find the matching address info; /// and make sure that the function info contains the address. GSYM allows; /// functions to overlap, and the most debug info is contained in the first; /// entries due to the sorting when GSYM files are created. We can have; /// multiple function info that start at the same address only if their; /// address range doesn't match. So find the first entry that matches \a Addr; /// and iterate forward until we find one that contains the address.; ///; /// \param[in] Addr A virtual address that matches the original object file; /// to lookup.; ///; /// \param[out] FuncStartAddr A virtual address that is the base address of; /// the function that is used for decoding the FunctionInfo.; ///; /// \returns An valid data extractor on success, or an error if we fail to; /// find the address in a function info or corrrectly decode the data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:913,error,error,913,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,1,['error'],['error']
Availability,"/// Given an expression that refers to an overloaded function, try to; /// resolve that overloaded function expression down to a single function.; ///; /// This routine can only resolve template-ids that refer to a single function; /// template, where that template-id refers to a single template whose template; /// arguments are either provided by the template-id or have defaults,; /// as described in C++0x [temp.arg.explicit]p3.; ///; /// If no template-ids are found, no diagnostics are emitted and NULL is; /// returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:119,down,down,119,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['down'],['down']
Availability,"/// Given an ordering required on success, emit all possible cmpxchg; /// instructions to cope with the provided (but possibly only dynamically known); /// FailureOrder.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:156,Failure,FailureOrder,156,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['Failure'],['FailureOrder']
Availability,"/// Given operands for a ShuffleVectorInst, fold the result or return null.; /// See class ShuffleVectorInst for a description of the mask representation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:134,mask,mask,134,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,1,['mask'],['mask']
Availability,"/// Given that expression S represents a pointer that would be dereferenced,; /// try to find a sub-expression from which the pointer came from.; /// This is used for tracking down origins of a null or undefined value:; /// ""this is null because that is null because that is null"" etc.; /// We wipe away field and element offsets because they merely add offsets.; /// We also wipe away all casts except lvalue-to-rvalue casts, because the; /// latter represent an actual pointer dereference; however, we remove; /// the final lvalue-to-rvalue cast before returning from this function; /// because it demonstrates more clearly from where the pointer rvalue was; /// loaded. Examples:; /// x->y.z ==> x (lvalue); /// foo()->y.z ==> foo() (rvalue)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:176,down,down,176,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['down'],['down']
Availability,"/// Given that this builder was created by beginning an array or struct; /// component on the given parent builder, finish the array/struct; /// component and add it to the parent.; ///; /// It is an intentional choice that the parent is passed in explicitly; /// despite it being redundant with information already kept in the; /// builder. This aids in readability by making it easier to find the; /// places that add components to a builder, as well as ""bookending""; /// the sub-builder more explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ConstantInitBuilder.h:281,redundant,redundant,281,interpreter/llvm-project/clang/include/clang/CodeGen/ConstantInitBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ConstantInitBuilder.h,1,['redundant'],['redundant']
Availability,"/// Given that this builder was created by beginning an array or struct; /// directly on a ConstantInitBuilder, finish the array/struct and; /// return a future which can be used to install the initializer in; /// a global later.; ///; /// This is useful for allowing a finished initializer to passed to; /// an API which will build the global. However, the ""future"" preserves; /// a dependency on the original builder; it is an error to pass it aside.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ConstantInitBuilder.h:429,error,error,429,interpreter/llvm-project/clang/include/clang/CodeGen/ConstantInitBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ConstantInitBuilder.h,1,['error'],['error']
Availability,/// Given the bitvector \p Available of free register units at position; /// \p From. Search backwards to find a register that is part of \p; /// Candidates and not used/clobbered until the point \p To. If there is; /// multiple candidates continue searching and pick the one that is not used/; /// clobbered for the longest time.; /// Returns the register and the earliest position we know it to be free or; /// the position MBB.end() if no register is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:27,Avail,Available,27,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,2,"['Avail', 'avail']","['Available', 'available']"
Availability,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:46,avail,available,46,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,['avail'],['available']
Availability,"/// Given the operands of an add/sub operation, see if the 2nd operand is a; /// masked 0/1 whose source operand is actually known to be 0/-1. If so, invert; /// the opcode and bypass the mask operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:81,mask,masked,81,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],"['mask', 'masked']"
Availability,"/// Given the order VEC_012 < VEC_021 < VEC_120 < VEC_102 < VEC_201 < VEC_210; /// returns true and the first (in lexical order) BankSwizzle affectation; /// starting from the one already provided in the Instruction Group MIs that; /// fits Read Port limitations in BS if available. Otherwise returns false; /// and undefined content in BS.; /// isLastAluTrans should be set if the last Alu of MIs will be executed on; /// Trans ALU. In this case, ValidTSwizzle returns the BankSwizzle value to; /// apply to the last instruction.; /// PV holds GPR to PV registers in the Instruction Group MIs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h:272,avail,available,272,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,1,['avail'],['available']
Availability,"/// Given the potential call expression \p Call, determine if there is a; /// specialization via the OpenMP declare variant mechanism available. If; /// there is, return the specialized call expression, otherwise return the; /// original \p Call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:134,avail,available,134,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avail'],['available']
Availability,/// Global flag to indicate that the LTO pipeline threw an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:59,error,error,59,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,1,['error'],['error']
Availability,/// Hack(tm) to ignore linking errors when we are doing ARC migration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:31,error,errors,31,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['error'],['errors']
Availability,"/// Handle (icmp(A & B) ==/!= C) &/| (icmp(A & D) ==/!= E).; /// Return the pattern classes (from MaskedICmpType) for the left hand side and; /// the right hand side as a pair.; /// LHS and RHS are the left hand side and the right hand side ICmps and PredL; /// and PredR are their predicates, respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:98,Mask,MaskedICmpType,98,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['Mask'],['MaskedICmpType']
Availability,"/// Handle a disconnection from the underlying transport. No further messages; /// should be sent to handleMessage after this is called.; /// Err may contain an Error value indicating unexpected disconnection. This; /// allows clients to log such errors, but no attempt should be made at; /// recovery (which should be handled inside the transport class, if it is; /// supported at all).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h:161,Error,Error,161,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,3,"['Error', 'error', 'recover']","['Error', 'errors', 'recovery']"
Availability,"/// Handle any DIE (debug info entry) from the DWARF.; ///; /// This function will find all DW_TAG_subprogram DIEs that convert them into; /// GSYM FuntionInfo objects and add them to the GsymCreator supplied during; /// construction. The DIE and all its children will be recursively parsed; /// with calls to this function.; ///; /// \param Strm The thread specific log stream for any non fatal errors and; /// warnings. Once a thread has finished parsing an entire compile unit, all; /// information in this temporary stream will be forwarded to the member; /// variable log. This keeps logging thread safe. If the value is NULL, then; /// don't log.; ///; /// \param CUI The compile unit specific information that contains the DWARF; /// line table, cached file list, and other compile unit specific; /// information.; ///; /// \param Die The DWARF debug info entry to parse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/DwarfTransformer.h:396,error,errors,396,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/DwarfTransformer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/DwarfTransformer.h,1,['error'],['errors']
Availability,"/// Handle any errors (if present) in an Expected<T>, then try a recovery path.; ///; /// If the incoming value is a success value it is returned unmodified. If it; /// is a failure value then it the contained error is passed to handleErrors.; /// If handleErrors is able to handle the error then the RecoveryPath functor; /// is called to supply the final result. If handleErrors is not able to; /// handle all errors then the unhandled errors are returned.; ///; /// This utility enables the follow pattern:; ///; /// @code{.cpp}; /// enum FooStrategy { Aggressive, Conservative };; /// Expected<Foo> foo(FooStrategy S);; ///; /// auto ResultOrErr =; /// handleExpected(; /// foo(Aggressive),; /// []() { return foo(Conservative); },; /// [](AggressiveStrategyError&) {; /// // Implicitly conusme this - we'll recover by using a conservative; /// // strategy.; /// });; ///; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:15,error,errors,15,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,9,"['Recover', 'error', 'failure', 'recover']","['RecoveryPath', 'error', 'errors', 'failure', 'recover', 'recovery']"
Availability,/// Handle case where shuffle sources are coming from the same 128-bit lane and; /// every lane can be represented as the same repeating mask - allowing us to; /// shuffle the sources with the repeating shuffle and then permute the result; /// to the destination lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:137,mask,mask,137,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,/// Handle lowering of 4-lane 64-bit floating point shuffles.; ///; /// Also ends up handling lowering of 4-lane 64-bit integer shuffles when AVX2; /// isn't available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:158,avail,available,158,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,/// Handle lowering of 8-lane 32-bit floating point shuffles.; ///; /// Also ends up handling lowering of 8-lane 32-bit integer shuffles when AVX2; /// isn't available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:158,avail,available,158,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,/// Handle mask types whose sizes are not between one and eight bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/FormatString.h:11,mask,mask,11,interpreter/llvm-project/clang/include/clang/AST/FormatString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/FormatString.h,1,['mask'],['mask']
Availability,"/// Handle receipt of a message.; ///; /// Returns an Error if the message cannot be handled, 'EndSession' if the; /// client will not accept any further messages, and 'ContinueSession'; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h:54,Error,Error,54,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,1,['Error'],['Error']
Availability,"/// Handle the Microsoft \#pragma detect_mismatch extension.; ///; /// The syntax is:; /// \code; /// #pragma detect_mismatch(""name"", ""value""); /// \endcode; /// Where 'name' and 'value' are quoted strings. The values are embedded in; /// the object file and passed along to the linker. If the linker detects a; /// mismatch in the object file's values for the given name, a LNK2038 error; /// is emitted. See MSDN for more details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:383,error,error,383,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,1,['error'],['error']
Availability,"/// Handle the debug-info implications of this instruction being removed. Any; /// attached DPValues need to ""fall"" down onto the next instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:116,down,down,116,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['down'],['down']
Availability,"/// Handle the given expression from the given node.; ///; /// \param E The expression value which we are tracking; /// \param Original A node ""downstream"" where the tracking started.; /// \param ExprNode A node where the evaluation of \c E actually happens.; /// \param Opts Tracking options specifying how we are tracking the value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h:144,down,downstream,144,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h,1,['down'],['downstream']
Availability,"/// Handle this diagnostic, reporting it to the user or; /// capturing it to a log as needed.; ///; /// The default implementation just keeps track of the total number of; /// warnings and errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:189,error,errors,189,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['errors']
Availability,/// HandleComment - Hook into the preprocessor and extract comments containing; /// expected errors and warnings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:93,error,errors,93,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,1,['error'],['errors']
Availability,"/// HandleDiagnostic - Store the errors, warnings, and notes that are; /// reported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticBuffer.cpp:33,error,errors,33,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticBuffer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticBuffer.cpp,1,['error'],['errors']
Availability,"/// HandlePrefixedOrGroupedOption - The specified argument string (which started; /// with at least one '-') does not fully match an available option. Check to; /// see if this is a prefix or grouped option. If so, split arg into output an; /// Arg/Value pair and return the Option to parse it with.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:133,avail,available,133,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['avail'],['available']
Availability,/// HandleRegMask - Call HandlePhysRegKill for all registers clobbered by Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:74,Mask,Mask,74,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,1,['Mask'],['Mask']
Availability,/// HandleUserDiagnosticDirective - Handle a #warning or #error directive.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:58,error,error,58,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['error'],['error']
Availability,/// Handles an initiation or an invication error. An initiation error typically; /// has a \c DiagnosticError payload that describes why initiation failed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h:43,error,error,43,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,2,['error'],['error']
Availability,"/// Harden a return instruction.; ///; /// Returns implicitly perform a load which we need to harden. Without hardening; /// this load, an attacker my speculatively write over the return address to; /// steer speculation of the return to an attacker controlled address. This is; /// called Spectre v1.1 or Bounds Check Bypass Store (BCBS) and is described in; /// this paper:; /// https://people.csail.mit.edu/vlk/spectre11.pdf; ///; /// We can harden this by introducing an LFENCE that will delay any load of the; /// return address until prior instructions have retired (and thus are not being; /// speculated), or we can harden the address used by the implicit load: the; /// stack pointer.; ///; /// If we are not using an LFENCE, hardening the stack pointer has an additional; /// benefit: it allows us to pass the predicate state accumulated in this; /// function back to the caller. In the absence of a BCBS attack on the return,; /// the caller will typically be resumed and speculatively executed due to the; /// Return Stack Buffer (RSB) prediction which is very accurate and has a high; /// priority. It is possible that some code from the caller will be executed; /// speculatively even during a BCBS-attacked return until the steering takes; /// effect. Whenever this happens, the caller can recover the (poisoned); /// predicate state from the stack pointer and continue to harden loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1305,recover,recover,1305,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['recover'],['recover']
Availability,/// Has a bit set for every virtual register for which it was determined; /// that it is alive across blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:89,alive,alive,89,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['alive'],['alive']
Availability,/// Has a bit set for tile virtual register for which it was determined; /// that it is alive across blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:88,alive,alive,88,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,1,['alive'],['alive']
Availability,/// Have we suppressed an error during deduction?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:26,error,error,26,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['error'],['error']
Availability,"/// Helper class for folding sign/zero extensions.; /// In particular, this class is used for the following combines:; /// add | add_vl -> vwadd(u) | vwadd(u)_w; /// sub | sub_vl -> vwsub(u) | vwsub(u)_w; /// mul | mul_vl -> vwmul(u) | vwmul_su; ///; /// An object of this class represents an operand of the operation we want to; /// combine.; /// E.g., when trying to combine `mul_vl a, b`, we will have one instance of; /// NodeExtensionHelper for `a` and one for `b`.; ///; /// This class abstracts away how the extension is materialized and; /// how its Mask, VL, number of users affect the combines.; ///; /// In particular:; /// - VWADD_W is conceptually == add(op0, sext(op1)); /// - VWADDU_W == add(op0, zext(op1)); /// - VWSUB_W == sub(op0, sext(op1)); /// - VWSUBU_W == sub(op0, zext(op1)); ///; /// And VMV_V_X_VL, depending on the value, is conceptually equivalent to; /// zext|sext(smaller_value).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:558,Mask,Mask,558,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// Helper class for managing resource cleanups.; ///; /// \tparam T Type of resource been reclaimed.; /// \tparam Cleanup Class that defines how the resource is reclaimed.; ///; /// Clients create objects of this type in the code executed in a crash recovery; /// context to ensure that the resource will be reclaimed even in the case of; /// crash. For example:; ///; /// \code; /// void actual_work(void *) {; /// ...; /// std::unique_ptr<Resource> R(new Resource());; /// CrashRecoveryContextCleanupRegistrar D(R.get());; /// ...; /// }; ///; /// void foo() {; /// CrashRecoveryContext CRC;; ///; /// if (!CRC.RunSafely(actual_work, 0)) {; /// ... a crash was detected, report error to user ...; /// }; /// \endcode; ///; /// If the code of `actual_work` in the example above does not crash, the; /// destructor of CrashRecoveryContextCleanupRegistrar removes cleanup code from; /// the current CrashRecoveryContext and the resource is reclaimed by the; /// destructor of std::unique_ptr. If crash happens, destructors are not called; /// and the resource is reclaimed by cleanup object registered in the recovery; /// context by the constructor of CrashRecoveryContextCleanupRegistrar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:251,recover,recovery,251,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,3,"['error', 'recover']","['error', 'recovery']"
Availability,"/// Helper class that determines the relationship between incoming values of a; /// phi in the control flow graph to determine where an incoming value can; /// simply be taken as a scalar lane mask as-is, and where it needs to be; /// merged with another, previously defined lane mask.; ///; /// The approach is as follows:; /// - Determine all basic blocks which, starting from the incoming blocks,; /// a wave may reach before entering the def block (the block containing the; /// phi).; /// - If an incoming block has no predecessors in this set, we can take the; /// incoming value as a scalar lane mask as-is.; /// -- A special case of this is when the def block has a self-loop.; /// - Otherwise, the incoming value needs to be merged with a previously; /// defined lane mask.; /// - If there is a path into the set of reachable blocks that does _not_ go; /// through an incoming block where we can take the scalar lane mask as-is,; /// we need to invent an available value for the SSAUpdater. Choices are; /// 0 and undef, with differing consequences for how to merge values etc.; ///; /// TODO: We could use region analysis to quickly skip over SESE regions during; /// the traversal.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp:193,mask,mask,193,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,6,"['avail', 'mask']","['available', 'mask']"
Availability,/// Helper class that handles loading Metadatas and keeping them available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:65,avail,available,65,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,1,['avail'],['available']
Availability,/// Helper class to downgrade -g metadata to -gline-tables-only metadata.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:20,down,downgrade,20,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,1,['down'],['downgrade']
Availability,/// Helper class to manage error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h:27,error,error,27,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,1,['error'],['error']
Availability,"/// Helper class to promote a scalar operation to a vector one.; /// This class is used to move downward extractelement transition.; /// E.g.,; /// a = vector_op <2 x i32>; /// b = extractelement <2 x i32> a, i32 0; /// c = scalar_op b; /// store c; ///; /// =>; /// a = vector_op <2 x i32>; /// c = vector_op a (equivalent to scalar_op on the related lane); /// * d = extractelement <2 x i32> c, i32 0; /// * store d; /// Assuming both extractelement and store can be combine, we get rid of the; /// transition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:96,down,downward,96,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['down'],['downward']
Availability,"/// Helper class used to represent the cost for mapping an instruction.; /// When mapping an instruction, we may introduce some repairing code.; /// In most cases, the repairing code is local to the instruction,; /// thus, we can omit the basic block frequency from the cost.; /// However, some alternatives may produce non-local cost, e.g., when; /// repairing a phi, and thus we then need to scale the local cost; /// to the non-local cost. This class does this for us.; /// \note: We could simply always scale the cost. The problem is that; /// there are higher chances that we saturate the cost easier and end; /// up having the same cost for actually different alternatives.; /// Another option would be to use APInt everywhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:128,repair,repairing,128,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,3,['repair'],['repairing']
Availability,"/// Helper for Errors used as out-parameters.; ///; /// This helper is for use with the Error-as-out-parameter idiom, where an error; /// is passed to a function or method by reference, rather than being returned.; /// In such cases it is helpful to set the checked bit on entry to the function; /// so that the error can be written to (unchecked Errors abort on assignment); /// and clear the checked bit on exit so that clients cannot accidentally forget; /// to check the result. This helper performs these actions automatically using; /// RAII:; ///; /// @code{.cpp}; /// Result foo(Error &Err) {; /// ErrorAsOutParameter ErrAsOutParam(&Err); // 'Checked' flag set; /// // <body of foo>; /// // <- 'Checked' flag auto-cleared when ErrAsOutParam is destructed.; /// }; /// @endcode; ///; /// ErrorAsOutParameter takes an Error* rather than Error& so that it can be; /// used with optional Errors (Error pointers that are allowed to be null). If; /// ErrorAsOutParameter took an Error reference, an instance would have to be; /// created inside every condition that verified that Error was non-null. By; /// taking an Error pointer we can just create one instance at the top of the; /// function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:15,Error,Errors,15,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,16,"['Error', 'error']","['Error', 'Error-as-out-parameter', 'ErrorAsOutParameter', 'Errors', 'error']"
Availability,/// Helper for Expected<T>s used as out-parameters.; ///; /// See ErrorAsOutParameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:66,Error,ErrorAsOutParameter,66,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['ErrorAsOutParameter']
Availability,/// Helper for check-and-exit error handling.; ///; /// For tool use only. NOT FOR USE IN LIBRARY CODE.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:30,error,error,30,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['error'],['error']
Availability,"/// Helper for converting an ECError to a std::error_code.; ///; /// This method requires that Err be Error() or an ECError, otherwise it; /// will trigger a call to abort().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:102,Error,Error,102,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['Error']
Availability,"/// Helper for converting an Error to a bool.; ///; /// This method returns true if Err is in an error state, or false if it is; /// in a success state. Puts Err in a checked state in both cases (unlike; /// Error::operator bool(), which only does this for success states).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:29,Error,Error,29,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,3,"['Error', 'error']","['Error', 'error']"
Availability,/// Helper for converting an std::error_code to a Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:50,Error,Error,50,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['Error']
Availability,/// Helper for getRegForVale. This function is called when the value; /// isn't already available in a register and must be materialized with new; /// instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:88,avail,available,88,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,1,['avail'],['available']
Availability,/// Helper for getRegForValue. This function is called when the value isn't; /// already available in a register and must be materialized with new; /// instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:89,avail,available,89,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,1,['avail'],['available']
Availability,"/// Helper for mapping JSON objects onto protocol structs.; ///; /// Example:; /// \code; /// bool fromJSON(const Value &E, MyStruct &R, Path P) {; /// ObjectMapper O(E, P);; /// // When returning false, error details were already reported.; /// return O && O.map(""mandatory_field"", R.MandatoryField) &&; /// O.mapOptional(""optional_field"", R.OptionalField);; /// }; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:204,error,error,204,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['error'],['error']
Availability,"/// Helper for testing applicability of, and applying, handlers for; /// ErrorInfo types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:73,Error,ErrorInfo,73,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['ErrorInfo']
Availability,"/// Helper function for \c LoadFromCompilerInvocation() and; /// \c LoadFromCommandLine(), which loads an AST from a compiler invocation.; ///; /// \param PrecompilePreambleAfterNParses After how many parses the preamble; /// of this translation unit should be precompiled, to improve the performance; /// of reparsing. Set to zero to disable preambles.; ///; /// \param VFS - A llvm::vfs::FileSystem to be used for all file accesses.; /// Note that preamble is saved to a temporary directory on a RealFileSystem,; /// so in order for it to be loaded correctly, VFS should have access to; /// it(i.e., be an overlay over RealFileSystem).; ///; /// \returns \c true if a catastrophic failure occurred (which means that the; /// \c ASTUnit itself is invalid), or \c false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:683,failure,failure,683,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['failure'],['failure']
Availability,/// Helper function for matchINS.; ///; /// \returns a value when \p M is an ins mask for \p NumInputElements.; ///; /// First element of the returned pair is true when the produced; /// G_INSERT_VECTOR_ELT destination should be the LHS of the G_SHUFFLE_VECTOR.; ///; /// Second element is the destination lane for the G_INSERT_VECTOR_ELT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp:81,mask,mask,81,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,1,['mask'],['mask']
Availability,"/// Helper function for repairIntervalsInRange(), walks backwards and; /// creates/modifies live segments in \p LR to match the operands found.; /// Only full operands or operands with subregisters matching \p LaneMask; /// are considered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:24,repair,repairIntervalsInRange,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,1,['repair'],['repairIntervalsInRange']
Availability,/// Helper function that returns true if the shuffle mask should be; /// commuted to improve canonicalization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:53,mask,mask,53,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,/// Helper function to flush deleted BasicBlocks if all available; /// trees are up-to-date.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:56,avail,available,56,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,1,['avail'],['available']
Availability,/// Helper function to get the Mask and VL from \p Root.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:31,Mask,Mask,31,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Mask'],['Mask']
Availability,/// Helper function to let the emitter report skip reason error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp:58,error,error,58,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,1,['error'],['error']
Availability,/// Helper function to return the IdentifierInfo structure of a Token; /// or generate a diagnostic if none available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:108,avail,available,108,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['avail'],['available']
Availability,/// Helper function to test whether a shuffle mask could be; /// simplified by widening the elements being shuffled.; ///; /// Appends the mask for wider elements in WidenedMask if valid. Otherwise; /// leaves it in an unspecified state.; ///; /// NOTE: This must handle normal vector shuffle masks and *target* vector; /// shuffle masks. The latter have the special property of a '-2' representing; /// a zero-ed lane of a vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,4,['mask'],"['mask', 'masks']"
Availability,"/// Helper macro for checking the result of an 'Expected<T>'; ///; /// @code{.cpp}; /// // function to be tested; /// Expected<int> myDivide(int A, int B);; ///; /// TEST(myDivideTests, GoodAndBad) {; /// // test good case; /// // if you only care about success or failure:; /// EXPECT_THAT_EXPECTED(myDivide(10, 5), Succeeded());; /// // if you also care about the value:; /// EXPECT_THAT_EXPECTED(myDivide(10, 5), HasValue(2));; ///; /// // test the error case; /// EXPECT_THAT_EXPECTED(myDivide(10, 0), Failed());; /// // also check the error message; /// EXPECT_THAT_EXPECTED(myDivide(10, 0),; /// FailedWithMessage(""B must not be zero!""));; /// }; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Testing/Support/Error.h:265,failure,failure,265,interpreter/llvm-project/llvm/include/llvm/Testing/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Testing/Support/Error.h,3,"['error', 'failure']","['error', 'failure']"
Availability,"/// Helper method for getting the code model, returning Default if; /// CM does not have a value. The tiny and kernel models will produce; /// an error, so targets that support them or require more complex codemodel; /// selection logic should implement and call their own getEffectiveCodeModel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h:146,error,error,146,interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,1,['error'],['error']
Availability,/// Helper method to turn variable array types into constant array; /// types in certain situations which would otherwise be errors (for; /// GCC compatibility).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:125,error,errors,125,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['error'],['errors']
Availability,/// Helper struct that represents how a value is partially mapped; /// into a register.; /// The StartIdx and Length represent what region of the orginal; /// value this partial mapping covers.; /// This can be represented as a Mask of contiguous bit starting; /// at StartIdx bit and spanning Length bits.; /// StartIdx is the number of bits from the less significant bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:228,Mask,Mask,228,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['Mask'],['Mask']
Availability,/// Helper to diagnose a failure,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h:25,failure,failure,25,interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,1,['failure'],['failure']
Availability,/// Helper to get compute inlane shuffle mask for a complete shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,/// Helper to recursively walk up the import stack and print each layer; /// on the way back down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:93,down,down,93,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,1,['down'],['down']
Availability,/// Helper to recursively walk up the include stack and print each layer; /// on the way back down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:94,down,down,94,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,1,['down'],['down']
Availability,/// Helper to reset target features for a new arch string. It; /// also records the new arch string that is expanded by RISCVISAInfo; /// and reports error for invalid arch string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:150,error,error,150,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,1,['error'],['error']
Availability,"/// Helper type for serializing Errors.; ///; /// llvm::Errors are move-only, and not inspectable except by consuming them.; /// This makes them unsuitable for direct serialization via; /// SPSSerializationTraits, which needs to inspect values twice (once to; /// determine the amount of space to reserve, and then again to serialize).; ///; /// The SPSSerializableError type is a helper that can be; /// constructed from an llvm::Error, but inspected more than once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h:32,Error,Errors,32,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h,3,['Error'],"['Error', 'Errors']"
Availability,"/// High level function that adds all passes necessary to go from llvm IR; /// representation to the MI representation.; /// Adds IR based lowering and target specific optimization passes and finally; /// the core instruction selection passes.; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:269,error,error,269,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,1,['error'],['error']
Availability,/// High-level routine to lower various 256-bit x86 vector shuffles.; ///; /// This routine either breaks down the specific type of a 256-bit x86 vector; /// shuffle or splits it into two 128-bit shuffles and fuses the results back; /// together based on the available instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:106,down,down,106,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['avail', 'down']","['available', 'down']"
Availability,/// High-level routine to lower various 512-bit x86 vector shuffles.; ///; /// This routine either breaks down the specific type of a 512-bit x86 vector; /// shuffle or splits it into two 256-bit shuffles and fuses the results back; /// together based on the available instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:106,down,down,106,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['avail', 'down']","['available', 'down']"
Availability,"/// Hijack all messages with given level and topics while this object is alive.; /// \param[in] level Minimum level to hijack. Higher levels also get captured.; /// \param[in] topics Topics to hijack. Use `|` to combine different topics, and cast to `RooFit::MsgTopic` if; /// necessary. \param[in] objectName Only hijack messages from an object with the given name. Defaults to any object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHelpers.cxx:73,alive,alive,73,roofit/roofitcore/src/RooHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHelpers.cxx,1,['alive'],['alive']
Availability,"/// Hijacks all messages with given level and topic (and optionally object name) while alive.; /// Use this like an ostringstream afterwards. The messages can e.g. be retrieved using `str()`.; /// Useful for unit tests / debugging.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooHelpers.h:87,alive,alive,87,roofit/roofitcore/inc/RooHelpers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooHelpers.h,1,['alive'],['alive']
Availability,"/// Hoist back-copies to the complement interval. It tries to hoist all; /// the back-copies to one BB if it is beneficial, or else simply remove; /// redundant backcopies dominated by others.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:151,redundant,redundant,151,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,1,['redundant'],['redundant']
Availability,"/// Holds all the casts that participate in the update chain of the induction; /// variables, and that have been proven to be redundant (possibly under a; /// runtime guard). These casts can be ignored when creating the vectorized; /// loop body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:126,redundant,redundant,126,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['redundant'],['redundant']
Availability,/// How the value is broken down between the different register banks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:28,down,down,28,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['down'],['down']
Availability,/// How to handle import errors that occur when import of a child declaration; /// of a DeclContext fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:25,error,errors,25,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['error'],['errors']
Availability,/// ID for the next recorded type. Starts at -1 and counts down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:59,down,down,59,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,1,['down'],['down']
Availability,"/// IMPORTANT NOTE: the order of the types in this PointerUnion are; /// important! The DeclarationName class has bidirectional conversion; /// to/from Selector through an opaque pointer (void *) which corresponds; /// to this PointerIntPair. The discriminator bit from the PointerUnion; /// corresponds to the high bit in the MultiArg enumerator. So while this; /// PointerIntPair only has two bits for the integer (and we mask off the; /// high bit in `MultiArg` when it is used), that discrimator bit is; /// still necessary for the opaque conversion. The discriminator bit; /// from the PointerUnion and the two integer bits from the; /// PointerIntPair are also exposed via the DeclarationName::StoredNameKind; /// enumeration; see the comments in DeclarationName.h for more details.; /// Do not reorder or add any arguments to this template; /// without thoroughly understanding how tightly coupled these classes are.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:424,mask,mask,424,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['mask'],['mask']
Availability,"/// IRMaterializationUnit is a convenient base class for MaterializationUnits; /// wrapping LLVM IR. Represents materialization responsibility for all symbols; /// in the given module. If symbols are overridden by other definitions, then; /// their linkage is changed to available-externally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h:271,avail,available-externally,271,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h,1,['avail'],['available-externally']
Availability,/// Identifies SelectInsts in a loop that has reduction with predication masks; /// and/or predicated tail folding,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:73,mask,masks,73,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['mask'],['masks']
Availability,"/// If EmbedBitcode is set, save a copy of the llvm IR as data in the; /// __LLVM,__bitcode section (.llvmbc on non-MacOS).; /// If available, pass the serialized module via the Buf parameter. If not,; /// pass an empty (default-initialized) MemoryBufferRef, and the serialization; /// will be handled by this API. The same behavior happens if the provided Buf; /// is not bitcode (i.e. if it's invalid data or even textual LLVM assembly).; /// If EmbedCmdline is set, the command line is also exported in; /// the corresponding section (__LLVM,_cmdline / .llvmcmd) - even if CmdArgs; /// were empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:132,avail,available,132,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,1,['avail'],['available']
Availability,"/// If Expr is a valid integer constant, get the value of the integer; /// expression and return success or failure. May output an error.; ///; /// Negative argument is implicitly converted to unsigned, unless; /// \p StrictlyUnsigned is true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:108,failure,failure,108,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// If O is not an object, this mapper is invalid and an error is reported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:57,error,error,57,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['error'],['error']
Availability,"/// If V is a shuffle of values that ONLY returns elements from either LHS or; /// RHS, return the shuffle mask and true. Otherwise, return false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:107,mask,mask,107,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"/// If \p CachedOnly is true, no pass is created, just existing results are; /// used. Also available per request.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:92,avail,available,92,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['avail'],['available']
Availability,"/// If \p R is a region with a VPBranchOnMaskRecipe in the entry block, return; /// the mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:88,mask,mask,88,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['mask'],['mask']
Availability,"/// If \p V is a bitwise not, returns the inverted operand. Otherwise returns; /// an empty SDValue. Only bits set in \p Mask are required to be inverted,; /// other bits may be arbitrary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:121,Mask,Mask,121,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['Mask'],['Mask']
Availability,"/// If ``FormatComplete`` is false, ``Line`` records a one-based; /// original line number at which a syntax error might have occurred. This is; /// based on a best-effort analysis and could be imprecise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:109,error,error,109,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['error'],['error']
Availability,"/// If a (v)select has a condition value that is a sign-bit test, try to smear; /// the condition operand sign-bit across the value width and use it as a mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:154,mask,mask,154,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"/// If a demangler is available, demangle all symbol names.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:22,avail,available,22,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,1,['avail'],['available']
Availability,/// If a module file is marked with errors treat it as out-of-date so the; /// caller can rebuild it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:36,error,errors,36,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['error'],['errors']
Availability,"/// If all arguments of the intrinsic are unary shuffles with the same mask,; /// try to shuffle after the intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:71,mask,mask,71,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['mask'],['mask']
Availability,"/// If all non-negative \p Mask elements are the same value, return that value.; /// If all elements are negative (undefined) or \p Mask contains different; /// non-negative values, return -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:27,Mask,Mask,27,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,2,['Mask'],['Mask']
Availability,"/// If available, this hold the ProfileData array used to correlate raw; /// instrumentation data to their functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h:7,avail,available,7,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,1,['avail'],['available']
Availability,"/// If conveniently available, return the content of the given Section.; ///; /// When the section is available in the local address space, in relocated; /// (loaded) form, e.g. because it was relocated by a JIT for execution, this; /// function should provide the contents of said section in `Data`. If the; /// loaded section is not available, or the cost of retrieving it would be; /// prohibitive, this function should return false. In that case, relocations; /// will be read from the local (unrelocated) object file and applied on the; /// fly. Note that this method is used purely for optimzation purposes in the; /// common case of JITting in the local address space, so returning false; /// should always be correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h:20,avail,available,20,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h,3,['avail'],['available']
Availability,"/// If exactly one element of the mask is set for a non-extending masked load,; /// it is a scalar load and vector insert.; /// Note: It is expected that the degenerate cases of an all-zeros or all-ones; /// mask have already been optimized in IR, so we don't bother with those here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['mask'],"['mask', 'masked']"
Availability,"/// If exactly one element of the mask is set for a non-truncating masked store,; /// it is a vector extract and scalar store.; /// Note: It is expected that the degenerate cases of an all-zeros or all-ones; /// mask have already been optimized in IR, so we don't bother with those here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['mask'],"['mask', 'masked']"
Availability,"/// If flag is true the processing of unrecognized RooCmdArgs; /// is not considered an error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCmdConfig.h:88,error,error,88,roofit/roofitcore/inc/RooCmdConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCmdConfig.h,1,['error'],['error']
Availability,"/// If intrinsic information is available, return it. If not, return null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h:32,avail,available,32,interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,1,['avail'],['available']
Availability,"/// If it is possible to read \a Size bytes at offset \a Offset, returns \b; /// true. Otherwise, returns \b false. If \a E is not nullptr, also sets the; /// error object to indicate an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:159,error,error,159,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,"/// If it is profitable, duplicate TailBB's contents in each; /// of its predecessors.; /// \p IsSimple result of isSimpleBB; /// \p TailBB Block to be duplicated.; /// \p ForcedLayoutPred When non-null, use this block as the layout predecessor; /// instead of the previous block in MF's order.; /// \p TDBBs A vector to keep track of all blocks tail-duplicated; /// into.; /// \p Copies A vector of copy instructions inserted. Used later to; /// walk all the inserted copies and remove redundant ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:487,redundant,redundant,487,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['redundant'],['redundant']
Availability,"/// If no error occurs, this returns a valid Remark object.; /// If an error of type EndOfFileError occurs, it is safe to recover from it; /// by stopping the parsing.; /// If any other error occurs, it should be propagated to the user.; /// The pointer should never be null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/RemarkParser.h:10,error,error,10,interpreter/llvm-project/llvm/include/llvm/Remarks/RemarkParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/RemarkParser.h,4,"['error', 'recover']","['error', 'recover']"
Availability,"/// If non-null, the updated current \c SCC being processed.; ///; /// This is set when a graph refinement takes place and the ""current"" point; /// in the graph moves ""down"" or earlier in the post-order walk. This will; /// often cause the ""current"" SCC to be a newly created SCC object and the; /// old one to be added to the above worklist. When that happens, this; /// pointer is non-null and can be used to continue processing the ""top"" of; /// the post-order walk.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:168,down,down,168,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['down'],['down']
Availability,"/// If profile information is available, this is the number of times the; /// corresponding code was executed in a profile instrumentation run.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:30,avail,available,30,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,2,['avail'],['available']
Availability,"/// If set to ``TCS_Wrapped`` will insert trailing commas in container; /// literals (arrays and objects) that wrap across multiple lines.; /// It is currently only available for JavaScript; /// and disabled by default ``TCS_None``.; /// ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``; /// as inserting the comma disables bin-packing.; /// \code; /// TSC_Wrapped:; /// const someArray = [; /// aaaaaaaaaaaaaaaaaaaaaaaaaa,; /// aaaaaaaaaaaaaaaaaaaaaaaaaa,; /// aaaaaaaaaaaaaaaaaaaaaaaaaa,; /// // ^ inserted; /// ]; /// \endcode; /// \version 11",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:165,avail,available,165,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['avail'],['available']
Availability,"/// If set to true, Create() will create an RInvalidField on error instead of throwing an exception.; /// This is used in RFieldBase::Check() to identify unsupported sub fields.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:61,error,error,61,tree/ntuple/v7/src/RField.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx,1,['error'],['error']
Availability,"/// If the cached entry represents an error, promotes it into `ErrorOr`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:38,error,error,38,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,2,"['Error', 'error']","['ErrorOr', 'error']"
Availability,"/// If the current Expr is a pointer, this will try to statically; /// determine the number of bytes available where the pointer is pointing.; /// Returns true if all of the above holds and we were able to figure out the; /// size, false otherwise.; ///; /// \param Type - How to evaluate the size of the Expr, as defined by the; /// ""type"" parameter of __builtin_object_size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:101,avail,available,101,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['avail'],['available']
Availability,"/// If the current token is of the given kind, consume it and return false.; /// Otherwise report an error and return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:101,error,error,101,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['error'],['error']
Availability,"/// If the given MemoryBuffer holds a bitcode image, return a Module; /// for it which does lazy deserialization of function bodies. Otherwise,; /// attempt to parse it as LLVM Assembly and return a fully populated; /// Module. The ShouldLazyLoadMetadata flag is passed down to the bitcode; /// reader to optionally enable lazy metadata loading. This takes ownership; /// of \p Buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IRReader/IRReader.h:270,down,down,270,interpreter/llvm-project/llvm/include/llvm/IRReader/IRReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IRReader/IRReader.h,1,['down'],['down']
Availability,"/// If the given expression contains an unexpanded parameter; /// pack, diagnose the error.; ///; /// \param E The expression that is being checked for unexpanded; /// parameter packs.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:85,error,error,85,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['error'],['error']
Availability,"/// If the given file holds a bitcode image, return a Module; /// for it which does lazy deserialization of function bodies. Otherwise,; /// attempt to parse it as LLVM Assembly and return a fully populated; /// Module. The ShouldLazyLoadMetadata flag is passed down to the bitcode; /// reader to optionally enable lazy metadata loading.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IRReader/IRReader.h:262,down,down,262,interpreter/llvm-project/llvm/include/llvm/IRReader/IRReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IRReader/IRReader.h,1,['down'],['down']
Availability,"/// If the given name contains an unexpanded parameter pack,; /// diagnose the error.; ///; /// \param NameInfo The name (with source location information) that; /// is being checked for unexpanded parameter packs.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:79,error,error,79,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['error'],['error']
Availability,"/// If the given nested-name-specifier contains an unexpanded; /// parameter pack, diagnose the error.; ///; /// \param SS The nested-name-specifier that is being checked for; /// unexpanded parameter packs.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:96,error,error,96,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['error'],['error']
Availability,"/// If the given requirees-expression contains an unexpanded reference to one; /// of its own parameter packs, diagnose the error.; ///; /// \param RE The requiress-expression that is being checked for unexpanded; /// parameter packs.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:124,error,error,124,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['error'],['error']
Availability,"/// If the given template argument contains an unexpanded parameter; /// pack, diagnose the error.; ///; /// \param Arg The template argument that is being checked for unexpanded; /// parameter packs.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:92,error,error,92,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['error'],['error']
Availability,"/// If the given template name contains an unexpanded parameter pack,; /// diagnose the error.; ///; /// \param Loc The location of the template name.; ///; /// \param Template The template name that is being checked for unexpanded; /// parameter packs.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:88,error,error,88,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['error'],['error']
Availability,"/// If the given type contains an unexpanded parameter pack,; /// diagnose the error.; ///; /// \param Loc The source location where a diagnostc should be emitted.; ///; /// \param T The type that is being checked for unexpanded parameter; /// packs.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:79,error,error,79,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['error'],['error']
Availability,"/// If the high bits of an 'and' operand are known zero, try setting the; /// high bits of an 'and' constant operand to produce a smaller encoding by; /// creating a small, sign-extended negative immediate rather than a large; /// positive one. This reverses a transform in SimplifyDemandedBits that; /// shrinks mask constants by clearing bits. There is also a possibility that; /// the 'and' mask can be made -1, so the 'and' itself is unnecessary. In that; /// case, just replace the 'and'. Return 'true' if the node is replaced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:313,mask,mask,313,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,"/// If the information for the register banks is available, return it.; /// Otherwise return nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:49,avail,available,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['avail'],['available']
Availability,"/// If the input path is a .dSYM bundle (as created by the dsymutil tool),; /// return the paths to the object files found in the bundle, otherwise return; /// an empty vector. If the path appears to be a .dSYM bundle but no objects; /// were found or there was a filesystem error, then return an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/MachO.h:275,error,error,275,interpreter/llvm-project/llvm/include/llvm/Object/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/MachO.h,2,['error'],['error']
Availability,"/// If the input shuffle mask results in a vector that is undefined in all upper; /// or lower half elements and that mask accesses only 2 halves of the; /// shuffle's operands, return true. A mask of half the width with mask indexes; /// adjusted to access the extracted halves of the original shuffle operands is; /// returned in HalfMask. HalfIdx1 and HalfIdx2 return whether the upper or; /// lower half of each input operand is accessed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,4,['mask'],['mask']
Availability,"/// If the operation was successful, returns a const reference to the inner type.; /// If there was an error, Inspect() instead throws an exception.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:103,error,error,103,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,1,['error'],['error']
Availability,"/// If the operation was successful, returns the inner type by value.; ///; /// For move-only types, Unwrap can only be called once, as it yields ownership of; /// the inner value to the caller using std::move, potentially leaving the; /// RResult in an unspecified state.; ///; /// If there was an error, Unwrap() instead throws an exception.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:299,error,error,299,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,1,['error'],['error']
Availability,"/// If the result of a load is shifted/masked/truncated to an effectively; /// narrower type, try to transform the load to a narrower type and/or; /// use an extending load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,mask,masked,39,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masked']
Availability,"/// If the result of the predicate LHS `Pred` RHS is loop invariant with; /// respect to L at given Context during at least first MaxIter iterations,; /// return a LoopInvariantPredicate with LHS and RHS being invariants,; /// available at L's entry. Otherwise, return std::nullopt. The predicate; /// should be the loop's exit condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:227,avail,available,227,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['avail'],['available']
Availability,"/// If the result of the predicate LHS `Pred` RHS is loop invariant with; /// respect to L, return a LoopInvariantPredicate with LHS and RHS being; /// invariants, available at L's entry. Otherwise, return std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:164,avail,available,164,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['avail'],['available']
Availability,"/// If the return symbol is assumed to be error, remove the allocated info; /// from consideration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:42,error,error,42,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['error'],['error']
Availability,"/// If the shuffle mask is taking exactly one element from the first vector; /// operand and passing through all other elements from the second vector; /// operand, return the index of the mask element that is choosing an element; /// from the first operand. Otherwise, return -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,"/// If the specified pointer points to an object that we control, try to modify; /// the object's alignment to PrefAlign. Returns a minimum known alignment of; /// the value after the operation, which may be lower than PrefAlign.; ///; /// Increating value alignment isn't often possible though. If alignment is; /// important, a more reliable approach is to simply align all global variables; /// and allocation instructions to their preferred alignment from the beginning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:335,reliab,reliable,335,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,1,['reliab'],['reliable']
Availability,"/// If the target has a standard stack protection check function that; /// performs validation and error handling, returns the function. Otherwise,; /// returns nullptr. Must be previously inserted by insertSSPDeclarations.; /// Should be used only when getIRStackGuard returns nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:99,error,error,99,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['error'],['error']
Availability,"/// If there are an extraordinary number of formulae to choose from, use some; /// rough heuristics to prune down the number of formulae. This keeps the main; /// solver from taking an extraordinary amount of time in some worst-case; /// scenarios.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:109,down,down,109,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['down'],['down']
Availability,"/// If there are any field references that refer to fields that have been; /// filled in, we can propagate the values now.; ///; /// This is a final resolve: any error messages, e.g. due to undefined !cast; /// references, are generated now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h:162,error,error,162,interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h,1,['error'],['error']
Availability,"/// If there are multiple different constraints that we could pick for this; /// operand (e.g. ""imr"") try to pick the 'best' one.; /// This is somewhat tricky: constraints (TargetLowering::ConstraintType) fall; /// into seven classes:; /// Register -> one specific register; /// RegisterClass -> a group of regs; /// Memory -> memory; /// Address -> a symbolic memory reference; /// Immediate -> immediate values; /// Other -> magic values (such as ""Flag Output Operands""); /// Unknown -> something we don't recognize yet and can't handle; /// Ideally, we would pick the most specific constraint possible: if we have; /// something that fits into a register, we would pick it. The problem here; /// is that if we have something that could either be in a register or in; /// memory that use of the register could cause selection of *other*; /// operands to fail: they might only succeed if we pick memory. Because of; /// this the heuristic we use is:; ///; /// 1) If there is an 'other' constraint, and if the operand is valid for; /// that constraint, use it. This makes us take advantage of 'i'; /// constraints when available.; /// 2) Otherwise, pick the most general constraint present. This prefers; /// 'm' over 'r', for example.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:1119,avail,available,1119,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avail'],['available']
Availability,"/// If this argument has nofpclass attribute, return the mask representing; /// disallowed floating-point values. Otherwise, fcNone is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Argument.h:57,mask,mask,57,interpreter/llvm-project/llvm/include/llvm/IR/Argument.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Argument.h,1,['mask'],['mask']
Availability,"/// If this change could not be created successfully, e.g. because of; /// conflicts among replacements, use this to set an error description.; /// Thereby, places that cannot be fixed automatically can be gathered when; /// applying changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:124,error,error,124,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,1,['error'],['error']
Availability,"/// If this is a zero/all-bits result that is bitwise-anded with a low bits; /// mask. (Mask == 1 for the x86 lowering of a SETCC + ZEXT), replace the 'and'; /// with a shift-right to eliminate loading the vector constant mask value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:81,mask,mask,81,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// If this is true, assume it's preferably to leave memory intrinsic calls; /// for replacement with a library call later. Otherwise this depends on; /// TargetLoweringInfo availability of the corresponding function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:174,avail,availability,174,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,1,['avail'],['availability']
Availability,"/// If this value is an out-of-band error then this returns the error message,; /// otherwise returns nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:36,error,error,36,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,2,['error'],['error']
Availability,"/// If true, only pass the diagnostic to the actual diagnostic consumer; /// if it is an error or a fixit was applied as part of the diagnostic.; /// It basically silences warnings without accompanying fixits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h:89,error,error,89,interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,1,['error'],['error']
Availability,"/// If we are extracting a subvector of a vector select and the select condition; /// is composed of concatenated vectors, try to narrow the select width. This; /// is a common pattern for AVX1 integer code because 256-bit selects may be; /// legal, but there is almost no integer math/logic available for 256-bit.; /// This function should only be called with legal types (otherwise, the calls; /// to get simple value types will assert).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:292,avail,available,292,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"/// If we have a Top Down pointer in the S_CanRelease state, make sure that; /// there are no CFG hazards by checking the states of various bottom up; /// pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:21,Down,Down,21,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['Down'],['Down']
Availability,"/// If we have a masked merge, in the canonical form of:; /// (assuming that A only has one use.); /// | A | |B|; /// ((x ^ y) & M) ^ y; /// | D |; /// * If M is inverted:; /// | D |; /// ((x ^ y) & ~M) ^ y; /// We can canonicalize by swapping the final xor operand; /// to eliminate the 'not' of the mask.; /// ((x ^ y) & M) ^ x; /// * If M is a constant, and D has one use, we transform to 'and' / 'or' ops; /// because that shortens the dependency chain and improves analysis:; /// (x & M) | (y & ~M)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:17,mask,masked,17,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,2,['mask'],"['mask', 'masked']"
Availability,"/// If we have a top down pointer in the S_Use state, make sure that there are; /// no CFG hazards by checking the states of various bottom up pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:21,down,down,21,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['down'],['down']
Availability,"/// If we have a unary shuffle of a shuffle, see if it can be folded away; /// completely. This has the potential to lose undef knowledge because the first; /// shuffle may not have an undef mask element where the second one does. So; /// only call this after doing simplifications based on demanded elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:191,mask,mask,191,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"/// Ignore import errors of the children.; /// If true, the context can be imported successfully if a child; /// of it failed to import. Otherwise the import errors of the child nodes; /// are accumulated (joined) into the import error object of the parent.; /// (Import of a parent can fail in other ways.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:18,error,errors,18,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,3,['error'],"['error', 'errors']"
Availability,"/// Implement default handling for Error.; /// Print ""error: "" to stderr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h:35,Error,Error,35,interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h,2,"['Error', 'error']","['Error', 'error']"
Availability,/// Implement property-find by ignoring it. We rely on properties being; /// serialized and deserialized in a reliable order instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/AbstractBasicReader.h:110,reliab,reliable,110,interpreter/llvm-project/clang/include/clang/AST/AbstractBasicReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/AbstractBasicReader.h,2,['reliab'],['reliable']
Availability,"/// Implementation of format_provider<T> for ranges.; ///; /// This will print an arbitrary range as a delimited sequence of items.; ///; /// The options string of a range type has the grammar:; ///; /// range_style ::= [separator] [element_style]; /// separator ::= ""$"" delimeted_expr; /// element_style ::= ""@"" delimeted_expr; /// delimeted_expr ::= ""["" expr ""]"" | ""("" expr "")"" | ""<"" expr "">""; /// expr ::= <any string not containing delimeter>; ///; /// where the separator expression is the string to insert between consecutive; /// items in the range and the argument expression is the Style specification to; /// be used when formatting the underlying type. The default separator if; /// unspecified is ' ' (space). The syntax of the argument expression follows; /// whatever grammar is dictated by the format provider or format adapter used; /// to format the value type.; ///; /// Note that attempting to format an `iterator_range<T>` where no format; /// provider can be found for T will result in a compile error.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatProviders.h:1017,error,error,1017,interpreter/llvm-project/llvm/include/llvm/Support/FormatProviders.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatProviders.h,1,['error'],['error']
Availability,"/// Implementation of getLg() and friends.; ///; /// Returns the rounded lg of \c Digits*2^Scale and an int specifying whether; /// this was rounded up (1), down (-1), or exact (0).; ///; /// Returns \c INT32_MIN when \c Digits is zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ScaledNumber.h:157,down,down,157,interpreter/llvm-project/llvm/include/llvm/Support/ScaledNumber.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ScaledNumber.h,1,['down'],['down']
Availability,/// Implementation of the checkPointerEscape callbacks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:26,checkPoint,checkPointerEscape,26,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['checkPoint'],['checkPointerEscape']
Availability,"/// Implementation of the target library information.; ///; /// This class constructs tables that hold the target library information and; /// make it available. However, it is somewhat expensive to compute and only; /// depends on the triple. So users typically interact with the \c; /// TargetLibraryInfo wrapper below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:151,avail,available,151,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,1,['avail'],['available']
Availability,"/// Implementations of this method should discard the given symbol; /// from the source (e.g. if the source is an LLVM IR Module and the; /// symbol is a function, delete the function body or mark it available; /// externally).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:200,avail,available,200,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['avail'],['available']
Availability,"/// Import the given APValue from the ""from"" context into; /// the ""to"" context.; ///; /// \return the equivalent APValue in the ""to"" context or the import; /// error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:161,error,error,161,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given C++ constructor initializer from the ""from""; /// context into the ""to"" context.; ///; /// \returns The equivalent initializer in the ""to"" context, or the import; /// error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:187,error,error,187,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given CXXBaseSpecifier from the ""from"" context into; /// the ""to"" context.; ///; /// \returns The equivalent CXXBaseSpecifier in the source manager of the; /// ""to"" context, or the import error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:203,error,error,203,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given Objective-C selector from the ""from""; /// context into the ""to"" context.; ///; /// \returns The equivalent selector in the ""to"" context, or the import; /// error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:177,error,error,177,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given attribute from the ""from"" context into the; /// ""to"" context.; ///; /// \returns The equivalent attribute in the ""to"" context, or the import; /// error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:167,error,error,167,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given declaration context from the ""from""; /// AST context into the ""to"" AST context.; ///; /// \returns the equivalent declaration context in the ""to""; /// context, or error value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:184,error,error,184,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given declaration from the ""from"" context into the; /// ""to"" context.; ///; /// \returns The equivalent declaration in the ""to"" context, or the import; /// error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:171,error,error,171,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given declaration name from the ""from""; /// context into the ""to"" context.; ///; /// \returns The equivalent declaration name in the ""to"" context, or the; /// import error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:181,error,error,181,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given expression from the ""from"" context into the; /// ""to"" context.; ///; /// \returns The equivalent expression in the ""to"" context, or the import; /// error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:169,error,error,169,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given file ID from the ""from"" context into the; /// ""to"" context.; ///; /// \returns The equivalent file ID in the source manager of the ""to""; /// context, or the import error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:185,error,error,185,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given nested-name-specifier from the ""from""; /// context into the ""to"" context.; ///; /// \returns The equivalent nested-name-specifier in the ""to""; /// context, or the import error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:191,error,error,191,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given nested-name-specifier-loc from the ""from""; /// context into the ""to"" context.; ///; /// \returns The equivalent nested-name-specifier-loc in the ""to""; /// context, or the import error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:199,error,error,199,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given qualified type from the ""from"" context into the ""to""; /// context. A null type is imported as a null type (no error).; ///; /// \returns The equivalent type in the ""to"" context, or the import error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:131,error,error,131,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,2,['error'],['error']
Availability,"/// Import the given source location from the ""from"" context into; /// the ""to"" context.; ///; /// \returns The equivalent source location in the ""to"" context, or the; /// import error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:179,error,error,179,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given source range from the ""from"" context into; /// the ""to"" context.; ///; /// \returns The equivalent source range in the ""to"" context, or the import; /// error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:173,error,error,173,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given statement from the ""from"" context into the; /// ""to"" context.; ///; /// \returns The equivalent statement in the ""to"" context, or the import; /// error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:167,error,error,167,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given template name from the ""from"" context into the; /// ""to"" context, or the import error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:101,error,error,101,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given type from the ""from"" context into the ""to""; /// context.; ///; /// \returns The equivalent type in the ""to"" context, or the import error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:152,error,error,152,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Import the given type source information from the; /// ""from"" context into the ""to"" context.; ///; /// \returns The equivalent type source information in the ""to""; /// context, or the import error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:195,error,error,195,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// In ARC, check whether the conventional meanings of the two methods; /// match. If they don't, it's a hard error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:110,error,error,110,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['error'],['error']
Availability,"/// In ARC, whether this function retains its return value. This; /// is not always reliable for call sites.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h:84,reliab,reliable,84,interpreter/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h,1,['reliab'],['reliable']
Availability,"/// In Microsoft mode, if we are inside a template class whose parent class has; /// dependent base classes, and we can't resolve an unqualified identifier, then; /// assume the identifier is a member of a dependent base class. We can only; /// recover successfully in static methods, instance methods, and other contexts; /// where 'this' is available. This doesn't precisely match MSVC's; /// instantiation model, but it's close enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:245,recover,recover,245,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,"['avail', 'recover']","['available', 'recover']"
Availability,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:631,recover,recover,631,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['recover'],['recover']
Availability,"/// In most cases this function returns the ABI alignment for a given type,; /// except for illegal vector types where the alignment exceeds that of the; /// stack. In such cases we attempt to break the vector down to a legal type; /// and return the ABI alignment for that instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:210,down,down,210,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['down'],['down']
Availability,"/// In the v2 ABI, ivar offset variables use the type encoding in their name; /// to trigger linker failures if the types don't match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:100,failure,failures,100,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['failure'],['failures']
Availability,"/// Incoming for lane maks phi as machine instruction, incoming register \p Reg; /// and incoming block \p Block are taken from machine instruction.; /// \p UpdatedReg (if valid) is \p Reg lane mask merged with another lane mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.h:194,mask,mask,194,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.h,2,['mask'],['mask']
Availability,"/// Increase warning or error count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx:24,error,error,24,core/foundation/inc/ROOT/RLogger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx,1,['error'],['error']
Availability,"/// Increment the fallible iterator.; ///; /// If the underlying 'inc' operation fails, this will set the Error value; /// and update this iterator value to point to end-of-range.; ///; /// The Error value is marked as needing checking, regardless of whether the; /// 'inc' operation succeeds or fails.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:106,Error,Error,106,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,2,['Error'],['Error']
Availability,"/// Increments memory address \p Addr according to the type of the value; /// \p DataVT that should be stored. If the data is stored in compressed; /// form, the memory address should be incremented according to the number of; /// the stored elements. This number is equal to the number of '1's bits; /// in the \p Mask.; /// \p DataVT is a vector type. \p Mask is a vector value.; /// \p DataVT and \p Mask have the same number of vector elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:315,Mask,Mask,315,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,3,['Mask'],['Mask']
Availability,/// Increments the first non-end iterator.; ///; /// It is an error to call this with all iterators at the end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:62,error,error,62,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['error'],['error']
Availability,/// Index into list with lane mask sequences. The sequence contains a lanemask; /// for every register unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h:30,mask,mask,30,interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,1,['mask'],['mask']
Availability,/// Index of the next available label.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.h:22,avail,available,22,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.h,1,['avail'],['available']
Availability,/// Index of the operand that will be repaired.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:38,repair,repaired,38,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,1,['repair'],['repaired']
Availability,"/// Indicate if the file has an ""indeterminate file position indicator"".; /// This can be set at a failing read or write or seek operation.; /// If it is set no more read or write is allowed.; /// This value is not dependent on the stream error flags:; /// The error flag may be cleared with `clearerr` but the file position; /// remains still indeterminate.; /// This value applies to all error states in ErrorState except FEOF.; /// An EOF+indeterminate state is the same as EOF state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:239,error,error,239,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,4,"['Error', 'error']","['ErrorState', 'error']"
Availability,/// Indicate that a rewritten value is available in the specified block with the; /// specified value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:39,avail,available,39,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,1,['avail'],['available']
Availability,/// Indicate that a rewritten value is available in the specified block with; /// the specified value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:39,avail,available,39,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,1,['avail'],['available']
Availability,/// Indicate that a rewritten value is available in the specified block; /// with the specified value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:39,avail,available,39,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,1,['avail'],['available']
Availability,/// Indicate that the specified indexed masked load does or does not work with; /// the specified type and indicate what to do about it.; ///; /// NOTE: All indexed mode masked loads are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:40,mask,masked,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['mask'],['masked']
Availability,/// Indicate that the specified indexed masked store does or does not work; /// with the specified type and indicate what to do about it.; ///; /// NOTE: All indexed mode masked stores are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:40,mask,masked,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['mask'],['masked']
Availability,"/// Indicates an error while processing a match after the match was found; /// for an expected or excluded pattern. The error is specified by \c Note,; /// to which it should be appropriate to prepend ""error: "" later. The full; /// match itself should be recorded in a preceding diagnostic of a different; /// \c MatchFound match type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h:17,error,error,17,interpreter/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h,3,['error'],['error']
Availability,/// Indicates if gaps between members of the group need to be masked out or if; /// unusued gaps can be loaded speculatively.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:62,mask,masked,62,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['mask'],['masked']
Availability,/// Indicates if the interleave group is in a conditional block and requires a; /// mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:84,mask,mask,84,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['mask'],['mask']
Availability,/// Indicates that an unrecoverable error has occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:36,error,error,36,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['error']
Availability,/// Indicates that the AST contained compiler errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h:46,error,errors,46,interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,1,['error'],['errors']
Availability,"/// Indicates whether we have already parsed the VST, used for error checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:63,error,error,63,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['error'],['error']
Availability,"/// InferAllTypes - Infer/propagate as many types throughout the expression; /// patterns as possible. Return true if all types are inferred, false; /// otherwise. Flags an error if a type contradiction is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:173,error,error,173,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['error'],['error']
Availability,"/// InferPossibleTypes - As we emit the pattern, we end up generating type; /// checks and applying them to the 'PatWithNoTypes' tree. As we do this, we; /// want to propagate implied types as far throughout the tree as possible so; /// that we avoid doing redundant type checks. This does the type propagation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:257,redundant,redundant,257,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,1,['redundant'],['redundant']
Availability,/// Inform the semantic consumer that Sema is no longer available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h:56,avail,available,56,interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,5,['avail'],['available']
Availability,/// Information stored for each error found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h:32,error,error,32,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,1,['error'],['error']
Availability,/// Information that allows to avoid completing redundant enumerators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:48,redundant,redundant,48,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['redundant'],['redundant']
Availability,/// Initialize available analysis information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:15,avail,available,15,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,1,['avail'],['available']
Availability,/// Initialize the builder. Return true if any initialization errors are; /// found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:62,error,errors,62,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['error'],['errors']
Availability,/// Initialize the machine function to the state that's described in the MIR; /// file.; ///; /// Return true if error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:113,error,error,113,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,1,['error'],['error']
Availability,/// Initialize the map with the default set of target features for the; /// CPU this should include all legal feature strings on the target.; ///; /// \return False on error (invalid features).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:168,error,error,168,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['error'],['error']
Availability,/// Initialize the set of available library functions based on the specified; /// target triple. This should be carefully written so that a missing target; /// triple gets a sane set of defaults.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:26,avail,available,26,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['avail'],['available']
Availability,"/// InitializeAllAsmParsers - The main program should call this function if it; /// wants all asm parsers that LLVM is configured to support, to make them; /// available via the TargetRegistry.; ///; /// It is legal for a client to make multiple calls to this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h:160,avail,available,160,interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,1,['avail'],['available']
Availability,"/// InitializeAllAsmPrinters - The main program should call this function if; /// it wants all asm printers that LLVM is configured to support, to make them; /// available via the TargetRegistry.; ///; /// It is legal for a client to make multiple calls to this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h:162,avail,available,162,interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,1,['avail'],['available']
Availability,"/// InitializeAllDisassemblers - The main program should call this function if; /// it wants all disassemblers that LLVM is configured to support, to make; /// them available via the TargetRegistry.; ///; /// It is legal for a client to make multiple calls to this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h:165,avail,available,165,interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,1,['avail'],['available']
Availability,"/// InitializeAllTargetInfos - The main program should call this function if; /// it wants access to all available targets that LLVM is configured to; /// support, to make them available via the TargetRegistry.; ///; /// It is legal for a client to make multiple calls to this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h:105,avail,available,105,interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,2,['avail'],['available']
Availability,"/// InitializeAllTargetMCs - The main program should call this function if it; /// wants access to all available target MC that LLVM is configured to; /// support, to make them available via the TargetRegistry.; ///; /// It is legal for a client to make multiple calls to this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h:103,avail,available,103,interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,2,['avail'],['available']
Availability,"/// InitializeAllTargets - The main program should call this function if it; /// wants access to all available target machines that LLVM is configured to; /// support, to make them available via the TargetRegistry.; ///; /// It is legal for a client to make multiple calls to this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h:101,avail,available,101,interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TargetSelect.h,2,['avail'],['available']
Availability,/// Initializes common fields of an instantiated method; /// declaration (New) from the corresponding fields of its template; /// (Tmpl).; ///; /// \returns true if there was an error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:178,error,error,178,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['error'],['error']
Availability,/// Initializes the common fields of an instantiation function; /// declaration (New) from the corresponding fields of its template (Tmpl).; ///; /// \returns true if there was an error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:180,error,error,180,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['error'],['error']
Availability,/// Inline C functions and blocks when their definitions are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h:61,avail,available,61,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,1,['avail'],['available']
Availability,"/// Inline callees(C, C++, ObjC) when their definitions are available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h:60,avail,available,60,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,1,['avail'],['available']
Availability,/// Inline: the bit mask to test the address against.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['mask'],['mask']
Availability,"/// Input: background sources correlated error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h:41,error,error,41,hist/unfold/inc/TUnfoldSys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h,1,['error'],['error']
Availability,"/// Input: correlated errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h:22,error,errors,22,hist/unfold/inc/TUnfoldSys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h,1,['error'],['errors']
Availability,"/// Input: error on fY prior to bgr subtraction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h:11,error,error,11,hist/unfold/inc/TUnfoldSys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h,1,['error'],['error']
Availability,"/// Input: error on tau",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h:11,error,error,11,hist/unfold/inc/TUnfoldSys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h,1,['error'],['error']
Availability,"/// Input: normalized errors from input matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h:22,error,errors,22,hist/unfold/inc/TUnfoldSys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h,1,['error'],['errors']
Availability,"/// Input: uncorr error squared from bgr sources",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h:18,error,error,18,hist/unfold/inc/TUnfoldSys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h,1,['error'],['error']
Availability,"/// Insert MI into the instruction list before I, possibly inside a bundle.; ///; /// If the insertion point is inside a bundle, MI will be added to the bundle,; /// otherwise MI will not be added to any bundle. That means this function; /// alone can't be used to prepend or append instructions to bundles. See; /// MIBundleBuilder::insert() for a more reliable way of doing that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:354,reliab,reliable,354,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['reliab'],['reliable']
Availability,"/// Insert a select instruction into MBB before I that will copy TrueReg to; /// DstReg when Cond is true, and FalseReg to DstReg when Cond is false.; ///; /// This function can only be called after canInsertSelect() returned true.; /// The condition in Cond comes from analyzeBranch, and it can be assumed; /// that the same flags or registers required by Cond are available at the; /// insertion point.; ///; /// @param MBB Block where select instruction should be inserted.; /// @param I Insertion point.; /// @param DL Source location for debugging.; /// @param DstReg Virtual register to be defined by select instruction.; /// @param Cond Condition as computed by analyzeBranch.; /// @param TrueReg Virtual register to copy when Cond is true.; /// @param FalseReg Virtual register to copy when Cons is false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:366,avail,available,366,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['avail'],['available']
Availability,"/// Insert one bit to mask vector, like v16i1 or v8i1.; /// AVX-512 feature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"/// Insert repairing code for \p Reg as specified by \p ValMapping.; /// The repairing placement is specified by \p RepairPt.; /// \p NewVRegs contains all the registers required to remap \p Reg.; /// In other words, the number of registers in NewVRegs must be equal; /// to ValMapping.BreakDown.size().; ///; /// The transformation could be sketched as:; /// \code; /// ... = op Reg; /// \endcode; /// Becomes; /// \code; /// <NewRegs> = COPY or extract Reg; /// ... = op Reg; /// \endcode; ///; /// and; /// \code; /// Reg = op ...; /// \endcode; /// Becomes; /// \code; /// Reg = op ...; /// Reg = COPY or build_sequence <NewRegs>; /// \endcode; ///; /// \pre NewVRegs.size() == ValMapping.BreakDown.size(); ///; /// \note The caller is supposed to do the rewriting of op if need be.; /// I.e., Reg = op ... => <NewRegs> = NewOp ...; ///; /// \return True if the repairing worked, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:11,repair,repairing,11,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,4,"['Repair', 'repair']","['RepairPt', 'repairing']"
Availability,"/// Insert the specified binary operator, doing a small amount of work to; /// avoid inserting an obviously redundant operation, and hoisting to an; /// outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:108,redundant,redundant,108,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,1,['redundant'],['redundant']
Availability,/// Insert truncates and extends for any truncated recipe. Redundant casts; /// will be folded later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:59,Redundant,Redundant,59,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,1,['Redundant'],['Redundant']
Availability,"/// InsertBinop - Insert the specified binary operator, doing a small amount; /// of work to avoid inserting an obviously redundant operation, and hoisting; /// to an outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:122,redundant,redundant,122,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['redundant'],['redundant']
Availability,/// Insertion point for the repair code.; /// The repairing code needs to happen just before these points.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:28,repair,repair,28,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,2,['repair'],"['repair', 'repairing']"
Availability,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// check mechanism. When the image is loaded, the loader puts the appropriate; /// guard check function pointer in the __guard_check_icall_fptr global; /// symbol. This checks that the target address is a valid address-taken; /// function. The address of the target function is passed to the guard check; /// function in an architecture-specific register (e.g. ECX on 32-bit X86,; /// X15 on Aarch64, and R0 on ARM). The guard check function has no return; /// value (if the target is invalid, the guard check funtion will raise an; /// error).; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load void (i8*)*, void (i8*)** @__guard_check_icall_fptr; /// %2 = bitcast i32 ()* %0 to i8*; /// call cfguard_checkcc void %1(i8* %2); /// %3 = call i32 %0(); /// \endcode; ///; /// For example, the following X86 assembly code:; /// \code; /// movl $_target_func, %eax; /// calll *%eax; /// \endcode; ///; /// is transformed to:; /// \code; /// 	movl	$_target_func, %ecx; /// 	calll	*___guard_check_icall_fptr; /// 	calll	*%ecx; /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:618,error,error,618,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,1,['error'],['error']
Availability,"/// Inst which is a def of an original reg and whose defs are already all; /// dead after remat is saved in DeadRemats. The deletion of such inst is; /// postponed till all the allocations are done, so its remat expr is; /// always available for the remat of all the siblings of the original reg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:232,avail,available,232,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,2,['avail'],['available']
Availability,"/// Install a ROOT diagnostic handler to analyse diagnostics.; /// It will record all diagnostics during its lifetime, and analyse them at destruction.; /// Required and/or optional diagnostics need to be predefined with expected location and message.; /// Unexpected or missing diagnostics will lead to gtest failures.; ///; /// Example:; /// ```c++; /// CheckDiagsRAII diagRAII{CheckDiagsRAII::EDK_Error, ""TFile::TFile"", ""<Expected message>""};; /// diagRAII.optionalDiag(kInfo, ""TFile::TFile"", ""Message that is issued only sometimes"");; /// <test code>; ///; /// ```",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/inc/ROOT/TestSupport.hxx:310,failure,failures,310,core/testsupport/inc/ROOT/TestSupport.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/inc/ROOT/TestSupport.hxx,1,['failure'],['failures']
Availability,"/// Installs a new bad alloc error handler that should be used whenever a; /// bad alloc error, e.g. failing malloc/calloc, is encountered by LLVM.; ///; /// The user can install a bad alloc handler, in order to define the behavior; /// in case of failing allocations, e.g. throwing an exception. Note that this; /// handler must not trigger any additional allocations itself.; ///; /// If no error handler is installed the default is to print the error message; /// to stderr, and call exit(1). If an error handler is installed then it is; /// the handler's responsibility to log the message, it will no longer be; /// printed to stderr. If the error handler returns, then exit(1) will be; /// called.; ///; ///; /// \param user_data - An argument which will be passed to the installed error; /// handler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:29,error,error,29,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,7,['error'],['error']
Availability,/// Instantiate or parse a C++ default argument expression as necessary.; /// Return true on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:93,error,error,93,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// Instantiate the declaration of a class template partial; /// specialization.; ///; /// \param ClassTemplate the (instantiated) class template that is partially; // specialized by the instantiation of \p PartialSpec.; ///; /// \param PartialSpec the (uninstantiated) class template partial; /// specialization that we are instantiating.; ///; /// \returns The instantiated partial specialization, if successful; otherwise,; /// NULL to indicate an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:451,error,error,451,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['error'],['error']
Availability,"/// Instantiate the declaration of a variable template partial; /// specialization.; ///; /// \param VarTemplate the (instantiated) variable template that is partially; /// specialized by the instantiation of \p PartialSpec.; ///; /// \param PartialSpec the (uninstantiated) variable template partial; /// specialization that we are instantiating.; ///; /// \returns The instantiated partial specialization, if successful; otherwise,; /// NULL to indicate an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:459,error,error,459,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['error'],['error']
Availability,"/// Instantiate the definition of a class from a given pattern.; ///; /// \param PointOfInstantiation The point of instantiation within the; /// source code.; ///; /// \param Instantiation is the declaration whose definition is being; /// instantiated. This will be either a class template specialization; /// or a member class of a class template specialization.; ///; /// \param Pattern is the pattern from which the instantiation; /// occurs. This will be either the declaration of a class template or; /// the declaration of a member class of a class template.; ///; /// \param TemplateArgs The template arguments to be substituted into; /// the pattern.; ///; /// \param TSK the kind of implicit or explicit instantiation to perform.; ///; /// \param Complain whether to complain if the class cannot be instantiated due; /// to the lack of a definition.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:889,error,error,889,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['error'],['error']
Availability,"/// Instantiate the definition of a field from the given pattern.; ///; /// \param PointOfInstantiation The point of instantiation within the; /// source code.; /// \param Instantiation is the declaration whose definition is being; /// instantiated. This will be a class of a class temploid; /// specialization, or a local enumeration within a function temploid; /// specialization.; /// \param Pattern The templated declaration from which the instantiation; /// occurs.; /// \param TemplateArgs The template arguments to be substituted into; /// the pattern.; ///; /// \return \c true if an error occurred, \c false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:592,error,error,592,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['error'],['error']
Availability,"/// Instantiate the definition of an enum from a given pattern.; ///; /// \param PointOfInstantiation The point of instantiation within the; /// source code.; /// \param Instantiation is the declaration whose definition is being; /// instantiated. This will be a member enumeration of a class; /// temploid specialization, or a local enumeration within a; /// function temploid specialization.; /// \param Pattern The templated declaration from which the instantiation; /// occurs.; /// \param TemplateArgs The template arguments to be substituted into; /// the pattern.; /// \param TSK The kind of implicit or explicit instantiation to perform.; ///; /// \return \c true if an error occurred, \c false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:678,error,error,678,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['error'],['error']
Availability,/// Instantiates a nested template parameter list in the current; /// instantiation context.; ///; /// \param L The parameter list to instantiate; ///; /// \returns NULL if there was an error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:186,error,error,186,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['error'],['error']
Availability,/// Instantiation or recovery rebuild of a for-range statement. Don't; /// attempt any typo-correction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:21,recover,recovery,21,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['recover'],['recovery']
Availability,/// IntMask - This is the unshifted mask for valid bits of the int type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h:36,mask,mask,36,interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h,1,['mask'],['mask']
Availability,"/// InterProceduralData aims to be a storage of whatever data should be passed; /// between analyses of different functions.; ///; /// At the moment, its primary goal is to make the information gathered during; /// the analysis of the blocks available during the analysis of the enclosing; /// function. This is important due to the fact that blocks are analyzed before; /// the enclosed function is even parsed fully, so it is not viable to access; /// anything in the outer scope while analyzing the block. On the other hand,; /// re-building CFG for blocks and re-analyzing them when we do have all the; /// information (i.e. during the analysis of the enclosing function) seems to be; /// ill-designed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:242,avail,available,242,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['avail'],['available']
Availability,"/// Interesting information about a specific parameter that can't simply; /// be reflected in parameter's type. This is only used by FunctionProtoType; /// but is in FunctionType to make this class available during the; /// specification of the bases of FunctionProtoType.; ///; /// It makes sense to model language features this way when there's some; /// sort of parameter-specific override (such as an attribute) that; /// affects how the function is called. For example, the ARC ns_consumed; /// attribute changes whether a parameter is passed at +0 (the default); /// or +1 (ns_consumed). This must be reflected in the function type,; /// but isn't really a change to the parameter type.; ///; /// One serious disadvantage of modelling language features this way is; /// that they generally do not work with language features that attempt; /// to destructure types. For example, template argument deduction will; /// not be able to match a parameter declared as; /// T (*)(U); /// against an argument of type; /// void (*)(__attribute__((ns_consumed)) id); /// because the substitution of T=void, U=id into the former will; /// not produce the latter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:198,avail,available,198,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['avail'],['available']
Availability,"/// Intersects the BVH with a single ray, using the given function to intersect the contents; /// of a leaf. The algorithm starts at the node index `start` and uses the given stack object.; /// When `IsAnyHit` is true, the function stops at the first intersection (useful for shadow; /// rays), otherwise it finds the closest intersection. When `IsRobust` is true, a slower but; /// numerically robust ray-box test is used, otherwise a fast, but less precise test is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/bvh.h:395,robust,robust,395,geom/geom/inc/bvh/v2/bvh.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/bvh.h,1,['robust'],['robust']
Availability,/// InvalidDecl - This indicates a semantic error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:44,error,error,44,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['error'],['error']
Availability,"/// Invalidate groups that require a scalar epilogue (due to gaps). This can; /// happen when optimizing for size forbids a scalar epilogue, and the gap; /// cannot be filtered by masking the load/store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:180,mask,masking,180,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['mask'],['masking']
Availability,"/// Invalidates cached information about the specified pointer, because it; /// may be too conservative in memdep.; ///; /// This is an optional call that can be used when the client detects an; /// equivalence between the pointer and some other value and replaces the; /// other value with ptr. This can make Ptr available in more places that; /// cached info does not necessarily keep.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:314,avail,available,314,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['avail'],['available']
Availability,/// Is a SFINAE diagnostic available?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:27,avail,available,27,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['avail'],['available']
Availability,/// Is domain available?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:14,avail,available,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,1,['avail'],['available']
Availability,/// Is objc_unsafeClaimAutoreleasedReturnValue available?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h:47,avail,available,47,interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,1,['avail'],['available']
Availability,"/// Is status available?; ///; /// @param path Input path.; /// @param result Set to true if status() != status_error.; /// @returns errc::success if result has been successfully set, otherwise a; /// platform-specific error_code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:14,avail,available,14,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['avail'],['available']
Availability,/// Is status available?; ///; /// @param s Input file status.; /// @returns True if status() != status_error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:14,avail,available,14,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['avail'],['available']
Availability,/// Is the last error level diagnostic immediate. This is used to determined; /// whether the next info diagnostic should be immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:16,error,error,16,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// Is this an implicit map type?; /// We have to capture 'IsMapTypeImplicit' from the parser for more; /// informative error messages. It helps distinguish map(r) from; /// map(tofrom: r), which is important to print more helpful error; /// messages for some target directives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:120,error,error,120,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,2,['error'],['error']
Availability,/// Is64Bit implies that x86_64 instructions are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h:49,avail,available,49,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.h,1,['avail'],['available']
Availability,"/// IsInvalidUnlessNestedName - This method is used for error recovery; /// purposes to determine whether the specified identifier is only valid as; /// a nested name specifier, for example a namespace name. It is; /// conservatively correct to always return false from this method.; ///; /// The arguments are the same as those passed to ActOnCXXNestedNameSpecifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:56,error,error,56,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"/// IsStartOfConflictMarker - If the specified pointer is the start of a version; /// control conflict marker like '<<<<<<<', recognize it as such, emit an error; /// and recover nicely. This returns true if it is a conflict marker and false; /// if not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:156,error,error,156,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"/// IsValueInFlagEnum - Determine if a value is allowed as part of a flag; /// enum. If AllowMask is true, then we also allow the complement of a valid; /// value, to be used as a mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:180,mask,mask,180,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['mask'],['mask']
Availability,/// Issue any -Wunguarded-availability warnings in \c FD,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:26,avail,availability,26,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avail'],['availability']
Availability,"/// Issue the message to the client.; ///; /// This actually returns an instance of DiagnosticBuilder which emits the; /// diagnostics (through @c ProcessDiag) when it is destroyed.; ///; /// \param DiagID A member of the @c diag::kind enum.; /// \param Loc Represents the source location associated with the diagnostic,; /// which can be an invalid location if no position information is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:389,avail,available,389,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['avail'],['available']
Availability,"/// Itanium C++ ABI p3.3.5:; ///; /// After constructing a global (or local static) object, that will require; /// destruction on exit, a termination function is registered as follows:; ///; /// extern ""C"" int __cxa_atexit ( void (*f)(void *), void *p, void *d );; ///; /// This registration, e.g. __cxa_atexit(f,p,d), is intended to cause the; /// call f(p) when DSO d is unloaded, before all such termination calls; /// registered before this one. It returns zero if registration is; /// successful, nonzero on failure.; // This pass will look for calls to __cxa_atexit where the function is trivial; // and remove them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:513,failure,failure,513,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['failure'],['failure']
Availability,"/// Iterate through the sections, searching for the relocation section; /// associated with the unwind index table section specified by; /// IndexSectionIndex. Iterate the associated section searching for the; /// relocation associated with the index table entry specified by; /// IndexTableOffset. The symbol is the section symbol for the exception; /// handling table. Use this symbol to recover the actual exception handling; /// table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h:390,recover,recover,390,interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h,1,['recover'],['recover']
Availability,/// Iterates over all BBs from BlockMap and recalculates AvailableIn/Out for; /// each of them until it converges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:57,Avail,AvailableIn,57,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['Avail'],['AvailableIn']
Availability,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:459,down,down,459,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['down'],['down']
Availability,"/// Jit code in the interpreter with TInterpreter::Calc, throw in case of errors.; /// The optional `context` parameter, if present, is mentioned in the error message.; /// The pointer returned by the call to TInterpreter::Calc is returned in case of success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:74,error,errors,74,tree/dataframe/inc/ROOT/RDF/Utils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx,2,['error'],"['error', 'errors']"
Availability,/// Just dump dot graph to a user-provided path and title.; /// This doesn't open the dot viewer program and; /// helps visualization when outside debugging session.; /// FileName expects absolute path. If provided; /// without any path separators then the file; /// will be created in the current directory.; /// Error will be emitted if the path is insane.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:314,Error,Error,314,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,2,['Error'],['Error']
Availability,/// Keep track of available resources.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:18,avail,available,18,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,2,['avail'],['available']
Availability,/// Keep track of merged data and reported errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:43,error,errors,43,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['error'],['errors']
Availability,/// Kind of repairing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:12,repair,repairing,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,1,['repair'],['repairing']
Availability,/// LIS - Used for accessing register mask interference maps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:38,mask,mask,38,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,1,['mask'],['mask']
Availability,"/// Last active error handler function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/inc/ROOT/TestSupport.hxx:16,error,error,16,core/testsupport/inc/ROOT/TestSupport.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/inc/ROOT/TestSupport.hxx,1,['error'],['error']
Availability,"/// Last chance recoloring has a high compile time cost especially for; /// targets with a lot of registers.; /// This method is used to decide whether or not \p VirtReg should; /// go through this expensive heuristic.; /// When this target hook is hit, by returning false, there is a high; /// chance that the register allocation will fail altogether (usually with; /// ""ran out of registers"").; /// That said, this error usually points to another problem in the; /// optimization pipeline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:417,error,error,417,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['error'],['error']
Availability,/// Last error message that can come from the YAML parser diagnostics.; /// We need this for catching errors in the constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.h:9,error,error,9,interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.h,2,['error'],"['error', 'errors']"
Availability,"/// Legacy interface.; /// \p PassName is the name of the pass emitting this diagnostic.; /// \p Fn is the function where the diagnostic is being emitted. \p Loc is; /// the location information to use in the diagnostic. If line table; /// information is available, the diagnostic will include the source code; /// location. \p Msg is the message to show. Note that this class does not; /// copy this message, so this reference must be valid for the whole life time; /// of the diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:255,avail,available,255,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['avail'],['available']
Availability,"/// Legalize a SETCC or VP_SETCC with given LHS and RHS and condition code CC; /// on the current target. A VP_SETCC will additionally be given a Mask; /// and/or EVL not equal to SDValue().; ///; /// If the SETCC has been legalized using AND / OR, then the legalized node; /// will be stored in LHS. RHS and CC will be set to SDValue(). NeedInvert; /// will be set to false. This will also hold if the VP_SETCC has been; /// legalized using VP_AND / VP_OR.; ///; /// If the SETCC / VP_SETCC has been legalized by using; /// getSetCCSwappedOperands(), then the values of LHS and RHS will be; /// swapped, CC will be set to the new condition, and NeedInvert will be set; /// to false.; ///; /// If the SETCC / VP_SETCC has been legalized using the inverse condcode,; /// then LHS and RHS will be unchanged, CC will set to the inverted condcode,; /// and NeedInvert will be set to true. The caller must invert the result of; /// the SETCC with SelectionDAG::getLogicalNOT() or take equivalent action to; /// swap the effect of a true/false result.; ///; /// \returns true if the SETCC / VP_SETCC has been legalized, false if it; /// hasn't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:146,Mask,Mask,146,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Mask'],['Mask']
Availability,"/// Legalize instruction \p MI where operands in \p OpIndices must be SGPRs. If; /// any of the required SGPR operands are VGPRs, perform a waterfall loop to; /// execute the instruction for each unique combination of values in all lanes; /// in the wave. The block will be split such that rest of the instructions are; /// moved to a new block.; ///; /// Essentially performs this loop:; //; /// Save Execution Mask; /// For (Lane : Wavefront) {; /// Enable Lane, Disable all other lanes; /// SGPR = read SGPR value for current lane from VGPR; /// VGPRResult[Lane] = use_op SGPR; /// }; /// Restore Execution Mask; ///; /// There is additional complexity to try for compare values to identify the; /// unique values used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:412,Mask,Mask,412,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,2,['Mask'],['Mask']
Availability,"/// Lex a header-name token (including one formed from header-name-tokens if; /// \p AllowConcatenation is \c true).; ///; /// \param FilenameTok Filled in with the next token. On success, this will; /// be either a header_name token. On failure, it will be whatever other; /// token was found instead.; /// \param AllowMacroExpansion If \c true, allow the header name to be formed; /// by macro expansion (concatenating tokens as necessary if the first; /// token is a '<').; /// \return \c true if we reached EOD or EOF while looking for a > token in; /// a concatenated header name and diagnosed it. \c false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:238,failure,failure,238,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['failure'],['failure']
Availability,"/// Lex a string literal, which may be the concatenation of multiple; /// string literals and may even come from macro expansion.; /// \returns true on success, false if a error diagnostic has been generated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:172,error,error,172,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['error'],['error']
Availability,/// Lex the provided source and emit the directive tokens.; ///; /// \returns True on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:86,error,error,86,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,1,['error'],['error']
Availability,"/// Lightweight error class with error context and mandatory checking.; ///; /// Instances of this class wrap a ErrorInfoBase pointer. Failure states; /// are represented by setting the pointer to a ErrorInfoBase subclass; /// instance containing information describing the failure. Success is; /// represented by a null pointer value.; ///; /// Instances of Error also contains a 'Checked' flag, which must be set; /// before the destructor is called, otherwise the destructor will trigger a; /// runtime error. This enforces at runtime the requirement that all Error; /// instances be checked or returned to the caller.; ///; /// There are two ways to set the checked flag, depending on what state the; /// Error instance is in. For Error instances indicating success, it; /// is sufficient to invoke the boolean conversion operator. E.g.:; ///; /// @code{.cpp}; /// Error foo(<...>);; ///; /// if (auto E = foo(<...>)); /// return E; // <- Return E if it is in the error state.; /// // We have verified that E was in the success state. It can now be safely; /// // destroyed.; /// @endcode; ///; /// A success value *can not* be dropped. For example, just calling 'foo(<...>)'; /// without testing the return value will raise a runtime error, even if foo; /// returns success.; ///; /// For Error instances representing failure, you must use either the; /// handleErrors or handleAllErrors function with a typed handler. E.g.:; ///; /// @code{.cpp}; /// class MyErrorInfo : public ErrorInfo<MyErrorInfo> {; /// // Custom error info.; /// };; ///; /// Error foo(<...>) { return make_error<MyErrorInfo>(...); }; ///; /// auto E = foo(<...>); // <- foo returns failure with MyErrorInfo.; /// auto NewE =; /// handleErrors(std::move(E),; /// [](const MyErrorInfo &M) {; /// // Deal with the error.; /// },; /// [](std::unique_ptr<OtherError> M) -> Error {; /// if (canHandle(*M)) {; /// // handle error.; /// return Error::success();; /// }; /// // Couldn't handle this error instance. Pass it up the s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:16,error,error,16,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,13,"['Error', 'Failure', 'error', 'failure']","['Error', 'ErrorInfoBase', 'Failure', 'error', 'failure']"
Availability,"/// Like getLazyBitcodeModule, except that the module takes ownership of; /// the memory buffer if successful. If successful, this moves Buffer. On; /// error, this *does not* move Buffer. If IsImporting is true, this module is; /// being parsed for ThinLTO importing into another module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:153,error,error,153,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,1,['error'],['error']
Availability,/// Link \p Src into the composite.; ///; /// Passing OverrideSymbols as true will have symbols from Src; /// shadow those in the Dest.; ///; /// Passing InternalizeCallback will have the linker call the function with; /// the new module and a list of global value names to be internalized by the; /// callback.; ///; /// Returns true on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Linker/Linker.h:338,error,error,338,interpreter/llvm-project/llvm/include/llvm/Linker/Linker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Linker/Linker.h,1,['error'],['error']
Availability,"/// List of instructions to remove. While lowering, we are not replacing all; /// users of a lowered instruction, if shape information is available and; /// those need to be removed after we finished lowering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:138,avail,available,138,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['avail'],['available']
Availability,/// List of instructions which this instruction could be control dependent; /// on. Allowing such nodes to be scheduled below this one could introduce; /// a runtime fault which didn't exist in the original program.; /// ex: this is a load or udiv following a readonly call which inf loops,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:166,fault,fault,166,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['fault'],['fault']
Availability,"/// List of operands for the shuffle vector instruction. It hold at max 2; /// operands, if the 3rd is going to be added, the first 2 are combined into; /// shuffle with \p CommonMask mask, the first operand sets to be the; /// resulting shuffle and the second operand sets to be the newly added; /// operand. The \p CommonMask is transformed in the proper way after that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:184,mask,mask,184,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,/// ListScheduleTopDown - The main loop of list scheduling for top-down; /// schedulers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:67,down,down,67,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['down'],['down']
Availability,"/// Little struct that can pack a float into the unused bits of the mantissa of a; /// NaN double. This can be used to transport information about violation; /// of function definition ranges, negative PDFs or other computation; /// problems in RooFit.; /// To separate NaNs that contain packed floats from regular NaNs, a tag is; /// written into the upper bits of the mantissa. If this tag is found, a payload; /// can be recovered. Otherwise, the NaN is assumed to originate from other sources; /// than a RooFit class that wants to signal to the minimiser.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooNaNPacker.h:424,recover,recovered,424,roofit/batchcompute/res/RooNaNPacker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooNaNPacker.h,1,['recover'],['recovered']
Availability,"/// Live range @p LR corresponding to the lane Mask @p LM has a live; /// PHI def at the beginning of block @p B. Extend the range @p LR of; /// all predecessor values that reach this def. If @p LR is a subrange,; /// the array @p Undefs is the set of all locations where it is undefined; /// via <def,read-undef> in other subranges for the same register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:47,Mask,Mask,47,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,1,['Mask'],['Mask']
Availability,"/// LiveOutPair - A value and the block that defined it. The domtree node is; /// redundant, it can be computed as: MDT[Indexes.getMBBFromIndex(VNI->def)].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:82,redundant,redundant,82,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,1,['redundant'],['redundant']
Availability,"/// Load a (real) dynamic library and make its symbols available through a; /// new JITDylib with the same name.; ///; /// If the given *executor* path contains a valid platform dynamic library; /// then that library will be loaded, and a new bare JITDylib whose name is; /// the given path will be created to make the library's symbols available to; /// JIT'd code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h:55,avail,available,55,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,2,['avail'],['available']
Availability,"/// Load the API notes associated with the given buffer, whether it is; /// the binary or source form of API notes.; ///; /// \returns the API notes reader for this file, or null if there is; /// a failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h:198,failure,failure,198,interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,1,['failure'],['failure']
Availability,"/// Load the API notes associated with the given file, whether it is; /// the binary or source form of API notes.; ///; /// \returns the API notes reader for this file, or null if there is; /// a failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h:196,failure,failure,196,interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,1,['failure'],['failure']
Availability,"/// Load the AST file and validate its contents against the given; /// Preprocessor.; ///; /// \param PP the preprocessor associated with the context in which this; /// precompiled header will be loaded.; ///; /// \param Context the AST context that this precompiled header will be; /// loaded into, if any.; ///; /// \param PCHContainerRdr the PCHContainerOperations to use for loading and; /// creating modules.; ///; /// \param Extensions the list of module file extensions that can be loaded; /// from the AST files.; ///; /// \param isysroot If non-NULL, the system include path specified by the; /// user. This is only used with relocatable PCH files. If non-NULL,; /// a relocatable PCH file will use the default path ""/"".; ///; /// \param DisableValidationKind If set, the AST reader will suppress most; /// of its regular consistency checking, allowing the use of precompiled; /// headers and module files that cannot be determined to be compatible.; ///; /// \param AllowASTWithCompilerErrors If true, the AST reader will accept an; /// AST file the was created out of an AST with compiler errors,; /// otherwise it will reject it.; ///; /// \param AllowConfigurationMismatch If true, the AST reader will not check; /// for configuration differences between the AST file and the invocation.; ///; /// \param ValidateSystemInputs If true, the AST reader will validate; /// system input files in addition to user input files. This is only; /// meaningful if \p DisableValidation is false.; ///; /// \param UseGlobalIndex If true, the AST reader will try to load and use; /// the global module index.; ///; /// \param ReadTimer If non-null, a timer used to track the time spent; /// deserializing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:1100,error,errors,1100,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['error'],['errors']
Availability,"/// Load the AST file designated by the given file name.; ///; /// \param FileName The name of the AST file to load.; ///; /// \param Type The kind of AST being loaded, e.g., PCH, module, main file,; /// or preamble.; ///; /// \param ImportLoc the location where the module file will be considered as; /// imported from. For non-module AST types it should be invalid.; ///; /// \param ClientLoadCapabilities The set of client load-failure; /// capabilities, represented as a bitset of the enumerators of; /// LoadFailureCapabilities.; ///; /// \param LoadedModuleFile The optional out-parameter refers to the new; /// loaded modules. In case the module specified by FileName is already; /// loaded, the module file pointer referred by NewLoadedModuleFile wouldn't; /// change. Otherwise if the AST file get loaded successfully,; /// NewLoadedModuleFile would refer to the address of the new loaded top level; /// module. The state of NewLoadedModuleFile is unspecified if the AST file; /// isn't loaded successfully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:431,failure,failure,431,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['failure'],['failure']
Availability,/// Load the coverage mapping data. Return nullptr if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:57,error,error,57,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,1,['error'],['error']
Availability,/// Load the given API notes file for the given header directory.; ///; /// \param HeaderDir The directory at which we; ///; /// \returns true if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h:149,error,error,149,interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,1,['error'],['error']
Availability,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:400,fault,fault,400,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h,1,['fault'],['fault']
Availability,"/// LoadFromCommandLine - Create an ASTUnit from a vector of command line; /// arguments, which must specify exactly one source file.; ///; /// \param ArgBegin - The beginning of the argument vector.; ///; /// \param ArgEnd - The end of the argument vector.; ///; /// \param PCHContainerOps - The PCHContainerOperations to use for loading and; /// creating modules.; ///; /// \param Diags - The diagnostics engine to use for reporting errors; its; /// lifetime is expected to extend past that of the returned ASTUnit.; ///; /// \param ResourceFilesPath - The path to the compiler resource files.; ///; /// \param StorePreamblesInMemory - Whether to store PCH in memory. If false,; /// PCH are stored in temporary files.; ///; /// \param PreambleStoragePath - The path to a directory, in which to create; /// temporary PCH files. If empty, the default system temporary directory is; /// used. This parameter is ignored if \p StorePreamblesInMemory is true.; ///; /// \param ModuleFormat - If provided, uses the specific module format.; ///; /// \param ErrAST - If non-null and parsing failed without any AST to return; /// (e.g. because the PCH could not be loaded), this accepts the ASTUnit; /// mainly to allow the caller to see the diagnostics.; ///; /// \param VFS - A llvm::vfs::FileSystem to be used for all file accesses.; /// Note that preamble is saved to a temporary directory on a RealFileSystem,; /// so in order for it to be loaded correctly, VFS should have access to; /// it(i.e., be an overlay over RealFileSystem). RealFileSystem will be used; /// if \p VFS is nullptr.; ///; // FIXME: Move OnlyLocalDecls, UseBumpAllocator to setters on the ASTUnit, we; // shouldn't need to specify them at construction time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:435,error,errors,435,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['error'],['errors']
Availability,"/// LoadFromCompilerInvocation - Create an ASTUnit from a source file, via a; /// CompilerInvocation object.; ///; /// \param CI - The compiler invocation to use; it must have exactly one input; /// source file. The ASTUnit takes ownership of the CompilerInvocation object.; ///; /// \param PCHContainerOps - The PCHContainerOperations to use for loading and; /// creating modules.; ///; /// \param Diags - The diagnostics engine to use for reporting errors; its; /// lifetime is expected to extend past that of the returned ASTUnit.; //; // FIXME: Move OnlyLocalDecls, UseBumpAllocator to setters on the ASTUnit, we; // shouldn't need to specify them at construction time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:451,error,errors,451,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['error'],['errors']
Availability,/// Loads 8 64-bit integer elements from memory starting at location \a base_addr; /// at packed 32-bit integer indices stored in the lower half of \a vindex; /// scaled by \a scale and stores them in dst using writemask \a mask (elements; /// are copied from \a src when the corresponding mask bit is not set).; ///; /// This intrinsic corresponds to the <c> VPGATHERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ELSE; /// dst[i+63:i] := src[i+63:i]; /// FI; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:224,mask,mask,224,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,3,['mask'],['mask']
Availability,/// Loads 8 double-precision (64-bit) floating-point elements from memory; /// starting at location \a base_addr at packed 32-bit integer indices stored in; /// the lower half of \a vindex scaled by \a scale into dst using writemask; /// \a mask (elements are copied from \a src when the corresponding mask bit is; /// not set).; ///; /// This intrinsic corresponds to the <c> VGATHERDPD </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ELSE; /// dst[i+63:i] := src[i+63:i]; /// FI; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:241,mask,mask,241,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,3,['mask'],['mask']
Availability,/// Loads a JSON compilation database from a data buffer.; ///; /// Returns NULL and sets ErrorMessage if the database could not be loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:90,Error,ErrorMessage,90,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,1,['Error'],['ErrorMessage']
Availability,/// Loads a JSON compilation database from the specified file.; ///; /// Returns NULL and sets ErrorMessage if the database could not be; /// loaded from the given file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:95,Error,ErrorMessage,95,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,1,['Error'],['ErrorMessage']
Availability,"/// Loads a compilation database from a build directory.; ///; /// Looks at the specified 'BuildDirectory' and creates a compilation database; /// that allows to query compile commands for source files in the; /// corresponding source tree.; ///; /// Returns NULL and sets ErrorMessage if we were not able to build up a; /// compilation database for the build directory.; ///; /// FIXME: Currently only supports JSON compilation databases, which; /// are named 'compile_commands.json' in the given directory. Extend this; /// for other build types (like ninja build files).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:273,Error,ErrorMessage,273,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,1,['Error'],['ErrorMessage']
Availability,/// Loads an ASTUnit for a function.; ///; /// \param FunctionName USR name of the function.; /// \param CrossTUDir Path to the directory used to store CTU related files.; /// \param IndexName Name of the file inside \p CrossTUDir which maps; /// function USR names to file paths. These files contain the corresponding; /// AST-dumps.; /// \param DisplayCTUProgress Display a message about loading new ASTs.; ///; /// \return An Expected instance which contains the ASTUnit pointer or the; /// error occurred during the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:494,error,error,494,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['error'],['error']
Availability,"/// Location of a PHI instruction that is also a debug-info variable value,; /// for the duration of register allocation. Loaded by the PHI-elimination; /// pass, and emitted as DBG_PHI instructions during VirtRegRewriter, with; /// maintenance applied by intermediate passes that edit registers (such as; /// coalescing and the allocator passes).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:233,mainten,maintenance,233,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['mainten'],['maintenance']
Availability,/// Lock this down to become a call site parameter location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:14,down,down,14,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,1,['down'],['down']
Availability,/// Lock this down to become a memory location description.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:14,down,down,14,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,1,['down'],['down']
Availability,/// Lock this down to become an entry value location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:14,down,down,14,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,1,['down'],['down']
Availability,"/// Locks the underlying file.; ///; /// @returns RAII object that releases the lock upon leaving the scope, if the; /// locking was successful. Otherwise returns corresponding; /// error code.; ///; /// The function blocks the current thread until the lock become available or; /// error occurs.; ///; /// Possible use of this function may be as follows:; ///; /// @code{.cpp}; /// if (auto L = stream.lock()) {; /// // ... do action that require file to be locked.; /// } else {; /// handleAllErrors(std::move(L.takeError()), [&](ErrorInfoBase &EIB) {; /// // ... handle lock error.; /// });; /// }; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:182,error,error,182,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,5,"['Error', 'avail', 'error']","['ErrorInfoBase', 'available', 'error']"
Availability,"/// Log all errors (if any) in E to OS. If there are any errors, ErrorBanner; /// will be printed before the first one is logged. A newline will be printed; /// after each error.; ///; /// This function is compatible with the helpers from Support/WithColor.h. You; /// can pass any of them as the OS. Please consider using them instead of; /// including 'error: ' in the ErrorBanner.; ///; /// This is useful in the base level of your program to allow clean termination; /// (allowing clean deallocation of resources, etc.), while reporting error; /// information to the user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:12,error,errors,12,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,7,"['Error', 'error']","['ErrorBanner', 'error', 'errors']"
Availability,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:54,error,error,54,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,11,['error'],['error']
Availability,/// Logs all errors to a raw_ostream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:13,error,errors,13,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,1,['error'],['errors']
Availability,"/// Look at Op. At this point, we know that only the DemandedBits bits of the; /// result of Op are ever used downstream. If we can use this information to; /// simplify Op, create a new simplified DAG node and return true, returning; /// the original and new nodes in Old and New. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:110,down,downstream,110,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,3,"['down', 'mask']","['downstream', 'mask', 'masks']"
Availability,"/// Look at Op. At this point, we know that only the OriginalDemandedBits of the; /// result of Op are ever used downstream. If we can use this information to; /// simplify Op, create a new simplified DAG node and return true, returning the; /// original and new nodes in Old and New. Otherwise, analyze the expression and; /// return a mask of Known bits for the expression (used to simplify the; /// caller). The Known bits may only be accurate for those bits in the; /// OriginalDemandedBits and OriginalDemandedElts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:113,down,downstream,113,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,"['down', 'mask']","['downstream', 'mask']"
Availability,"/// Look at Vector Op. At this point, we know that only the DemandedElts; /// elements of the result of Op are ever used downstream. If we can use; /// this information to simplify Op, create a new simplified DAG node and; /// return true, storing the original and new nodes in TLO.; /// Otherwise, analyze the expression and return a mask of KnownUndef and; /// KnownZero elements for the expression (used to simplify the caller).; /// The KnownUndef/Zero elements may only be accurate for those bits; /// in the DemandedMask.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:121,down,downstream,121,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,"['down', 'mask']","['downstream', 'mask']"
Availability,/// Look for available copies whose destination register is used by \p MI and; /// replace the use in \p MI with the copy's source register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:13,avail,available,13,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['avail'],['available']
Availability,"/// Look for the following loop:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode; ///; /// And transform it into:; /// \code; /// entry:; /// %bitmask = shl i32 1, %bitpos; /// %lowbitmask = add i32 %bitmask, -1; /// %mask = or i32 %lowbitmask, %bitmask; /// %x.masked = and i32 %x, %mask; /// %x.masked.numleadingzeros = call i32 @llvm.ctlz.i32(i32 %x.masked,; /// i1 true); /// %x.masked.numactivebits = sub i32 32, %x.masked.numleadingzeros; /// %x.masked.leadingonepos = add i32 %x.masked.numactivebits, -1; /// %backedgetakencount = sub i32 %bitpos, %x.masked.leadingonepos; /// %tripcount = add i32 %backedgetakencount, 1; /// %x.curr = shl i32 %x, %backedgetakencount; /// %x.next = shl i32 %x, %tripcount; /// br label %loop; ///; /// loop:; /// %loop.iv = phi i32 [ 0, %entry ], [ %loop.iv.next, %loop ]; /// %loop.iv.next = add nuw i32 %loop.iv, 1; /// %loop.ivcheck = icmp eq i32 %loop.iv.next, %tripcount; /// <...>; /// br i1 %loop.ivcheck, label %end, label %loop; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:687,mask,mask,687,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,10,['mask'],"['mask', 'masked']"
Availability,/// Look for the indentation level of a block scalar.; ///; /// Return false if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:83,error,error,83,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['error'],['error']
Availability,/// Look up the indices for function records which are at least partially; /// defined in the specified file. This is guaranteed to return a superset of; /// such records: extra records not in the file may be included if there is; /// a hash collision on the filename. Clients must be robust to collisions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h:285,robust,robust,285,interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,1,['robust'],['robust']
Availability,"/// Looks at a single use of an argument or return value and determines if it; /// should be alive or not. Adds this use to MaybeLiveUses if it causes the; /// used value to become MaybeLive.; ///; /// RetValNum is the return value number to use when this use is used in a; /// return instruction. This is used in the recursion, you should always leave; /// it at 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:93,alive,alive,93,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['alive'],['alive']
Availability,"/// Looks at a token type and creates the relevant operand from this; /// information, adding to Operands. Return true upon an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:127,error,error,127,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,1,['error'],['error']
Availability,"/// Looks for the std::initializer_list template and instantiates it; /// with Element, or emits an error if it's not found.; ///; /// \returns The instantiated template, or null on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:100,error,error,100,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['error'],['error']
Availability,"/// Looks into the <parameters> part of the mangled name in search; /// for valid paramaters at the beginning of the string; /// `ParseString`.; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `StepOrPos`; /// accordingly, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:336,error,error,336,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,2,['error'],['error']
Availability,"/// Looks into the <parameters> part of the mangled name in search; /// of a valid 'aligned' clause. The function should be invoked; /// after parsing a parameter via `tryParseParameter`.; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `StepOrPos`; /// accordingly, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:380,error,error,380,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,2,['error'],['error']
Availability,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:192,mask,mask,192,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,9,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Looks up a vertex with Identifier I, or an error if it does not exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:47,error,error,47,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,1,['error'],['error']
Availability,"/// Looks up an edge with Identifier I, or an error if it does not exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:46,error,error,46,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,1,['error'],['error']
Availability,"/// Lookup a single address within a line table's data.; ///; /// Clients have the option to decode an entire line table using; /// LineTable::decode() or just find a single matching entry using this; /// function. The benefit of using this function is that parsed LineEntry; /// objects that do not match will not be stored in an array. This will avoid; /// memory allocation costs and parsing can stop once a match has been found.; ///; /// \param Data The binary stream to read the data from. This object must; /// have the data for the LineTable object starting at offset zero. The data; /// can contain more data than needed.; ///; /// \param BaseAddr The base address to use when decoding the line table.; /// This will be the FunctionInfo's start address and will be used to; /// initialize the line table row prior to parsing any opcodes.; ///; /// \returns An LineEntry object if a match is found, error otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/LineTable.h:907,error,error,907,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/LineTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/LineTable.h,1,['error'],['error']
Availability,"/// Lookup a symbol address in the main binary symbol table. The; /// parser only needs to query common symbols, thus not every symbol's; /// address is available through this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:153,avail,available,153,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,1,['avail'],['available']
Availability,"/// Lookup an address in the a GSYM.; ///; /// Lookup just the information needed for a specific address \a Addr. This; /// function is faster that calling getFunctionInfo() as it will only return; /// information that pertains to \a Addr and allows the parsing to skip any; /// extra information encoded for other addresses. For example the line table; /// parsing can stop when a matching LineEntry has been fouhnd, and the; /// InlineInfo can stop parsing early once a match has been found and also; /// skip information that doesn't match. This avoids memory allocations and; /// is much faster for lookups.; ///; /// \param Addr A virtual address from the orignal object file to lookup.; /// \returns An expected LookupResult that contains only the information; /// needed for the current address, or an error object that indicates reason; /// for failing to lookup the address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:809,error,error,809,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,1,['error'],['error']
Availability,"/// Lookup an address within a FunctionInfo object's data stream.; ///; /// Instead of decoding an entire FunctionInfo object when doing lookups,; /// we can decode only the information we need from the FunctionInfo's data; /// for the specific address. The lookup result information is returned as; /// a LookupResult.; ///; /// \param Data The binary stream to read the data from. This object must; /// have the data for the object starting at offset zero. The data; /// can contain more data than needed.; ///; /// \param GR The GSYM reader that contains the string and file table that; /// will be used to fill in information in the returned result.; ///; /// \param FuncAddr The function start address decoded from the GsymReader.; ///; /// \param Addr The address to lookup.; ///; /// \returns An LookupResult or an error describing the issue that was; /// encountered during decoding. An error should only be returned if the; /// address is not contained in the FunctionInfo or if the data is corrupted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h:822,error,error,822,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h,2,['error'],['error']
Availability,"/// Lookup flags that apply to each symbol in a lookup.; ///; /// If RequiredSymbol is used (the default) for a given symbol then that symbol; /// must be found during the lookup or the lookup will fail returning a; /// SymbolNotFound error. If WeaklyReferencedSymbol is used and the given; /// symbol is not found then the query will continue, and no result for the; /// missing symbol will be present in the result (assuming the rest of the; /// lookup succeeds).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:235,error,error,235,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['error'],['error']
Availability,"/// Lookup the specified comparison category types in the standard; /// library, an check the VarDecls possibly returned by the operator<=>; /// builtins for that type.; ///; /// \return The type of the comparison category type corresponding to the; /// specified Kind, or a null type if an error occurs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:291,error,error,291,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// Lookup, cache, and verify the specified directory (real or; /// virtual).; ///; /// This function is deprecated and will be removed at some point in the; /// future, new clients should use; /// \c getDirectoryRef.; ///; /// This returns a \c std::error_code if there was an error reading the; /// directory. If there is no error, the DirectoryEntry is guaranteed to be; /// non-NULL.; ///; /// \param CacheFailure If true and the file does not exist, we'll cache; /// the failure to find this file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:278,error,error,278,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,3,"['error', 'failure']","['error', 'failure']"
Availability,"/// Lookup, cache, and verify the specified directory (real or; /// virtual).; ///; /// This returns a \c std::error_code if there was an error reading the; /// directory. On success, returns the reference to the directory entry; /// together with the exact path that was used to access a file by a; /// particular call to getDirectoryRef.; ///; /// \param CacheFailure If true and the file does not exist, we'll cache; /// the failure to find this file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:138,error,error,138,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Lookup, cache, and verify the specified file (real or virtual). Return the; /// reference to the file entry together with the exact path that was used to; /// access a file by a particular call to getFileRef. If the underlying VFS is; /// a redirecting VFS that uses external file names, the returned FileEntryRef; /// will use the external name instead of the filename that was passed to this; /// method.; ///; /// This returns a \c std::error_code if there was an error loading the file,; /// or a \c FileEntryRef otherwise.; ///; /// \param OpenFile if true and the file exists, it will be opened.; ///; /// \param CacheFailure If true and the file does not exist, we'll cache; /// the failure to find this file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:471,error,error,471,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Lookup, cache, and verify the specified file (real or; /// virtual).; ///; /// This function is deprecated and will be removed at some point in the; /// future, new clients should use; /// \c getFileRef.; ///; /// This returns a \c std::error_code if there was an error loading the file.; /// If there is no error, the FileEntry is guaranteed to be non-NULL.; ///; /// \param OpenFile if true and the file exists, it will be opened.; ///; /// \param CacheFailure If true and the file does not exist, we'll cache; /// the failure to find this file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:268,error,error,268,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,3,"['error', 'failure']","['error', 'failure']"
Availability,"/// LookupFile - Given a ""foo"" or \<foo> reference, look up the indicated file,; /// return null on failure. isAngled indicates whether the file reference is; /// for system \#include's or not (i.e. using <> instead of """"). Includers, if; /// non-empty, indicates where the \#including file(s) are, in case a relative; /// search is needed. Microsoft mode will pass all \#including files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:100,failure,failure,100,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['failure'],['failure']
Availability,"/// Loop over all of the basic blocks, replacing address; /// calculations in load and store instructions, if it's already; /// been calculated by LEA. Also, remove redundant LEAs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:165,redundant,redundant,165,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['redundant'],['redundant']
Availability,"/// Loop over the elements of this SymbolLookupSet, applying the Body function; /// to each one. Body must be callable as; /// Expected<bool>(const SymbolStringPtr &, SymbolLookupFlags).; /// If Body returns a failure value, the loop exits immediately. If Body; /// returns true then the element just passed in is removed from the set. If; /// Body returns false then the element is retained.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:210,failure,failure,210,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['failure'],['failure']
Availability,"/// LoopVectorizationLegality checks if it is legal to vectorize a loop, and; /// to what vectorization factor.; /// This class does not look at the profitability of vectorization, only the; /// legality. This class has two main kinds of checks:; /// * Memory checks - The code in canVectorizeMemory checks if vectorization; /// will change the order of memory accesses in a way that will change the; /// correctness of the program.; /// * Scalars checks - The code in canVectorizeInstrs and canVectorizeMemory; /// checks for a number of different conditions, such as the availability of a; /// single induction variable, that all types are supported and vectorize-able,; /// etc. This code reflects the capabilities of InnerLoopVectorizer.; /// This class is also used by InnerLoopVectorizer for identifying; /// induction variable and the different reduction variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:573,avail,availability,573,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['avail'],['availability']
Availability,"/// Lower a vector shuffle as a zero or any extension.; ///; /// Given a specific number of elements, element bit width, and extension; /// stride, produce either a zero or any extension based on the available; /// features of the subtarget. The extended elements are consecutive and; /// begin and can start from an offsetted element index in the input; to; /// avoid excess shuffling the offset must either being in the bottom lane; /// or at the start of a higher lane. All extended elements must be from; /// the same lane.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:200,avail,available,200,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"/// Lower all instructions that def or use vreg_1 registers.; ///; /// In a first pass, we lower COPYs from vreg_1 to vector registers, as can; /// occur around inline assembly. We do this first, before vreg_1 registers; /// are changed to scalar mask registers.; ///; /// Then we lower all defs of vreg_1 registers. Phi nodes are lowered before; /// all others, because phi lowering looks through copies and can therefore; /// often make copy lowering unnecessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp:247,mask,mask,247,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,1,['mask'],['mask']
Availability,"/// Lower an interleaved store into a stN intrinsic.; ///; /// E.g. Lower an interleaved store (Factor = 3):; /// %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; /// <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; /// store <12 x i32> %i.vec, <12 x i32>* %ptr; ///; /// Into:; /// %sub.v0 = shuffle <8 x i32> %v0, <8 x i32> v1, <0, 1, 2, 3>; /// %sub.v1 = shuffle <8 x i32> %v0, <8 x i32> v1, <4, 5, 6, 7>; /// %sub.v2 = shuffle <8 x i32> %v0, <8 x i32> v1, <8, 9, 10, 11>; /// call void llvm.aarch64.neon.st3(%sub.v0, %sub.v1, %sub.v2, %ptr); ///; /// Note that the new shufflevectors will be removed and we'll only generate one; /// st3 instruction in CodeGen.; ///; /// Example for a more general valid mask (Factor 3). Lower:; /// %i.vec = shuffle <32 x i32> %v0, <32 x i32> %v1,; /// <4, 32, 16, 5, 33, 17, 6, 34, 18, 7, 35, 19>; /// store <12 x i32> %i.vec, <12 x i32>* %ptr; ///; /// Into:; /// %sub.v0 = shuffle <32 x i32> %v0, <32 x i32> v1, <4, 5, 6, 7>; /// %sub.v1 = shuffle <32 x i32> %v0, <32 x i32> v1, <32, 33, 34, 35>; /// %sub.v2 = shuffle <32 x i32> %v0, <32 x i32> v1, <16, 17, 18, 19>; /// call void llvm.aarch64.neon.st3(%sub.v0, %sub.v1, %sub.v2, %ptr)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:698,mask,mask,698,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,"/// Lower an interleaved store into a vstN intrinsic.; ///; /// E.g. Lower an interleaved store (Factor = 3):; /// %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; /// <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; /// store <12 x i32> %i.vec, <12 x i32>* %ptr, align 4; ///; /// Into:; /// %sub.v0 = shuffle <8 x i32> %v0, <8 x i32> v1, <0, 1, 2, 3>; /// %sub.v1 = shuffle <8 x i32> %v0, <8 x i32> v1, <4, 5, 6, 7>; /// %sub.v2 = shuffle <8 x i32> %v0, <8 x i32> v1, <8, 9, 10, 11>; /// call void llvm.arm.neon.vst3(%ptr, %sub.v0, %sub.v1, %sub.v2, 4); ///; /// Note that the new shufflevectors will be removed and we'll only generate one; /// vst3 instruction in CodeGen.; ///; /// Example for a more general valid mask (Factor 3). Lower:; /// %i.vec = shuffle <32 x i32> %v0, <32 x i32> %v1,; /// <4, 32, 16, 5, 33, 17, 6, 34, 18, 7, 35, 19>; /// store <12 x i32> %i.vec, <12 x i32>* %ptr; ///; /// Into:; /// %sub.v0 = shuffle <32 x i32> %v0, <32 x i32> v1, <4, 5, 6, 7>; /// %sub.v1 = shuffle <32 x i32> %v0, <32 x i32> v1, <32, 33, 34, 35>; /// %sub.v2 = shuffle <32 x i32> %v0, <32 x i32> v1, <16, 17, 18, 19>; /// call void llvm.arm.neon.vst3(%ptr, %sub.v0, %sub.v1, %sub.v2, 4)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:709,mask,mask,709,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,"/// Lower barriers out of existence (if the associated GCStrategy hasn't; /// already done so...), and insert initializing stores to roots as a defensive; /// measure. Given we're going to report all roots live at all safepoints, we; /// need to be able to ensure each root has been initialized by the point the; /// first safepoint is reached. This really should have been done by the; /// frontend, but the old API made this non-obvious, so we do a potentially; /// redundant store just in case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:468,redundant,redundant,468,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,1,['redundant'],['redundant']
Availability,"/// Lower binary operators, if shape information is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:52,avail,available,52,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['avail'],['available']
Availability,"/// Lower deopt state and gc pointer arguments of the statepoint. The actual; /// lowering is described in lowerIncomingStatepointValue. This function is; /// responsible for lowering everything in the right position and playing some; /// tricks to avoid redundant stack manipulation where possible. On; /// completion, 'Ops' will contain ready to use operands for machine code; /// statepoint. The chain nodes will have already been created and the DAG root; /// will be set to the last value spilled (if any were).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:255,redundant,redundant,255,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['redundant'],['redundant']
Availability,"/// Lower load instructions, if shape information is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:53,avail,available,53,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['avail'],['available']
Availability,"/// Lower unary operators, if shape information is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:51,avail,available,51,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['avail'],['available']
Availability,"/// Lowering of single-input v8i16 shuffles is the cornerstone of SSE2; /// shuffle lowering, and the most complex part.; ///; /// The lowering strategy is to try to form pairs of input lanes which are; /// targeted at the same half of the final vector, and then use a dword shuffle; /// to place them onto the right half, and finally unpack the paired lanes into; /// their final position.; ///; /// The exact breakdown of how to form these dword pairs and align them on the; /// correct sides is really tricky. See the comments within the function for; /// more of the details.; ///; /// This code also handles repeated 128-bit lanes of v8i16 shuffles, but each; /// lane must shuffle the *exact* same way. In fact, you must pass a v8 Mask to; /// this routine for it to work correctly. To shuffle a 256-bit or 512-bit i16; /// vector, form the analogous 128-bit 8-element Mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:737,Mask,Mask,737,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['Mask'],['Mask']
Availability,/// Lowers masks values (v*i1) to the local register values; /// \returns DAG node after lowering to register type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:11,mask,masks,11,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['mask'],['masks']
Availability,/// MCRegUnitMaskIterator enumerates a list of register units and their; /// associated lane masks for Reg. The register units are in ascending; /// numerical order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h:93,mask,masks,93,interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,1,['mask'],['masks']
Availability,/// MO_OPTION_MASK - Most flags are mutually exclusive; this mask selects; /// just that part of the flag set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h:61,mask,mask,61,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMBaseInfo.h,1,['mask'],['mask']
Availability,"/// MSVC has a bug where if during an using declaration name lookup,; /// the declaration found is unaccessible (private) and that declaration; /// was bring into scope via another using declaration whose target; /// declaration is accessible (public) then no error is generated.; /// Example:; /// class A {; /// public:; /// int f();; /// };; /// class B : public A {; /// private:; /// using A::f;; /// };; /// class C : public B {; /// private:; /// using B::f;; /// };; ///; /// Here, B::f is private so this should fail in Standard C++, but; /// because B::f refers to A::f which is public MSVC accepts it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:260,error,error,260,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['error'],['error']
Availability,/// MachOBindEntry encapsulates the current state in the decompression of; /// binding opcodes. This allows you to iterate through the compressed table of; /// bindings using:; /// Error Err = Error::success();; /// for (const llvm::object::MachOBindEntry &Entry : Obj->bindTable(&Err)) {; /// }; /// if (Err) { report error ...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/MachO.h:181,Error,Error,181,interpreter/llvm-project/llvm/include/llvm/Object/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/MachO.h,3,"['Error', 'error']","['Error', 'error']"
Availability,/// MachORebaseEntry encapsulates the current state in the decompression of; /// rebasing opcodes. This allows you to iterate through the compressed table of; /// rebasing using:; /// Error Err = Error::success();; /// for (const llvm::object::MachORebaseEntry &Entry : Obj->rebaseTable(&Err)) {; /// }; /// if (Err) { report error ...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/MachO.h:184,Error,Error,184,interpreter/llvm-project/llvm/include/llvm/Object/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/MachO.h,3,"['Error', 'error']","['Error', 'error']"
Availability,"/// MachineFunctionPassManager adds/removes below features to/from the base; /// PassManager template instantiation.; ///; /// - Support passes that implement doInitialization/doFinalization. This is for; /// machine function passes to work on module level constructs. One such pass; /// is AsmPrinter.; ///; /// - Support machine module pass which runs over the module (for example,; /// MachineOutliner). A machine module pass needs to define the method:; ///; /// ```Error run(Module &, MachineFunctionAnalysisManager &)```; ///; /// FIXME: machine module passes still need to define the usual machine; /// function pass interface, namely,; /// `PreservedAnalyses run(MachineFunction &,; /// MachineFunctionAnalysisManager &)`; /// But this interface wouldn't be executed. It is just a placeholder; /// to satisfy the pass manager type-erased inteface. This; /// special-casing of machine module pass is due to its limited use; /// cases and the unnecessary complexity it may bring to the machine; /// pass manager.; ///; /// - The base class `run` method is replaced by an alternative `run` method.; /// See details below.; ///; /// - Support codegening in the SCC order. Users include interprocedural; /// register allocation (IPRA).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:470,Error,Error,470,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,1,['Error'],['Error']
Availability,/// MachineLateInstrsCleanup - This pass removes redundant identical; /// instructions after register allocation and rematerialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:49,redundant,redundant,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['redundant'],['redundant']
Availability,/// MachineSchedRegistry provides a selection of available machine instruction; /// schedulers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:49,avail,available,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['avail'],['available']
Availability,"/// Main generic intersect function.; /// It intersects all of the given range sets. If some of the given arguments; /// don't hold a range set (nullptr or std::nullopt), the function will skip; /// them.; ///; /// Available representations for the arguments are:; /// * RangeSet; /// * std::optional<RangeSet>; /// * RangeSet *; /// Pointer to a RangeSet is automatically assumed to be nullable and will get; /// checked as well as the optional version. If this behaviour is undesired,; /// please dereference the pointer in the call.; ///; /// Return type depends on the arguments' types. If we can be sure in compile; /// time that there will be a range set as a result, the returning type is; /// simply RangeSet, in other cases we have to back off to; /// std::optional<RangeSet>.; ///; /// Please, prefer optional range sets to raw pointers. If the last argument is; /// a raw pointer and all previous arguments are std::nullopt, it will cost one; /// additional check to convert RangeSet * into std::optional<RangeSet>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:215,Avail,Available,215,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['Avail'],['Available']
Availability,/// Main interface to parsing a bitcode buffer.; /// \returns true if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:73,error,error,73,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['error'],['error']
Availability,"/// Make a (potentially elidable) temporary copy of the object; /// provided by the given initializer by calling the appropriate copy; /// constructor.; ///; /// \param S The Sema object used for type-checking.; ///; /// \param T The type of the temporary object, which must either be; /// the type of the initializer expression or a superclass thereof.; ///; /// \param Entity The entity being initialized.; ///; /// \param CurInit The initializer expression.; ///; /// \param IsExtraneousCopy Whether this is an ""extraneous"" copy that; /// is permitted in C++03 (but not C++0x) when binding a reference to; /// an rvalue.; ///; /// \returns An expression that copies the initializer expression into; /// a temporary object, or an error expression if a copy could not be; /// created.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:732,error,error,732,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['error'],['error']
Availability,/// Make a Error instance representing failure using the given error info; /// type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:11,Error,Error,11,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,3,"['Error', 'error', 'failure']","['Error', 'error', 'failure']"
Availability,"/// Make a register of the specific register class available from the current; /// position backwards to the place before \p To. If \p RestoreAfter is true; /// this includes the instruction following the current position.; /// SPAdj is the stack adjustment due to call frame, it's passed along to; /// eliminateFrameIndex().; /// Returns the scavenged register.; ///; /// If \p AllowSpill is false, fail if a spill is required to make the; /// register available, and return NoRegister.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h:51,avail,available,51,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h,2,['avail'],['available']
Availability,"/// Make coefficients of RooAddPdf sum to more than 1. Fitter should recover from this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:69,recover,recover,69,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,1,['recover'],['recover']
Availability,"/// Make coefficients of RooRealSumPdf sum to more than 1. Fitter should recover from this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:73,recover,recover,73,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,1,['recover'],['recover']
Availability,/// Make module to use export_as as the link dependency name if enough; /// information is available or add it to a pending list otherwise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:91,avail,available,91,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['avail'],['available']
Availability,"/// Make sure the value of 'this' is actually available in the current; /// context, if it is a potentially evaluated context.; ///; /// \param Loc The location at which the capture of 'this' occurs.; ///; /// \param Explicit Whether 'this' is explicitly captured in a lambda; /// capture list.; ///; /// \param FunctionScopeIndexToStopAt If non-null, it points to the index; /// of the FunctionScopeInfo stack beyond which we do not attempt to capture.; /// This is useful when enclosing lambdas must speculatively capture; /// 'this' that may or may not be used in certain specializations of; /// a nested generic lambda (depending on whether the name resolves to; /// a non-static member function or a static function).; /// \return returns 'true' if failed, 'false' if success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:46,avail,available,46,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avail'],['available']
Availability,"/// Manages a set of available checkers for running a static analysis.; /// The checkers are organized into packages by full name, where including; /// a package will recursively include all subpackages and checkers within it.; /// For example, the checker ""core.builtin.NoReturnFunctionChecker"" will be; /// included if initializeManager() is called with an option of ""core"",; /// ""core.builtin"", or the full name ""core.builtin.NoReturnFunctionChecker"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h:21,avail,available,21,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h,1,['avail'],['available']
Availability,/// Map containing a mask with all operands indices that can be found for; /// that class inside a instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['mask'],['mask']
Availability,/// Map for recovering vreg name from vreg number.; /// This map is used by the MIR Printer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:12,recover,recovering,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,1,['recover'],['recovering']
Availability,"/// Mapping from the already-imported declarations in the ""from""; /// context to the error status of the import of that declaration.; /// This map contains only the declarations that were not correctly; /// imported. The same declaration may or may not be included in; /// ImportedDecls. This map is updated continuously during imports and never; /// cleared (like ImportedDecls).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:85,error,error,85,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Mapping from the already-imported declarations in the ""to""; /// context to the error status of the import of that declaration.; /// This map contains only the declarations that were not correctly; /// imported. The same declaration may or may not be included in; /// ImportedFromDecls. This map is updated continuously during imports and; /// never cleared (like ImportedFromDecls).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporterSharedState.h:83,error,error,83,interpreter/llvm-project/clang/include/clang/AST/ASTImporterSharedState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporterSharedState.h,1,['error'],['error']
Availability,"/// Maps a match result to a list of concrete edits (with possible; /// failure). This type is a building block of rewrite rules, but users will; /// generally work in terms of `ASTEdit`s (below) rather than directly in terms; /// of `EditGenerator`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:72,failure,failure,72,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,1,['failure'],['failure']
Availability,"/// Maps a property to a field, if it exists.; /// If the property exists and is invalid, reports an error.; /// (Optional requires special handling, because missing keys are OK).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:101,error,error,101,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['error'],['error']
Availability,"/// Maps a property to a field, if it exists.; /// If the property exists and is invalid, reports an error.; /// If the property does not exist, Out is unchanged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:101,error,error,101,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['error'],['error']
Availability,"/// Maps a property to a field.; /// If the property is missing or invalid, reports an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:87,error,error,87,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['error'],['error']
Availability,"/// Maps from a start to an end spelling location of transformations; /// performed by the preprocessor. These include:; /// 1. range from '#' to the last token in the line for PP directives,; /// 2. macro name and arguments for macro expansions.; /// Note that we record only top-level macro expansions, intermediate; /// expansions (e.g. inside macro arguments) are ignored.; ///; /// Used to find correct boundaries of macro calls and directives when; /// building mappings from spelled to expanded tokens.; ///; /// Logically, at each point of the preprocessor execution there is a stack of; /// macro expansions being processed and we could use it to recover the; /// location information we need. However, the public preprocessor API only; /// exposes the points when macro expansions start (when we push a macro onto; /// the stack) and not when they end (when we pop a macro from the stack).; /// To workaround this limitation, we rely on source location information; /// stored in this map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:656,recover,recover,656,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,1,['recover'],['recover']
Availability,/// Maps from register mask names to register masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIParser.h:23,mask,mask,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIParser.h,2,['mask'],"['mask', 'masks']"
Availability,/// Mark (newly) imported declaration with error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:43,error,error,43,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Mark MI as dead. If a def of one of MI's operands, DefMI, would also be; /// dead due to MI being killed, then mark DefMI as dead too.; /// Some of the combines (extends(trunc)), try to walk through redundant; /// copies in between the extends and the truncs, and this attempts to collect; /// the in between copies if they're dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h:203,redundant,redundant,203,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h,1,['redundant'],['redundant']
Availability,/// Mark domain as available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:19,avail,available,19,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,1,['avail'],['available']
Availability,"/// Mark every physreg used by this instruction as; /// dead except those in the UsedRegs list.; ///; /// On instructions with register mask operands, also add implicit-def; /// operands for all registers in UsedRegs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:136,mask,mask,136,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['mask'],['mask']
Availability,"/// Mark the given Function as alive, meaning that it cannot be changed in any; /// way. Additionally, mark any values that are used as this function's; /// parameters or by its return values (according to Uses) live as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:31,alive,alive,31,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['alive'],['alive']
Availability,"/// Mark the pointer as escaped, and the visit as aborted. Intended; /// for use in a void return.; /// \param I The instruction which both escapes the pointer and aborts the; /// visit, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:190,avail,available,190,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,1,['avail'],['available']
Availability,"/// Mark the pointer as escaped. Intended for use in a void return.; /// \param I The instruction which escapes the pointer, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:128,avail,available,128,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,1,['avail'],['available']
Availability,/// Mark the semantic form of the InitListExpr as error when the semantic; /// analysis fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:50,error,error,50,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['error'],['error']
Availability,"/// Mark the visit as aborted. Intended for use in a void return.; /// \param I The instruction which caused the visit to abort, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:132,avail,available,132,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,1,['avail'],['available']
Availability,/// Mark this repairing placement as impossible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:14,repair,repairing,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,1,['repair'],['repairing']
Availability,"/// Marks a symbol as important to a checker.; ///; /// For metadata symbols,; /// this will keep the symbol alive as long as its associated region is also; /// live. For other symbols, this has no effect; checkers are not permitted; /// to influence the life of other symbols. This should be used before any; /// symbol marking has occurred, i.e. in the MarkLiveSymbols callback.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h:109,alive,alive,109,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,1,['alive'],['alive']
Availability,"/// Marks the column as complete; must be done for all columns, even empty ones without associated pages,; /// before the cluster is given from the page storage to the cluster pool. Marking the available columns is; /// typically the last step of RPageSouce::LoadCluster().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:194,avail,available,194,tree/ntuple/v7/inc/ROOT/RCluster.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx,1,['avail'],['available']
Availability,/// Mask for encoding the frame registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:4,Mask,Mask,4,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,1,['Mask'],['Mask']
Availability,/// Mask for encoding the frameless registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:4,Mask,Mask,4,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,1,['Mask'],['Mask']
Availability,"/// Mask for the subfield that contains the stride of Control Flow Guard; /// function table entries (that is, the additional count of bytes per table; /// entry).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:4,Mask,Mask,4,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,1,['Mask'],['Mask']
Availability,"/// Mask of bits used to identify ""Fix"" variants in MessagePack.; ///; /// For example, FixStr objects encode their size in the five least significant; /// bits of their first byte, which is identified by the bit pattern ""101"" in; /// the three most significant bits. So FixBitsMask::String contains; /// 0b11100000.; ///; /// The corresponding bit pattern to mask for is found in FixBits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:4,Mask,Mask,4,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,/// Mask value initialized to 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h:4,Mask,Mask,4,interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,1,['Mask'],['Mask']
Availability,"/// Mask values for IT and VPT Blocks, to be used by MCOperands.; /// Note that this is different from the ""real"" encoding used by the; /// instructions. In this encoding, the lowest set bit indicates the end of; /// the encoding, and above that, ""1"" indicates an else, while ""0"" indicates; /// a then.; /// Tx = x100; /// Txy = xy10; /// Txyz = xyz1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h:4,Mask,Mask,4,interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Utils/ARMBaseInfo.h,1,['Mask'],['Mask']
Availability,/// Mask we are iterating over.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:4,Mask,Mask,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['Mask'],['Mask']
Availability,/// MaskedValueIsAllOnes - Return true if '(Op & Mask) == Mask'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:4,Mask,MaskedValueIsAllOnes,4,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,3,['Mask'],"['Mask', 'MaskedValueIsAllOnes']"
Availability,/// MaskedValueIsZero - Return true if 'V & Mask' is known to be zero in; /// DemandedElts. We use this predicate to simplify operations downstream.; /// Mask is known to be zero for bits that V cannot have.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:4,Mask,MaskedValueIsZero,4,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,4,"['Mask', 'down']","['Mask', 'MaskedValueIsZero', 'downstream']"
Availability,/// MaskedValueIsZero - Return true if 'V & Mask' is known to be zero. We use; /// this predicate to simplify operations downstream. Mask is known to be zero; /// for bits that V cannot have.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:4,Mask,MaskedValueIsZero,4,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,4,"['Mask', 'down']","['Mask', 'MaskedValueIsZero', 'downstream']"
Availability,/// MaskedVectorIsZero - Return true if 'Op' is known to be zero in; /// DemandedElts. We use this predicate to simplify operations downstream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:4,Mask,MaskedVectorIsZero,4,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,2,"['Mask', 'down']","['MaskedVectorIsZero', 'downstream']"
Availability,"/// Match (and (load x), mask) -> zextload x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:25,mask,mask,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['mask'],['mask']
Availability,"/// Match a G_SHUFFLE_VECTOR with a mask which corresponds to a; /// G_INSERT_VECTOR_ELT and G_EXTRACT_VECTOR_ELT pair.; ///; /// e.g.; /// %shuf = G_SHUFFLE_VECTOR %left, %right, shufflemask(0, 0); ///; /// Can be represented as; ///; /// %extract = G_EXTRACT_VECTOR_ELT %left, 0; /// %ins = G_INSERT_VECTOR_ELT %left, %extract, 1; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,1,['mask'],['mask']
Availability,"/// Match the index vector of a scatter or gather node as the shuffle mask; /// which performs the rearrangement if possible. Will only match if; /// all lanes are touched, and thus replacing the scatter or gather with; /// a unit strided access and shuffle is legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:70,mask,mask,70,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,/// Match v(f)slide1up/down idioms. These operations involve sliding; /// N-1 elements to make room for an inserted scalar at one end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,down,down,23,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['down'],['down']
Availability,"/// Match: and (lshr x, cst), mask -> ubfx x, cst, width",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:30,mask,mask,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['mask'],['mask']
Availability,"/// MatchAndEmitInstruction - Recognize a series of operands of a parsed; /// instruction as an actual MCInst and emit it to the specified MCStreamer.; /// This returns false on success and returns true on failure to match.; ///; /// On failure, the target parser is responsible for emitting a diagnostic; /// explaining the match failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h:206,failure,failure,206,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,3,['failure'],['failure']
Availability,"/// MatchWrapper - Try to match MSP430ISD::Wrapper node into an addressing mode.; /// These wrap things that will resolve down into a symbol reference. If no; /// match is possible, this returns true, otherwise it returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp:122,down,down,122,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp,1,['down'],['down']
Availability,"/// MatcherDescriptor that wraps multiple ""overloads"" of the same; /// matcher.; ///; /// It will try every overload and generate appropriate errors for when none or; /// more than one overloads match the arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:142,error,errors,142,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,1,['error'],['errors']
Availability,/// Matches MaskedGather Intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h:12,Mask,MaskedGather,12,interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,1,['Mask'],['MaskedGather']
Availability,/// Matches MaskedLoad Intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h:12,Mask,MaskedLoad,12,interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,1,['Mask'],['MaskedLoad']
Availability,/// Matches ShuffleVectorInst independently of mask value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h:47,mask,mask,47,interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,1,['mask'],['mask']
Availability,"/// Matches the pattern string against the input buffer \p Buffer.; ///; /// \returns either (1) an error resulting in no match or (2) a match possibly; /// with an error encountered while processing the match.; ///; /// The GlobalVariableTable StringMap in the FileCheckPatternContext class; /// instance provides the current values of FileCheck string variables and is; /// updated if this match defines new values. Likewise, the; /// GlobalNumericVariableTable StringMap in the same class provides the; /// current values of FileCheck numeric variables and is updated if this; /// match defines new numeric values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:100,error,error,100,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,2,['error'],['error']
Availability,/// Matches when the selector is the empty selector; ///; /// Matches only when the selector of the objCMessageExpr is NULL. This may; /// represent an error condition in the tree!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h:152,error,error,152,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,1,['error'],['error']
Availability,/// MatchingStackOffset - Return true if the given stack call argument is; /// already available in the same position (relatively) of the caller's; /// incoming argument stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:87,avail,available,87,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,"/// May contain only a subset of all the available clusters, e.g. the clusters of the current file; /// from a chain of files",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:41,avail,available,41,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,1,['avail'],['available']
Availability,"/// Mechanism to add runtime checking of devirtualization decisions, optionally; /// trapping or falling back to indirect call on any that are not correct.; /// Trapping mode is useful for debugging undefined behavior leading to failures; /// with WPD. Fallback mode is useful for ensuring safety when whole program; /// visibility may be compromised.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:229,failure,failures,229,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['failure'],['failures']
Availability,/// MemProf profile schema (if available).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h:31,avail,available,31,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,1,['avail'],['available']
Availability,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:420,redundant,redundant,420,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['redundant'],['redundant']
Availability,"/// Merge a block chain into this one.; ///; /// This routine merges a block chain into this one. It takes care of forming; /// a contiguous sequence of basic blocks, updating the edge list, and; /// updating the block -> chain mapping. It does not free or tear down the; /// old chain, but the old chain's block list is no longer valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:262,down,down,262,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['down'],['down']
Availability,"/// Merge a unified set of type and id records, splitting them into; /// separate output streams.; ///; /// \param DestIds The table to store the re-written id records into.; ///; /// \param DestTypes the table to store the re-written type records into.; ///; /// \param SourceToDest A vector, indexed by the TypeIndex in the source; /// id stream, that contains the index of the corresponding id record; /// in the destination stream.; ///; /// \param IdsAndTypes The collection of id records to merge in.; ///; /// \returns Error::success() if the operation succeeded, otherwise an; /// appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeStreamMerger.h:526,Error,Error,526,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeStreamMerger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeStreamMerger.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// Merge availability attributes for a redeclaration, which requires; /// an exact match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:10,avail,availability,10,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avail'],['availability']
Availability,/// Merge availability attributes for an implementation of; /// a protocol requirement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:10,avail,availability,10,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avail'],['availability']
Availability,/// Merge availability attributes for an implementation of; /// an optional protocol requirement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:10,avail,availability,10,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avail'],['availability']
Availability,"/// Merge availability attributes for an override, which requires; /// an exact match or a weakening of constraints.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:10,avail,availability,10,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avail'],['availability']
Availability,"/// Merge one set of id records into another. This method assumes; /// that all records are id records, and there are no Type records present.; /// However, since Id records can refer back to Type records, this method; /// assumes that the referenced type records have also been merged into; /// another type stream (for example using the above method), and accepts; /// the mapping from source to dest for that stream so that it can re-write; /// the type record mappings accordingly.; ///; /// \param Dest The table to store the re-written id records into.; ///; /// \param Types The mapping to use for the type records that these id; /// records refer to.; ///; /// \param SourceToDest A vector, indexed by the TypeIndex in the source; /// id stream, that contains the index of the corresponding id record; /// in the destination stream.; ///; /// \param Ids The collection of id records to merge in.; ///; /// \returns Error::success() if the operation succeeded, otherwise an; /// appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeStreamMerger.h:923,Error,Error,923,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeStreamMerger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeStreamMerger.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// Merge one set of type records into another. This method assumes; /// that all records are type records, and there are no Id records present.; ///; /// \param Dest The table to store the re-written type records into.; ///; /// \param SourceToDest A vector, indexed by the TypeIndex in the source; /// type stream, that contains the index of the corresponding type record; /// in the destination stream.; ///; /// \param Types The collection of types to merge in.; ///; /// \returns Error::success() if the operation succeeded, otherwise an; /// appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeStreamMerger.h:485,Error,Error,485,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeStreamMerger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeStreamMerger.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// MergeCXXFunctionDecl - Merge two declarations of the same C++; /// function, once we already know that they have the same; /// type. Subroutine of MergeFunctionDecl. Returns true if there was an; /// error, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:204,error,error,204,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['error']
Availability,"/// MergeFunctionDecl - We just parsed a function 'New' from; /// declarator D which has the same name and scope as a previous; /// declaration 'Old'. Figure out how to resolve this situation,; /// merging decls or emitting diagnostics as appropriate.; ///; /// In C++, New and Old must be declarations that are not; /// overloaded. Use IsOverload to determine whether New and Old are; /// overloaded, and to select the Old declaration that New should be; /// merged with.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:512,error,error,512,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"/// MergeTypedefNameDecl - We just parsed a typedef 'New' which has the; /// same name and scope as a previous declaration 'Old'. Figure out; /// how to resolve this situation, merging decls or emitting; /// diagnostics as appropriate. If there was an error, set New to be invalid.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:252,error,error,252,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,/// MergeValues - Compute and return the merge of the two specified lattice; /// values. Merging should only move one direction down the lattice to; /// guarantee convergence (toward overdefined).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:128,down,down,128,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,1,['down'],['down']
Availability,"/// Merges 16-bit integer values from either of the two 256-bit vectors; /// \a V1 or \a V2, as specified by the immediate integer operand \a M,; /// and returns the resulting 256-bit vector of [16 x i16].; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*16; /// IF M[i] == 0; /// result[7+j:j] := V1[7+j:j]; /// result[135+j:128+j] := V1[135+j:128+j]; /// ELSE; /// result[7+j:j] := V2[7+j:j]; /// result[135+j:128+j] := V2[135+j:128+j]; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_blend_epi16(__m256i V1, __m256i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPBLENDW instruction.; ///; /// \param V1; /// A 256-bit vector of [16 x i16] containing source values.; /// \param V2; /// A 256-bit vector of [16 x i16] containing source values.; /// \param M; /// An immediate 8-bit integer operand, with bits [7:0] specifying the; /// source for each element of the result. The position of the mask bit; /// corresponds to the index of a copied value. When a mask bit is 0, the; /// element is copied from \a V1; otherwise, it is copied from \a V2.; /// \a M[0] determines the source for elements 0 and 8, \a M[1] for; /// elements 1 and 9, and so forth.; /// \returns A 256-bit vector of [16 x i16] containing the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:998,mask,mask,998,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['mask'],['mask']
Availability,"/// Merges 32-bit integer elements from either of the two 128-bit vectors of; /// [4 x i32] in \a V1 or \a V2 to the result's 128-bit vector of [4 x i32],; /// as specified by the immediate integer operand \a M.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*32; /// IF M[i] == 0; /// result[31+j:j] := V1[31+j:j]; /// ELSE; /// result[31+j:j] := V2[32+j:j]; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_blend_epi32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPBLENDDD instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing source values.; /// \param V2; /// A 128-bit vector of [4 x i32] containing source values.; /// \param M; /// An immediate 8-bit integer operand, with bits [3:0] specifying the; /// source for each element of the result. The position of the mask bit; /// corresponds to the index of a copied value. When a mask bit is 0, the; /// element is copied from \a V1; otherwise, it is copied from \a V2.; /// \returns A 128-bit vector of [4 x i32] containing the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:916,mask,mask,916,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['mask'],['mask']
Availability,"/// Merges 32-bit integer elements from either of the two 256-bit vectors of; /// [8 x i32] in \a V1 or \a V2 to return a 256-bit vector of [8 x i32],; /// as specified by the immediate integer operand \a M.; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*32; /// IF M[i] == 0; /// result[31+j:j] := V1[31+j:j]; /// ELSE; /// result[31+j:j] := V2[32+j:j]; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_blend_epi32(__m256i V1, __m256i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPBLENDDD instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x i32] containing source values.; /// \param V2; /// A 256-bit vector of [8 x i32] containing source values.; /// \param M; /// An immediate 8-bit integer operand, with bits [7:0] specifying the; /// source for each element of the result. The position of the mask bit; /// corresponds to the index of a copied value. When a mask bit is 0, the; /// element is copied from \a V1; otherwise, it is is copied from \a V2.; /// \returns A 256-bit vector of [8 x i32] containing the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:915,mask,mask,915,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['mask'],['mask']
Availability,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 223, 191, 159, 127, 95, 63,; /// and 31 specifying how the values are to be copied. The position of the; /// mask bit corresponds to the most significant bit of a copied value. When; /// a mask bit is 0, the corresponding 32-bit element in operand \a __a is; /// copied to the same position in the destination. When a mask bit is 1, the; /// corresponding 32-bit element in operand \a __b is copied to the same; /// position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:438,mask,mask,438,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,4,['mask'],['mask']
Availability,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_blend_ps(__m256 V1, __m256 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x float].; /// \param V2; /// A 256-bit vector of [8 x float].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 32-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:534,mask,mask,534,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,4,['mask'],['mask']
Availability,"/// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 191, 127, and 63 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __a is copied to the same; /// position in the destination. When a mask bit is 1, the corresponding; /// 64-bit element in operand \a __b is copied to the same position in the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:441,mask,mask,441,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,4,['mask'],['mask']
Availability,"/// Merges 8-bit integer values from either of the two 256-bit vectors; /// \a __V1 or \a __V2, as specified by the 256-bit mask \a __M and returns; /// the resulting 256-bit integer vector.; ///; /// \code{.operation}; /// FOR i := 0 TO 31; /// j := i*8; /// IF __M[7+i] == 0; /// result[7+j:j] := __V1[7+j:j]; /// ELSE; /// result[7+j:j] := __V2[7+j:j]; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPBLENDVB instruction.; ///; /// \param __V1; /// A 256-bit integer vector containing source values.; /// \param __V2; /// A 256-bit integer vector containing source values.; /// \param __M; /// A 256-bit integer vector, with bit [7] of each byte specifying the; /// source for each corresponding byte of the result. When the mask bit; /// is 0, the byte is copied from \a __V1; otherwise, it is copied from; /// \a __V2.; /// \returns A 256-bit integer vector containing the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:124,mask,mask,124,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['mask'],['mask']
Availability,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,mask,masks,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['masks']
Availability,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,mask,masks,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,5,['mask'],"['mask', 'masks']"
Availability,/// Merging redundant sexts when one is dominating the other.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,redundant,redundant,12,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['redundant'],['redundant']
Availability,/// MinAvailableCycle - Cycle of the soonest available instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:45,avail,available,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avail'],['available']
Availability,/// MinReadyCycle - Cycle of the soonest available instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:41,avail,available,41,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['avail'],['available']
Availability,/// Model the effect of an instruction on the set of available values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:53,avail,available,53,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['avail'],['available']
Availability,"/// Models memory deallocation.; ///; /// \param [in] ArgExpr The variable who's pointee needs to be freed.; /// \param [in] Call The expression that frees the memory.; /// \param [in] State The \c ProgramState right before allocation.; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:859,failure,failure,859,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['failure'],['failure']
Availability,"/// Models memory deallocation.; ///; /// \param [in] Call The expression that frees memory.; /// \param [in] State The \c ProgramState right before allocation.; /// \param [in] Num Index of the argument that needs to be freed. This is; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:859,failure,failure,859,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['failure'],['failure']
Availability,/// Modify the flags via a mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h:27,mask,mask,27,interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h,1,['mask'],['mask']
Availability,"/// Module pass, wrapping the inliner pass. This works in conjunction with the; /// InlineAdvisorAnalysis to facilitate inlining decisions taking into account; /// module-wide state, that need to keep track of inter-inliner pass runs, for; /// a given module. An InlineAdvisor is configured and kept alive for the; /// duration of the ModuleInlinerWrapperPass::run.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Inliner.h:300,alive,alive,300,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Inliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Inliner.h,1,['alive'],['alive']
Availability,/// Most of the errors produced by this module are inconvertible StringErrors.; /// This convenience function lets us return one of those more easily.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:16,error,errors,16,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['error'],['errors']
Availability,"/// Most significant bits used to identify ""Fix"" variants in MessagePack.; ///; /// For example, FixStr objects encode their size in the five least significant; /// bits of their first byte, which is identified by the bit pattern ""101"" in; /// the three most significant bits. So FixBits::String contains 0b10100000.; ///; /// A corresponding mask of the bit pattern is found in \c FixBitsMask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:343,mask,mask,343,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,1,['mask'],['mask']
Availability,/// Move the error field value out of this JITSymbol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h:13,error,error,13,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,1,['error'],['error']
Availability,"/// Move tracking from one reference to another.; ///; /// Semantically equivalent to \c untrack(MD) followed by \c track(New),; /// except that ownership callbacks are maintained.; ///; /// Note: it is an error if \c *MD does not equal \c New.; ///; /// \return true iff tracking is supported by \c MD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h:206,error,error,206,interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h,1,['error'],['error']
Availability,"/// Move-assign an error value. The current error must represent success, you; /// you cannot overwrite an unhandled error. The current error is then; /// considered unchecked. The source error becomes a checked success value,; /// regardless of its original state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:19,error,error,19,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,5,['error'],['error']
Availability,"/// Move-construct an error value. The newly constructed error is considered; /// unchecked, even if the source error had been checked. The original error; /// becomes a checked Success value, regardless of its original state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:22,error,error,22,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,4,['error'],['error']
Availability,"/// Moves double-precision values from a 128-bit vector of [2 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector \a __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [2 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:152,mask,mask,152,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,5,['mask'],['mask']
Availability,"/// Moves double-precision values from a 256-bit vector of [4 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element in the mask vector represents; /// the mask bits. If a mask bit is zero, the corresponding value from vector; /// __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [4 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:152,mask,mask,152,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,5,['mask'],['mask']
Availability,"/// Moves single-precision floating point values from a 128-bit vector; /// of [4 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [4 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:166,mask,mask,166,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,5,['mask'],['mask']
Availability,"/// Multi-threaded top-down builder that partitions primitives using a grid. Multiple instances; /// of a single-threaded builder are run in parallel on that partition, generating many small; /// trees. Finally, a top-level tree is built on these smaller trees to form the final BVH.; /// This builder is inspired by; /// ""Rapid Bounding Volume Hierarchy Generation using Mini Trees"", by P. Ganestam et al.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/mini_tree_builder.h:23,down,down,23,geom/geom/inc/bvh/v2/mini_tree_builder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/mini_tree_builder.h,1,['down'],['down']
Availability,"/// Multiply two APFloats, rounding ties to the nearest even.; /// No error checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:70,error,error,70,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,1,['error'],['error']
Availability,/// Name lookup results in an ambiguity because an entity with a; /// tag name was hidden by an entity with an ordinary name from; /// a different context.; /// @code; /// namespace A { struct Foo {}; }; /// namespace B { void Foo(); }; /// namespace C {; /// using namespace A;; /// using namespace B;; /// }; /// void test() {; /// C::Foo(); // error: tag 'A::Foo' is hidden by an object in a; /// // different namespace; /// }; /// @endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:347,error,error,347,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['error'],['error']
Availability,/// Name lookup results in an ambiguity because multiple definitions; /// of entity that meet the lookup criteria were found in different; /// declaration contexts.; /// @code; /// namespace A {; /// int i;; /// namespace B { int i; }; /// int test() {; /// using namespace B;; /// return i; // error 'i' is found in namespace A and A::B; /// }; /// }; /// @endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:295,error,error,295,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['error'],['error']
Availability,"/// Name lookup results in an ambiguity because multiple; /// entities that meet the lookup criteria were found in; /// subobjects of different types. For example:; /// @code; /// struct A { void f(int); }; /// struct B { void f(double); }; /// struct C : A, B { };; /// void test(C c) {; /// c.f(0); // error: A::f and B::f come from subobjects of different; /// // types. overload resolution is not performed.; /// }; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:304,error,error,304,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['error'],['error']
Availability,"/// Name lookup results in an ambiguity because multiple; /// nonstatic entities that meet the lookup criteria were found; /// in different subobjects of the same type. For example:; /// @code; /// struct A { int x; };; /// struct B : A { };; /// struct C : A { };; /// struct D : B, C { };; /// int test(D d) {; /// return d.x; // error: 'x' is found in two A subobjects (of B and C); /// }; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:332,error,error,332,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['error'],['error']
Availability,"/// Named Registers are named metadata pointing to the register name; /// which will be read from/written to as an argument to the intrinsic; /// @llvm.read/write_register.; /// So far, only the name is being passed down, but other options such as; /// register type, allocation type or even optimization options could be; /// passed down via the metadata node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:216,down,down,216,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,2,['down'],['down']
Availability,/// Next unique number available for a MachineFunction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h:23,avail,available,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h,1,['avail'],['available']
Availability,"/// No compact unwind encoding available. Instead the low 23-bits of; /// the compact unwind encoding is the offset of the DWARF FDE in the; /// __eh_frame section. This mode is never used in object files. It is only; /// generated by the linker in final linked images, which have only DWARF info; /// for a function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp:31,avail,available,31,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp,1,['avail'],['available']
Availability,/// No compact unwind encoding is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:34,avail,available,34,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,1,['avail'],['available']
Availability,/// No error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:7,error,error,7,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['error'],['error']
Availability,/// No error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:7,error,error,7,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['error'],['error']
Availability,/// No errors is found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:7,error,errors,7,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['error'],['errors']
Availability,/// No-op implementation of the TTI interface using the utility base; /// classes.; ///; /// This is used when no target specific information is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:145,avail,available,145,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,1,['avail'],['available']
Availability,/// Non-owning pointer to the file contents.; ///; /// We're using pointer here to keep the size of this class small. Instances; /// representing directories and filesystem errors don't hold any contents; /// anyway.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:173,error,errors,173,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['error'],['errors']
Availability,"/// Normalize the distribution.; ///; /// Combines multiple edges to the same \a Weight::TargetNode and scales; /// down so that \a Total fits into 32-bits.; ///; /// This is linear in the size of \a Weights. For the vast majority of; /// cases, adjacent edge weights are combined by sorting WeightList and; /// combining adjacent weights. However, for very large edge lists an; /// auxiliary hash table is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:116,down,down,116,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,1,['down'],['down']
Availability,/// Notes that BE's global block is available via Addr. Asserts that BE; /// isn't already emitted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:36,avail,available,36,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['avail'],['available']
Availability,"/// Nothing to repair, just drop this action.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:15,repair,repair,15,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,1,['repair'],['repair']
Availability,/// Notifies the target JITDylib (and any pending queries on that JITDylib); /// that all symbols covered by this MaterializationResponsibility instance; /// have been emitted.; ///; /// This method will return an error if any symbols being resolved have been; /// moved to the error state due to the failure of a dependency. If this; /// method returns an error then clients should log it and call; /// failMaterialize. If no dependencies have been registered for the; /// symbols covered by this MaterializationResponsibility then this method; /// is guaranteed to return Error::success() and can be wrapped with cantFail.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:214,error,error,214,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,5,"['Error', 'error', 'failure']","['Error', 'error', 'failure']"
Availability,"/// Notifies the target JITDylib that the given symbols have been resolved.; /// This will update the given symbols' addresses in the JITDylib, and notify; /// any pending queries on the given symbols of their resolution. The given; /// symbols must be ones covered by this MaterializationResponsibility; /// instance. Individual calls to this method may resolve a subset of the; /// symbols, but all symbols must have been resolved prior to calling emit.; ///; /// This method will return an error if any symbols being resolved have been; /// moved to the error state due to the failure of a dependency. If this; /// method returns an error then clients should log it and call; /// failMaterialize. If no dependencies have been registered for the; /// symbols covered by this MaterializationResponsibility then this method; /// is guaranteed to return Error::success() and can be wrapped with cantFail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:493,error,error,493,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,5,"['Error', 'error', 'failure']","['Error', 'error', 'failure']"
Availability,/// Notify DTU that the entry block was replaced.; /// Recalculate all available trees and flush all BasicBlocks; /// awaiting deletion immediately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:71,avail,available,71,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,1,['avail'],['available']
Availability,"/// Notify all not-yet-emitted covered by this MaterializationResponsibility; /// instance that an error has occurred.; /// This will remove all symbols covered by this MaterializationResponsibility; /// from the target JITDylib, and send an error to any queries waiting on; /// these symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:99,error,error,99,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,2,['error'],['error']
Availability,/// Number of Error Bits e,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:14,Error,Error,14,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['Error'],['Error']
Availability,/// Number of bits in a mask element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h:24,mask,mask,24,interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,1,['mask'],['mask']
Availability,/// Number of bits in a mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h:24,mask,mask,24,interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,1,['mask'],['mask']
Availability,/// Number of errors reported,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:14,error,errors,14,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['errors']
Availability,"/// Number of errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx:14,error,errors,14,core/foundation/inc/ROOT/RLogger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx,1,['error'],['errors']
Availability,"/// Number of fatal errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx:20,error,errors,20,core/foundation/inc/ROOT/RLogger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx,1,['error'],['errors']
Availability,/// Number of partial mapping to break down this value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:39,down,down,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['down'],['down']
Availability,"/// Number of samples used from the profile.; ///; /// When a sampling record is used for the first time, the samples from; /// that record are added to this accumulator. Coverage is later computed; /// based on the total number of samples available in this function and; /// its callsites.; ///; /// Note that this accumulator tracks samples used from a single function; /// and all the inlined callsites. Strictly, we should have a map of counters; /// keyed by FunctionSamples pointers, but these stats are cleared after; /// every function, so we just need to keep a single counter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h:240,avail,available,240,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h,1,['avail'],['available']
Availability,"/// ObjCIvarDecl - Represents an ObjC instance variable. In general, ObjC; /// instance variables are identical to C. The only exception is Objective-C; /// supports C++ style access control. For example:; ///; /// \@interface IvarExample : NSObject; /// {; /// id defaultToProtected;; /// \@public:; /// id canBePublic; // same as C++.; /// \@protected:; /// id canBeProtected; // same as C++.; /// \@package:; /// id canBePackage; // framework visibility (not available in C++).; /// }; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:462,avail,available,462,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['avail'],['available']
Availability,"/// Oct2022: No longer doing this because want to allow fitResult to be used to get partial error; // // need to add any floating parameters not included somewhere already in the fit result ...; // RooArgList l;; // for(auto& p : pars()) {; // auto v = p->get<RooRealVar>();; // if (!v) continue;; // if (v->isConstant()) continue;; // if (fr->floatParsFinal().find(v->GetName())) continue;; // if (fr->_constPars && fr->_constPars->find(v->GetName())) continue;; // l.add(*v);; // }; //; // if (!l.empty()) {; // RooArgList l2; l2.addClone(fr->floatParsFinal());; // l2.addClone(l);; // fr->setFinalParList(l2);; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:92,error,error,92,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['error'],['error']
Availability,"/// Oct2022: No longer doing this because want to allow fitResult to be used to get partial error; // // need to add any floating parameters not included somewhere already in the fit result ...; // RooArgList l;; // for(auto& p : pars()) {; // auto vv = p->get<RooRealVar>();; // if (!vv) continue;; // if (vv == dynamic_cast<RooRealVar*>(v)) continue;; // if (vv->isConstant()) continue;; // if (fr->floatParsFinal().find(vv->GetName())) continue;; // if (fr->_constPars && fr->_constPars->find(vv->GetName())) continue;; // l.add(*vv);; // }; //; // if (!l.empty()) {; // RooArgList l2; l2.addClone(fr->floatParsFinal());; // l2.addClone(l);; // fr->setFinalParList(l2);; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:92,error,error,92,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['error'],['error']
Availability,"/// On Unix systems and Windows, this function exits with an ""IO error"" exit; /// code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Signals.h:65,error,error,65,interpreter/llvm-project/llvm/include/llvm/Support/Signals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Signals.h,1,['error'],['error']
Availability,"/// One of Op0/Op1 is a constant expression.; /// Attempt to symbolically evaluate the result of a binary operator merging; /// these together. If target data info is available, it is provided as DL,; /// otherwise DL is null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:167,avail,available,167,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['avail'],['available']
Availability,"/// One specifier in an @available expression.; ///; /// \code; /// @available(macos 10.10, *); /// \endcode; ///; /// Here, 'macos 10.10' and '*' both map to an instance of this type.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Availability.h:25,avail,available,25,interpreter/llvm-project/clang/include/clang/AST/Availability.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Availability.h,2,['avail'],['available']
Availability,/// Only true when all threads are down spawning new threads,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h:35,down,down,35,interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,1,['down'],['down']
Availability,/// Opaque pointer containing additional data about; /// this deduction failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:72,failure,failure,72,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,"/// Open the specified file for reading/writing/seeking. If an error occurs,; /// information about the error is put into EC, and the stream should be; /// immediately destroyed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:63,error,error,63,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,2,['error'],['error']
Availability,"/// Open the specified file for writing. If an error occurs, information; /// about the error is put into EC, and the stream should be immediately; /// destroyed;; /// \p Flags allows optional flags to control how the file will be opened.; ///; /// As a special case, if Filename is ""-"", then the stream will use; /// STDOUT_FILENO instead of opening a file. This will not close the stdout; /// descriptor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:47,error,error,47,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,2,['error'],['error']
Availability,/// Operator - This is a vector operation that is available for use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp:50,avail,available,50,interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,1,['avail'],['available']
Availability,"/// Optimize quickly without destroying debuggability.; ///; /// This level is tuned to produce a result from the optimizer as quickly; /// as possible and to avoid destroying debuggability. This tends to result; /// in a very good development mode where the compiled code will be; /// immediately executed as part of testing. As a consequence, where; /// possible, we would like to produce efficient-to-execute code, but not; /// if it significantly slows down compilation or would prevent even basic; /// debugging of the resulting binary.; ///; /// As an example, complex loop transformations such as versioning,; /// vectorization, or fusion don't make sense here due to the degree to; /// which the executed code differs from the source code, and the compile; /// time cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h:457,down,down,457,interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,1,['down'],['down']
Availability,/// Option names for limiting the codegen pipeline.; /// Those are used in error reporting and we didn't want; /// to duplicate their names all over the place.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:75,error,error,75,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['error'],['error']
Availability,"/// Optional owned invocation, just used to make the invocation used in; /// LoadFromCommandLine available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:97,avail,available,97,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['avail'],['available']
Availability,"/// Optional target hook which partitions \p MBB into outlinable ranges for; /// instruction mapping purposes. Each range is defined by two iterators:; /// [start, end).; ///; /// Ranges are expected to be ordered top-down. That is, ranges closer to the; /// top of the block should come before ranges closer to the end of the block.; ///; /// Ranges cannot overlap.; ///; /// If an entire block is mappable, then its range is [MBB.begin(), MBB.end()); ///; /// All instructions not present in an outlinable range are considered; /// illegal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:218,down,down,218,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['down'],['down']
Availability,"/// Orient p against line v1-v2 2D: robust geometric predicate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/CDTUtils.h:36,robust,robust,36,math/mathcore/src/CDT/CDTUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/CDTUtils.h,1,['robust'],['robust']
Availability,"/// Original IR callsite corresponding to this call, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:56,avail,available,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,1,['avail'],['available']
Availability,"/// Original declaration, used to emit the error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:43,error,error,43,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,1,['error'],['error']
Availability,/// Other error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImportError.h:10,error,error,10,interpreter/llvm-project/clang/include/clang/AST/ASTImportError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImportError.h,1,['error'],['error']
Availability,/// Output (and read) PCM files regardless of compiler errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h:55,error,errors,55,interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,1,['error'],['errors']
Availability,"/// Output all diffs in \p DiffsByFilesPresent using the desired output style.; /// \returns Error::success() on success, and an Error otherwise.; /// \p InputFileNameA - Name of input file A; may be used in the report.; /// \p InputFileNameB - Name of input file B; may be used in the report.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkSizeDiff.cpp:93,Error,Error,93,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkSizeDiff.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkSizeDiff.cpp,2,['Error'],['Error']
Availability,"/// Outputs all instruction count remarks in the file as a CSV.; /// \returns Error::success() on success, and an Error otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkCount.cpp:78,Error,Error,78,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkCount.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkCount.cpp,2,['Error'],['Error']
Availability,/// Owner object. Used for error reporting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:27,error,error,27,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['error'],['error']
Availability,"/// PHITranslateWithInsertion - PHI translate this value into the specified; /// predecessor block, inserting a computation of the value if it is; /// unavailable.; ///; /// All newly created instructions are added to the NewInsts list. This; /// returns null on failure.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:263,failure,failure,263,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,1,['failure'],['failure']
Availability,"/// PPC970_Cracked - This instruction is cracked into two pieces, requiring; /// two dispatch pipes to be available to issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:106,avail,available,106,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,1,['avail'],['available']
Availability,/// Pair of physical register and lane mask.; /// This is not simply a std::pair typedef because the members should be named; /// clearly as they both have an integer type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:39,mask,mask,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['mask'],['mask']
Availability,"/// Paired begin/end actions for all symbols. Receives all record data,; /// including the fixed-length record prefix. visitSymbolBegin() should; /// return the type of the Symbol, or an error if it cannot be determined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/SymbolVisitorCallbacks.h:187,error,error,187,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/SymbolVisitorCallbacks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/SymbolVisitorCallbacks.h,1,['error'],['error']
Availability,"/// Paired begin/end actions for all types. Receives all record data,; /// including the fixed-length record prefix. visitTypeBegin() should return; /// the type of the Record, or an error if it cannot be determined. Exactly; /// one of the two visitTypeBegin methods will be called, depending on whether; /// records are being visited sequentially or randomly. An implementation; /// should be prepared to handle both (or assert if it can't handle random; /// access visitation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeVisitorCallbacks.h:183,error,error,183,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeVisitorCallbacks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeVisitorCallbacks.h,1,['error'],['error']
Availability,/// Parse LLVM Assembly for summary index from a MemoryBuffer.; ///; /// \param F The MemoryBuffer containing assembly with summary; /// \param Err Error result info.; ///; /// parseSummaryIndexAssemblyFile is a wrapper around this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:148,Error,Error,148,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,1,['Error'],['Error']
Availability,/// Parse LLVM Assembly including the summary index from a MemoryBuffer.; ///; /// \param F The MemoryBuffer containing assembly with summary; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; ///; /// parseAssemblyFileWithIndex is a wrapper around this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:158,Error,Error,158,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,1,['Error'],['Error']
Availability,"/// Parse RISC-V ISA info from an arch string that is already in normalized; /// form (as defined in the psABI). Unlike parseArchString, this function; /// will not error for unrecognized extension names or extension versions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/RISCVISAInfo.h:165,error,error,165,interpreter/llvm-project/llvm/include/llvm/Support/RISCVISAInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/RISCVISAInfo.h,1,['error'],['error']
Availability,"/// Parse YAML remarks and reserialize as bitstream remarks.; /// \returns Error::success() on success, and an Error otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkConvert.cpp:75,Error,Error,75,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkConvert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkConvert.cpp,2,['Error'],['Error']
Availability,"/// Parse \p ToParse into a conjunction (logical-and) of range checks; and; /// append them to \p Checks. Returns true on success, may clobber \c Checks; /// on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:161,failure,failure,161,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,1,['failure'],['failure']
Availability,"/// Parse a C++ unqualified-id (or a C identifier), which describes the; /// name of an entity.; ///; /// \code; /// unqualified-id: [C++ expr.prim.general]; /// identifier; /// operator-function-id; /// conversion-function-id; /// [C++0x] literal-operator-id [TODO]; /// ~ class-name; /// template-id; ///; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param AllowDestructorName whether we allow parsing of a destructor name.; ///; /// \param AllowConstructorName whether we allow parsing a constructor name.; ///; /// \param AllowDeductionGuide whether we allow parsing a deduction guide name.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:794,error,errors,794,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['error'],['errors']
Availability,/// Parse a `match` clause for an '#pragma omp declare variant'. Return true; /// if there was an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:98,error,error,98,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['error'],['error']
Availability,/// Parse a data layout string and return the layout. Return an error; /// description on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:64,error,error,64,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Parse a lambda introducer.; /// \param Intro A LambdaIntroducer filled in with information about the; /// contents of the lambda-introducer.; /// \param Tentative If non-null, we are disambiguating between a; /// lambda-introducer and some other construct. In this mode, we do not; /// produce any diagnostics or take any other irreversible action unless; /// we're sure that this is a lambda-expression.; /// \return \c true if parsing (or disambiguation) failed with a diagnostic and; /// the caller should bail out / recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:524,recover,recover,524,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recover']
Availability,"/// Parse a matcher expression.; ///; /// \param MatcherCode The matcher expression to parse.; ///; /// \param S The Sema instance that will help the parser; /// construct the matchers. If null, it uses the default registry.; ///; /// \param NamedValues A map of precomputed named values. This provides; /// the dictionary for the <NamedValue> rule of the grammar.; /// If null, it is ignored.; ///; /// \return The matcher object constructed by the processor, or an empty; /// Optional if an error occurred. In that case, \c Error will contain a; /// description of the error.; /// The caller takes ownership of the DynTypedMatcher object returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Parser.h:493,error,error,493,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Parser.h,3,"['Error', 'error']","['Error', 'error']"
Availability,"/// Parse a module-id.; ///; /// module-id:; /// identifier; /// identifier '.' module-id; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:120,error,error,120,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['error'],['error']
Availability,/// Parse a primary expression.; ///; /// \param Res - The value of the expression. The result is undefined; /// on error.; /// \return - False on success.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h:116,error,error,116,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,1,['error'],['error']
Availability,/// Parse a string \p Asm that starts with a type.; /// \p Read[out] gives the number of characters that have been read to parse; /// the type in \p Asm.; ///; /// \param Slots The optional slot mapping that will restore the parsing state; /// of the module.; /// \return null on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:280,error,error,280,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,1,['error'],['error']
Availability,"/// Parse a textual alias analysis pipeline into the provided AA manager.; ///; /// The format of the textual AA pipeline is a comma separated list of AA; /// pass names:; ///; /// basic-aa,globals-aa,...; ///; /// The AA manager is set up such that the provided alias analyses are tried; /// in the order specified. See the \c AAManaager documentation for details; /// about the logic used. This routine just provides the textual mapping; /// between AA names and the analyses to register with the manager.; ///; /// Returns false if the text cannot be parsed cleanly. The specific state of; /// the \p AA manager is unspecified if such an error is encountered and this; /// returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:641,error,error,641,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['error'],['error']
Availability,"/// Parse a type and a constant value in the given string.; ///; /// The constant value can be any LLVM constant, including a constant; /// expression.; ///; /// \param Slots The optional slot mapping that will restore the parsing state; /// of the module.; /// \return null on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:278,error,error,278,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,1,['error'],['error']
Availability,/// Parse a type in the given string.; ///; /// \param Slots The optional slot mapping that will restore the parsing state; /// of the module.; /// \return null on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:164,error,error,164,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,1,['error'],['error']
Availability,"/// Parse a type name of the form `T[n][m]...` and return the base type `T` and a vector that contains,; /// in order, the declared size for each dimension, e.g. for `unsigned char[1][2][3]` it returns the tuple; /// `{""unsigned char"", {1, 2, 3}}`. Extra whitespace in `typeName` should be removed before calling this function.; ///; /// If `typeName` is not an array type, it returns a tuple `{T, {}}`. On error, it returns a default-constructed tuple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:407,error,error,407,tree/ntuple/v7/src/RField.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx,1,['error'],['error']
Availability,"/// Parse an ARM memory expression, return false if successful else return true; /// or an error. The first token must be a '[' when called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:91,error,error,91,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,"/// Parse an XCOFF Traceback Table from \a Ptr with \a Size bytes.; /// Returns an XCOFFTracebackTable upon successful parsing, otherwise an; /// Error is returned.; ///; /// \param[in] Ptr; /// A pointer that points just past the initial 4 bytes of zeros at the; /// beginning of an XCOFF Traceback Table.; ///; /// \param[in, out] Size; /// A pointer that points to the length of the XCOFF Traceback Table.; /// If the XCOFF Traceback Table is not parsed successfully or there are; /// extra bytes that are not recognized, \a Size will be updated to be the; /// size up to the end of the last successfully parsed field of the table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:146,Error,Error,146,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['Error'],['Error']
Availability,"/// Parse an arbitrary expression of a specified parenthesis depth,; /// assuming that the initial '(' characters have already been consumed.; ///; /// \param ParenDepth - Specifies how many trailing expressions outside the; /// current parentheses we have to parse.; /// \param Res - The value of the expression. The result is undefined; /// on error.; /// \return - False on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h:346,error,error,346,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,1,['error'],['error']
Availability,"/// Parse an arbitrary expression, assuming that an initial '(' has; /// already been consumed.; ///; /// \param Res - The value of the expression. The result is undefined; /// on error.; /// \return - False on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h:180,error,error,180,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,1,['error'],['error']
Availability,/// Parse an arbitrary expression.; ///; /// \param Res - The value of the expression. The result is undefined; /// on error.; /// \return - False on success.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h:119,error,error,119,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,1,['error'],['error']
Availability,/// Parse an expression which must evaluate to an absolute value.; ///; /// \param Res - The value of the absolute expression. The result is undefined; /// on error.; /// \return - False on success.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h:159,error,error,159,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,1,['error'],['error']
Availability,"/// Parse an list of arguments into an InputArgList.; ///; /// The resulting InputArgList will reference the strings in [\p ArgBegin,; /// \p ArgEnd), and their lifetime should extend past that of the returned; /// InputArgList.; ///; /// The only error that can occur in this routine is if an argument is; /// missing values; in this case \p MissingArgCount will be non-zero.; ///; /// \param MissingArgIndex - On error, the index of the option which could; /// not be parsed.; /// \param MissingArgCount - On error, the number of missing options.; /// \param VisibilityMask - Only include options with any of these; /// visibility flags set.; /// \return An InputArgList; on error this will contain all the options; /// which could be parsed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/OptTable.h:248,error,error,248,interpreter/llvm-project/llvm/include/llvm/Option/OptTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/OptTable.h,4,['error'],['error']
Availability,"/// Parse an optional simple-asm-expr and attributes, and attach them to a; /// declarator. Returns true on an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:111,error,error,111,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"/// Parse and store a sequence of CFI instructions from Data,; /// starting at *Offset and ending at EndOffset. *Offset is updated; /// to EndOffset upon successful parsing, or indicates the offset; /// where a problem occurred in case an error is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h:239,error,error,239,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,1,['error'],['error']
Availability,"/// Parse and validate a matcher expression.; /// \return \c true on success, in which case \c Value has the matcher parsed.; /// If the input is malformed, or some argument has an error, it; /// returns \c false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:181,error,error,181,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,1,['error'],['error']
Availability,/// Parse availability query specification.; ///; /// availability-spec:; /// '*'; /// identifier version-tuple,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:10,avail,availability,10,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,2,['avail'],"['availability', 'availability-spec']"
Availability,"/// Parse bitstream remarks and reserialize as YAML remarks.; /// \returns An Error if reserialization fails, or Error::success() on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkConvert.cpp:78,Error,Error,78,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkConvert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkConvert.cpp,2,['Error'],['Error']
Availability,"/// Parse configuration from YAML-formatted text.; ///; /// Style->Language is used to get the base style, if the ``BasedOnStyle``; /// option is present.; ///; /// The FormatStyleSet of Style is reset.; ///; /// When ``BasedOnStyle`` is not present, options not present in the YAML; /// document, are retained in \p Style.; ///; /// If AllowUnknownOptions is true, no errors are emitted if unknown; /// format options are occurred.; ///; /// If set all diagnostics are emitted through the DiagHandler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:369,error,errors,369,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['error'],['errors']
Availability,/// Parse expressions that start with an identifier.; ///; /// This function can parse named values and matchers.; /// In case of failure it will try to determine the user's intent to give; /// an appropriate error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:130,failure,failure,130,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1016,error,errors,1016,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['error'],['errors']
Availability,"/// Parse optional attributes.; ///; /// attributes:; /// attribute attributes; /// attribute; ///; /// attribute:; /// [ identifier ]; ///; /// \param Attrs Will be filled in with the parsed attributes.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:234,error,error,234,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['error'],['error']
Availability,"/// Parse the !find operation. Return null on error.; ///; /// Substr ::= !find(string, string [, start-int]) => int",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:46,error,error,46,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"/// Parse the !foreach and !filter operations. Return null on error.; ///; /// ForEach ::= !foreach(ID, list-or-dag, expr) => list<expr type>; /// Filter ::= !foreach(ID, list, predicate) ==> list<list type>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:62,error,error,62,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"/// Parse the !substr operation. Return null on error.; ///; /// Substr ::= !substr(string, start-int [, length-int]) => string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:48,error,error,48,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,/// Parse the META_BLOCK and fill the available entries.; /// This helper does not check for the validity of the fields.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/BitstreamRemarkParser.h:38,avail,available,38,interpreter/llvm-project/llvm/include/llvm/Remarks/BitstreamRemarkParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/BitstreamRemarkParser.h,1,['avail'],['available']
Availability,/// Parse the REMARK_BLOCK and fill the available entries.; /// This helper does not check for the validity of the fields.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/BitstreamRemarkParser.h:40,avail,available,40,interpreter/llvm-project/llvm/include/llvm/Remarks/BitstreamRemarkParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/BitstreamRemarkParser.h,1,['avail'],['available']
Availability,"/// Parse the SDK information from the SDKSettings.json file.; ///; /// \returns an error if the SDKSettings.json file is invalid, std::nullopt if; /// the SDK has no SDKSettings.json, or a valid \c DarwinSDKInfo otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DarwinSDKInfo.h:84,error,error,84,interpreter/llvm-project/clang/include/clang/Basic/DarwinSDKInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DarwinSDKInfo.h,1,['error'],['error']
Availability,"/// Parse the TableGen file defined within the main buffer of the given; /// SourceMgr. On success, populates the provided RecordKeeper with the parsed; /// records and returns false. On failure, returns true.; ///; /// NOTE: TableGen currently relies on global state within a given parser; /// invocation, so this function is not thread-safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Parser.h:187,failure,failure,187,interpreter/llvm-project/llvm/include/llvm/TableGen/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Parser.h,1,['failure'],['failure']
Availability,"/// Parse the argument to the -ftest-module-file-extension; /// command-line argument.; ///; /// \returns true on error, false on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:114,error,error,114,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['error'],['error']
Availability,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:31,avail,availability,31,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,3,['avail'],"['availability', 'availability-attribute']"
Availability,"/// Parse the current string as an integer of the specified \p Radix. If; /// \p Radix is specified as zero, this does radix autosensing using; /// extended C rules: 0 is octal, 0x is hex, 0b is binary.; ///; /// If the string does not begin with a number of the specified radix,; /// this returns true to signify the error. The string is considered; /// erroneous if empty.; /// The portion of the string representing the discovered numeric value; /// is removed from the beginning of the string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:318,error,error,318,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,1,['error'],['error']
Availability,"/// Parse the current string as an integer of the specified radix. If; /// \p Radix is specified as zero, this does radix autosensing using; /// extended C rules: 0 is octal, 0x is hex, 0b is binary.; ///; /// If the string does not begin with a number of the specified radix,; /// this returns true to signify the error. The string is considered; /// erroneous if empty or if it overflows T.; /// The portion of the string representing the discovered numeric value; /// is removed from the beginning of the string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:315,error,error,315,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,1,['error'],['error']
Availability,"/// Parse the current string as an integer of the specified radix. If; /// \p Radix is specified as zero, this does radix autosensing using; /// extended C rules: 0 is octal, 0x is hex, 0b is binary.; ///; /// If the string is invalid or if only a subset of the string is valid,; /// this returns true to signify the error. The string is considered; /// erroneous if empty or if it overflows T.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:317,error,error,317,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,1,['error'],['error']
Availability,"/// Parse the first top-level declaration in a translation unit.; ///; /// translation-unit:; /// [C] external-declaration; /// [C] translation-unit external-declaration; /// [C++] top-level-declaration-seq[opt]; /// [C++20] global-module-fragment[opt] module-declaration; /// top-level-declaration-seq[opt] private-module-fragment[opt]; ///; /// Note that in C, it is an error if there is no first declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:372,error,error,372,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['error'],['error']
Availability,"/// Parse the given module map file, and record any modules we; /// encounter.; ///; /// \param File The file to be parsed.; ///; /// \param IsSystem Whether this module map file is in a system header; /// directory, and therefore should be considered a system module.; ///; /// \param HomeDir The directory in which relative paths within this module; /// map file will be resolved.; ///; /// \param ID The FileID of the file to process, if we've already entered it.; ///; /// \param Offset [inout] On input the offset at which to start parsing. On; /// output, the offset at which the module map terminated.; ///; /// \param ExternModuleLoc The location of the ""extern module"" declaration; /// that caused us to load this module map file, if any.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:778,error,error,778,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['error'],['error']
Availability,"/// Parse the given plugin command line arguments.; ///; /// \param CI - The compiler instance, for use in reporting diagnostics.; /// \return True if the parsing succeeded; otherwise the plugin will be; /// destroyed and no action run. The plugin is responsible for using the; /// CompilerInstance's Diagnostic object to report errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:329,error,errors,329,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['error'],['errors']
Availability,"/// Parse the given string as a cache pruning policy. Defaults are taken from a; /// default constructed CachePruningPolicy object.; /// For example: ""prune_interval=30s:prune_after=24h:cache_size=50%""; /// which means a pruning interval of 30 seconds, expiration time of 24 hours; /// and maximum cache size of 50% of available disk space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:319,avail,available,319,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,1,['avail'],['available']
Availability,"/// Parse the machine basic block definitions, and skip the machine; /// instructions.; ///; /// This function runs the first parsing pass on the machine function's body.; /// It parses only the machine basic block definitions and creates the machine; /// basic blocks in the given machine function.; ///; /// The machine instructions aren't parsed during the first pass because all; /// the machine basic blocks aren't defined yet - this makes it impossible to; /// resolve the machine basic block references.; ///; /// Return true if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIParser.h:539,error,error,539,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIParser.h,1,['error'],['error']
Availability,/// Parse the machine function in the current YAML document.; ///; ///; /// Return true if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:94,error,error,94,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,1,['error'],['error']
Availability,/// Parse the machine instructions.; ///; /// This function runs the second parsing pass on the machine function's body.; /// It skips the machine basic block definitions and parses only the machine; /// instructions and basic block attributes like liveins and successors.; ///; /// The second parsing pass assumes that the first parsing pass already ran; /// on the given source string.; ///; /// Return true if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIParser.h:416,error,error,416,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIParser.h,1,['error'],['error']
Availability,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:609,error,error,609,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['error'],['error']
Availability,/// Parse the register live-out mask and return a vector of live-out registers; /// that need to be recorded in the stackmap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,1,['mask'],['mask']
Availability,/// Parse the register live-out mask and return a vector of live-out; /// registers that need to be recorded in the stackmap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,1,['mask'],['mask']
Availability,"/// Parse the section specifier indicated by ""Spec"". This is a string that can; /// appear after a .section directive in a mach-o flavored .s file. If; /// successful, this fills in the specified Out parameters and returns an; /// empty string. When an invalid section specifier is present, this returns; /// an Error indicating the problem. If no TAA was parsed, TAA is not altered,; /// and TAAWasSet becomes false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSectionMachO.h:312,Error,Error,312,interpreter/llvm-project/llvm/include/llvm/MC/MCSectionMachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSectionMachO.h,1,['Error'],['Error']
Availability,"/// Parse the source file into a translation unit using the given compiler; /// invocation, replacing the current translation unit.; ///; /// \returns True if a failure occurred that causes the ASTUnit not to; /// contain any translation-unit information, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:161,failure,failure,161,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['failure'],['failure']
Availability,"/// ParseBody - Read the body of a class or def. Return true on error, false on; /// success.; ///; /// Body ::= ';'; /// Body ::= '{' BodyList '}'; /// BodyList BodyItem*; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:64,error,error,64,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"/// ParseCXXCondition - if/switch/while condition expression.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [Clang] type-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; ///; /// In C++1z, a condition may in some contexts be preceded by an; /// optional init-statement. This function will parse that too.; ///; /// \param InitStmt If non-null, an init-statement is permitted, and if present; /// will be parsed and stored here.; ///; /// \param Loc The location of the start of the statement that requires this; /// condition, e.g., the ""for"" in a for loop.; ///; /// \param MissingOK Whether an empty condition is acceptable here. Otherwise; /// it is considered an error to be recovered from.; ///; /// \param FRI If non-null, a for range declaration is permitted, and if; /// present will be parsed and stored here, and a null result will be returned.; ///; /// \param EnterForConditionScope If true, enter a continue/break scope at the; /// appropriate moment for a 'for' loop.; ///; /// \returns The parsed condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1000,error,error,1000,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,2,"['error', 'recover']","['error', 'recovered']"
Availability,"/// ParseCXXIdExpression - Handle id-expression.; ///; /// id-expression:; /// unqualified-id; /// qualified-id; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' identifier; /// '::' operator-function-id; /// '::' template-id; ///; /// NOTE: The standard specifies that, for qualified-id, the parser does not; /// expect:; ///; /// '::' conversion-function-id; /// '::' '~' class-name; ///; /// This may cause a slight inconsistency on diagnostics:; ///; /// class C {};; /// namespace A {}; /// void f() {; /// :: A :: ~ C(); // Some Sema error about using destructor with a; /// // namespace.; /// :: ~ C(); // Some Parser error like 'unexpected ~'.; /// }; ///; /// We simplify the parser a bit and make it work like:; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' unqualified-id; ///; /// That way Sema can handle and report similar errors for namespaces and the; /// global scope.; ///; /// The isAddressOfOperand parameter indicates that this id-expression is a; /// direct operand of the address-of operator. This is, besides member contexts,; /// the only place where a qualified-id naming a non-static class member may; /// appear.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:592,error,error,592,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,3,['error'],"['error', 'errors']"
Availability,/// ParseClassID - Parse and resolve a reference to a class name. This returns; /// null on error.; ///; /// ClassID ::= ID; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:92,error,error,92,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"/// ParseConstraints - Split up the constraint string into the specific; /// constraints and their prefixes. If this returns an empty vector, and if; /// the constraint string itself isn't empty, there was an error parsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InlineAsm.h:209,error,error,209,interpreter/llvm-project/llvm/include/llvm/IR/InlineAsm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InlineAsm.h,1,['error'],['error']
Availability,"/// ParseDecimalOrOctalCommon - This method is called for decimal or octal; /// numbers. It issues an error for illegal digits, and handles floating point; /// parsing. If it detects a floating point number, the radix is set to 10.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:102,error,error,102,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['error'],['error']
Availability,"/// ParseDeclaration - Read a declaration, returning the name of field ID, or an; /// empty string on error. This can happen in a number of different contexts,; /// including within a def or in the template args for a class (in which case; /// CurRec will be non-null) and within the template args for a multiclass (in; /// which case CurRec will be null, but CurMultiClass will be set). This can; /// also happen within a def that is within a multiclass, which will set both; /// CurRec and CurMultiClass.; ///; /// Declaration ::= FIELD? Type ID ('=' Value)?; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:102,error,error,102,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"/// ParseDef - Parse and return a top level or multiclass record definition.; /// Return false if okay, true if error.; ///; /// DefInst ::= DEF ObjectName ObjectBody; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:112,error,error,112,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"/// ParseFile - Main entrypoint for parsing a tblgen file. These parser; /// routines return true on error, or false on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.h:101,error,error,101,interpreter/llvm-project/llvm/lib/TableGen/TGParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.h,1,['error'],['error']
Availability,/// ParseForeach - Parse a for statement. Return the record corresponding; /// to it. This returns true on error.; ///; /// Foreach ::= FOREACH Declaration IN '{ ObjectList '}'; /// Foreach ::= FOREACH Declaration IN Object; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:107,error,error,107,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"/// ParseForeachDeclaration - Read a foreach declaration, returning; /// the name of the declared object or a NULL Init on error. Return; /// the name of the parsed initializer list through ForeachListName.; ///; /// ForeachDeclaration ::= ID '=' '{' RangeList '}'; /// ForeachDeclaration ::= ID '=' RangePiece; /// ForeachDeclaration ::= ID '=' Value; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:123,error,error,123,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"/// ParseGNUAttributes - Parse a non-empty attributes list.; ///; /// [GNU] attributes:; /// attribute; /// attributes attribute; ///; /// [GNU] attribute:; /// '__attribute__' '(' '(' attribute-list ')' ')'; ///; /// [GNU] attribute-list:; /// attrib; /// attribute_list ',' attrib; ///; /// [GNU] attrib:; /// empty; /// attrib-name; /// attrib-name '(' identifier ')'; /// attrib-name '(' identifier ',' nonempty-expr-list ')'; /// attrib-name '(' argument-expression-list [C99 6.5.2] ')'; ///; /// [GNU] attrib-name:; /// identifier; /// typespec; /// typequal; /// storageclass; ///; /// Whether an attribute takes an 'identifier' is determined by the; /// attrib-name. GCC's behavior here is not worth imitating:; ///; /// * In C mode, if the attribute argument list starts with an identifier; /// followed by a ',' or an ')', and the identifier doesn't resolve to; /// a type, it is parsed as an identifier. If the attribute actually; /// wanted an expression, it's out of luck (but it turns out that no; /// attributes work that way, because C constant expressions are very; /// limited).; /// * In C++ mode, if the attribute argument list starts with an identifier,; /// and the attribute *wants* an identifier, it is parsed as an identifier.; /// At block scope, any additional tokens between the identifier and the; /// ',' or ')' are ignored, otherwise they produce a parse error.; ///; /// We follow the C++ model, but don't allow junk after the identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:1386,error,error,1386,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"/// ParseImplicitInt - This method is called when we have an non-typename; /// identifier in a declspec (which normally terminates the decl spec) when; /// the declspec has no type specifier. In this case, the declspec is either; /// malformed or is ""implicit int"" (in K&R and C89).; ///; /// This method handles diagnosing this prettily and returns false if the; /// declspec is done being processed. If it recovers and thinks there may be; /// other pieces of declspec after it, it returns true.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:408,recover,recovers,408,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recovers']
Availability,"/// ParseInstruction - Parse one assembly instruction.; ///; /// The parser is positioned following the instruction name. The target; /// specific instruction parser should parse the entire instruction and; /// construct the appropriate MCInst, or emit an error. On success, the entire; /// line should be parsed up to and including the end-of-statement token. On; /// failure, the parser is not required to read to the end of the line.; //; /// \param Name - The instruction name.; /// \param NameLoc - The source location of the name.; /// \param Operands [out] - The list of parsed operands, this returns; /// ownership of them to the caller.; /// \return True on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h:256,error,error,256,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,3,"['error', 'failure']","['error', 'failure']"
Availability,/// ParseMultiClassID - Parse and resolve a reference to a multiclass name.; /// This returns null on error.; ///; /// MultiClassID ::= ID; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:102,error,error,102,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"/// ParseObjectName - If a valid object name is specified, return it. If no; /// name is specified, return the unset initializer. Return nullptr on parse; /// error.; /// ObjectName ::= Value [ '#' Value ]*; /// ObjectName ::= /*empty*/; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:159,error,error,159,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,/// ParseOperation - Parse an operator. This returns null on error.; ///; /// Operation ::= XOperator ['<' Type '>'] '(' Args ')'; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:61,error,error,61,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,/// ParseOperatorType - Parse a type for an operator. This returns; /// null on error.; ///; /// OperatorType ::= '<' Type '>'; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:80,error,error,80,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:184,error,error,184,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,6,"['error', 'recover']","['error', 'errors', 'recover', 'recovery']"
Availability,"/// ParseSimpleValue - Parse a tblgen value. This returns null on error.; ///; /// SimpleValue ::= IDValue; /// SimpleValue ::= INTVAL; /// SimpleValue ::= STRVAL+; /// SimpleValue ::= CODEFRAGMENT; /// SimpleValue ::= '?'; /// SimpleValue ::= '{' ValueList '}'; /// SimpleValue ::= ID '<' ValueListNE '>'; /// SimpleValue ::= '[' ValueList ']'; /// SimpleValue ::= '(' IDValue DagArgList ')'; /// SimpleValue ::= CONCATTOK '(' Value ',' Value ')'; /// SimpleValue ::= ADDTOK '(' Value ',' Value ')'; /// SimpleValue ::= DIVTOK '(' Value ',' Value ')'; /// SimpleValue ::= SUBTOK '(' Value ',' Value ')'; /// SimpleValue ::= SHLTOK '(' Value ',' Value ')'; /// SimpleValue ::= SRATOK '(' Value ',' Value ')'; /// SimpleValue ::= SRLTOK '(' Value ',' Value ')'; /// SimpleValue ::= LISTCONCATTOK '(' Value ',' Value ')'; /// SimpleValue ::= LISTSPLATTOK '(' Value ',' Value ')'; /// SimpleValue ::= LISTREMOVETOK '(' Value ',' Value ')'; /// SimpleValue ::= RANGE '(' Value ')'; /// SimpleValue ::= RANGE '(' Value ',' Value ')'; /// SimpleValue ::= RANGE '(' Value ',' Value ',' Value ')'; /// SimpleValue ::= STRCONCATTOK '(' Value ',' Value ')'; /// SimpleValue ::= COND '(' [Value ':' Value,]+ ')'; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:66,error,error,66,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,/// ParseSubClassReference - Parse a reference to a subclass or a; /// multiclass. This returns a SubClassRefTy with a null Record* on error.; ///; /// SubClassRef ::= ClassID; /// SubClassRef ::= ClassID '<' ArgValueList '>'; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:135,error,error,135,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,/// ParseSubMultiClassReference - Parse a reference to a subclass or to a; /// templated submulticlass. This returns a SubMultiClassRefTy with a null; /// Record* on error.; ///; /// SubMultiClassRef ::= MultiClassID; /// SubMultiClassRef ::= MultiClassID '<' ArgValueList '>'; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:166,error,error,166,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"/// ParseTemplateArgumentList - Parse a C++ template-argument-list; /// (C++ [temp.names]). Returns true if there was an error.; ///; /// template-argument-list: [C++ 14.2]; /// template-argument; /// template-argument-list ',' template-argument; ///; /// \param Template is only used for code completion, and may be null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:121,error,error,121,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['error'],['error']
Availability,"/// ParseTemplateParameters - Parses a template-parameter-list enclosed in; /// angle brackets. Depth is the depth of this template-parameter-list, which; /// is the number of template headers directly enclosing this template header.; /// TemplateParams is the current list of template parameters we're building.; /// The template parameter we parse will be added to this list. LAngleLoc and; /// RAngleLoc will receive the positions of the '<' and '>', respectively,; /// that enclose this template parameter list.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:546,error,error,546,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['error'],['error']
Availability,/// ParseType - Parse and return a tblgen type. This returns null on error.; ///; /// Type ::= STRING // string type; /// Type ::= CODE // code type; /// Type ::= BIT // bit type; /// Type ::= BITS '<' INTVAL '>' // bits<x> type; /// Type ::= INT // int type; /// Type ::= LIST '<' Type '>' // list<x> type; /// Type ::= DAG // dag type; /// Type ::= ClassID // Record Type; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:69,error,error,69,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,/// ParseValue - Parse a TableGen value. This returns null on error.; ///; /// Value ::= SimpleValue ValueSuffix*; /// ValueSuffix ::= '{' BitList '}'; /// ValueSuffix ::= '[' SliceElements ']'; /// ValueSuffix ::= '.' ID; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:62,error,error,62,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"/// Parses AVX512 specific operand primitives: masked registers ({%k<NUM>}, {z}); /// and memory broadcasting ({1to<NUM>}) primitives, updating Operands vector if required.; /// return false if no parsing errors occurred, true otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:47,mask,masked,47,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,2,"['error', 'mask']","['errors', 'masked']"
Availability,/// Parses MachineFunctions in the MIR file and add them to the given; /// MachineModuleInfo \p MMI.; ///; /// \returns true if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h:131,error,error,131,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h,1,['error'],['error']
Availability,"/// Parses \p Expr for a numeric substitution block at line \p LineNumber,; /// or before input is parsed if \p LineNumber is None. Parameter; /// \p IsLegacyLineExpr indicates whether \p Expr should be a legacy @LINE; /// expression and \p Context points to the class instance holding the live; /// string and numeric variables. \returns a pointer to the class instance; /// representing the expression whose value must be substitued, or an error; /// holding a diagnostic against \p SM if parsing fails. If substitution was; /// successful, sets \p DefinedNumericVariable to point to the class; /// representing the numeric variable defined in this numeric substitution; /// block, or std::nullopt if this block does not define any variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:442,error,error,442,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,"/// Parses \p Expr for an argument list belonging to a call to function \p; /// FuncName at line \p LineNumber, or before input is parsed if \p LineNumber; /// is None. Parameter \p FuncLoc is the source location used for diagnostics.; /// Parameter \p Context points to the class instance holding the live string; /// and numeric variables. \returns the class representing that call in the; /// AST of the expression or an error holding a diagnostic against \p SM; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:424,error,error,424,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,"/// Parses \p Expr for the name of a numeric variable to be defined at line; /// \p LineNumber, or before input is parsed if \p LineNumber is None.; /// \returns a pointer to the class instance representing that variable,; /// creating it if needed, or an error holding a diagnostic against \p SM; /// should defining such a variable be invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:256,error,error,256,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,"/// Parses \p Expr for use of a numeric operand at line \p LineNumber, or; /// before input is parsed if \p LineNumber is None. Accepts literal values,; /// numeric variables and function calls, depending on the value of \p AO.; /// \p MaybeInvalidConstraint indicates whether the text being parsed could; /// be an invalid constraint. \p Context points to the class instance holding; /// the live string and numeric variables. \returns the class representing; /// that operand in the AST of the expression or an error holding a; /// diagnostic against \p SM otherwise. If \p Expr starts with a ""("" this; /// function will attempt to parse a parenthesized expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:513,error,error,513,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,"/// Parses \p Name as a (pseudo if \p IsPseudo is true) numeric variable use; /// at line \p LineNumber, or before input is parsed if \p LineNumber is; /// None. Parameter \p Context points to the class instance holding the live; /// string and numeric variables. \returns the pointer to the class instance; /// representing that variable if successful, or an error holding a; /// diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:360,error,error,360,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,/// Parses a command line argument into a mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/XRayInstr.h:42,mask,mask,42,interpreter/llvm-project/clang/include/clang/Basic/XRayInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/XRayInstr.h,1,['mask'],['mask']
Availability,"/// Parses a parenthesized expression inside \p Expr at line \p LineNumber, or; /// before input is parsed if \p LineNumber is None. \p Expr must start with; /// a '('. Accepts both literal values and numeric variables. Parameter \p; /// Context points to the class instance holding the live string and numeric; /// variables. \returns the class representing that operand in the AST of the; /// expression or an error holding a diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:412,error,error,412,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,"/// Parses a target-specific assembler directive.; ///; /// The parser is positioned following the directive name. The target-specific; /// directive parser should parse the entire directive doing or recording any; /// target-specific work, or emit an error. On success, the entire line should; /// be parsed up to and including the end-of-statement token. On failure, the; /// parser is not required to read to the end of the line. If the directive is; /// not target-specific, no tokens should be consumed and NoMatch is returned.; ///; /// \param DirectiveID - The token identifying the directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h:252,error,error,252,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Parses all remarks in the input YAML file.; /// \p [out] ParsedRemarks - Filled with remarks parsed from the input file.; /// \p [out] StrTab - A string table populated for later remark serialization.; /// \returns Error::success() if all remarks were successfully parsed, and an; /// Error otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkConvert.cpp:219,Error,Error,219,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkConvert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkConvert.cpp,2,['Error'],['Error']
Availability,/// Parses and returns the DebugMaps of the input binary. The binary contains; /// multiple maps in case it is a universal binary.; /// \returns an error in case the provided BinaryPath doesn't exist; /// or isn't of a supported type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:148,error,error,148,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,1,['error'],['error']
Availability,"/// Parses and updates \p RemainingExpr for a binary operation at line; /// \p LineNumber, or before input is parsed if \p LineNumber is None. The; /// left operand of this binary operation is given in \p LeftOp and \p Expr; /// holds the string for the full expression, including the left operand.; /// Parameter \p IsLegacyLineExpr indicates whether we are parsing a legacy; /// @LINE expression. Parameter \p Context points to the class instance; /// holding the live string and numeric variables. \returns the class; /// representing the binary operation in the AST of the expression, or an; /// error holding a diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:600,error,error,600,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,"/// Parses the ""-selection"" command-line argument.; ///; /// \returns true on error, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:78,error,error,78,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,1,['error'],['error']
Availability,/// Parses the command line options into the LinkOptions struct and performs; /// some sanity checking. Returns an error in case the latter fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:115,error,error,115,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,1,['error'],['error']
Availability,/// Parses the database file and creates the index.; ///; /// Returns whether parsing succeeded. Sets ErrorMessage if parsing; /// failed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:102,Error,ErrorMessage,102,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,1,['Error'],['ErrorMessage']
Availability,"/// Parses the optional LLVM IR module in the MIR file.; ///; /// A new, empty module is created if the LLVM IR isn't present.; /// \returns nullptr if a parsing error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h:162,error,error,162,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h,1,['error'],['error']
Availability,"/// Parses the pattern in \p PatternStr and initializes this Pattern instance; /// accordingly.; ///; /// \p Prefix provides which prefix is being matched, \p Req describes the; /// global options that influence the parsing such as whitespace; /// canonicalization, \p SM provides the SourceMgr used for error reports.; /// \returns true in case of an error, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:304,error,error,304,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,2,['error'],['error']
Availability,"/// Parses the special case list entries from files. On failure, reports a; /// fatal error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SpecialCaseList.h:56,failure,failure,56,interpreter/llvm-project/llvm/include/llvm/Support/SpecialCaseList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SpecialCaseList.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Parses the special case list entries from files. On failure, returns; /// 0 and writes an error message to string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SpecialCaseList.h:56,failure,failure,56,interpreter/llvm-project/llvm/include/llvm/Support/SpecialCaseList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SpecialCaseList.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Parses the special case list from a memory buffer. On failure, returns; /// 0 and writes an error message to string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SpecialCaseList.h:58,failure,failure,58,interpreter/llvm-project/llvm/include/llvm/Support/SpecialCaseList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SpecialCaseList.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Parses the string at the start of \p Str for a variable name. \returns; /// a VariableProperties structure holding the variable name and whether it; /// is the name of a pseudo variable, or an error holding a diagnostic; /// against \p SM if parsing fail. If parsing was successful, also strips; /// \p Str from the variable name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:197,error,error,197,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1062,error,error,1062,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,3,"['error', 'mask']","['error', 'masked']"
Availability,"/// Pass the ErrorInfo(s) contained in E to their respective handlers. Any; /// unhandled errors (or Errors returned by handlers) are re-concatenated and; /// returned.; /// Because this function returns an error, its result must also be checked; /// or returned. If you intend to handle all errors use handleAllErrors; /// (which returns void, and will abort() on unhandled errors) instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:13,Error,ErrorInfo,13,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,6,"['Error', 'error']","['ErrorInfo', 'Errors', 'error', 'errors']"
Availability,/// Pass the SDK version to the compiler when the SDK information is; /// available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:74,avail,available,74,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['avail'],['available']
Availability,/// Pass the target variant SDK version to the compiler when the SDK; /// information is available and is required for target variant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:89,avail,available,89,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['avail'],['available']
Availability,"/// PendingQueue - This contains all of the instructions whose operands have; /// been issued, but their results are not ready yet (due to the latency of; /// the operation). Once the operands become available, the instruction is; /// added to the AvailableQueue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp:200,avail,available,200,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,2,"['Avail', 'avail']","['AvailableQueue', 'available']"
Availability,"/// PendingQueue - This contains all of the instructions whose operands have; /// been issued, but their results are not ready yet (due to the latency of; /// the operation). Once the operands becomes available, the instruction is; /// added to the AvailableQueue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:201,avail,available,201,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,4,"['Avail', 'avail']","['AvailableQueue', 'available']"
Availability,"/// Per-value info for LI. The lane bit masks are all relative to the final; /// joined register, so they can be compared directly between SrcReg and; /// DstReg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:40,mask,masks,40,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['mask'],['masks']
Availability,"/// Perform ODR-like check for C/ObjC when merging tag types from modules.; /// Differently from C++, actually parse the body and reject / error out; /// in case of a structural mismatch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:139,error,error,139,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// Perform a atomicrmw expansion using a target-specific way. This is; /// expected to be called when masked atomicrmw and bit test atomicrmw don't; /// work, and the target supports another way to lower atomicrmw.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:103,mask,masked,103,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['mask'],['masked']
Availability,/// Perform a cast towards the class of the Decl (either up or down the; /// hierarchy).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:63,down,down,63,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['down'],['down']
Availability,"/// Perform a control flow join (lattice value meet) of the values in machine; /// locations at \p MBB. Follows the algorithm described in the file-comment,; /// reading live-outs of predecessors from \p OutLocs, the current live ins; /// from \p InLocs, and assigning the newly computed live ins back into; /// \p InLocs. \returns two bools -- the first indicates whether a change; /// was made, the second whether a lattice downgrade occurred. If the latter; /// is true, revisiting this block is necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:426,down,downgrade,426,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['down'],['downgrade']
Availability,/// Perform a masked atomicrmw using a target-specific intrinsic. This; /// represents the core LL/SC loop which will be lowered at a late stage by; /// the backend. The target-specific intrinsic returns the loaded value and; /// is not responsible for masking and shifting the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:14,mask,masked,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['mask'],"['masked', 'masking']"
Availability,/// Perform a masked cmpxchg using a target-specific intrinsic. This; /// represents the core LL/SC loop which will be lowered at a late stage by; /// the backend. The target-specific intrinsic returns the loaded value and; /// is not responsible for masking and shifting the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:14,mask,masked,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['mask'],"['masked', 'masking']"
Availability,"/// Perform all actions needed to make the code owned by this RuntimeDyld; /// instance executable:; ///; /// 1) Apply relocations.; /// 2) Register EH frames.; /// 3) Update memory permissions*.; ///; /// * Finalization is potentially recursive**, and the 3rd step will only be; /// applied by the outermost call to finalize. This allows different; /// RuntimeDyld instances to share a memory manager without the innermost; /// finalization locking the memory and causing relocation fixup errors in; /// outer instances.; ///; /// ** Recursive finalization occurs when one RuntimeDyld instances needs the; /// address of a symbol owned by some other instance in order to apply; /// relocations.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:490,error,errors,490,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['error'],['errors']
Availability,"/// Perform any debug-info specific maintenence for the given splice; /// activity. In the DPValue debug-info representation, debug-info is not; /// in instructions, and so it does not automatically move from one block; /// to another.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h:36,mainten,maintenence,36,interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,1,['mainten'],['maintenence']
Availability,"/// Perform initialization based on the user configured; /// set of features (e.g., +sse4).; ///; /// The list is guaranteed to have at most one entry per feature.; ///; /// The target may modify the features list, to change which options are; /// passed onwards to the backend.; /// FIXME: This part should be fixed so that we can change handleTargetFeatures; /// to merely a TargetInfo initialization routine.; ///; /// \return False on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:439,error,error,439,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['error'],['error']
Availability,"/// Perform semantic checking of a new function declaration.; ///; /// Performs semantic analysis of the new function declaration; /// NewFD. This routine performs all semantic checking that does not; /// require the actual declarator involved in the declaration, and is; /// used both for the declaration of functions as they are parsed; /// (called via ActOnDeclarator) and for the declaration of functions; /// that have been instantiated via C++ template instantiation (called; /// via InstantiateDecl).; ///; /// \param IsMemberSpecialization whether this new function declaration is; /// a member specialization (that replaces any definition provided by the; /// previous declaration).; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// \returns true if the function declaration is a redeclaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:759,error,error,759,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:451,error,error,451,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"/// Perform several checks on the arguments of @llvm.get.active.lane.mask; /// intrinsic. E.g., check that the loop induction variable and the element; /// count are of the form we expect, and also perform overflow checks for; /// the new expressions that are created.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:69,mask,mask,69,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,1,['mask'],['mask']
Availability,"/// Perform substitution on the base class specifiers of the; /// given class template specialization.; ///; /// Produces a diagnostic and returns true on error, returns false and; /// attaches the instantiated base classes to the class template; /// specialization if successful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:155,error,error,155,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['error'],['error']
Availability,"/// Perform the action using Records, and write output to OS.; /// Returns true on error, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Main.h:83,error,error,83,interpreter/llvm-project/llvm/include/llvm/TableGen/Main.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Main.h,1,['error'],['error']
Availability,/// Perform the relevant checks on the loop and convert active lane masks if; /// possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:68,mask,masks,68,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,1,['mask'],['masks']
Availability,"/// Perform two related transforms whose purpose is to incrementally recognize; /// an explode_vector followed by scalar reduction as a vector reduction node.; /// This exists to recover from a deficiency in SLP which can't handle; /// forests with multiple roots sharing common nodes. In some cases, one; /// of the trees will be vectorized, and the other will remain (unprofitably); /// scalarized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:179,recover,recover,179,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['recover'],['recover']
Availability,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType by following the standard; /// conversion sequence SCS. Returns the converted; /// expression. Flavor is the context in which we're performing this; /// conversion, for use in error messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:286,error,error,286,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['error'],['error']
Availability,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType using the pre-computed implicit; /// conversion sequence ICS. Returns the converted; /// expression. Action is the kind of conversion we're performing,; /// used in the error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:279,error,error,279,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['error'],['error']
Availability,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType. Returns the; /// converted expression. Flavor is the kind of conversion we're; /// performing, used in the error message. If @p AllowExplicit,; /// explicit user-defined conversions are permitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:218,error,error,218,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:129,mask,mask,129,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,5,['mask'],['mask']
Availability,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:129,mask,mask,129,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,5,['mask'],['mask']
Availability,"/// Performs dataflow analysis and returns a mapping from basic block IDs to; /// dataflow analysis states that model the respective basic blocks. Indices of; /// the returned vector correspond to basic block IDs. Returns an error if the; /// dataflow analysis cannot be performed successfully. Otherwise, calls; /// `PostVisitCFG` on each CFG element with the final analysis results at that; /// program point.; ///; /// `MaxBlockVisits` caps the number of block visits during analysis. It doesn't; /// distinguish between repeat visits to the same block and visits to distinct; /// blocks. This parameter is a backstop to prevent infinite loops, in the case; /// of bugs in the lattice and/or transfer functions that prevent the analysis; /// from converging.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.h:225,error,error,225,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.h,1,['error'],['error']
Availability,"/// Performs dataflow analysis and returns a mapping from basic block IDs to; /// dataflow analysis states that model the respective basic blocks. The; /// returned vector, if any, will have the same size as the number of CFG; /// blocks, with indices corresponding to basic block IDs. Returns an error if; /// the dataflow analysis cannot be performed successfully. Otherwise, calls; /// `PostVisitCFG` on each CFG element with the final analysis results at that; /// program point.; ///; /// `MaxBlockVisits` caps the number of block visits during analysis. See; /// `runTypeErasedDataflowAnalysis` for a full description. The default value is; /// essentially arbitrary -- large enough to accommodate what seems like any; /// reasonable CFG, but still small enough to limit the cost of hitting the; /// limit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h:297,error,error,297,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h,1,['error'],['error']
Availability,"/// Performs operation and \returns its result or an error in case of failure,; /// such as if an overflow occurs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:53,error,error,53,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Performs the Request, passing response data to the Handler. Returns all; /// errors which occur during the request. Aborts if an error is returned by a; /// Handler method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h:81,error,errors,81,interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,2,['error'],"['error', 'errors']"
Availability,"/// Performs the initial survey of the specified function, checking out whether; /// it uses any of its incoming arguments or whether any callers use the return; /// value. This fills in the LiveValues set and Uses map.; ///; /// We consider arguments of non-internal functions to be intrinsically alive as; /// well as arguments to functions which have their ""address taken"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:298,alive,alive,298,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['alive'],['alive']
Availability,"/// Permanently loads the library at the given path and, on success, returns; /// a DynamicLibrarySearchGenerator that will search it for symbol definitions; /// in the library. On failure returns the reason the library failed to load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.h:181,failure,failure,181,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.h,2,['failure'],['failure']
Availability,"/// Permanently loads the library at the given path and, on success, returns; /// a DynamicLibrarySearchGenerator that will search it for symbol definitions; /// in the library. On failure returns the reason the library failed to load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp:181,failure,failure,181,interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,1,['failure'],['failure']
Availability,"/// Permissive - True when recovering from errors, in which case precautions; /// are taken to handle incomplete scope information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:27,recover,recovering,27,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,2,"['error', 'recover']","['errors', 'recovering']"
Availability,"/// Phi instructions will eventually be lowered to copy instructions.; /// If phi is in a loop header, a recurrence may formulated around the source; /// and destination of the phi. For such case commuting operands of the; /// instructions in the recurrence may enable coalescing of the copy instruction; /// generated from the phi. For example, if there is a recurrence of; ///; /// LoopHeader:; /// %1 = phi(%0, %100); /// LoopLatch:; /// %0<def, tied1> = ADD %2<def, tied0>, %1; ///; /// , the fact that %0 and %2 are in the same tied operands set makes; /// the coalescing of copy instruction generated from the phi in; /// LoopHeader(i.e. %1 = COPY %0) impossible, because %1 and; /// %2 have overlapping live range. This introduces additional move; /// instruction to the final assembly. However, if we commute %2 and; /// %1 of ADD instruction, the redundant move instruction can be; /// avoided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:856,redundant,redundant,856,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['redundant'],['redundant']
Availability,"/// Plotting engine function for internal use; ///; /// Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; /// function that occur in the previously plotted dataset are projected via partial integration,; /// otherwise no projections are performed. Optionally, certain projections can be performed; /// by summing over the values present in a provided dataset ('projData'), to correctly; /// project out data dependents that are not properly described by the PDF (e.g. per-event errors).; ///; /// The functions value can be multiplied with an optional scale factor. The interpretation; /// of the scale factor is unique for generic real functions, for PDFs there are various interpretations; /// possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; ///; /// The default projection behaviour can be overridden by supplying an optional set of dependents; /// to project via RooFit command arguments.; //_____________________________________________________________________________; // coverity[PASS_BY_VALUE]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:521,error,errors,521,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['error'],['errors']
Availability,"/// Pointer to a new[]'d array of declarations that need to be available; /// for lookup inside the function body, if one exists. Does not exist in; /// C++.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h:63,avail,available,63,interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,1,['avail'],['available']
Availability,"/// Pointer to the ExecuteCC1Tool function, if available.; /// When the clangDriver lib is used through clang.exe, this provides a; /// shortcut for executing the -cc1 command-line directly, in the same; /// process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:47,avail,available,47,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['avail'],['available']
Availability,/// Pointer to the parser's SMLoc if available. This is used to provide; /// locations for diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:37,avail,available,37,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['avail'],['available']
Availability,"/// PointerIntPair - This class implements a pair of a pointer and small; /// integer. It is designed to represent this in the space required by one; /// pointer by bitmangling the integer into the low part of the pointer. This; /// can only be done for small integers: typically up to 3 bits, but it depends; /// on the number of bits available according to PointerLikeTypeTraits for the; /// type.; ///; /// Note that PointerIntPair always puts the IntVal part in the highest bits; /// possible. For example, PointerIntPair<void*, 1, bool> will put the bit for; /// the bool into bit #2, not bit #0, which allows the low two bits to be used; /// for something else. For example, this allows:; /// PointerIntPair<PointerIntPair<void*, 1, bool>, 1, bool>; /// ... and the two bools will land in different bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h:336,avail,available,336,interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h,1,['avail'],['available']
Availability,/// Points to the deallocation function used in case of error. May be null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:56,error,error,56,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['error'],['error']
Availability,/// Populate UP with analysis pass that are used or required by; /// pass P and are available. Populate RP_NotAvail with analysis; /// pass that are required by pass P but are not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:84,avail,available,84,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,2,['avail'],['available']
Availability,/// Populate UsedPasses with analysis pass that are used or required by pass; /// P and are available. Populate ReqPassNotAvailable with analysis pass that; /// are required by pass P but are not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:92,avail,available,92,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,2,['avail'],['available']
Availability,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:666,redundant,redundant,666,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['redundant'],['redundant']
Availability,"/// Populates vector Masks with processor resource masks.; ///; /// The number of bits set in a mask depends on the processor resource type.; /// Each processor resource mask has at least one bit set. For groups, the; /// number of bits set in the mask is equal to the cardinality of the group plus; /// one. Excluding the most significant bit, the remaining bits in the mask; /// identify processor resources that are part of the group.; ///; /// Example:; ///; /// ResourceA -- Mask: 0b001; /// ResourceB -- Mask: 0b010; /// ResourceAB -- Mask: 0b100 U (ResourceA::Mask | ResourceB::Mask) == 0b111; ///; /// ResourceAB is a processor resource group containing ResourceA and ResourceB.; /// Each resource mask uniquely identifies a resource; both ResourceA and; /// ResourceB only have one bit set.; /// ResourceAB is a group; excluding the most significant bit in the mask, the; /// remaining bits identify the composition of the group.; ///; /// Resource masks are used by the ResourceManager to solve set membership; /// problems with simple bit manipulation operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Support.h:21,Mask,Masks,21,interpreter/llvm-project/llvm/include/llvm/MCA/Support.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Support.h,14,"['Mask', 'mask']","['Mask', 'Masks', 'mask', 'masks']"
Availability,"/// PragmaMessageHandler - Handle the microsoft and gcc \#pragma message; /// extension. The syntax is:; /// \code; /// #pragma message(string); /// \endcode; /// OR, in GCC mode:; /// \code; /// #pragma message string; /// \endcode; /// string is a string, which is fully macro expanded, and permits string; /// concatenation, embedded escape characters, etc... See MSDN for more details.; /// Also handles \#pragma GCC warning and \#pragma GCC error which take the same; /// form as \#pragma message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:446,error,error,446,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['error'],['error']
Availability,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:920,recover,recover,920,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['recover'],['recover']
Availability,/// Prepare a memory buffer for the contents of \p Filename.; ///; /// \returns an error code indicating the status of the buffer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp:83,error,error,83,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,1,['error'],['error']
Availability,"/// Prepare file reports for each directory in \p SourceFiles. The total; /// report for all files is returned and its Name is set to the LCP of all; /// files. The size of \p SourceFiles must be greater than 1 or else the; /// behavior is undefined, in which case you should use; /// CoverageReport::prepareSingleFileReport instead. If an error occurs,; /// the recursion will stop immediately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h:340,error,error,340,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h,1,['error'],['error']
Availability,"/// Prepare the action for processing the input file \p Input.; ///; /// This is run after the options and frontend have been initialized,; /// but prior to executing any per-file processing.; ///; /// \param CI - The compiler instance this action is being run from. The; /// action may store and use this object up until the matching EndSourceFile; /// action.; ///; /// \param Input - The input filename and kind. Some input kinds are handled; /// specially, for example AST inputs, since the AST file itself contains; /// several objects which would normally be owned by the; /// CompilerInstance. When processing AST input files, these objects should; /// generally not be initialized in the CompilerInstance -- they will; /// automatically be shared with the AST file in between; /// BeginSourceFile() and EndSourceFile().; ///; /// \return True on success; on failure the compilation of this file should; /// be aborted and neither Execute() nor EndSourceFile() should be called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:866,failure,failure,866,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['failure'],['failure']
Availability,"/// Prepares the program state for array destruction. If no error happens; /// the function binds a 'PendingArrayDestruction' entry to the state, which; /// it returns along with the index. If any error happens (we fail to read; /// the size, the index would be -1, etc.) the function will return the; /// original state along with an index of 0. The actual element count of the; /// array can be accessed by the optional 'ElementCountVal' parameter. \param; /// State The program state. \param Region The memory region where the array; /// is stored. \param ElementTy The type an element in the array. \param LCty; /// The location context. \param ElementCountVal A pointer to an optional; /// SVal. If specified, the size of the array will be returned in it. It can; /// be Unknown.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h:60,error,error,60,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,2,['error'],['error']
Availability,"/// Print a SelectionDAG node and all children down to; /// the leaves. The given SelectionDAG allows target-specific nodes; /// to be printed in human-readable form. Unlike printr, this will; /// print the whole DAG, including children that appear multiple; /// times.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:47,down,down,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['down'],['down']
Availability,/// Print an error message to an output stream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:13,error,error,13,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['error'],['error']
Availability,"/// Print attributes of an edge in the DDG graph. If the edge; /// is a MemoryDependence edge, then detailed dependence info; /// available from DependenceAnalysis is displayed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:130,avail,available,130,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,1,['avail'],['available']
Availability,/// Print debugging view to standard error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h:37,error,error,37,interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,1,['error'],['error']
Availability,/// Print diagnostic associated with this error when printing the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:42,error,error,42,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,6,['error'],['error']
Availability,/// Print execution trace of the schedule top-down or bottom-up.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:46,down,down,46,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['down'],['down']
Availability,"/// Print information about why evaluation failed.; /// Using _printEvalErrors, the number of errors printed can be steered.; /// Negative values disable printing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx:94,error,errors,94,roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,1,['error'],['errors']
Availability,/// Print libclang's resource usage to standard error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:48,error,error,48,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h,1,['error'],['error']
Availability,/// Print name of variable associated with this error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:48,error,error,48,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,/// Print out an error that codegen doesn't support the specified decl yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:17,error,error,17,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['error'],['error']
Availability,/// Print out an error that codegen doesn't support the specified stmt yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:17,error,error,17,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['error'],['error']
Availability,"/// Print out the dependency information into a string using the dependency; /// file format that is specified in the options (-MD is the default) and; /// return it.; ///; /// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, dependency file contents otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:239,error,errors,239,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,1,['error'],['errors']
Availability,"/// Print register mask for MOVEM instruction in order A7-A0,D7-D0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h,1,['mask'],['mask']
Availability,"/// Print register mask for MOVEM instruction in order D0-D7,A0-A7",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h,1,['mask'],['mask']
Availability,/// Print statistics to standard error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h:33,error,error,33,interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,1,['error'],['error']
Availability,"/// Print the current values and errors of pdf parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/inc/RooStats/HistFactory/HistFactoryNavigation.h:33,error,errors,33,roofit/histfactory/inc/RooStats/HistFactory/HistFactoryNavigation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/inc/RooStats/HistFactory/HistFactoryNavigation.h,1,['error'],['errors']
Availability,/// Print the error message to the error output stream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:14,error,error,14,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,2,['error'],['error']
Availability,"/// Print the register mask on OS.; /// If IsForDebug is false, then only the name of the register bank; /// is printed. Otherwise, all the fields are printing.; /// TRI is then used to print the name of the register classes that; /// this register bank covers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h:23,mask,mask,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h,1,['mask'],['mask']
Availability,"/// Print the root value with the error shown inline as a comment.; /// Unrelated parts of the value are elided for brevity, e.g.; /// {; /// ""id"": 42,; /// ""name"": /* expected string */ null,; /// ""properties"": { ... }; /// }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:34,error,error,34,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['error'],['error']
Availability,/// Print the warning message to the error output stream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:37,error,error,37,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,1,['error'],['error']
Availability,/// Prints the values in the OffloadArrays \p OAs using LLVM_DEBUG.; /// For now this is a way to test that the function getValuesInOffloadArrays; /// is working properly.; /// TODO: Move this to a unittest when unittests are available for OpenMPOpt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:226,avail,available,226,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['avail'],['available']
Availability,"/// Prints two successive strings, which much be kept alive as long as the; /// PrettyStackTrace entry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp:54,alive,alive,54,interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,1,['alive'],['alive']
Availability,"/// Prints values for stacks in a format consumable for the flamegraph.pl; /// tool. This is a line based format that lists each level in the stack; /// hierarchy in a semicolon delimited form followed by a space and a numeric; /// value. If breaking down by thread, the thread ID will be added as the; /// root level of the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-stacks.cpp:251,down,down,251,interpreter/llvm-project/llvm/tools/llvm-xray/xray-stacks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-stacks.cpp,1,['down'],['down']
Availability,"/// Prior to adding the live-out mask to a stackmap or patchpoint; /// instruction, provide the target the opportunity to adjust it (mainly to; /// remove pseudo-registers that should be ignored).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:33,mask,mask,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['mask'],['mask']
Availability,"/// Process a matcher expression.; ///; /// All the arguments passed here have already been processed.; ///; /// \param Ctor A matcher constructor looked up by lookupMatcherCtor.; ///; /// \param NameRange The location of the name in the matcher source.; /// Useful for error reporting.; ///; /// \param BindID The ID to use to bind the matcher, or a null \c StringRef; /// if no ID is specified.; ///; /// \param Args The argument list for the matcher.; ///; /// \return The matcher objects constructed by the processor, or a null; /// matcher if an error occurred. In that case, \c Error will contain a; /// description of the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Parser.h:270,error,error,270,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Parser.h,4,"['Error', 'error']","['Error', 'error']"
Availability,"/// Process an Xray record and expand the graph.; ///; /// This Function will return true on success, or false if records are not; /// presented in per-thread call-tree DFS order. (That is for each thread the; /// Records should be in order runtime on an ideal system.); ///; /// FIXME: Make this more robust against small irregularities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h:302,robust,robust,302,interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h,1,['robust'],['robust']
Availability,"/// Process any TypoExprs in the given Expr and its children,; /// generating diagnostics as appropriate and returning a new Expr if there; /// were typos that were all successfully corrected and ExprError if one or; /// more typos could not be corrected.; ///; /// \param E The Expr to check for TypoExprs.; ///; /// \param InitDecl A VarDecl to avoid because the Expr being corrected is its; /// initializer.; ///; /// \param RecoverUncorrectedTypos If true, when typo correction fails, it; /// will rebuild the given Expr with all TypoExprs degraded to RecoveryExprs.; ///; /// \param Filter A function applied to a newly rebuilt Expr to determine if; /// it is an acceptable/usable result from a single combination of typo; /// corrections. As long as the filter returns ExprError, different; /// combinations of corrections will be tried until all are exhausted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:428,Recover,RecoverUncorrectedTypos,428,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,3,"['Recover', 'degraded']","['RecoverUncorrectedTypos', 'RecoveryExprs', 'degraded']"
Availability,/// Process the import result of a child (of the current declaration).; /// \param ResultErr The import error that can be used as result of; /// importing the parent. This may be changed by the function.; /// \param ChildErr Result of importing a child. Can be success or error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:104,error,error,104,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,['error'],['error']
Availability,/// Process the specified .incbin file by searching for it in the include paths; /// then just emitting the byte contents of the file to the streamer. This; /// returns true on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:177,failure,failure,177,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['failure'],['failure']
Availability,/// Process the specified file for the .incbin directive.; /// This returns true on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:84,failure,failure,84,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['failure'],['failure']
Availability,"/// Produce an argument string from ArgList \p Args, which shows how it; /// provides some sanitizer kind from \p Mask. For example, the argument list; /// ""-fsanitize=thread,vptr -fsanitize=address"" with mask \c NeedsUbsanRt; /// would produce ""-fsanitize=vptr"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:114,Mask,Mask,114,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Produce an argument string from argument \p A, which shows how it provides; /// a value in \p Mask. For instance, the argument; /// ""-fsanitize=address,alignment"" with mask \c NeedsUbsanRt would produce; /// ""-fsanitize=alignment"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:98,Mask,Mask,98,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Produce an error diagnostic and return true.; ///; /// This routine should only be used for fatal errors that have to; /// do with non-routine failures (e.g., corrupted AST file).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:15,error,error,15,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,3,"['error', 'failure']","['error', 'errors', 'failures']"
Availability,"/// Profile to identify equivalent bug reports for error report coalescing.; /// A (stack of) a set of symbols that are registered with this; /// report as being ""interesting"", and thus used to help decide which; /// diagnostics to include when constructing the final path diagnostic.; /// The stack is largely used by BugReporter when generating PathDiagnostics; /// for multiple PathDiagnosticConsumers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h:51,error,error,51,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,1,['error'],['error']
Availability,/// Profile to identify equivalent bug reports for error report coalescing.; /// Reports are uniqued to ensure that we do not emit multiple diagnostics; /// for each bug.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h:51,error,error,51,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,1,['error'],['error']
Availability,"/// Project all bins into a 1-dimensional histogram,; /// keeping only axis ""xDim"".; /// If ""option"" contains:; /// - ""E"" errors will be calculated.; /// - ""A"" ranges of the taget axes will be ignored.; /// - ""O"" original axis range of the taget axes will be; /// kept, but only bins inside the selected range; /// will be filled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/THnBase.h:122,error,errors,122,hist/hist/inc/THnBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/THnBase.h,1,['error'],['errors']
Availability,"/// Project all bins into a 2-dimensional histogram,; /// keeping only axes ""xDim"" and ""yDim"".; ///; /// WARNING: just like TH3::Project3D(""yx"") and TTree::Draw(""y:x""),; /// Projection(y,x) uses the first argument to define the y-axis and the; /// second for the x-axis!; ///; /// If ""option"" contains ""E"" errors will be calculated.; /// ""A"" ranges of the taget axes will be ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/THnBase.h:306,error,errors,306,hist/hist/inc/THnBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/THnBase.h,1,['error'],['errors']
Availability,"/// Project all bins into a 3-dimensional histogram,; /// keeping only axes ""xDim"", ""yDim"", and ""zDim"".; /// If ""option"" contains:; /// - ""E"" errors will be calculated.; /// - ""A"" ranges of the taget axes will be ignored.; /// - ""O"" original axis range of the taget axes will be; /// kept, but only bins inside the selected range; /// will be filled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/THnBase.h:142,error,errors,142,hist/hist/inc/THnBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/THnBase.h,1,['error'],['errors']
Availability,/// Project an l-value down to the value field.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:23,down,down,23,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['down'],['down']
Availability,"/// Promote \p ToBePromoted by moving \p Def downward through.; /// I.e., we have the following sequence:; /// Def = Transition <ty1> a to <ty2>; /// b = ToBePromoted <ty2> Def, ...; /// =>; /// b = ToBePromoted <ty1> a, ...; /// Def = Transition <ty1> ToBePromoted to <ty2>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:45,down,downward,45,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['down'],['downward']
Availability,"/// Promote the allocas, using the best available technique.; ///; /// This attempts to promote whatever allocas have been identified as viable in; /// the PromotableAllocas list. If that list is empty, there is nothing to do.; /// This function returns whether any promotion occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:40,avail,available,40,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['avail'],['available']
Availability,/// Provides a sequence of function IDs from a previously interned PathID.; ///; /// Returns an error if |P| had not been interned before into the Profile.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:96,error,error,96,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,1,['error'],['error']
Availability,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:245,mask,mask,245,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,5,['mask'],"['mask', 'masked']"
Availability,"/// Provides information about an attempted template argument; /// deduction, whose success or failure was described by a; /// TemplateDeductionResult value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:95,failure,failure,95,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,/// Provides information about what library functions are available for; /// the current target.; ///; /// This both allows optimizations to handle them specially and frontends to; /// disable such optimizations through -fno-builtin etc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:58,avail,available,58,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,1,['avail'],['available']
Availability,/// Public interface to the address sanitizer module pass for instrumenting code; /// to check for various memory errors.; ///; /// This adds 'asan.module_ctor' to 'llvm.global_ctors'. This pass may also; /// run intependently of the function address sanitizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/AddressSanitizer.h:114,error,errors,114,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/AddressSanitizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/AddressSanitizer.h,1,['error'],['errors']
Availability,"/// RAII class that determines when any errors have occurred; /// between the time the instance was created and the time it was; /// queried.; ///; /// Note that you almost certainly do not want to use this. It's usually; /// meaningless to ask whether a particular scope triggered an error message,; /// because error messages outside that scope can mark things invalid (or cause; /// us to reach an error limit), which can suppress errors within that scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:40,error,errors,40,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,5,['error'],"['error', 'errors']"
Availability,/// RAII class used to determine whether SFINAE has; /// trapped any errors that occur during template argument; /// deduction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:69,error,errors,69,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['errors']
Availability,"/// RAII object that makes sure paren/bracket/brace count is correct; /// after declaration/statement parsing, even when there's a parsing error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h:139,error,error,139,interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h,1,['error'],['error']
Availability,"/// RAII object wrapping the visitation of a sequenced subexpression of an; /// expression. At the end of this process, the side-effects of the evaluation; /// become sequenced with respect to the value computation of the result, so; /// we downgrade any UK_ModAsSideEffect within the evaluation to; /// UK_ModAsValue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:241,down,downgrade,241,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['down'],['downgrade']
Availability,/// Range of bytes to consider prefetching expressed as an offset; /// and size. The offset is from the start (possibly negative) of; /// amd_kernel_code_t object. Set both to 0 if no prefetch; /// information is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:213,avail,available,213,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['avail'],['available']
Availability,"/// Ranges act as filters when it comes to selecting entries that downstream nodes should process",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx:66,down,downstream,66,tree/dataframe/inc/ROOT/RDF/RRange.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx,1,['down'],['downstream']
Availability,/// Read YAML text into the MsgPack document. Returns false on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:63,failure,failure,63,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,2,['failure'],['failure']
Availability,"/// Read \p Length bytes from the underlying stream into \p Ref. This is; /// equivalent to calling getUnderlyingStream().slice(Offset, Length).; /// Updates the stream's offset to point after the newly read object. Never; /// causes a copy.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:271,error,error,271,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,4,['error'],['error']
Availability,"/// Read \p Size bytes from the underlying stream at the current offset and; /// and set \p Buffer to the resulting data slice. Whether a copy occurs; /// depends on the implementation of the underlying stream. Updates the; /// stream's offset to point after the newly read data.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:309,error,error,309,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,"/// Read a FixedStreamArray of \p NumItems elements and store the result into; /// \p Array. Updates the stream's offset to point after the newly read; /// array. Never causes a copy (although iterating the elements of the; /// FixedStreamArray may, depending upon the implementation of the underlying; /// stream).; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:345,error,error,345,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,"/// Read a VarStreamArray of size \p Size bytes and store the result into; /// \p Array. Updates the stream's offset to point after the newly read; /// array. Never causes a copy (although iterating the elements of the; /// VarStreamArray may, depending upon the implementation of the underlying; /// stream).; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:339,error,error,339,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,"/// Read a \p Length byte string into \p Dest. Whether a copy occurs depends; /// on the implementation of the underlying stream. Updates the stream's; /// offset to point after the newly read data.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:228,error,error,228,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,"/// Read a document from a binary msgpack blob, merging into anything already; /// in the Document. The blob data must remain valid for the lifetime of this; /// Document (because a string object in the document contains a StringRef; /// into the original blob). If Multi, then this sets root to an array and; /// adds top-level objects to it. If !Multi, then it only reads a single; /// top-level object, even if there are more, and sets root to that. Returns; /// false if failed due to illegal format or merge error.; ///; /// The Merger arg is a callback function that is called when the merge has a; /// conflict, that is, it is trying to set an item that is already set. If the; /// conflict cannot be resolved, the callback function returns -1. If the; /// conflict can be resolved, the callback returns a non-negative number and; /// sets *DestNode to the resolved node. The returned non-negative number is; /// significant only for an array node; it is then the array index to start; /// populating at. That allows Merger to choose whether to merge array; /// elements (returns 0) or append new elements (returns existing size).; ///; /// If SrcNode is an array or map, the resolution must be that *DestNode is an; /// array or map respectively, although it could be the array or map; /// (respectively) that was already there. MapKey is the key if *DestNode is a; /// map entry, a nil node otherwise.; ///; /// The default for Merger is to disallow any conflict.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:513,error,error,513,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,1,['error'],['error']
Availability,/// Read a global index file for the given directory.; ///; /// \param Path The path to the specific module cache where the module files; /// for the intended configuration reside.; ///; /// \returns A pair containing the global module index (if it exists) and; /// the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h:270,error,error,270,interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,1,['error'],['error']
Availability,"/// Read a null terminated string from \p Dest. Whether a copy occurs depends; /// on the implementation of the underlying stream. Updates the stream's; /// offset to point after the newly read data.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:229,error,error,229,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,"/// Read a numeric value of type T from the profile.; ///; /// If an error occurs during decoding, a diagnostic message is emitted and; /// EC is set.; ///; /// \returns the read value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h:69,error,error,69,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,1,['error'],['error']
Availability,/// Read a preallocated preprocessed entity from the external source.; ///; /// \returns null if an error occurred that prevented the preprocessed; /// entity from being loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:100,error,error,100,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,2,['error'],['error']
Availability,"/// Read a signed LEB128 encoded value.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:69,error,error,69,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,"/// Read a string from the profile.; ///; /// If an error occurs during decoding, a diagnostic message is emitted and; /// EC is set.; ///; /// \returns the read value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h:52,error,error,52,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,1,['error'],['error']
Availability,/// Read a value out of the specified record from slot 'Slot'. Increment Slot; /// past the number of slots used by the value in the record. Return true if; /// there is an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:173,error,error,173,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['error'],['error']
Availability,/// Read a value/type pair out of the specified record from slot 'Slot'.; /// Increment Slot past the number of slots used in the record. Return true on; /// failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:158,failure,failure,158,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['failure'],['failure']
Availability,"/// Read an integer of the specified endianness into \p Dest and update the; /// stream's offset. The data is always copied from the stream's underlying; /// buffer into \p Dest. Updates the stream's offset to point after the newly; /// read data.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:277,error,error,277,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,"/// Read an unsigned LEB128 encoded value.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:72,error,error,72,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,"/// Read and return a block info block from the bitstream. If an error was; /// encountered, return std::nullopt.; ///; /// \param ReadBlockInfoNames Whether to read block/record name information in; /// the BlockInfo block. Only llvm-bcanalyzer uses this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:65,error,error,65,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,1,['error'],['error']
Availability,"/// Read as much as possible from the underlying string at the current offset; /// without invoking a copy, and set \p Buffer to the resulting data slice.; /// Updates the stream's offset to point after the newly read data.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:253,error,error,253,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,"/// Read one object from the input buffer, advancing past it.; ///; /// The \p Obj is updated with the kind of the object read, and the; /// corresponding union member is updated.; ///; /// For the collection objects (Array and Map), only the length is read, and; /// the caller must make and additional \c N calls (in the case of Array) or; /// \c N*2 calls (in the case of Map) to \c Read to retrieve the collection; /// elements.; ///; /// \param [out] Obj filled with next object on success.; ///; /// \returns true when object successfully read, false when at end of; /// input (and so \p Obj was not updated), otherwise an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:629,error,error,629,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,1,['error'],['error']
Availability,"/// Read options from the specified file.; ///; /// \param [in] FileName File to read.; /// \param [in] Search and expansion options.; /// \returns true, if error occurred while reading.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:157,error,error,157,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['error'],['error']
Availability,"/// Read the contents of the given module map file.; ///; /// \param File The module map file.; /// \param IsSystem Whether this file is in a system header directory.; /// \param ID If the module map file is already mapped (perhaps as part of; /// processing a preprocessed module), the ID of the file.; /// \param Offset [inout] An offset within ID to start parsing. On exit,; /// filled by the end of the parsed contents (either EOF or the; /// location of an end-of-module-map pragma).; /// \param OriginalModuleMapFile The original path to the module map file,; /// used to resolve paths within the module (this is required when; /// building the module from preprocessed source).; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:710,error,error,710,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['error'],['error']
Availability,"/// Read the control block for the named AST file.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:81,error,error,81,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['error'],['error']
Availability,"/// Read the entire remainder of the underlying stream into \p Ref. This is; /// equivalent to calling getUnderlyingStream().slice(Offset). Updates the; /// stream's offset to point to the end of the stream. Never causes a copy.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:258,error,error,258,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,/// Read the given file from the filesystem and parse it as a yaml file. The; /// template parameter must have a yaml MappingTraits.; /// Emit diagnostic error in case of any failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h:154,error,error,154,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/Yaml.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Read the header of the specified bitcode buffer and extract just the; /// producer string information. If successful, this returns a string. On; /// error, this returns """".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:153,error,error,153,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,1,['error'],['error']
Availability,"/// Read the header of the specified bitcode buffer and extract just the; /// triple information. If successful, this returns a string. On error, this; /// returns """".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:139,error,error,139,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,1,['error'],['error']
Availability,"/// Read the source location entry with index ID, which will always be; /// less than -1.; ///; /// \returns true if an error occurred that prevented the source-location; /// entry from being loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:120,error,error,120,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['error'],['error']
Availability,"/// ReadFunctionLikeMacroArgs - After reading ""MACRO"" and knowing that the next; /// token is the '(' of the macro, this method is invoked to read all of the; /// actual arguments specified for the macro invocation. This returns null on; /// error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:242,error,error,242,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['error'],['error']
Availability,"/// Reads 'size' values from the associated field, starting from 'firstIndex'. Note that the index is given; /// relative to a certain cluster. The return value points to the array of read objects.; /// The 'maskReq' parameter is a bool array of at least 'size' elements. Only objects for which the mask is; /// true are guaranteed to be read in the returned value array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:208,mask,maskReq,208,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,2,['mask'],"['mask', 'maskReq']"
Availability,"/// Reads \p Buf.size() bytes from \p FileHandle at offset \p Offset into \p; /// Buf. If 'pread' is available, this will use that, otherwise it will use; /// 'lseek'. Returns the number of bytes actually read. Returns 0 when reaching; /// EOF.; ///; /// @param FileHandle File to read from.; /// @param Buf Buffer to read into.; /// @param Offset Offset into the file at which the read should occur.; /// @returns The number of bytes read, or error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:101,avail,available,101,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,2,"['avail', 'error']","['available', 'error']"
Availability,"/// Reads \p Buf.size() bytes from \p FileHandle into \p Buf. Returns the number; /// of bytes actually read. On Unix, this is equivalent to `return ::read(FD,; /// Buf.data(), Buf.size())`, with error reporting. Returns 0 when reaching EOF.; ///; /// @param FileHandle File to read from.; /// @param Buf Buffer to read into.; /// @returns The number of bytes read, or error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:196,error,error,196,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,2,['error'],['error']
Availability,"/// Reads a module from a file. On error, messages are written to stderr; /// and null is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp:35,error,error,35,interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/llvm-diff.cpp,1,['error'],['error']
Availability,"/// Reads flags from the given file, one-per-line.; /// Returns nullptr and sets ErrorMessage if we can't read the file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:81,Error,ErrorMessage,81,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,1,['Error'],['ErrorMessage']
Availability,"/// Reads from \p FileHandle until EOF, appending to \p Buffer in chunks of; /// size \p ChunkSize.; ///; /// This calls \a readNativeFile() in a loop. On Error, previous chunks that; /// were read successfully are left in \p Buffer and returned.; ///; /// Note: For reading the final chunk at EOF, \p Buffer's capacity needs extra; /// storage of \p ChunkSize.; ///; /// \param FileHandle File to read from.; /// \param Buffer Where to put the file content.; /// \param ChunkSize Size of chunks.; /// \returns The error if EOF was not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:155,Error,Error,155,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// Reads the check file from \p Buffer and records the expected strings it; /// contains. Errors are reported against \p SM.; ///; /// If \p ImpPatBufferIDRange, then the range (inclusive start, exclusive end); /// of IDs for source buffers added to \p SM for implicit patterns are; /// recorded in it. The range is empty if there are none.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h:91,Error,Errors,91,interpreter/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h,1,['Error'],['Errors']
Availability,"/// Reads two 32 bit registers and creates a 64 bit mask value.; /// \param VA The current 32 bit value that need to be assigned.; /// \param NextVA The next 32 bit value that need to be assigned.; /// \param Root The parent DAG node.; /// \param [in,out] InGlue Represents SDvalue in the parent DAG node for; /// glue purposes. In the case the DAG is already using; /// physical register instead of virtual, we should glue; /// our new SDValue to InGlue SDvalue.; /// \return a new SDvalue of size 64bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:52,mask,mask,52,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['mask'],['mask']
Availability,"/// RecognizableInstr - Encapsulates all information required to decode a single; /// instruction, as extracted from the LLVM instruction tables. Has methods; /// to interpret the information available in the LLVM tables, and to emit the; /// instruction into DisassemblerTables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86RecognizableInstr.h:192,avail,available,192,interpreter/llvm-project/llvm/utils/TableGen/X86RecognizableInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86RecognizableInstr.h,1,['avail'],['available']
Availability,"/// Record a RegMask operand being executed. Defs any register we currently; /// track, stores a pointer to the mask in case we have to account for it; /// later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:112,mask,mask,112,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['mask'],['mask']
Availability,"/// Record a relocation described by the .reloc directive. Return std::nullopt; /// if succeeded. Otherwise, return a pair (Name is invalid, error message).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:141,error,error,141,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['error'],['error']
Availability,"/// Record addresses of the given symbols in the given ExecutorAddrs.; ///; /// Useful for making permanent records of symbol addreses to call or; /// access in the executor (e.g. runtime support functions in Platform; /// subclasses).; ///; /// By default the symbols are looked up using; /// SymbolLookupFlags::RequiredSymbol, and an error will be generated if any of; /// the requested symbols are not defined.; ///; /// If SymbolLookupFlags::WeaklyReferencedSymbol is used then any missing; /// symbols will have their corresponding address objects set to zero, and; /// this function will never generate an error (the caller will need to check; /// addresses before using them).; ///; /// Asynchronous version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LookupAndRecordAddrs.h:336,error,error,336,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LookupAndRecordAddrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LookupAndRecordAddrs.h,2,['error'],['error']
Availability,"/// Record of a use-before-def: created when a value that's live-in to the; /// current block isn't available in any machine location, but it will be; /// defined in this block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:100,avail,available,100,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avail'],['available']
Availability,"/// Record that \p Var has value \p ID, a value that becomes available; /// later in the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:61,avail,available,61,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avail'],['available']
Availability,"/// Record the downward impact of a single instruction on current register; /// pressure. Unlike the advance/recede pressure tracking interface, this does; /// not discover live in/outs.; ///; /// This is intended for speculative queries. It leaves pressure inconsistent; /// with the current position, so must be restored by the caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:15,down,downward,15,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,1,['down'],['downward']
Availability,/// Record the typo correction failure and return an empty correction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:31,failure,failure,31,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['failure'],['failure']
Availability,"/// RecordMatchingPHIs - For each PHI node that matches, record it in both; /// the BBMap and the AvailableVals mapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:98,Avail,AvailableVals,98,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,1,['Avail'],['AvailableVals']
Availability,/// Records if this operand's mask needs to match the mask of the operation; /// that it will fold into.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],['mask']
Availability,"/// Records that the value at the current path is invalid.; /// Message is e.g. ""expected number"" and becomes part of the final error.; /// This overwrites any previously written error message in the root.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:128,error,error,128,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,2,['error'],['error']
Availability,/// Recovers the address of a local in a parent function. ParentVar is the; /// address of the variable used in the immediate parent function. It can; /// either be an alloca or a call to llvm.localrecover if there are nested; /// outlined functions. ParentFP is the frame pointer of the outermost parent; /// frame.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:4,Recover,Recovers,4,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['Recover'],['Recovers']
Availability,"/// Recursive helper for hasConcreteDef(). Unfortunately, this currently boils; /// down to checking that all operands are constant and listing instructions; /// that may hide undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:84,down,down,84,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['down'],['down']
Availability,"/// Recursively delete a directory.; ///; /// @param path Input path.; /// @returns errc::success if path has been removed or didn't exist, otherwise a; /// platform-specific error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:175,error,error,175,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['error'],['error']
Availability,"/// Recursively walk the \p DIE tree and check ""keepness"" and ""placement""; /// information. It is an error if parent node does not have ""keep"" flag,; /// while child has one. It is an error if parent node has ""TypeTable""; /// placement while child has ""PlainDwarf"" placement. This function dump error; /// at stderr in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:101,error,error,101,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,3,['error'],['error']
Availability,"/// Recycle small arrays allocated from a BumpPtrAllocator.; ///; /// Arrays are allocated in a small number of fixed sizes. For each supported; /// array size, the ArrayRecycler keeps a free list of available arrays.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h:200,avail,available,200,interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,1,['avail'],['available']
Availability,/// Reduce a sequence of masked half-width multiplies to a single multiply.; /// ((XLow * YHigh) + (YLow * XHigh)) << HalfBits) + (XLow * YLow) --> X * Y,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:25,mask,masked,25,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['mask'],['masked']
Availability,"/// Reduce cast expression by removing redundant intermediate casts.; /// E.g.; /// - (char)(short)(int x) -> (char)(int x); /// - (int)(int x) -> int x; ///; /// \param V -- SymbolVal, which pressumably contains SymbolCast or any symbol; /// that is applicable for cast operation.; /// \param CastTy -- QualType, which `V` shall be cast to.; /// \return SVal with simplified cast expression.; /// \note: Currently only support integral casts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:39,redundant,redundant,39,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,1,['redundant'],['redundant']
Availability,"/// Reduce the number of arguments in this call expression. This is used for; /// example during error recovery to drop extra arguments. There is no way; /// to perform the opposite because: 1.) We don't track how much storage; /// we have for the argument array 2.) This would potentially require growing; /// the argument array, something we cannot support since the arguments are; /// stored in a trailing array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:97,error,error,97,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,2,"['error', 'recover']","['error', 'recovery']"
Availability,/// Redundant parentheses over an equality comparison can indicate; /// that the user intended an assignment used as condition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Redundant,Redundant,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['Redundant'],['Redundant']
Availability,"/// Refines the subranges to support \p LaneMask. This may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:359,mask,mask,359,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,2,['mask'],"['mask', 'masks']"
Availability,/// Region size name. Used for error reporting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:31,error,error,31,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['error'],['error']
Availability,"/// Register a DefinitionGenerator to dynamically provide symbols for; /// generated code that are not already available within the process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:111,avail,available,111,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,3,['avail'],['available']
Availability,"/// Register cleanup handler, which is used when the recovery context is; /// finished.; /// The recovery context owns the handler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:53,recover,recovery,53,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,2,['recover'],['recovery']
Availability,"/// Register functions annotated with __attribute__((destructor)) using; /// __cxa_atexit, if it is available, or atexit otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:100,avail,available,100,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['avail'],['available']
Availability,/// Register is not available and can't be recovered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h:20,avail,available,20,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,2,"['avail', 'recover']","['available', 'recovered']"
Availability,"/// Register this instance as diagnostic handler.; /// With no further action, any diagnostic will lead to a test failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/inc/ROOT/TestSupport.hxx:114,failure,failure,114,core/testsupport/inc/ROOT/TestSupport.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/inc/ROOT/TestSupport.hxx,1,['failure'],['failure']
Availability,"/// RegisterAnalysisGroup - Register a Pass as a member of an analysis _group_.; /// Analysis groups are used to define an interface (which need not derive from; /// Pass) that is required by passes to do their job. Analysis Groups differ; /// from normal analyses because any available implementation of the group will; /// be used if it is available.; ///; /// If no analysis implementing the interface is available, a default; /// implementation is created and added. A pass registers itself as the default; /// implementation by specifying 'true' as the second template argument of this; /// class.; ///; /// In addition to registering itself as an analysis group member, a pass must; /// register itself normally as well. Passes may be members of multiple groups; /// and may still be ""required"" specifically by name.; ///; /// The actual interface may also be registered as well (by not specifying the; /// second template argument). The interface should be registered to associate; /// a nice name with the interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:277,avail,available,277,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h,3,['avail'],['available']
Availability,"/// RegisterPressure computed within a region of instructions delimited by; /// TopIdx and BottomIdx. During pressure computation, the maximum pressure per; /// register pressure set is increased. Once pressure within a region is fully; /// computed, the live-in and live-out sets are recorded.; ///; /// This is preferable to RegionPressure when LiveIntervals are available,; /// because delimiting regions by SlotIndex is more robust and convenient than; /// holding block iterators. The block contents can change without invalidating; /// the pressure result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:365,avail,available,365,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,2,"['avail', 'robust']","['available', 'robust']"
Availability,/// Registers all available CGSCC analysis passes.; ///; /// This is an interface that can be used to populate a \c CGSCCAnalysisManager; /// with all registered CGSCC analyses. Callers can still manually register any; /// additional analyses. Callers can also pre-register analyses and this will; /// not override those.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:18,avail,available,18,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['avail'],['available']
Availability,/// Registers all available function analysis passes.; ///; /// This is an interface that can be used to populate a \c; /// FunctionAnalysisManager with all registered function analyses. Callers can; /// still manually register any additional analyses. Callers can also; /// pre-register analyses and this will not override those.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:18,avail,available,18,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['avail'],['available']
Availability,/// Registers all available loop analysis passes.; ///; /// This is an interface that can be used to populate a \c LoopAnalysisManager; /// with all registered loop analyses. Callers can still manually register any; /// additional analyses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:18,avail,available,18,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['avail'],['available']
Availability,/// Registers all available machine function analysis passes.; ///; /// This is an interface that can be used to populate a \c; /// MachineFunctionAnalysisManager with all registered function analyses.; /// Callers can still manually register any additional analyses. Callers can; /// also pre-register analyses and this will not override those.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:18,avail,available,18,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['avail'],['available']
Availability,/// Registers all available module analysis passes.; ///; /// This is an interface that can be used to populate a \c; /// ModuleAnalysisManager with all registered module analyses. Callers can; /// still manually register any additional analyses. Callers can also; /// pre-register analyses and this will not override those.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:18,avail,available,18,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['avail'],['available']
Availability,"/// Registers an externally loaded library. The library will be unloaded; /// when the program terminates.; ///; /// It is safe to call this function multiple times for the same library,; /// though ownership is only taken if there was no error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:239,error,error,239,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['error'],['error']
Availability,"/// Registers an option to a given checker. A checker option will always have; /// the following format:; /// CheckerFullName:OptionName=Value; /// And can be specified from the command line like this:; /// -analyzer-config CheckerFullName:OptionName=Value; ///; /// Options for unknown checkers, or unknown options for a given checker, or; /// invalid value types for that given option are reported as an error in; /// non-compatibility mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h:406,error,error,406,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h,1,['error'],['error']
Availability,"/// Registers an option to a given package. A package option will always have; /// the following format:; /// PackageFullName:OptionName=Value; /// And can be specified from the command line like this:; /// -analyzer-config PackageFullName:OptionName=Value; ///; /// Options for unknown packages, or unknown options for a given package, or; /// invalid value types for that given option are reported as an error in; /// non-compatibility mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h:406,error,error,406,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h,1,['error'],['error']
Availability,"/// Release SU to make it ready. If it's not in hazard, remove it from; /// pending queue (if already in) and push into available queue.; /// Otherwise, push the SU into pending queue.; ///; /// @param SU The unit to be released.; /// @param ReadyCycle Until which cycle the unit is ready.; /// @param InPQueue Whether SU is already in pending queue.; /// @param Idx Position offset in pending queue (if in it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:120,avail,available,120,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['avail'],['available']
Availability,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,avail,available,42,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['avail'],['available']
Availability,"/// Relex the token at the specified location.; /// \returns true if there was a failure, false on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Lexer.h:81,failure,failure,81,interpreter/llvm-project/clang/include/clang/Lex/Lexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Lexer.h,3,['failure'],['failure']
Availability,"/// Remove a lock from the lockset, warning if the lock is not there.; /// \param UnlockLoc The source location of the unlock (only used in error msg)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:140,error,error,140,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,1,['error'],['error']
Availability,/// Remove all registers from the set that get clobbered by the register; /// mask.; /// The clobbers set will be the list of live registers clobbered; /// by the regmask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp:78,mask,mask,78,interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp,1,['mask'],['mask']
Availability,"/// Remove path. Equivalent to POSIX remove().; ///; /// @param path Input path.; /// @returns errc::success if path has been removed or didn't exist, otherwise a; /// platform-specific error code. If IgnoreNonExisting is false, also; /// returns error if the file didn't exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:186,error,error,186,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,2,['error'],['error']
Availability,/// Remove redundant EpxandSCEVRecipes in \p Plan's entry block by replacing; /// them with already existing recipes expanding the same SCEV expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,redundant,redundant,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,1,['redundant'],['redundant']
Availability,/// Remove redundant VPBasicBlocks by merging them into their predecessor if; /// the predecessor has a single successor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,redundant,redundant,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,1,['redundant'],['redundant']
Availability,"/// Remove redundant casts of inductions.; ///; /// Such redundant casts are casts of induction variables that can be ignored,; /// because we already proved that the casted phi is equal to the uncasted phi; /// in the vectorized loop. There is no need to vectorize the cast - the same; /// value can be used for both the phi and casts in the vector loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,redundant,redundant,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,2,['redundant'],['redundant']
Availability,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,redundant,redundant,11,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,2,['redundant'],['redundant']
Availability,/// Remove redundant debug value MIs for the given machine function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:11,redundant,redundant,11,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,1,['redundant'],['redundant']
Availability,/// Remove redundant definitions within sequences of consecutive location defs.; /// This is done using a backward scan to keep the last def describing a; /// specific variable/fragment.; ///; /// This implements removeRedundantDbgInstrsUsingBackwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,redundant,redundant,11,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['redundant'],['redundant']
Availability,"/// Remove redundant instructions within sequences of consecutive dbg.value; /// instructions. This is done using a backward scan to keep the last dbg.value; /// describing a specific variable/fragment.; ///; /// BackwardScan strategy:; /// ----------------------; /// Given a sequence of consecutive DbgValueInst like this; ///; /// dbg.value ..., ""x"", FragmentX1 (*); /// dbg.value ..., ""y"", FragmentY1; /// dbg.value ..., ""x"", FragmentX2; /// dbg.value ..., ""x"", FragmentX1 (**); ///; /// then the instruction marked with (*) can be removed (it is guaranteed to be; /// obsoleted by the instruction marked with (**) as the latter instruction is; /// describing the same variable using the same fragment info).; ///; /// Possible improvements:; /// - Check fully overlapping fragments and not only identical fragments.; /// - Support dbg.declare. dbg.label, and possibly other meta instructions being; /// part of the sequence of consecutive instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,redundant,redundant,11,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['redundant'],['redundant']
Availability,"/// Remove redundant leading ""./"" pieces and consecutive separators.; ///; /// @param path Input path.; /// @result The cleaned-up \a path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Path.h:11,redundant,redundant,11,interpreter/llvm-project/llvm/include/llvm/Support/Path.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Path.h,1,['redundant'],['redundant']
Availability,/// Remove redundant location defs using a forward scan. This can remove a; /// location definition that is redundant due to indicating that a variable has; /// the same value as is already being indicated by an earlier def.; ///; /// This implements removeRedundantDbgInstrsUsingForwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,redundant,redundant,11,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,2,['redundant'],['redundant']
Availability,"/// Remove redundant parentheses.; /// \warning; /// Setting this option to any value other than ``Leave`` could lead to; /// incorrect code formatting due to clang-format's lack of complete semantic; /// information. As such, extra care should be taken to review code changes; /// made by this option.; /// \endwarning; /// \version 17",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:11,redundant,redundant,11,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['redundant'],['redundant']
Availability,"/// Remove redundant spills in the same BB. Save those redundant spills in; /// SpillsToRm, and save the spill to keep and its BB in SpillBBToSpill map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:11,redundant,redundant,11,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,2,['redundant'],['redundant']
Availability,"/// Remove redundant undef dbg.assign intrinsic from an entry block using a; /// forward scan.; /// Strategy:; /// ---------------------; /// Scanning forward, delete dbg.assign intrinsics iff they are undef, not; /// linked to an intrinsic, and don't share an aggregate variable with a debug; /// intrinsic that didn't meet the criteria. In other words, undef dbg.assigns; /// that come before non-undef debug intrinsics for the variable are; /// deleted. Given:; ///; /// dbg.assign undef, ""x"", FragmentX1 (*); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value %V, ""x"", FragmentX2; /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.assign undef, ""x"", FragmentX1; ///; /// then (only) the instruction marked with (*) can be removed.; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,redundant,redundant,11,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['redundant'],['redundant']
Availability,"/// Remove the specific pragma handler from this preprocessor.; ///; /// If \p Namespace is non-null, then it should be the namespace that; /// \p Handler was added to. It is an error to remove a handler that; /// has not been registered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:178,error,error,178,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['error'],['error']
Availability,/// Remove the specified comment handler.; ///; /// It is an error to remove a handler that has not been registered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:61,error,error,61,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['error'],['error']
Availability,"/// Remove this link from a chain's list of notify subscribers.; /// Templated only to remove an include dependency from TChain: it expects; /// a TChain as input (in practice anything that implements SetNotify and; /// GetNotify will work, but in ROOT that is only TTree and its sub-classes).; /// \note No error is emitted if the TNotifyLink is not part of the linked list; /// for the chain passed as argument. The TNotifyLink will still remove itself; /// from the doubly linked list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TNotifyLink.h:308,error,error,308,core/base/inc/TNotifyLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TNotifyLink.h,1,['error'],['error']
Availability,"/// RemovePragmaHandler - Remove the specific pragma handler from the; /// preprocessor. If \arg Namespace is non-null, then it should be the; /// namespace that \arg Handler was added to. It is an error to remove; /// a handler that has not been registered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:198,error,error,198,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['error'],['error']
Availability,/// Removes redundant address calculations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:12,redundant,redundant,12,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['redundant'],['redundant']
Availability,/// Removes unused/repeated shuffle source inputs and adjusts the shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:74,mask,mask,74,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"/// Render \p Title, a project title if one is available, and the; /// created time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h:47,avail,available,47,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageView.h,1,['avail'],['available']
Availability,/// Reorders operands of the node to the given mask \p Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,mask,mask,47,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Reorders the given \p Order according to the given \p Mask. \p Order - is; /// the original order of the scalars. Procedure transforms the provided order; /// in accordance with the given \p Mask. If the resulting \p Order is just an; /// identity order, \p Order is cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:58,Mask,Mask,58,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['Mask'],['Mask']
Availability,/// Reorders the given \p Reuses mask according to the given \p Mask. \p Reuses; /// contains original mask for the scalars reused in the node. Procedure; /// transform this mask in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,5,"['Mask', 'mask']","['Mask', 'mask']"
Availability,/// Reorders the list of scalars in accordance with the given \p Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:65,Mask,Mask,65,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['Mask'],['Mask']
Availability,/// Repair indexes after adding and removing instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h:4,Repair,Repair,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h,1,['Repair'],['Repair']
Availability,"/// Reparse the source files using the same command-line options that; /// were originally used to produce this translation unit.; ///; /// \param VFS - A llvm::vfs::FileSystem to be used for all file accesses.; /// Note that preamble is saved to a temporary directory on a RealFileSystem,; /// so in order for it to be loaded correctly, VFS should give an access to; /// this(i.e. be an overlay over RealFileSystem).; /// FileMgr->getVirtualFileSystem() will be used if \p VFS is nullptr.; ///; /// \returns True if a failure occurred that causes the ASTUnit not to; /// contain any translation-unit information, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:519,failure,failure,519,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['failure'],['failure']
Availability,"/// Repetitively apply `widenShuffleMaskElts()` for as long as it succeeds,; /// to get the shuffle mask with widest possible elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:100,mask,mask,100,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['mask'],['mask']
Availability,"/// Replace (ICMP_ULE, wide canonical IV, backedge-taken-count) checks with an; /// (active-lane-mask recipe, wide canonical IV, trip-count). If \p; /// UseActiveLaneMaskForControlFlow is true, introduce an; /// VPActiveLaneMaskPHIRecipe. If \p DataAndControlFlowWithoutRuntimeCheck is; /// true, no minimum-iteration runtime check will be created (during skeleton; /// creation) and instead it is handled using active-lane-mask. \p; /// DataAndControlFlowWithoutRuntimeCheck implies \p; /// UseActiveLaneMaskForControlFlow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:97,mask,mask,97,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,2,['mask'],['mask']
Availability,/// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed; /// load.; ///; /// \param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.; /// \param InVecVT type of the input vector to EVE with bitcasts resolved.; /// \param EltNo index of the vector element to load.; /// \param OriginalLoad load that EVE came from to be replaced.; /// \returns EVE on success SDValue() on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:375,failure,failure,375,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['failure'],['failure']
Availability,"/// Replace each shuffle mask index with the scaled sequential indices for an; /// equivalent mask of narrowed elements. Mask elements that are less than 0; /// (sentinel values) are repeated in the output mask.; ///; /// Example with Scale = 4:; /// <4 x i32> <3, 2, 0, -1> -->; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1>; ///; /// This is the reverse process of widening shuffle mask elements, but it always; /// succeeds because the indexes can always be multiplied (scaled up) to map to; /// narrower vector elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:25,mask,mask,25,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,5,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:1910,error,error,1910,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['error'],['error']
Availability,"/// Replace with a (mostly) real path, or don't modify. Resolves symlinks; /// in the directory, using \a CachedDirs to avoid redundant lookups, but; /// leaves the filename as a possible symlink.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h:126,redundant,redundant,126,interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h,1,['redundant'],['redundant']
Availability,"/// Replaces a template-id annotation token with a type; /// annotation token.; ///; /// If there was a failure when forming the type from the template-id,; /// a type annotation token will still be created, but will have a; /// NULL type pointer to signify an error.; ///; /// \param SS The scope specifier appearing before the template-id, if any.; ///; /// \param AllowImplicitTypename whether this is a context where T::type; /// denotes a dependent type.; /// \param IsClassName Is this template-id appearing in a context where we; /// know it names a class, such as in an elaborated-type-specifier or; /// base-specifier? ('typename' and 'template' are unneeded and disallowed; /// in those contexts.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:104,failure,failure,104,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,/// Report a error for this execution session.; ///; /// Unhandled errors can be sent here to log them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:13,error,error,13,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,2,['error'],"['error', 'errors']"
Availability,/// Report a fatal error if Err is a failure value.; ///; /// This function can be used to wrap calls to fallible functions ONLY when it; /// is known that the Error will always be a success value. E.g.; ///; /// @code{.cpp}; /// // foo only attempts the fallible operation if DoFallibleOperation is; /// // true. If DoFallibleOperation is false then foo always returns; /// // Error::success().; /// Error foo(bool DoFallibleOperation);; ///; /// cantFail(foo(false));; /// @endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:19,error,error,19,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,5,"['Error', 'error', 'failure']","['Error', 'error', 'failure']"
Availability,"/// Report a fatal error if ValOrErr is a failure value, otherwise unwraps and; /// returns the contained reference.; ///; /// This function can be used to wrap calls to fallible functions ONLY when it; /// is known that the Error will always be a success value. E.g.; ///; /// @code{.cpp}; /// // foo only attempts the fallible operation if DoFallibleOperation is; /// // true. If DoFallibleOperation is false then foo always returns a Bar&.; /// Expected<Bar&> foo(bool DoFallibleOperation);; ///; /// Bar &X = cantFail(foo(false));; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:19,error,error,19,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,3,"['Error', 'error', 'failure']","['Error', 'error', 'failure']"
Availability,"/// Report a fatal error if ValOrErr is a failure value, otherwise unwraps and; /// returns the contained value.; ///; /// This function can be used to wrap calls to fallible functions ONLY when it; /// is known that the Error will always be a success value. E.g.; ///; /// @code{.cpp}; /// // foo only attempts the fallible operation if DoFallibleOperation is; /// // true. If DoFallibleOperation is false then foo always returns an int.; /// Expected<int> foo(bool DoFallibleOperation);; ///; /// int X = cantFail(foo(false));; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:19,error,error,19,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,3,"['Error', 'error', 'failure']","['Error', 'error', 'failure']"
Availability,/// Report a given error with the location translated from the location in an; /// embedded string literal to a location in the MIR file.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,1,['error'],['error']
Availability,"/// Report a message to the currently installed diagnostic handler.; ///; /// This function returns, in particular in the case of error reporting; /// (DI.Severity == \a DS_Error), so the caller should leave the compilation; /// process in a self-consistent state, even though the generated code; /// need not be correct.; ///; /// The diagnostic message will be implicitly prefixed with a severity keyword; /// according to \p DI.getSeverity(), i.e., ""error: "" for \a DS_Error,; /// ""warning: "" for \a DS_Warning, and ""note: "" for \a DS_Note.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:130,error,error,130,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,2,['error'],['error']
Availability,/// Report a parse error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h:19,error,error,19,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,1,['error'],['error']
Availability,"/// Report a serious error, calling any installed error handler. See; /// ErrorHandling.h.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:21,error,error,21,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,3,"['Error', 'error']","['ErrorHandling', 'error']"
Availability,"/// Report a use-after-dealloc on Sym. If not empty,; /// Desc will be used to describe the error; otherwise,; /// a default warning will be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp:92,error,error,92,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp,1,['error'],['error']
Availability,/// Report an ISel error as a missed optimization remark to the LLVMContext's; /// diagnostic stream. Set the FailedISel MachineFunction property.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h:19,error,error,19,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h,1,['error'],['error']
Availability,/// Report an error at the current lexer location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h:14,error,error,14,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,1,['error'],['error']
Availability,/// Report an error at the current location with the given message.; ///; /// This function always return true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:14,error,error,14,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['error'],['error']
Availability,/// Report an error at the given location with the given message.; ///; /// This function always return true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:14,error,error,14,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['error'],['error']
Availability,"/// Report an error regarding overriding, along with any relevant; /// overridden methods.; ///; /// \param DiagID the primary error to report.; /// \param MD the overriding method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:14,error,error,14,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['error'],['error']
Availability,/// Report an error with the given message at the given location.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:14,error,error,14,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,1,['error'],['error']
Availability,/// Report an error with the given message at unknown location.; ///; /// Always returns true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:14,error,error,14,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,1,['error'],['error']
Availability,"/// Report an evaluation error. This should only be called when an error is; /// first discovered. When propagating an error, just return false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:25,error,error,25,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,3,['error'],['error']
Availability,/// Report error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h:11,error,error,11,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h,2,['error'],['error']
Availability,"/// Reports a bad alloc error, calling any user defined bad alloc; /// error handler. In contrast to the generic 'report_fatal_error'; /// functions, this function might not terminate, e.g. the user; /// defined error handler throws an exception, but it won't return.; ///; /// Note: When throwing an exception in the bad alloc handler, make sure that; /// the following unwind succeeds, e.g. do not trigger additional allocations; /// in the unwind chain.; ///; /// If no error handler is installed (default), throws a bad_alloc exception; /// if LLVM is compiled with exception support. Otherwise prints the error; /// to standard error and calls abort().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:24,error,error,24,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,6,['error'],['error']
Availability,/// Reports a localization error for the passed in method call and SVal,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:27,error,error,27,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,1,['error'],['error']
Availability,"/// Reports a serious error, calling any installed error handler. These; /// functions are intended to be used for error conditions which are outside; /// the control of the compiler (I/O errors, invalid user input, etc.); ///; /// If no error handler is installed the default is to print the message to; /// standard error, followed by a newline.; /// After the error handler is called this function will call abort(), it; /// does not return.; /// NOTE: The std::string variant was removed to avoid a <string> dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:22,error,error,22,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,7,['error'],"['error', 'errors']"
Availability,"/// Reports a vectorization failure: print \p DebugMsg for debugging; /// purposes along with the corresponding optimization remark \p RemarkName.; /// If \p I is passed, it is an instruction that prevents vectorization.; /// Otherwise, the loop \p TheLoop is used for the location of the remark.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:28,failure,failure,28,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,1,['failure'],['failure']
Availability,"/// Reports errors if a module must not include a specific file.; ///; /// \param RequestingModule The module including a file.; ///; /// \param RequestingModuleIsModuleInterface \c true if the inclusion is in; /// the interface of RequestingModule, \c false if it's in the; /// implementation of RequestingModule. Value is ignored and; /// meaningless if RequestingModule is nullptr.; ///; /// \param FilenameLoc The location of the inclusion's filename.; ///; /// \param Filename The included filename as written.; ///; /// \param File The included file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:12,error,errors,12,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['error'],['errors']
Availability,"/// Represents a JIT'd dynamic library.; ///; /// This class aims to mimic the behavior of a regular dylib or shared object,; /// but without requiring the contained program representations to be compiled; /// up-front. The JITDylib's content is defined by adding MaterializationUnits,; /// and contained MaterializationUnits will typically rely on the JITDylib's; /// links-against order to resolve external references (similar to a regular; /// dylib).; ///; /// The JITDylib object is a thin wrapper that references state held by the; /// ExecutionSession. JITDylibs can be removed, clearing this underlying state; /// and leaving the JITDylib object in a defunct state. In this state the; /// JITDylib's name is guaranteed to remain accessible. If the ExecutionSession; /// is still alive then other operations are callable but will return an Error; /// or null result (depending on the API). It is illegal to call any operation; /// other than getName on a JITDylib after the ExecutionSession has been torn; /// down.; ///; /// JITDylibs cannot be moved or copied. Their address is stable, and useful as; /// a key in some JIT data structures.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:787,alive,alive,787,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,3,"['Error', 'alive', 'down']","['Error', 'alive', 'down']"
Availability,"/// Represents a K&R-style 'int foo()' function, which has; /// no information available about its arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:79,avail,available,79,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['avail'],['available']
Availability,"/// Represents a function declaration or definition.; ///; /// Since a given function can be declared several times in a program,; /// there may be several FunctionDecls that correspond to that; /// function. Only one of those FunctionDecls will be found when; /// traversing the list of declarations in the context of the; /// FunctionDecl (e.g., the translation unit); this FunctionDecl; /// contains all of the information known about the function. Other,; /// previous declarations of the function are available via the; /// getPreviousDecl() chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:506,avail,available,506,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['avail'],['available']
Availability,"/// Represents a selected AST node.; ///; /// AST selection is represented using a tree of \c SelectedASTNode. The tree; /// follows the top-down shape of the actual AST. Each selected node has; /// a selection kind. The kind might be none as the node itself might not; /// actually be selected, e.g. a statement in macro whose child is in a macro; /// argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h:141,down,down,141,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h,1,['down'],['down']
Availability,"/// Represents a template name that was expressed as a; /// qualified name.; ///; /// This kind of template name refers to a template name that was; /// preceded by a nested name specifier, e.g., \c std::vector. Here,; /// the nested name specifier is ""std::"" and the template name is the; /// declaration for ""vector"". The QualifiedTemplateName class is only; /// used to provide ""sugar"" for template names that were expressed; /// with a qualified name, and has no semantic meaning. In this; /// manner, it is to TemplateName what ElaboratedType is to Type,; /// providing extra syntactic sugar for downstream clients.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h:601,down,downstream,601,interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,1,['down'],['downstream']
Availability,/// Represents a temporary file.; ///; /// The temporary file must be eventually discarded or given a final name and; /// kept.; ///; /// The destructor doesn't implicitly discard because there is no way to; /// properly handle errors in a destructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:228,error,errors,228,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['error'],['errors']
Availability,/// Represents an AvailableValue which can be rematerialized at the end of; /// the associated BasicBlock.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:18,Avail,AvailableValue,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['Avail'],['AvailableValue']
Availability,"/// Represents an allocation which has not been finalized yet.; ///; /// InFlightAllocs manage both executor memory allocations and working; /// memory allocations.; ///; /// On finalization, the InFlightAlloc should transfer the content of; /// working memory into executor memory, apply memory protections, and; /// run any finalization functions.; ///; /// Working memory should be kept alive at least until one of the following; /// happens: (1) the InFlightAlloc instance is destroyed, (2) the; /// InFlightAlloc is abandoned, (3) finalized target memory is destroyed.; ///; /// If abandon is called then working memory and executor memory should both; /// be freed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h:390,alive,alive,390,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,1,['alive'],['alive']
Availability,"/// Represents difference between two FPOptions values.; ///; /// The effect of language constructs changing the set of floating point options; /// is usually a change of some FP properties while leaving others intact. This; /// class describes such changes by keeping information about what FP options; /// are overridden.; ///; /// The integral set of FP options, described by the class FPOptions, may be; /// represented as a default FP option set, defined by language standard and; /// command line options, with the overrides introduced by pragmas.; ///; /// The is implemented as a value of the new FPOptions plus a mask showing which; /// fields are actually set in it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h:622,mask,mask,622,interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,1,['mask'],['mask']
Availability,"/// Represents either an error or a value T.; ///; /// ErrorOr<T> is a pointer-like class that represents the result of an; /// operation. The result is either an error, or a value of type T. This is; /// designed to emulate the usage of returning a pointer where nullptr indicates; /// failure. However instead of just knowing that the operation failed, we also; /// have an error_code and optional user data that describes why it failed.; ///; /// It is used like the following.; /// \code; /// ErrorOr<Buffer> getBuffer();; ///; /// auto buffer = getBuffer();; /// if (error_code ec = buffer.getError()); /// return ec;; /// buffer->write(""adena"");; /// \endcode; ///; ///; /// Implicit conversion to bool returns true if there is a usable value. The; /// unary * and -> operators provide pointer like access to the value. Accessing; /// the value when there is an error has undefined behavior.; ///; /// When T is a reference type the behavior is slightly different. The reference; /// is held in a std::reference_wrapper<std::remove_reference<T>::type>, and; /// there is special handling to make operator -> work as if T was not a; /// reference.; ///; /// T cannot be a rvalue reference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorOr.h:25,error,error,25,interpreter/llvm-project/llvm/include/llvm/Support/ErrorOr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorOr.h,6,"['Error', 'error', 'failure']","['ErrorOr', 'error', 'failure']"
Availability,"/// Represents information about a change in availability for; /// an entity, which is part of the encoding of the 'availability'; /// attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:45,avail,availability,45,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,2,['avail'],['availability']
Availability,"/// Represents return slots for NRVO candidates in the current scope.; /// If a variable is present in this set, it means that a return slot is; /// available for this variable in the current scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Scope.h:149,avail,available,149,interpreter/llvm-project/clang/include/clang/Sema/Scope.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Scope.h,1,['avail'],['available']
Availability,/// Represents the body of a coroutine. This wraps the normal function; /// body and holds the additional semantic context required to set up and tear; /// down the coroutine frame.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtCXX.h:156,down,down,156,interpreter/llvm-project/clang/include/clang/AST/StmtCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtCXX.h,1,['down'],['down']
Availability,"/// Represents the cost of inlining a function.; ///; /// This supports special values for functions which should ""always"" or; /// ""never"" be inlined. Otherwise, the cost represents a unitless amount;; /// smaller values increase the likelihood of the function being inlined.; ///; /// Objects of this type also provide the adjusted threshold for inlining; /// based on the information available for a particular callsite. They can be; /// directly tested to determine if inlining should occur given the cost and; /// threshold for this cost metric.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:386,avail,available,386,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,1,['avail'],['available']
Availability,/// Represents the diagnostic message with the error message associated; /// and the information on the location of the problem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h:47,error,error,47,interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,1,['error'],['error']
Availability,"/// Represents the version that this specifier requires. If the host OS; /// version is greater than or equal to Version, the @available will evaluate; /// to true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Availability.h:127,avail,available,127,interpreter/llvm-project/clang/include/clang/AST/Availability.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Availability.h,1,['avail'],['available']
Availability,"/// Require that all of the parameter types of function be complete. Normally,; /// parameter types are only required to be complete when a function is called; /// or defined, but to mangle functions with certain calling conventions, the; /// mangler needs to know the size of the parameter list. In this situation,; /// MSVC doesn't emit an error or instantiate templates. Instead, MSVC mangles; /// the function as _foo@0, i.e. zero bytes of parameters, which will usually; /// result in a linker error. Clang doesn't implement this behavior, and instead; /// attempts to error at compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:342,error,error,342,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,3,['error'],['error']
Availability,"/// Require the given type to be a structural type, and diagnose if it is not.; ///; /// \return \c true if an error was produced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:111,error,error,111,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['error'],['error']
Availability,/// Reserialize a list of parsed YAML remarks into bitstream remarks.; /// \p ParsedRemarks - A list of remarks.; /// \p StrTab - The string table for the remarks.; /// \returns Error::success() on success.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkConvert.cpp:178,Error,Error,178,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkConvert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkConvert.cpp,1,['Error'],['Error']
Availability,/// Reset state that only changes when we switch functions.; ///; /// This currently includes:; ///; /// 1. FailureMBB since we reuse the failure code path for all stack; /// protector checks created in an individual function.; ///; /// 2.The guard variable since the guard variable we are checking against is; /// always the same.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:108,Failure,FailureMBB,108,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,2,"['Failure', 'failure']","['FailureMBB', 'failure']"
Availability,/// Reset the parameter list to having zero parameters.; ///; /// This is used in various places for error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h:101,error,error,101,interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,2,"['error', 'recover']","['error', 'recovery']"
Availability,/// Resets LLVM's pretty stack state so that stack traces are printed correctly; /// when there are nested CrashRecoveryContexts and the inner one recovers from; /// a crash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:147,recover,recovers,147,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,1,['recover'],['recovers']
Availability,"/// Resolve all of the unresolved conflicts in the given module.; ///; /// \param Mod The module whose conflicts should be resolved.; ///; /// \param Complain Whether to emit diagnostics for failures.; ///; /// \returns true if any errors were encountered while resolving conflicts,; /// false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:191,failure,failures,191,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,2,"['error', 'failure']","['errors', 'failures']"
Availability,"/// Resolve all of the unresolved exports in the given module.; ///; /// \param Mod The module whose exports should be resolved.; ///; /// \param Complain Whether to emit diagnostics for failures.; ///; /// \returns true if any errors were encountered while resolving exports,; /// false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:187,failure,failures,187,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,2,"['error', 'failure']","['errors', 'failures']"
Availability,"/// Resolve all of the unresolved uses in the given module.; ///; /// \param Mod The module whose uses should be resolved.; ///; /// \param Complain Whether to emit diagnostics for failures.; ///; /// \returns true if any errors were encountered while resolving uses,; /// false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:181,failure,failures,181,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,2,"['error', 'failure']","['errors', 'failures']"
Availability,"/// ResolveAddressOfOverloadedFunction - Try to resolve the address of; /// an overloaded function (C++ [over.over]), where @p From is an; /// expression with overloaded function type and @p ToType is the type; /// we're trying to resolve to. For example:; ///; /// @code; /// int f(double);; /// int f(int);; ///; /// int (*pfd)(double) = f; // selects f(double); /// @endcode; ///; /// This routine returns the resulting FunctionDecl if it could be; /// resolved, and NULL otherwise. When @p Complain is true, this; /// routine will emit diagnostics if there is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:567,error,error,567,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,/// Restore EFLAGS from the provided GPR. This should be produced by; /// `saveEFLAGS`.; ///; /// This must be done within the same basic block as the save in order to; /// reliably lower.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:173,reliab,reliably,173,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['reliab'],['reliably']
Availability,/// Restores default bad alloc error handling behavior.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:31,error,error,31,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,1,['error'],['error']
Availability,/// Restores default error handling behaviour.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:21,error,error,21,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,1,['error'],['error']
Availability,"/// Restores the topmost element of the ""pretty"" stack state to State, which; /// should come from a previous call to SavePrettyStackState(). This is; /// useful when using a CrashRecoveryContext in code that also uses; /// PrettyStackTraceEntries, to make sure the stack that's printed if a crash; /// happens after a crash that's been recovered by CrashRecoveryContext; /// doesn't have frames on it that were added in code unwound by the; /// CrashRecoveryContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PrettyStackTrace.h:337,recover,recovered,337,interpreter/llvm-project/llvm/include/llvm/Support/PrettyStackTrace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PrettyStackTrace.h,1,['recover'],['recovered']
Availability,/// Restrict the PHI's contents down to only \c NewBlocks.; /// \c NewBlocks must be a subset of \c this->Blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:32,down,down,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,1,['down'],['down']
Availability,"/// Result files which are generated correctly on failure, and which should; /// only be removed if we crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h:50,failure,failure,50,interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,1,['failure'],['failure']
Availability,/// Result files which should be removed on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h:44,failure,failure,44,interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,1,['failure'],['failure']
Availability,"/// Result: syst.error from fDA2 on fAx",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h:17,error,error,17,hist/unfold/inc/TUnfoldSys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h,1,['error'],['error']
Availability,"/// Result: syst.error from fDA2 on fX",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h:17,error,error,17,hist/unfold/inc/TUnfoldSys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h,1,['error'],['error']
Availability,"/// Retain the given block, with _Block_copy semantics.; /// call i8* \@objc_retainBlock(i8* %value); ///; /// \param mandatory - If false, emit the call with metadata; /// indicating that it's okay for the optimizer to eliminate this call; /// if it can prove that the block never escapes except down the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:297,down,down,297,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['down'],['down']
Availability,"/// Retrieve a FileEntry that bypasses VFE, which is expected to be a virtual; /// file entry, to access the real file. The returned FileEntry will have; /// the same filename as FE but a different identity and its own stat.; ///; /// This should be used only for rare error recovery paths because it; /// bypasses all mapping and uniquing, blindly creating a new FileEntry.; /// There is no attempt to deduplicate these; if you bypass the same file; /// twice, you get two new file entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:269,error,error,269,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,2,"['error', 'recover']","['error', 'recovery']"
Availability,"/// Retrieve a canonical type pointer with a different static type,; /// upcasting or downcasting as needed.; ///; /// The getAs() function is typically used to try to downcast to a; /// more specific (canonical) type in the type system. For example:; ///; /// @code; /// void f(CanQual<Type> T) {; /// if (CanQual<PointerType> Ptr = T->getAs<PointerType>()) {; /// // look at Ptr's pointee type; /// }; /// }; /// @endcode; ///; /// \returns A proxy pointer to the same type, but with the specified; /// static type (@p U). If the dynamic type is not the specified static type; /// or a derived class thereof, a NULL canonical type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h:86,down,downcasting,86,interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,2,['down'],"['downcast', 'downcasting']"
Availability,/// Retrieve the availability of this code completion result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:17,avail,availability,17,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['avail'],['availability']
Availability,"/// Retrieve the config object which can be used to set flags for things like offsetting the likelihood; /// or using the error wall for the minimiser.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/RooStatsUtils.h:122,error,error,122,roofit/roostats/inc/RooStats/RooStatsUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/RooStatsUtils.h,1,['error'],['error']
Availability,"/// Retrieve the current frame info if one is available and it is not yet; /// closed. Otherwise, issue an error and return null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:46,avail,available,46,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,2,"['avail', 'error']","['available', 'error']"
Availability,"/// Retrieve the current function, if any, that should be analyzed for; /// potential availability violations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:86,avail,availability,86,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avail'],['availability']
Availability,"/// Retrieve the diagnostic which caused this deduction failure,; /// if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:56,failure,failure,56,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,/// Retrieve the effective availability of the given declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:27,avail,availability,27,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,1,['avail'],['availability']
Availability,/// Retrieve the name of the platform as it is used in the; /// availability attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:64,avail,availability,64,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['avail'],['availability']
Availability,/// Retrieve the source location information for the type; /// being destroyed.; ///; /// This type-source information is available for non-dependent; /// pseudo-destructor expressions and some dependent pseudo-destructor; /// expressions. Returns null if we only have the identifier for a; /// dependent pseudo-destructor expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:122,avail,available,122,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['avail'],['available']
Availability,"/// Retrieve the template argument list associated with this; /// deduction failure, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:76,failure,failure,76,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,"/// Retrieve the template parameter this deduction failure; /// refers to, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:51,failure,failure,51,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,"/// Retrieve the version of the target platform in which this; /// declaration was introduced.; ///; /// \returns An empty version tuple if this declaration has no 'introduced'; /// availability attributes, or the version tuple that's specified in the; /// attribute otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:182,avail,availability,182,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['avail'],['availability']
Availability,"/// Retrieves the ""canonical"" template name that refers to a; /// given template.; ///; /// The canonical template name is the simplest expression that can; /// be used to refer to a given template. For most templates, this; /// expression is just the template declaration itself. For example,; /// the template std::vector can be referred to via a variety of; /// names---std::vector, \::std::vector, vector (if vector is in; /// scope), etc.---but all of these names map down to the same; /// TemplateDecl, which is used to form the canonical template name.; ///; /// Dependent template names are more interesting. Here, the; /// template name could be something like T::template apply or; /// std::allocator<T>::template rebind, where the nested name; /// specifier itself is dependent. In this case, the canonical; /// template name uses the shortest form of the dependent; /// nested-name-specifier, which itself contains all canonical; /// types, values, and templates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:473,down,down,473,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['down'],['down']
Availability,/// Retrieves the clang CC1 specific flags out of the compilation's jobs.; /// \returns NULL on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:96,error,error,96,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,1,['error'],['error']
Availability,"/// Retrieves the error string associated with the last system error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/TError.h:18,error,error,18,core/foundation/inc/TError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/TError.h,2,['error'],['error']
Availability,/// Retrieves the locations of each of the identifiers that make up; /// the complete module name in the import declaration.; ///; /// This will return an empty array if the locations of the individual; /// identifiers aren't available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:226,avail,available,226,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['avail'],['available']
Availability,/// Retrieves the max available threads for the current strategy. This; /// accounts for affinity masks and takes advantage of all CPU sockets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:22,avail,available,22,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,2,"['avail', 'mask']","['available', 'masks']"
Availability,"/// Return 'true' if this vector operation is ""horizontal""; /// and return the operands for the horizontal operation in LHS and RHS. A; /// horizontal operation performs the binary operation on successive elements; /// of its first operand, then on successive elements of its second operand,; /// returning the resulting values in a vector. For example, if; /// A = < float a0, float a1, float a2, float a3 >; /// and; /// B = < float b0, float b1, float b2, float b3 >; /// then the result of doing a horizontal operation on A and B is; /// A horizontal-op B = < a0 op a1, a2 op a3, b0 op b1, b2 op b3 >.; /// In short, LHS and RHS are inspected to see if LHS op RHS is of the form; /// A horizontal-op B, for some already available A and B, and if so then LHS is; /// set to A, RHS to B, and the routine returns 'true'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:724,avail,available,724,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"/// Return (and \p Op, \p Mask) for compare instructions or; /// (vselect \p Mask, \p Op, \p PreservedSrc) for others along with the; /// necessary casting or extending for \p Mask when lowering masking intrinsics",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,Mask,Mask,26,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,4,"['Mask', 'mask']","['Mask', 'masking']"
Availability,/// Return Mask with the necessary casting or extending; /// for \p Mask according to \p MaskVT when lowering masking intrinsics,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:11,Mask,Mask,11,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,4,"['Mask', 'mask']","['Mask', 'MaskVT', 'masking']"
Availability,"/// Return a CodeSegAttr from a containing class. The Microsoft docs say; /// when __declspec(code_seg) ""is applied to a class, all member functions of; /// the class and nested classes -- this includes compiler-generated special; /// member functions -- are put in the specified segment.""; /// The actual behavior is a little more complicated. The Microsoft compiler; /// won't check outer classes if there is an active value from #pragma code_seg.; /// The CodeSeg is always applied from the direct parent but only from outer; /// classes when the #pragma code_seg stack is empty. See:; /// https://reviews.llvm.org/D22931, the Microsoft feedback page is no longer; /// available since MS has removed the page.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:672,avail,available,672,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avail'],['available']
Availability,/// Return a MachineFunction pass that identifies call sites; /// and propagates register usage information of callee to caller; /// if available with PysicalRegisterUsageInfo pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:136,avail,available,136,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['avail'],['available']
Availability,"/// Return a RDefineReader or a RVariationReader, or nullptr if not available.; /// If requestedType does not match the actual type of the Define or Variation, an exception is thrown.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:68,avail,available,68,tree/dataframe/src/RDFColumnRegister.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx,1,['avail'],['available']
Availability,"/// Return a RDefineReader or a RVariationReader, or nullptr if not available.; /// No type checking is done on the requested reader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:68,avail,available,68,tree/dataframe/src/RDFColumnRegister.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx,1,['avail'],['available']
Availability,"/// Return a StringRef to the source buffer data for the; /// specified FileID.; ///; /// \param FID The file ID whose contents will be returned.; /// \param Invalid If non-NULL, will be set true if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:202,error,error,202,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['error'],['error']
Availability,"/// Return a bitmask representing the parts of a register that are covered by; /// SubIdx \see LaneBitmask.; ///; /// SubIdx == 0 is allowed, it has the lane mask ~0u.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:158,mask,mask,158,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['mask'],['mask']
Availability,/// Return a list of input files. This function has logic for dealing with the; /// special case where we might have dSYM bundles as input. The function; /// returns an error when the directory structure doesn't match that of a dSYM; /// bundle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:169,error,error,169,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,1,['error'],['error']
Availability,"/// Return a mask of call-preserved registers for the given calling convention; /// on the current function. The mask should include all call-preserved; /// aliases. This is used by the register allocator to determine which; /// registers can be live across a call.; ///; /// The mask is an array containing (TRI::getNumRegs()+31)/32 entries.; /// A set bit indicates that all bits of the corresponding register are; /// preserved across the function call. The bit mask is expected to be; /// sub-register complete, i.e. if A is preserved, so are all its; /// sub-registers.; ///; /// Bits are numbered from the LSB, so the bit for physical register Reg can; /// be found as (Mask[Reg / 32] >> Reg % 32) & 1.; ///; /// A NULL pointer means that no register mask will be used, and call; /// instructions should use implicit-def operands to indicate call clobbered; /// registers.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:13,mask,mask,13,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,6,"['Mask', 'mask']","['Mask', 'mask']"
Availability,/// Return a mask of vector type MaskVT to replace InMask. Also adjust; /// MaskVT to ToMaskVT if needed with vector extension or truncation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h:13,mask,mask,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,3,"['Mask', 'mask']","['MaskVT', 'mask']"
Availability,/// Return a node that can be scheduled in this cycle. Requirements:; /// (1) Ready: latency has been satisfied; /// (2) No Hazards: resources are available; /// (3) No Interferences: may unschedule to break register interferences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:147,avail,available,147,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avail'],['available']
Availability,"/// Return a null-terminated list of all of the callee-saved registers on; /// this target. The register should be in the order of desired callee-save; /// stack frame offset. The first register is closest to the incoming stack; /// pointer if stack grows down, and vice versa.; /// Notice: This function does not take into account disabled CSRs.; /// In most cases you will want to use instead the function; /// getCalleeSavedRegs that is implemented in MachineRegisterInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:256,down,down,256,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['down'],['down']
Availability,"/// Return a pair of lane masks (reads, writes) indicating which lanes this; /// instruction uses with Reg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundle.h:26,mask,masks,26,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundle.h,1,['mask'],['masks']
Availability,/// Return a pass that removes redundant LEA instructions and redundant address; /// recalculations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:31,redundant,redundant,31,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h,2,['redundant'],['redundant']
Availability,/// Return a point at the end of the given \p MBB to insert SALU instructions; /// for lane mask calculation. Take terminators and SCC into account.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp:92,mask,mask,92,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,1,['mask'],['mask']
Availability,"/// Return a pointer to the value of the current entry.; /// Return a nullptr and print an error if no entry has been loaded yet.; /// The returned address is guaranteed to stay constant while a given TTree is being read from a given file,; /// unless the branch addresses are manipulated directly (e.g. through TTree::SetBranchAddress()).; /// The address might also change when the underlying TTree/TFile is switched, e.g. when a TChain switches files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReaderValue.h:91,error,error,91,tree/treeplayer/inc/TTreeReaderValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReaderValue.h,1,['error'],['error']
Availability,"/// Return a register mask for the registers preserved by the unwinder,; /// or nullptr if no custom mask is needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:22,mask,mask,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,2,['mask'],['mask']
Availability,/// Return a register mask that clobbers everything.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:22,mask,mask,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['mask'],['mask']
Availability,"/// Return a single atomic ordering that is at least as strong as both the; /// success and failure orderings for an atomic operation. (For operations; /// other than cmpxchg, this is equivalent to getSuccessOrdering().)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:92,failure,failure,92,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,2,['failure'],['failure']
Availability,"/// Return a string with the location information for this diagnostic; /// in the format ""file:line:col"". If location information is not available,; /// it returns ""<unknown>:0:0"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:137,avail,available,137,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['avail'],['available']
Availability,"/// Return a vector_shuffle of the specified vector of zero or undef vector.; /// This produces a shuffle where the low element of V2 is swizzled into the; /// zero/undef vector, landing at element Idx.; /// This produces a shuffle mask like 4,1,2,3 (idx=0) or 0,1,2,4 (idx=3).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:232,mask,mask,232,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,/// Return all available registers in the register class in Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h:15,avail,available,15,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h,2,"['Mask', 'avail']","['Mask', 'available']"
Availability,/// Return all the available information about this type's exception spec.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:19,avail,available,19,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['avail'],['available']
Availability,/// Return all the call-preserved register masks defined for this target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:43,mask,masks,43,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['mask'],['masks']
Availability,"/// Return an ISD::VECTOR_SHUFFLE node. The number of elements in VT,; /// which must be a vector type, must match the number of mask elements; /// NumElts. An integer mask element equal to -1 is treated as undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:129,mask,mask,129,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,2,['mask'],['mask']
Availability,"/// Return an SMDiagnostic at the specified location with the specified; /// string.; ///; /// \param Msg If non-null, the kind of message (e.g., ""error"") which is; /// prefixed to the message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h:147,error,error,147,interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h,1,['error'],['error']
Availability,/// Return an all true boolean vector (mask) with \p NumElts lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:39,mask,mask,39,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['mask'],['mask']
Availability,"/// Return an error at the location \p L, with the message \p Msg. This; /// may be modified before being emitted.; ///; /// \return The return value is always true, as an idiomatic convenience to; /// clients.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h:14,error,error,14,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,1,['error'],['error']
Availability,"/// Return an iterator to the beginning of the contained object if this makes; /// sense, throw a compilation error otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:110,error,error,110,tree/dataframe/inc/ROOT/RResultPtr.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx,1,['error'],['error']
Availability,"/// Return an iterator to the end of the contained object if this makes; /// sense, throw a compilation error otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:104,error,error,104,tree/dataframe/inc/ROOT/RResultPtr.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx,1,['error'],['error']
Availability,"/// Return an open handle to standard error. On Unix, this is typically FD 2.; /// Returns kInvalidFile when the stream is closed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:38,error,error,38,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['error'],['error']
Availability,"/// Return an operand bundle by name, if present.; ///; /// It is an error to call this for operand bundle types that may have; /// multiple instances of them on the same instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:69,error,error,69,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['error'],['error']
Availability,"/// Return an operand bundle by tag ID, if present.; ///; /// It is an error to call this for operand bundle types that may have; /// multiple instances of them on the same instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:71,error,error,71,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['error'],['error']
Availability,/// Return bit mask that contains all register classes that are projected into; /// RC by SubRegIdx. The result is cached in SuperRegMasks data-member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,1,['mask'],['mask']
Availability,/// Return bitmask of domains that are available and in mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:39,avail,available,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,2,"['avail', 'mask']","['available', 'mask']"
Availability,"/// Return default level for MINUIT error analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNLLVarNew.h:36,error,error,36,roofit/roofitcore/src/RooNLLVarNew.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNLLVarNew.h,1,['error'],['error']
Availability,"/// Return error contained inside this Cursor, if any. Clears the internal; /// Cursor state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:11,error,error,11,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['error'],['error']
Availability,"/// Return false and print error messages if there is any unexpected; /// duplicates BIT constant in any of the class hierarchy knows; /// to TClassTable.; /// If verbose is true, also print all the bit declare in eacho of the classes; /// and all their bases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStatusBitsChecker.cxx:27,error,error,27,core/meta/src/TStatusBitsChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStatusBitsChecker.cxx,1,['error'],['error']
Availability,"/// Return false and print error messages if there is any unexpected; /// duplicates BIT constant in the class hierarchy.; /// If verbose is true, also print all the bit declare in this class; /// and all its bases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStatusBitsChecker.cxx:27,error,error,27,core/meta/src/TStatusBitsChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStatusBitsChecker.cxx,2,['error'],['error']
Availability,/// Return false if the next token is an identifier. An 'expected identifier'; /// error is emitted otherwise.; ///; /// The parser tries to recover from the error by checking if the next token; /// is a C++ keyword when parsing Objective-C++. Return false if the recovery; /// was successful.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:83,error,error,83,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,4,"['error', 'recover']","['error', 'recover', 'recovery']"
Availability,/// Return false if there is an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:32,error,error,32,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,2,['error'],['error']
Availability,"/// Return function's PGO name from the function name's symbol; /// address in the object file. If an error occurs, return; /// an empty string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:102,error,error,102,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,1,['error'],['error']
Availability,/// Return if import of the given declaration has failed and if yes; /// the kind of the problem. This gives the first error encountered with; /// the node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:119,error,error,119,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Return if the target supports combining a; /// chain like:; /// \code; /// %andResult = and %val1, #mask; /// %icmpResult = icmp %andResult, 0; /// \endcode; /// into a single machine instruction of a form like:; /// \code; /// cc = test %register, #mask; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:104,mask,mask,104,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['mask'],['mask']
Availability,/// Return mask number \p Idx.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:11,mask,mask,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['mask'],['mask']
Availability,/// Return parsed documentation comment attached to a given declaration.; /// Returns nullptr if no comment is attached.; ///; /// \param PP the Preprocessor used with this TU. Could be nullptr if; /// preprocessor is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:222,avail,available,222,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['avail'],['available']
Availability,/// Return sanitizers which are available in this toolchain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:32,avail,available,32,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['avail'],['available']
Availability,"/// Return the 'spelling' of the Tok token.; ///; /// The spelling of a token is the characters used to represent the token in; /// the source file after trigraph expansion and escaped-newline folding. In; /// particular, this wants to get the true, uncanonicalized, spelling of; /// things like digraphs, UCNs, etc.; ///; /// \param Invalid If non-null, will be set \c true if an error occurs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:381,error,error,381,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['error'],['error']
Availability,"/// Return the 'spelling' of the token at the given; /// location; does not go up to the spelling location or down to the; /// expansion location.; ///; /// \param buffer A buffer which will be used only if the token requires; /// ""cleaning"", e.g. if it contains trigraphs or escaped newlines; /// \param invalid If non-null, will be set \c true if an error occurs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:110,down,down,110,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,2,"['down', 'error']","['down', 'error']"
Availability,/// Return the BundleOpInfo for the operand at index OpIdx.; ///; /// It is an error to call this with an OpIdx that does not correspond to an; /// bundle operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:79,error,error,79,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['error'],['error']
Availability,"/// Return the NamedInstrProfRecord associated with FuncName and FuncHash.; /// When return a hash_mismatch error and MismatchedFuncSum is not nullptr,; /// the sum of all counters in the mismatched function will be set to; /// MismatchedFuncSum. If there are multiple instances of mismatched; /// functions, MismatchedFuncSum returns the maximum. If \c FuncName is not; /// found, try to lookup \c DeprecatedFuncName to handle profiles built by; /// older compilers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h:108,error,error,108,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,1,['error'],['error']
Availability,"/// Return the SubclassData value, without HasDebugValue. This contains an; /// encoding of the volatile flag, as well as bits used by subclasses. This; /// function should only be used to compute a FoldingSetNodeID value.; /// The HasDebugValue bit is masked out because CSE map needs to match; /// nodes with debug info with nodes without debug info. Same is about; /// isDivergent bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:253,mask,masked,253,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['mask'],['masked']
Availability,/// Return the UBSan prologue signature for \p FD if one is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:60,avail,available,60,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['avail'],['available']
Availability,"/// Return the algorithm name used for solving; /// Note the name is available only after having called solved; /// Otherwise an empyty string is returned",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMultiRootFinder.h:69,avail,available,69,math/mathmore/inc/Math/GSLMultiRootFinder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMultiRootFinder.h,1,['avail'],['available']
Availability,"/// Return the amount of memory used by memory buffers, breaking down; /// by heap-backed versus mmap'ed memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h:65,down,down,65,interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,6,['down'],['down']
Availability,"/// Return the asymmetric errors on the current weight.; /// See also weightError(ErrorType) const for symmetric error.; /// \param[out] lo Low error.; /// \param[out] hi High error.; // \param[in] etype Type of error to compute. May throw if not supported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h:26,error,errors,26,roofit/roofitcore/inc/RooAbsData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h,6,"['Error', 'error']","['ErrorType', 'error', 'errors']"
Availability,"/// Return the bits demanded from instruction I.; ///; /// For vector instructions individual vector elements are not distinguished:; /// A bit is demanded if it is demanded for any of the vector elements. The; /// size of the return value corresponds to the type size in bits of the; /// scalar type.; ///; /// Instructions that do not have integer or vector of integer type are; /// accepted, but will always produce a mask with all bits set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h:421,mask,mask,421,interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h,1,['mask'],['mask']
Availability,"/// Return the buffer for the specified FileID.; ///; /// If there is an error opening this buffer the first time, this; /// manufactures a temporary buffer and returns it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:73,error,error,73,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['error'],['error']
Availability,"/// Return the comparison category information as specified by; /// `getCategoryForType(Ty)`. If the information is not already cached,; /// the declaration is looked up and a cache entry is created.; /// NOTE: Lookup is expected to succeed. Use lookupInfo if failure is; /// possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ComparisonCategories.h:260,failure,failure,260,interpreter/llvm-project/clang/include/clang/AST/ComparisonCategories.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ComparisonCategories.h,1,['failure'],['failure']
Availability,/// Return the cost of a vrgather.vv instruction for the type VT. vrgather.vv; /// is generally quadratic in the number of vreg implied by LMUL. Note that; /// operand (index and possibly mask) are handled separately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:188,mask,mask,188,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,/// Return the cost of full scalarization of gather / scatter operation.; ///; /// Opcode - Load or Store instruction.; /// SrcVTy - The type of the data vector that should be gathered or scattered.; /// VariableMask - The mask is non-constant at compile time.; /// Alignment - Alignment for one element.; /// AddressSpace - pointer[s] address space.; ///; /// FIXME: Add TargetCostKind support.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:223,mask,mask,223,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['mask'],['mask']
Availability,/// Return the costs for our two available strategies for lowering a; /// div/rem operation which requires speculating at least one lane.; /// First result is for scalarization (will be invalid for scalable; /// vectors); second is for the safe-divisor strategy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,avail,available,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avail'],['available']
Availability,"/// Return the current execution domain and bit mask of; /// possible domains for instruction.; ///; /// Some micro-architectures have multiple execution domains, and multiple; /// opcodes that perform the same operation in different domains. For; /// example, the x86 architecture provides the por, orps, and orpd; /// instructions that all do the same thing. There is a latency penalty if a; /// register is written in one domain and read in another.; ///; /// This function returns a pair (domain, mask) containing the execution; /// domain of MI, and a bit mask of possible domains. The setExecutionDomain; /// function can be used to change the opcode to one of the domains in the; /// bit mask. Instructions whose execution domain can't be changed should; /// return a 0 mask.; ///; /// The execution domain numbers don't have any special meaning except domain; /// 0 is used for instructions that are not associated with any interesting; /// execution domain.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:48,mask,mask,48,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,5,['mask'],['mask']
Availability,/// Return the current position of this Cursor. In the error state this is; /// the position of the Cursor before the first error was encountered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:55,error,error,55,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,/// Return the cycle for the given class and operand. Return std::nullopt if; /// the information is not available for the operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrItineraries.h:105,avail,available,105,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrItineraries.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrItineraries.h,1,['avail'],['available']
Availability,/// Return the error message as a string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:15,error,error,15,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['error'],['error']
Availability,"/// Return the error on the given point.; /// Safer method returning in any case the error and not the inverse as in the; /// function above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h:15,error,error,15,math/mathcore/inc/Fit/BinData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h,2,['error'],['error']
Availability,"/// Return the expression that represents the number of times; /// a loop iterates. The function takes the operands that represent the; /// loop start value, loop end value, and induction value. Based upon; /// these operands, the function attempts to compute the trip count.; /// If the trip count is not directly available (as an immediate value,; /// or a register), the function will attempt to insert computation of it; /// to the loop's preheader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:315,avail,available,315,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['avail'],['available']
Availability,"/// Return the first template argument this deduction failure; /// refers to, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:54,failure,failure,54,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,"/// Return the full length of this table, including the length field.; /// Return std::nullopt if the length cannot be identified reliably.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugAddr.h:130,reliab,reliably,130,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugAddr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugAddr.h,1,['reliab'],['reliably']
Availability,/// Return the generic fixup kind for a value with the given size. It; /// is an error to pass an unsupported size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFixup.h:81,error,error,81,interpreter/llvm-project/llvm/include/llvm/MC/MCFixup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFixup.h,1,['error'],['error']
Availability,"/// Return the hazard type of emitting this node. There are three; /// possible results. Either:; /// * NoHazard: it is legal to issue this instruction on this cycle.; /// * Hazard: issuing this instruction would stall the machine. If some; /// other instruction is available, issue it first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:266,avail,available,266,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,1,['avail'],['available']
Availability,"/// Return the index of the call argument that this deduction; /// failure refers to, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:67,failure,failure,67,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,/// Return the largest available SGPR aligned to \p Align for the register; /// class \p RC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.h:23,avail,available,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.h,1,['avail'],['available']
Availability,"/// Return the location for the register in \a RegNum if there is a location.; ///; /// \param RegNum the register number to find a location for.; ///; /// \returns A location if one is available for \a RegNum, or std::nullopt; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h:186,avail,available,186,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,1,['avail'],['available']
Availability,/// Return the mask for this instruction as a vector of integers. Undefined; /// elements of the mask are returned as PoisonMaskElem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:15,mask,mask,15,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['mask'],['mask']
Availability,"/// Return the mask for this instruction, for use in bitcode.; ///; /// TODO: This is temporary until we decide a new bitcode encoding for; /// shufflevector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:15,mask,mask,15,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['mask'],['mask']
Availability,/// Return the mask of a predicated VPReplicateRecipe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['mask'],['mask']
Availability,/// Return the mask used by this recipe. Note that a full mask is represented; /// by a nullptr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,6,['mask'],['mask']
Availability,"/// Return the masked discriminator value for an input discrimnator value D; /// (i.e. zero out the (B+1)-th and above bits for D (B is 0-base).; // Example: an input of (0x1FF, 7) returns 0xFF.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h:15,mask,masked,15,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,1,['mask'],['masked']
Availability,"/// Return the maximum size of a call frame that must be; /// allocated for an outgoing function call. This is only available if; /// CallFrameSetup/Destroy pseudo instructions are used by the target, and; /// then only during or after prolog/epilog code insertion.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:116,avail,available,116,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['avail'],['available']
Availability,"/// Return the module that this code generator is building into.; ///; /// This may return null after HandleTranslationUnit is called;; /// this signifies that there was an error generating code. A; /// diagnostic will have been generated in this case, and the module; /// will be deleted.; ///; /// It will also return null if the module is released.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ModuleBuilder.h:173,error,error,173,interpreter/llvm-project/clang/include/clang/CodeGen/ModuleBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ModuleBuilder.h,1,['error'],['error']
Availability,/// Return the nofpclass mask that can be applied to floating-point parameters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:25,mask,mask,25,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['mask'],['mask']
Availability,"/// Return the number of currently available slot.; ///; /// The method is safe to call concurrently to other TThreadedObject methods.; /// Note that slots could be available but contain no data (i.e. a nullptr) if; /// they have not been used yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:35,avail,available,35,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,2,['avail'],['available']
Availability,"/// Return the number of incoming values, taking into account that a single; /// incoming value has no mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:103,mask,mask,103,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['mask'],['mask']
Availability,"/// Return the number of samples collected at the given location.; /// Each location is specified by \p LineOffset and \p Discriminator.; /// If the location is not found in profile, return error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:190,error,error,190,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['error'],['error']
Availability,/// Return the operand bundle for the operand at index OpIdx.; ///; /// It is an error to call this with an OpIdx that does not correspond to an; /// bundle operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:81,error,error,81,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['error'],['error']
Availability,"/// Return the second template argument this deduction failure; /// refers to, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:55,failure,failure,55,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,"/// Return the set of patterns (from MaskedICmpType) that (icmp SCC (A & B), C); /// satisfies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:37,Mask,MaskedICmpType,37,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['Mask'],['MaskedICmpType']
Availability,/// Return the shuffle mask value of this instruction for the given element; /// index. Return PoisonMaskElem if the element is undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:23,mask,mask,23,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['mask'],['mask']
Availability,"/// Return the symmetric error on the current weight.; /// See also weightError(double&,double&,ErrorType) const for asymmetric errors.; // \param[in] etype Type of error to compute. May throw if not supported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h:25,error,error,25,roofit/roofitcore/inc/RooAbsData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h,4,"['Error', 'error']","['ErrorType', 'error', 'errors']"
Availability,/// Return the target machine (if available).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:34,avail,available,34,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['avail'],['available']
Availability,/// Return the test mask which returns true after fabs is applied to the value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:20,mask,mask,20,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,1,['mask'],['mask']
Availability,"/// Return the test mask which returns true if the value could have the same set; /// of classes, but with a different sign.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:20,mask,mask,20,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,1,['mask'],['mask']
Availability,/// Return the test mask which returns true if the value's sign bit is flipped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:20,mask,mask,20,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,1,['mask'],['mask']
Availability,/// Return the type of the mask type suitable for masking the provided; /// vector type. This is simply an i1 element type vector of the same; /// (possibly scalable) length.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],"['mask', 'masking']"
Availability,/// Return the unique wchar_t type available in C++ (and available as; /// __wchar_t as a Microsoft extension).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:35,avail,available,35,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,2,['avail'],['available']
Availability,/// Return the value of 'self' if available in the given context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h:34,avail,available,34,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,1,['avail'],['available']
Availability,"/// Return the value of the flag in this raw_fd_ostream indicating whether an; /// output error has been encountered.; /// This doesn't implicitly flush any pending output. Also, it doesn't; /// guarantee to detect all errors unless the stream has been closed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:90,error,error,90,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,2,['error'],"['error', 'errors']"
Availability,"/// Return the value of the last argument as an integer, or a default. If Diags; /// is non-null, emits an error if the argument is given, but non-integral.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/OptionUtils.h:107,error,error,107,interpreter/llvm-project/clang/include/clang/Driver/OptionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/OptionUtils.h,1,['error'],['error']
Availability,"/// Return this JITDylib and its transitive dependencies in DFS order; /// based on linkage relationships.; ///; /// If any JITDylib in the order is defunct then this method will return an; /// error, otherwise returns the order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:194,error,error,194,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['error'],['error']
Availability,"/// Return true (the default) if it is profitable to remove a sext_inreg(x); /// where the sext is redundant, and use x directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:99,redundant,redundant,99,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['redundant'],['redundant']
Availability,/// Return true if '(Op & Mask) == Mask'.; /// Op and Mask are known to be the same type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:26,Mask,Mask,26,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,3,['Mask'],['Mask']
Availability,/// Return true if 'Op & Mask' is known to be zero in DemandedElts. We; /// use this predicate to simplify operations downstream. Op and Mask are; /// known to be the same type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:25,Mask,Mask,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,3,"['Mask', 'down']","['Mask', 'downstream']"
Availability,/// Return true if 'Op & Mask' is known to be zero. We; /// use this predicate to simplify operations downstream. Op and Mask are; /// known to be the same type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:25,Mask,Mask,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,3,"['Mask', 'down']","['Mask', 'downstream']"
Availability,/// Return true if 'Op' is known to be zero in DemandedElts. We; /// use this predicate to simplify operations downstream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:111,down,downstream,111,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['down'],['downstream']
Availability,"/// Return true if 'V & Mask' is known to be zero. We use this predicate to; /// simplify operations downstream. Mask is known to be zero for bits that V; /// cannot have.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, the mask, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the elements in the vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:24,Mask,Mask,24,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,4,"['Mask', 'down', 'mask']","['Mask', 'downstream', 'mask']"
Availability,"/// Return true if LSR should attempts to replace a use of an otherwise dead; /// primary IV in the latch condition with another IV available in the loop.; /// When successful, makes the primary IV dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:132,avail,available,132,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['avail'],['available']
Availability,/// Return true if \p FaultingMI can be hoisted from after the; /// instructions in \p InstsSeenSoFar to before them. Set \p Dependence to a; /// non-null value if we also need to (and legally can) hoist a dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:22,Fault,FaultingMI,22,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['Fault'],['FaultingMI']
Availability,"/// Return true if \p VMI is applicable in \p Ctx, that is, all traits required; /// by \p VMI are available in the OpenMP context \p Ctx. If \p DeviceSetOnly is; /// true, only the device selector set, if present, are checked. Note that we; /// still honor extension traits provided by the user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPContext.h:99,avail,available,99,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPContext.h,1,['avail'],['available']
Availability,/// Return true if a G_SHUFFLE_VECTOR instruction \p MI has an undef mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:69,mask,mask,69,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['mask'],['mask']
Availability,/// Return true if a RISC-V target specified op has a mask operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,/// Return true if a particular error+note combination must be downgraded to a; /// warning in Microsoft mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:32,error,error,32,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,2,"['down', 'error']","['downgraded', 'error']"
Availability,/// Return true if a particular note should be downgraded to a compatibility; /// warning in C++11 mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:47,down,downgraded,47,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,1,['down'],['downgraded']
Availability,"/// Return true if a shuffle mask chooses elements identically in its top and; /// bottom halves. For example, any splat mask has the same top and bottom; /// halves. If an element is undefined in only one half of the mask, the halves; /// are not considered identical.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['mask'],['mask']
Availability,/// Return true if all bits that are set in mask \p mask0 are also set in; /// \p mask1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:44,mask,mask,44,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['mask'],['mask']
Availability,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:133,mask,masking,133,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,3,"['Mask', 'mask']","['MaskedOp', 'masked', 'masking']"
Availability,/// Return true if divmod libcall is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,avail,available,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avail'],['available']
Availability,"/// Return true if either PBI or BI has branch weight available, and store; /// the weights in {Pred|Succ}{True|False}Weight. If one of PBI and BI does; /// not have branch weight, use 1:1 as its weight.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:54,avail,available,54,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avail'],['available']
Availability,/// Return true if every element in Mask is the undef sentinel value or equal to; /// the specified value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Mask,Mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// Return true if every element in Mask is undef or if its value; /// falls within the specified range (L, H].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Mask,Mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// Return true if every element in Mask is undef, zero or if its value; /// falls within the specified range (L, H].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Mask,Mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// Return true if every element in Mask, beginning from position Pos and ending; /// in Pos+Size is the undef sentinel value or equal to the specified value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Mask,Mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// Return true if every element in Mask, beginning from position Pos and ending; /// in Pos+Size is the undef sentinel value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Mask,Mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// Return true if every element in Mask, beginning; /// from position Pos and ending in Pos + Size, falls within the specified; /// sequence (Low, Low + Step, ..., Low + (Size - 1) * Step) or is undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Mask,Mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// Return true if every element in Mask, beginning; /// from position Pos and ending in Pos+Size is undef or is zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Mask,Mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// Return true if every element in Mask, beginning; /// from position Pos and ending in Pos+Size, falls within the specified; /// sequential range (Low, Low+Size], or is undef or is zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Mask,Mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,/// Return true if it is profitable to fold a pair of shifts into a mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h:68,mask,mask,68,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,1,['mask'],['mask']
Availability,"/// Return true if it is profitable to fold a pair of shifts into a mask.; /// This is usually true on most targets. But some targets, like Thumb1,; /// have immediate shift instructions, but no immediate ""and"" instruction;; /// this makes the fold unprofitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:68,mask,mask,68,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['mask'],['mask']
Availability,/// Return true if it's known this can never be one of the mask entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:59,mask,mask,59,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['mask'],['mask']
Availability,/// Return true if location information is available for this diagnostic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:43,avail,available,43,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['avail'],['available']
Availability,/// Return true if multiple condition registers are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:52,avail,available,52,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['avail'],['available']
Availability,/// Return true if sincos libcall is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:37,avail,available,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['avail'],['available']
Availability,/// Return true if the @llvm.get.active.lane.mask intrinsic should be expanded; /// using generic code in SelectionDAGBuilder.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:45,mask,mask,45,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['mask'],['mask']
Availability,"/// Return true if the Context runtime configuration is set to discard all; /// value names. When true, only GlobalValue names will be available in the; /// IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:135,avail,available,135,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,1,['avail'],['available']
Availability,"/// Return true if the argument contains a non-empty sequence of ones with the; /// remainder zero (32 bit version.) Ex. isShiftedMask_32(0x0000FF00U) == true.; /// If true, \p MaskIdx will specify the index of the lowest set bit and \p; /// MaskLen is updated to specify the length of the mask, else neither are; /// updated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h:177,Mask,MaskIdx,177,interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,3,"['Mask', 'mask']","['MaskIdx', 'MaskLen', 'mask']"
Availability,"/// Return true if the argument contains a non-empty sequence of ones with the; /// remainder zero (64 bit version.) If true, \p MaskIdx will specify the index; /// of the lowest set bit and \p MaskLen is updated to specify the length of the; /// mask, else neither are updated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h:129,Mask,MaskIdx,129,interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,3,"['Mask', 'mask']","['MaskIdx', 'MaskLen', 'mask']"
Availability,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:444,avail,available,444,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,2,['avail'],['available']
Availability,/// Return true if the current thread is recovering from a crash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:41,recover,recovering,41,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,1,['recover'],['recovering']
Availability,"/// Return true if the function type FTy is valid for the library function; /// F, regardless of whether the function is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:121,avail,available,121,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,2,['avail'],['available']
Availability,"/// Return true if the given indirect call site can be made to call \p Callee.; ///; /// This function ensures that the number and type of the call site's arguments; /// and return value match those of the given function. If the types do not; /// match exactly, they must at least be bitcast compatible. If \p FailureReason; /// is non-null and the indirect call cannot be promoted, the failure reason; /// will be stored in it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:310,Failure,FailureReason,310,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,2,"['Failure', 'failure']","['FailureReason', 'failure']"
Availability,"/// Return true if the given shuffle mask can be codegen'd directly, or if it; /// should be stack expanded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,2,['mask'],['mask']
Availability,/// Return true if the given stack call argument is already available in the; /// same position (relatively) of the caller's incoming argument stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:60,avail,available,60,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,['avail'],['available']
Availability,"/// Return true if the instruction is a ""coalescable"" extension instruction.; /// That is, it's like a copy where it's legal for the source to overlap the; /// destination. e.g. X86::MOVSX64rr32. If this returns true, then it's; /// expected the pre-extension value is available as a subreg of the result; /// register. This also returns the sub-register index in SubIdx.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:269,avail,available,269,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['avail'],['available']
Availability,"/// Return true if the instruction is trivially rematerializable, meaning it; /// has no side effects and requires no operands that aren't always available.; /// This means the only allowed uses are constants and unallocatable physical; /// registers so that the instructions result is independent of the place; /// in the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:146,avail,available,146,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['avail'],['available']
Availability,/// Return true if the mask contains the specified attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/AttributeMask.h:23,mask,mask,23,interpreter/llvm-project/llvm/include/llvm/IR/AttributeMask.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/AttributeMask.h,1,['mask'],['mask']
Availability,/// Return true if the mask creates a vector whose lower half is undefined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,/// Return true if the mask creates a vector whose upper half is undefined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"/// Return true if the mask interleaves one or more input vectors together.; ///; /// I.e. <0, LaneLen, ... , LaneLen*(Factor - 1), 1, LaneLen + 1, ...>; /// E.g. For a Factor of 2 (LaneLen=4):; /// <0, 4, 1, 5, 2, 6, 3, 7>; /// E.g. For a Factor of 3 (LaneLen=4):; /// <4, 0, 9, 5, 1, 10, 6, 2, 11, 7, 3, 12>; /// E.g. For a Factor of 4 (LaneLen=2):; /// <0, 2, 6, 4, 1, 3, 7, 5>; ///; /// NumInputElts is the total number of elements in the input vectors.; ///; /// StartIndexes are the first indexes of each vector being interleaved,; /// substituting any indexes that were undef; /// E.g. <4, -1, 2, 5, 1, 3> (Factor=3): StartIndexes=<4, 0, 2>; ///; /// Note that this does not check if the input vectors are consecutive:; /// It will return true for masks such as; /// <0, 4, 6, 1, 5, 7> (Factor=3, LaneLen=2)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:23,mask,mask,23,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['mask'],"['mask', 'masks']"
Availability,/// Return true if the reader encountered an error reading profiling data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h:45,error,error,45,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,1,['error'],['error']
Availability,/// Return true if the result produced by the instruction has no side effects on; /// any paths other than where it is used. This is less conservative than; /// wouldInstructionBeTriviallyDead which is based on the assumption; /// that the use count will be 0. An example usage of this API is for; /// identifying instructions that can be sunk down to use(s).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:344,down,down,344,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,1,['down'],['down']
Availability,/// Return true if the sign bit of Op is known to be zero.; /// We use this predicate to simplify operations downstream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:109,down,downstream,109,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['down'],['downstream']
Availability,/// Return true if the specified diagnostic is mapped to errors by; /// default.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h:57,error,errors,57,interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,1,['error'],['errors']
Availability,/// Return true if the target forces scalarizing of llvm.masked.gather; /// intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:57,mask,masked,57,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['masked']
Availability,/// Return true if the target forces scalarizing of llvm.masked.scatter; /// intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:57,mask,masked,57,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['masked']
Availability,"/// Return true if the target should transform:; /// (X & Y) == Y ---> (~X & Y) == 0; /// (X & Y) != Y ---> (~X & Y) != 0; ///; /// This may be profitable if the target has a bitwise and-not operation that; /// sets comparison flags. A target may want to limit the transformation based; /// on the type of Y or if Y is a constant.; ///; /// Note that the transform will not occur if Y is known to be a power-of-2; /// because a mask and compare of a single bit can be handled by inverting the; /// predicate, for example:; /// (X & 8) == 8 ---> (X & 8) != 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:428,mask,mask,428,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['mask'],['mask']
Availability,/// Return true if the target supports masked compress store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,mask,masked,39,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['masked']
Availability,/// Return true if the target supports masked expand load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,mask,masked,39,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['masked']
Availability,/// Return true if the target supports masked gather.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,mask,masked,39,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['masked']
Availability,/// Return true if the target supports masked load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,mask,masked,39,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['masked']
Availability,/// Return true if the target supports masked scatter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,mask,masked,39,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['masked']
Availability,/// Return true if the target supports masked store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,mask,masked,39,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['masked']
Availability,"/// Return true if the value of any element in Mask falls within the specified; /// range (L, H].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,Mask,Mask,47,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,/// Return true if the value of any element in Mask is the zero or undef; /// sentinel values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,Mask,Mask,47,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,/// Return true if the value of any element in Mask is the zero sentinel value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,Mask,Mask,47,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,/// Return true if there was an error retrieving this symbol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h:32,error,error,32,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,1,['error'],['error']
Availability,"/// Return true if this APInt value contains a non-empty sequence of ones with; /// the remainder zero. If true, \p MaskIdx will specify the index of the; /// lowest set bit and \p MaskLen is updated to specify the length of the; /// mask, else neither are updated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:116,Mask,MaskIdx,116,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,3,"['Mask', 'mask']","['MaskIdx', 'MaskLen', 'mask']"
Availability,"/// Return true if this function requires a split stack prolog, even if it; /// uses no stack space. This is only meaningful for functions where; /// MachineFunction::shouldSplitStack() returns true.; //; // For non-leaf functions we have to allow for the possibility that the call; // is to a non-split function, as in PR37807. This function could also take; // the address of a non-split function. When the linker tries to adjust its; // non-existent prologue, it would fail with an error. Mark the object file so; // that such failures are not errors. See this Go language bug-report; // https://go-review.googlesource.com/c/go/+/148819/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:485,error,error,485,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,3,"['error', 'failure']","['error', 'errors', 'failures']"
Availability,"/// Return true if this instruction cannot be safely duplicated.; /// For example, if the instruction has a unique labels attached; /// to it, duplicating it would cause multiple definition errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:190,error,errors,190,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['error'],['errors']
Availability,"/// Return true if this instruction cannot be safely; /// duplicated. For example, if the instruction has a unique labels attached; /// to it, duplicating it would cause multiple definition errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h:190,error,errors,190,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,1,['error'],['errors']
Availability,"/// Return true if this instruction may have an ordered; /// or volatile memory reference, or if the information describing the memory; /// reference is not available. Return false if it is known to have no; /// ordered or volatile memory references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:157,avail,available,157,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['avail'],['available']
Availability,/// Return true if this is an alternating opcode pattern that can be lowered; /// to a single instruction on the target. In X86 this is for the addsub; /// instruction which corrsponds to a Shuffle + Fadd + FSub pattern in IR.; /// This function expectes two opcodes: \p Opcode1 and \p Opcode2 being; /// selected by \p OpcodeMask. The mask contains one bit per lane and is a `0`; /// when \p Opcode0 is selected and `1` when Opcode1 is selected.; /// \p VecTy is the vector type of the instruction to be generated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:336,mask,mask,336,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['mask']
Availability,/// Return true if this is an operation on mask registers. Note that; /// this includes both arithmetic/logical ops and load/store (vlm/vsm).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['mask'],['mask']
Availability,"/// Return true if this loop is no longer valid. The only valid use of this; /// helper is ""assert(L.isInvalid())"" or equivalent, since IsInvalid is set to; /// true by the destructor. In other words, if this accessor returns true,; /// the caller has already triggered UB by calling this accessor; and so it; /// can only be called in a context where a return value of true indicates a; /// programmer error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h:403,error,error,403,interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h,1,['error'],['error']
Availability,"/// Return true if this shuffle chooses elements from its source vectors; /// without lane crossings and all operands have the same number of elements.; /// In other words, this shuffle is equivalent to a vector select with a; /// constant condition operand.; /// Example: shufflevector <4 x n> A, <4 x n> B, <undef,1,6,3>; /// This returns false if the mask does not choose from both input vectors.; /// In that case, the shuffle is better classified as an identity shuffle.; /// TODO: Optionally allow length-changing shuffles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:354,mask,mask,354,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['mask'],['mask']
Availability,"/// Return true if this shuffle mask chooses all elements with the same value; /// as the first element of exactly one source vector.; /// Example: <4,undef,undef,4>; /// This assumes that vector operands (of length \p NumSrcElts) are the same; /// length as the mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['mask'],['mask']
Availability,"/// Return true if this shuffle mask chooses elements from exactly one source; /// vector without lane crossings. A shuffle using this mask is not; /// necessarily a no-op because it may change the number of elements from its; /// input vectors or it may provide demanded bits knowledge via undef lanes.; /// Example: <undef,undef,2,3>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['mask'],['mask']
Availability,"/// Return true if this shuffle mask chooses elements from exactly one source; /// vector.; /// Example: <7,5,undef,7>; /// This assumes that vector operands (of length \p NumSrcElts) are the same; /// length as the mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['mask'],['mask']
Availability,"/// Return true if this shuffle mask chooses elements from its source vectors; /// without lane crossings. A shuffle using this mask would be; /// equivalent to a vector select with a constant condition operand.; /// Example: <4,1,6,undef>; /// This returns false if the mask does not choose from both input vectors.; /// In that case, the shuffle is better classified as an identity shuffle.; /// This assumes that vector operands are the same length as the mask; /// (a length-changing shuffle can never be equivalent to a vector select).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,4,['mask'],['mask']
Availability,"/// Return true if this shuffle mask is a one-use-single-source(""clustered""); /// mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['mask'],['mask']
Availability,/// Return true if this shuffle mask is a replication mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,4,['mask'],['mask']
Availability,"/// Return true if this shuffle mask is a splice mask, concatenating the two; /// inputs together and then extracts an original width vector starting from; /// the splice index.; /// Example: shufflevector <4 x n> A, <4 x n> B, <1,2,3,4>; /// This assumes that vector operands (of length \p NumSrcElts) are the same; /// length as the mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,3,['mask'],['mask']
Availability,"/// Return true if this shuffle mask is a transpose mask.; /// Transpose vector masks transpose a 2xn matrix. They read corresponding; /// even- or odd-numbered vector elements from two n-dimensional source; /// vectors and write each result into consecutive elements of an; /// n-dimensional destination vector. Two shuffles are necessary to complete; /// the transpose, one for the even elements and another for the odd elements.; /// This description closely follows how the TRN1 and TRN2 AArch64; /// instructions operate.; ///; /// For example, a simple 2x2 matrix can be transposed with:; ///; /// ; Original matrix; /// m0 = < a, b >; /// m1 = < c, d >; ///; /// ; Transposed matrix; /// t0 = < a, c > = shufflevector m0, m1, < 0, 2 >; /// t1 = < b, d > = shufflevector m0, m1, < 1, 3 >; ///; /// For matrices having greater than n columns, the resulting nx2 transposed; /// matrix is stored in two result vectors such that one vector contains; /// interleaved elements from all the even-numbered rows and the other vector; /// contains interleaved elements from all the odd-numbered rows. For example,; /// a 2x4 matrix can be transposed with:; ///; /// ; Original matrix; /// m0 = < a, b, c, d >; /// m1 = < e, f, g, h >; ///; /// ; Transposed matrix; /// t0 = < a, e, c, g > = shufflevector m0, m1 < 0, 4, 2, 6 >; /// t1 = < b, f, d, h > = shufflevector m0, m1 < 1, 5, 3, 7 >",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,3,['mask'],"['mask', 'masks']"
Availability,/// Return true if this shuffle mask is an extract subvector mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['mask'],['mask']
Availability,/// Return true if this shuffle mask is an extract subvector mask.; /// A valid extract subvector mask returns a smaller vector from a single; /// source operand. The base extraction index is returned as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,3,['mask'],['mask']
Availability,/// Return true if this shuffle mask is an insert subvector mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['mask'],['mask']
Availability,/// Return true if this shuffle mask is an insert subvector mask.; /// A valid insert subvector mask inserts the lowest elements of a second; /// source operand into an in-place first source operand.; /// Both the sub vector width and the insertion index is returned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,3,['mask'],['mask']
Availability,"/// Return true if this shuffle mask replicates each of the \p VF elements; /// in a vector \p ReplicationFactor times.; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['mask'],['mask']
Availability,"/// Return true if this shuffle mask represents ""clustered"" mask of size VF,; /// i.e. each index between [0..VF) is used exactly once in each submask of; /// size VF.; /// For example, the mask for \p VF=4 is:; /// 0, 1, 2, 3, 3, 2, 0, 1 - ""clustered"", because each submask of size 4; /// (0,1,2,3 and 3,2,0,1) uses indices [0..VF) exactly one time.; /// 0, 1, 2, 3, 3, 3, 1, 0 - not ""clustered"", because; /// element 3 is used twice in the second submask; /// (3,3,1,0) and index 2 is not used at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,3,['mask'],['mask']
Availability,"/// Return true if this shuffle mask swaps the order of elements from exactly; /// one source vector.; /// Example: <7,6,undef,4>; /// This assumes that vector operands (of length \p NumSrcElts) are the same; /// length as the mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:32,mask,mask,32,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['mask'],['mask']
Availability,"/// Return true if value Def dominates use U, in the sense that Def is; /// available at U, and could be substituted as the used value without; /// violating the SSA dominance requirement.; ///; /// In particular, it is worth noting that:; /// * Non-instruction Defs dominate everything.; /// * Def does not dominate a use in Def itself (outside of degenerate cases; /// like unreachable code or trivial phi cycles).; /// * Invoke Defs only dominate uses in their default destination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Dominators.h:76,avail,available,76,interpreter/llvm-project/llvm/include/llvm/IR/Dominators.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Dominators.h,1,['avail'],['available']
Availability,"/// Return true if we can prove that the value; /// we're analyzing is fully available in the specified block. As we go, keep; /// track of which blocks we know are fully alive in FullyAvailableBlocks. This; /// map is actually a tri-state map with the following values:; /// 0) we know the block *is not* fully available.; /// 1) we know the block *is* fully available.; /// 2) we do not know whether the block is fully available or not, but we are; /// currently speculating that it will be.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:77,avail,available,77,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,5,"['alive', 'avail']","['alive', 'available']"
Availability,"/// Return true if we can vectorize this loop while folding its tail by; /// masking, and mark all respective loads/stores for masking.; /// This object's state is only modified iff this function returns true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:77,mask,masking,77,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,2,['mask'],['masking']
Availability,"/// Return true iff the cursor is at the end of the buffer, regardless of the; /// error state of the cursor. The only way both eof and error states can be; /// true is if one attempts a read while the cursor is at the very end of the; /// data buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:83,error,error,83,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['error'],['error']
Availability,/// Return true on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:19,error,error,19,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,2,['error'],['error']
Availability,/// Return whether an error during the parsing of the input args.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h:22,error,error,22,interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,1,['error'],['error']
Availability,"/// Return whether removing this instruction will have no effect on the; /// program, ignoring the possible effects on some instructions, returning; /// the redundant use-def chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:157,redundant,redundant,157,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,2,['redundant'],['redundant']
Availability,"/// Return whether removing this instruction will have no effect on the; /// program, returning the redundant use-def chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:100,redundant,redundant,100,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,1,['redundant'],['redundant']
Availability,/// ReturnError - Set the error to the specified string at the specified; /// location. This is defined to always return AsmToken::Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmLexer.cpp:26,error,error,26,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmLexer.cpp,2,"['Error', 'error']","['Error', 'error']"
Availability,/// ReturnError - Set the error to the specified string at the specified; /// location. This is defined to always return tgtok::Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp:26,error,error,26,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,2,"['Error', 'error']","['Error', 'error']"
Availability,/// Returns AnalysisDeclContext for the callee stack frame.; /// Currently may fail; returns null on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h:101,failure,failure,101,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,1,['failure'],['failure']
Availability,"/// Returns InlineResult::success() if the call site should be always inlined; /// because of user directives, and the inlining is viable. Returns; /// InlineResult::failure() if the inlining may never happen because of user; /// directives or incompatibilities detectable without needing callee traversal.; /// Otherwise returns std::nullopt, meaning that inlining should be decided; /// based on other criteria (e.g. cost modeling).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:166,failure,failure,166,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,1,['failure'],['failure']
Availability,"/// Returns True if V can be considered as an induction variable in this; /// loop. V can be the induction phi, or some redundant cast in the def-use; /// chain of the inducion phi.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:120,redundant,redundant,120,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['redundant'],['redundant']
Availability,"/// Returns True if V is a cast that is part of an induction def-use chain,; /// and had been proven to be redundant under a runtime guard (in other; /// words, the cast has the same SCEV expression as the induction phi).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:107,redundant,redundant,107,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['redundant'],['redundant']
Availability,"/// Returns a 128-bit vector of [16 x i8] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPBLENDVB / PBLENDVB </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [16 x i8].; /// \param __V2; /// A 128-bit vector of [16 x i8].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 119, 111...7 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 8-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 8-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [16 x i8] containing the copied values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:172,mask,mask,172,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,5,['mask'],['mask']
Availability,"/// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD / BLENDVPD </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [2 x double].; /// \param __V2; /// A 128-bit vector of [2 x double].; /// \param __M; /// A 128-bit vector operand, with mask bits 127 and 63 specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 64-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:172,mask,mask,172,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,5,['mask'],['mask']
Availability,"/// Returns a 128-bit vector of [4 x float] where the values are selected; /// from either the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_blend_ps(__m128 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS / BLENDPS </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x float].; /// \param V2; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 32-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:171,mask,mask,171,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,5,['mask'],['mask']
Availability,"/// Returns a 128-bit vector of [4 x float] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS / BLENDVPS </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [4 x float].; /// \param __V2; /// A 128-bit vector of [4 x float].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 95, 63, and 31 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 32-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 32-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:171,mask,mask,171,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,5,['mask'],['mask']
Availability,"/// Returns a 128-bit vector of [8 x i16] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_blend_epi16(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPBLENDW / PBLENDW </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [8 x i16].; /// \param V2; /// A 128-bit vector of [8 x i16].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 16-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 16-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [8 x i16] containing the copied values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:172,mask,mask,172,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,5,['mask'],['mask']
Availability,"/// Returns a MaterializationUnit::Interface for the object file contained in; /// the given buffer, or an error if the buffer does not contain a valid object; /// file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ObjectFileInterface.h:107,error,error,107,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ObjectFileInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ObjectFileInterface.h,1,['error'],['error']
Availability,"/// Returns a SymbolizableModule or an error if loading debug info failed.; /// Only one attempt is made to load a module, and errors during loading are; /// only reported once. Subsequent calls to get module info for a module that; /// failed to load will return nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h:39,error,error,39,interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,2,['error'],"['error', 'errors']"
Availability,"/// Returns a SymbolizableModule or an error if loading debug info failed.; /// Unlike the above, errors are reported each time, since they are more; /// likely to be transient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h:39,error,error,39,interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,2,['error'],"['error', 'errors']"
Availability,"/// Returns a default thread strategy where all available hardware resources; /// are to be used, except for those initially excluded by an affinity mask.; /// This function takes affinity into consideration. Returns 1 when LLVM is; /// configured with LLVM_ENABLE_THREADS=OFF.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:48,avail,available,48,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,2,"['avail', 'mask']","['available', 'mask']"
Availability,"/// Returns a failure if the sealed page has no checksum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:14,failure,failure,14,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['failure'],['failure']
Availability,/// Returns a filter object if all the arguments provided are valid regex; /// types otherwise return an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkCounter.h:105,error,error,105,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkCounter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkCounter.h,1,['error'],['error']
Availability,"/// Returns a map from every section matching \p IsMatch to its relocation; /// section, or \p nullptr if it has no relocation section. This function; /// returns an error if any of the \p IsMatch calls fail or if it fails to; /// retrieve the content section of any relocation section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:166,error,error,166,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,1,['error'],['error']
Availability,/// Returns a mask covering all bits that can appear in lane masks of; /// subregisters of the virtual register @p Reg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:14,mask,mask,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,2,['mask'],"['mask', 'masks']"
Availability,/// Returns a mask for which lanes get read/written by the given (register); /// machine operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:14,mask,mask,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['mask'],['mask']
Availability,"/// Returns a mask of busy resources, and populates vector Insts with; /// instructions that could not be issued to the underlying pipelines because; /// not all pipeline resources were available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:14,mask,mask,14,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,2,"['avail', 'mask']","['available', 'mask']"
Availability,"/// Returns a mask that represents on which hardware thread, core, CPU, NUMA; /// group, the calling thread can be executed. On Windows, threads cannot; /// cross CPU sockets boundaries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:14,mask,mask,14,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,1,['mask'],['mask']
Availability,"/// Returns a pair of (return value, chain).; /// It is an error to pass RTLIB::UNKNOWN_LIBCALL as \p LC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:59,error,error,59,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['error'],['error']
Availability,"/// Returns a pair of values, which if passed to llvm.is.fpclass, returns the; /// same result as an fcmp with the given operands.; ///; /// If \p LookThroughSrc is true, consider the input value when computing the; /// mask.; ///; /// If \p LookThroughSrc is false, ignore the source value (i.e. the first pair; /// element will always be LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:220,mask,mask,220,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['mask'],['mask']
Availability,"/// Returns a pointer to a newly allocated MemoryBuffer that contains the; /// object which corresponds with Module M, or 0 if an object is not; /// available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ObjectCache.h:149,avail,available,149,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ObjectCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ObjectCache.h,1,['avail'],['available']
Availability,"/// Returns a reference to the type cast instructions in the induction; /// update chain, that are redundant when guarded with a runtime; /// SCEV overflow check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:99,redundant,redundant,99,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,1,['redundant'],['redundant']
Availability,/// Returns a simple string representation of each error.; ///; /// Each error only shows the error message without any context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h:51,error,error,51,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,3,['error'],['error']
Availability,/// Returns a single ordering which is at least as strong as both the; /// success and failure orderings for this cmpxchg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:87,failure,failure,87,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['failure'],['failure']
Availability,/// Returns a sorted array of slot indices of all instructions with register; /// mask operands in the basic block numbered \p MBBNum.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:82,mask,mask,82,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,1,['mask'],['mask']
Availability,"/// Returns a string representation of the errno value, using whatever; /// thread-safe variant of strerror() is available. Be sure to call this; /// immediately after the function that set errno, or errno may have been; /// overwritten by an intervening call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Errno.h:113,avail,available,113,interpreter/llvm-project/llvm/include/llvm/Support/Errno.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Errno.h,1,['avail'],['available']
Availability,"/// Returns a thread strategy for tasks requiring significant memory or other; /// resources. To be used for workloads where hardware_concurrency() proves to; /// be less efficient. Avoid this strategy if doing lots of I/O. Currently; /// based on physical cores, if available for the host system, otherwise falls; /// back to hardware_concurrency(). Returns 1 when LLVM is configured with; /// LLVM_ENABLE_THREADS = OFF.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:267,avail,available,267,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,1,['avail'],['available']
Availability,"/// Returns a truth assignment to boolean values that satisfies the queried; /// boolean formula if available. Otherwise, an empty optional is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Solver.h:100,avail,available,100,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Solver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Solver.h,1,['avail'],['available']
Availability,/// Returns a vector function ABI variant string on the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:77,mask,mask,77,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,1,['mask'],['mask']
Availability,"/// Returns a vector of BBAddrMap structs corresponding to each function; /// within the text section that the SHT_LLVM_BB_ADDR_MAP section \p Sec; /// is associated with. If the current ELFFile is relocatable, a corresponding; /// \p RelaSec must be passed in as an argument.; /// Optional out variable to collect all PGO Analyses. New elements are only; /// added if no error occurs. If not provided, the PGO Analyses are decoded; /// then ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:372,error,error,372,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,1,['error'],['error']
Availability,"/// Returns a vector of all BB address maps in the object file. When; /// `TextSectionIndex` is specified, only returns the BB address maps; /// corresponding to the section with that index. When `PGOAnalyses`is; /// specified (PGOAnalyses is not nullptr), the vector is cleared then filled; /// with extra PGO data. `PGOAnalyses` will always be the same length as the; /// return value when it is requested assuming no error occurs. Upon failure,; /// `PGOAnalyses` will be emptied.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h:420,error,error,420,interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Returns a vector_shuffle mask for an movs{s|d}, movd; /// operation of specified width.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['mask'],['mask']
Availability,/// Returns an array of mask pointers corresponding to; /// getRegMaskSlotsInBlock(MBBNum).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:24,mask,mask,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,1,['mask'],['mask']
Availability,/// Returns an array of register mask pointers corresponding to; /// getRegMaskSlots().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:33,mask,mask,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,1,['mask'],['mask']
Availability,/// Returns an iterator range over all physical register and mask operands for; /// \p MI and bundled instructions. This also skips any debug operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h:61,mask,mask,61,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h,1,['mask'],['mask']
Availability,"/// Returns an opaque identifier for a diagnostic.; ///; /// This opaque identifier is intended to be stable even when the source code; /// is changed. It allows to track diagnostics in the long term, for example,; /// find which diagnostics are ""new"", maintain a database of suppressed; /// diagnostics etc.; ///; /// We may introduce more variants of issue hashes in the future; /// but older variants will still be available for compatibility.; ///; /// This hash is based on the following information:; /// - Name of the checker that emitted the diagnostic.; /// - Warning message.; /// - Name of the enclosing declaration.; /// - Contents of the line of code with the issue, excluding whitespace.; /// - Column number (but not the line number! - which makes it stable).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/IssueHash.h:418,avail,available,418,interpreter/llvm-project/clang/include/clang/Analysis/IssueHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/IssueHash.h,1,['avail'],['available']
Availability,"/// Returns detailed output. The value returned by this function is updated after each call to Evaluate().; /// The returned RooArgSet contains the following for the alternative and null hypotheses:; /// - the minimum nll, fitstatus and convergence quality for each fit; /// - for each fit and for each non-constant parameter, the value, error and pull of the parameter are stored",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/RatioOfProfiledLikelihoodsTestStat.h:338,error,error,338,roofit/roostats/inc/RooStats/RatioOfProfiledLikelihoodsTestStat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/RatioOfProfiledLikelihoodsTestStat.h,1,['error'],['error']
Availability,"/// Returns detailed output. The value returned by this function is updated after each call to Evaluate().; /// The returned RooArgSet contains the following:; ///; /// - the minimum nll, fitstatus and convergence quality for each fit; /// - for each fit and for each non-constant parameter, the value, error and pull of the parameter are stored; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ProfileLikelihoodTestStat.h:303,error,error,303,roofit/roostats/inc/RooStats/ProfileLikelihoodTestStat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ProfileLikelihoodTestStat.h,1,['error'],['error']
Availability,"/// Returns diagnostics emitted during parsing.; /// (By default, errors cause test failures, see TestInputs::ErrorOK).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:66,error,errors,66,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,3,"['Error', 'error', 'failure']","['ErrorOK', 'errors', 'failures']"
Availability,"/// Returns either (1) \c ErrorSuccess if there was no error or (2); /// \c ErrorReported if an error was reported, such as an unexpected match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:26,Error,ErrorSuccess,26,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,4,"['Error', 'error']","['ErrorReported', 'ErrorSuccess', 'error']"
Availability,"/// Returns either (1) \c ErrorSuccess if there was no error, or (2); /// \c ErrorReported if an error was reported, such as an expected match not; /// found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:26,Error,ErrorSuccess,26,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,4,"['Error', 'error']","['ErrorReported', 'ErrorSuccess', 'error']"
Availability,"/// Returns either (1) \c ErrorSuccess if there was no error, or (2); /// \c ErrorReported if an error was reported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:26,Error,ErrorSuccess,26,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,4,"['Error', 'error']","['ErrorReported', 'ErrorSuccess', 'error']"
Availability,/// Returns empty string of Asan runtime library is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:56,avail,available,56,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,1,['avail'],['available']
Availability,"/// Returns entry associated with the filename in the shared cache if there is; /// some. Otherwise, constructs new one with the given error code, associates; /// it with the filename and returns the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:135,error,error,135,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['error'],['error']
Availability,"/// Returns estimate for max latch taken count of the loop of the narrowest; /// available type. If the latch block has such estimate, it is returned.; /// Otherwise, we use max exit count of whole loop (that is potentially of wider; /// type than latch check itself), which is still better than no estimate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:81,avail,available,81,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,1,['avail'],['available']
Availability,/// Returns false if N is a bit extraction pattern of (X >> C) & Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h:65,Mask,Mask,65,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,2,['Mask'],['Mask']
Availability,"/// Returns http address of the server, empty string when not available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/inc/ROOT/RWebWindowsManager.hxx:62,avail,available,62,gui/webdisplay/inc/ROOT/RWebWindowsManager.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/inc/ROOT/RWebWindowsManager.hxx,1,['avail'],['available']
Availability,/// Returns memory location for a parameter variable within the callee stack; /// frame. The behavior is undefined if the block count is different from the; /// one that is there when call happens. May fail; returns null on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h:224,failure,failure,224,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,1,['failure'],['failure']
Availability,/// Returns subprogram DIE with address range encompassing the provided; /// address. The pointer is alive as long as parsed compile unit DIEs are not; /// cleared.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h:101,alive,alive,101,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h,1,['alive'],['alive']
Availability,/// Returns the *entry* mask for the block \p BB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,1,['mask'],['mask']
Availability,"/// Returns the MacroExpansionContext for the imported TU to which the given; /// source-location corresponds.; /// \p ToLoc Source location in the imported-to AST.; /// \note If any error happens such as \p ToLoc is a non-imported; /// source-location, empty is returned.; /// \note Macro expansion tracking for imported TUs is not implemented yet.; /// It returns empty unconditionally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:183,error,error,183,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['error'],['error']
Availability,"/// Returns the Windows version as Major.Minor.0.BuildNumber. Uses; /// RtlGetVersion or GetVersionEx under the hood depending on what is available.; /// GetVersionEx is deprecated, but this API exposes the build number which can; /// be useful for working around certain kernel bugs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Windows/WindowsSupport.h:138,avail,available,138,interpreter/llvm-project/llvm/include/llvm/Support/Windows/WindowsSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Windows/WindowsSupport.h,1,['avail'],['available']
Availability,"/// Returns the `Decl` containing the statement used to construct the CFG, if; /// available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/ControlFlowContext.h:83,avail,available,83,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/ControlFlowContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/ControlFlowContext.h,1,['avail'],['available']
Availability,"/// Returns the address of the requested section (or an error message; /// in the second element of the pair if the address cannot be found).; ///; /// if 'LocalAddress' is true, this returns the address of the section; /// within the linker's memory. If 'LocalAddress' is false it returns the; /// address within the target process (i.e. the load address).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyldChecker.h:56,error,error,56,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyldChecker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyldChecker.h,1,['error'],['error']
Availability,/// Returns the address of this pointer in this block.; ///; /// This can be different than the address queried for the non-local result; /// because of phi translation. This returns null if the address was not; /// available in a block (i.e. because phi translation failed) or if this is; /// a cached result and that address was deleted.; ///; /// The address is always null for a non-local 'call' dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:216,avail,available,216,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['avail'],['available']
Availability,/// Returns the bit mask of register classes that getSubReg() projects into; /// RC.; /// See TargetRegisterClass::getSubClassMask() for how to use it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:20,mask,mask,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['mask'],['mask']
Availability,"/// Returns the call target map collected at a given location specified by \p; /// CallSite. If the location is not found in profile, return error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:141,error,error,141,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['error'],['error']
Availability,"/// Returns the call target map collected at a given location.; /// Each location is specified by \p LineOffset and \p Discriminator.; /// If the location is not found in profile, return error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:187,error,error,187,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['error'],['error']
Availability,"/// Returns the callee stack frame. That stack frame will only be entered; /// during analysis if the call is inlined, but it may still be useful; /// in intermediate calculations even if the call isn't inlined.; /// May fail; returns null on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h:243,failure,failure,243,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,1,['failure'],['failure']
Availability,/// Returns the child storage location for `D`.; ///; /// May return null if `D` has reference type; guaranteed to return non-null; /// in all other cases.; ///; /// Note that it is an error to call this with a field that does not exist.; /// The function does not return null in this case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h:185,error,error,185,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h,1,['error'],['error']
Availability,/// Returns the combination of all lane masks of register in this class.; /// The lane masks of the registers are the combination of all lane masks; /// of their subregisters. Returns 1 if there are no subregisters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:40,mask,masks,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,3,['mask'],['masks']
Availability,"/// Returns the contents of the Exception stream. An error is returned if the; /// file does not contain this stream, or the stream is smaller than the size; /// of the ExceptionStream structure. The internal consistency of the stream; /// is not checked in any way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h:53,error,error,53,interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,1,['error'],['error']
Availability,"/// Returns the contents of the SystemInfo stream, cast to the appropriate; /// type. An error is returned if the file does not contain this stream, or; /// the stream is smaller than the size of the SystemInfo structure. The; /// internal consistency of the stream is not checked in any way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h:89,error,error,89,interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,1,['error'],['error']
Availability,"/// Returns the correct return opcode for the current feature set.; /// Use BX if available to allow mixing thumb/arm code, but fall back; /// to plain mov pc,lr on ARMv4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:82,avail,available,82,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,1,['avail'],['available']
Availability,/// Returns the cost estimation for alternating opcode pattern that can be; /// lowered to a single instruction on the target. In X86 this is for the; /// addsub instruction which corrsponds to a Shuffle + Fadd + FSub pattern in; /// IR. This function expects two opcodes: \p Opcode1 and \p Opcode2 being; /// selected by \p OpcodeMask. The mask contains one bit per lane and is a `0`; /// when \p Opcode0 is selected and `1` when Opcode1 is selected.; /// \p VecTy is the vector type of the instruction to be generated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:341,mask,mask,341,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['mask']
Availability,"/// Returns the current number of errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx:34,error,errors,34,core/foundation/inc/ROOT/RLogger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx,1,['error'],['errors']
Availability,"/// Returns the current number of fatal errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx:40,error,errors,40,core/foundation/inc/ROOT/RLogger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx,1,['error'],['errors']
Availability,"/// Returns the current value of the counter or error if it cannot be read.; /// FunctionBytes: The benchmark function being executed.; /// This is used to filter out the measurements to ensure they are only; /// within the benchmarked code.; /// If empty (or not specified), then no filtering will be done.; /// Not all counters choose to use this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h:48,error,error,48,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.h,1,['error'],['error']
Availability,"/// Returns the demanded splatted constant FP or null if this is not a; /// constant FP splat.; ///; /// The DemandedElts mask indicates the elements that must be in the splat.; /// If passed a non-null UndefElements bitvector, it will resize it to match; /// the vector width and set the bits where elements are undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:122,mask,mask,122,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['mask'],['mask']
Availability,"/// Returns the demanded splatted constant or null if this is not a constant; /// splat.; ///; /// The DemandedElts mask indicates the elements that must be in the splat.; /// If passed a non-null UndefElements bitvector, it will resize it to match; /// the vector width and set the bits where elements are undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:116,mask,mask,116,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['mask'],['mask']
Availability,"/// Returns the demanded splatted value or a null value if this is not a; /// splat.; ///; /// The DemandedElts mask indicates the elements that must be in the splat.; /// If passed a non-null UndefElements bitvector, it will resize it to match; /// the vector width and set the bits where elements are undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:112,mask,mask,112,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['mask'],['mask']
Availability,"/// Returns the driver mode option's value, i.e. `X` in `--driver-mode=X`. If \p; /// Args doesn't mention one explicitly, tries to deduce from `ProgName`.; /// Returns empty on failure.; /// Common values are ""gcc"", ""g++"", ""cpp"", ""cl"" and ""flang"". Returned value need; /// not be one of these.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:178,failure,failure,178,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['failure'],['failure']
Availability,"/// Returns the dynamic class id of this error, or null if this is a success; /// value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:41,error,error,41,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['error'],['error']
Availability,/// Returns the error message or an empty string if it does not exist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:16,error,error,16,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,1,['error'],['error']
Availability,/// Returns the estimated profile count of \p BB.; /// This computes the relative block frequency of \p BB and multiplies it by; /// the enclosing function's count (if available) and returns the value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h:168,avail,available,168,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,1,['avail'],['available']
Availability,/// Returns the estimated profile count of \p Freq.; /// This uses the frequency \p Freq and multiplies it by; /// the enclosing function's count (if available) and returns the value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h:150,avail,available,150,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,1,['avail'],['available']
Availability,"/// Returns the exponent of the internal representation of the APFloat.; ///; /// Because the radix of APFloat is 2, this is equivalent to floor(log2(x)).; /// For special APFloat values, this returns special error codes:; ///; /// NaN -> \c IEK_NaN; /// 0 -> \c IEK_Zero; /// Inf -> \c IEK_Inf; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:209,error,error,209,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,1,['error'],['error']
Availability,/// Returns the failure ordering constraint of this cmpxchg instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:16,failure,failure,16,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['failure'],['failure']
Availability,/// Returns the first potential AsynchEH faulty instruction; /// currently it checks for loads/stores (which may dereference a null; /// pointer) and calls/invokes (which may propagate exceptions),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h:41,fault,faulty,41,interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,1,['fault'],['faulty']
Availability,/// Returns the full string representation of each error.; ///; /// Each error message contains the full context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h:51,error,error,51,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,2,['error'],['error']
Availability,"/// Returns the fully resolved address and flags for each of the given; /// symbols.; ///; /// This method will return an error if any of the given symbols can not be; /// resolved, or if the resolution process itself triggers an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h:122,error,error,122,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,2,['error'],['error']
Availability,"/// Returns the given JITDylibs and all of their transitive dependencies in; /// DFS order (based on linkage relationships). Each JITDylib will appear; /// only once.; ///; /// If any JITDylib in the order is defunct then this method will return an; /// error, otherwise returns the order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:254,error,error,254,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['error'],['error']
Availability,"/// Returns the given JITDylibs and all of their transitive dependencies in; /// reverse DFS order (based on linkage relationships). Each JITDylib will; /// appear only once.; ///; /// If any JITDylib in the order is defunct then this method will return an; /// error, otherwise returns the order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:262,error,error,262,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['error'],['error']
Availability,"/// Returns the height of this node, which is the length of the; /// maximum path down to any node which has no successors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:82,down,down,82,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['down'],['down']
Availability,/// Returns the identifier namespace mask for this lookup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:37,mask,mask,37,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['mask'],['mask']
Availability,/// Returns the internal register number for the current AT. Also checks if; /// the current AT is unavailable (set to $0) and gives an error if it is.; /// This should be used in pseudo-instruction expansions which need AT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:136,error,error,136,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"/// Returns the last error reported, or else a generic error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:21,error,error,21,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,2,['error'],['error']
Availability,"/// Returns the linker path, respecting the -fuse-ld= argument to determine; /// the linker suffix or name.; /// If LinkerIsLLD is non-nullptr, it is set to true if the returned linker; /// is LLD. If it's set, it can be assumed that the linker is LLD built; /// at the same revision as clang, and clang can make assumptions about; /// LLD's supported flags, error output, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:359,error,error,359,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['error'],['error']
Availability,"/// Returns the list of all files available in the compilation database.; ///; /// By default, returns nothing. Implementations should override this if they; /// can enumerate their source files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:34,avail,available,34,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,1,['avail'],['available']
Availability,/// Returns the list of all files available in the compilation database.; ///; /// These are the 'file' entries of the JSON objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:34,avail,available,34,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,1,['avail'],['available']
Availability,/// Returns the list of all the available refactoring actions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:32,avail,available,32,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,1,['avail'],['available']
Availability,"/// Returns the list of descriptors embedded in the MemoryInfoList stream. The; /// descriptors provide properties (e.g. permissions) of interesting regions; /// of memory at the time the minidump was taken. An error is returned if the; /// file does not contain this stream, or if the stream is not large enough to; /// contain the number of memory descriptors declared in the stream header.; /// The consistency of the MemoryInfoList entries themselves is not checked; /// in any way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h:211,error,error,211,interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,1,['error'],['error']
Availability,"/// Returns the list of descriptors embedded in the MemoryList stream. The; /// descriptors provide the content of interesting regions of memory at the; /// time the minidump was taken. An error is returned if the file does not; /// contain this stream, or if the stream is not large enough to contain the; /// number of memory descriptors declared in the stream header. The; /// consistency of the MemoryDescriptor entries themselves is not checked in; /// any way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h:189,error,error,189,interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,1,['error'],['error']
Availability,"/// Returns the location of the entity being transformed, if that; /// information was not available elsewhere in the AST.; ///; /// By default, returns no source-location information. Subclasses can; /// provide an alternative implementation that provides better location; /// information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:91,avail,available,91,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['avail'],['available']
Availability,"/// Returns the location of the result object for a record-type prvalue.; ///; /// In C++, prvalues of record type serve only a limited purpose: They can; /// only be used to initialize a result object (e.g. a variable or a; /// temporary). This function returns the location of that result object.; ///; /// When creating a prvalue of record type, we already need the storage; /// location of the result object to pass in `this`, even though prvalues are; /// otherwise not associated with storage locations.; ///; /// FIXME: Currently, this simply returns a stable storage location for `E`,; /// but this doesn't do the right thing in scenarios like the following:; /// ```; /// MyClass c = some_condition()? MyClass(foo) : MyClass(bar);; /// ```; /// Here, `MyClass(foo)` and `MyClass(bar)` will have two different storage; /// locations, when in fact their storage locations should be the same.; /// Eventually, we want to propagate storage locations from result objects; /// down to the prvalues that initialize them, similar to the way that this is; /// done in Clang's CodeGen.; ///; /// Requirements:; /// `E` must be a prvalue of record type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h:980,down,down,980,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h,1,['down'],['down']
Availability,/// Returns the memory dependences. If null is returned we exceeded; /// the MaxDependences threshold and this information is not; /// available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:135,avail,available,135,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['avail'],['available']
Availability,"/// Returns the minidump string at the given offset. An error is returned if; /// we fail to parse the string, or the string is invalid UTF16.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h:56,error,error,56,interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,1,['error'],['error']
Availability,"/// Returns the module list embedded in the ModuleList stream. An error is; /// returned if the file does not contain this stream, or if the stream is; /// not large enough to contain the number of modules declared in the stream; /// header. The consistency of the Module entries themselves is not checked in; /// any way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h:66,error,error,66,interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,1,['error'],['error']
Availability,/// Returns the most recent error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:28,error,error,28,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['error'],['error']
Availability,"/// Returns the name of a type starting from its type_info; /// An empty string is returned in case of failure; /// References and pointers are not supported since those cannot be stored in; /// columns.; /// Note that this function will take a lock and may be a potential source of; /// contention in multithreaded execution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:103,failure,failure,103,tree/dataframe/src/RDFUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx,1,['failure'],['failure']
Availability,"/// Returns the name of the callee, if its name is a simple identifier.; ///; /// Note that this will fail for Objective-C methods, blocks, and C++; /// overloaded operators. The former is named by a Selector rather than a; /// simple identifier, and the latter two do not have names.; // FIXME: Move this down to AnyFunctionCall once checkers have more; // precise callbacks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h:306,down,down,306,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,1,['down'],['down']
Availability,"/// Returns the name of the entity being transformed, if that; /// information was not available elsewhere in the AST.; ///; /// By default, returns an empty name. Subclasses can provide an alternative; /// implementation with a more precise name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:87,avail,available,87,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['avail'],['available']
Availability,"/// Returns the next available unique source location. It is an offset into; /// the limitless virtual file. Each time this interface is used it bumps; /// an internal counter. This is very useful for using the various API in; /// clang which expect valid source locations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.h:21,avail,available,21,interpreter/cling/lib/Interpreter/IncrementalParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.h,1,['avail'],['available']
Availability,"/// Returns the number of newly available values, that is the number of bools in bulkSpec.fMaskAvail that; /// flipped from false to true. As a special return value, kAllSet can be used if all values are read; /// independent from the masks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:32,avail,available,32,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,2,"['avail', 'mask']","['available', 'masks']"
Availability,"/// Returns the operand index that is a def of the specified register or; /// -1 if it is not found. If isDead is true, defs that are not dead are; /// skipped. If Overlap is true, then it also looks for defs that merely; /// overlap the specified register. If TargetRegisterInfo is non-null,; /// then it also checks if there is a def of a super-register.; /// This may also return a register mask operand when Overlap is true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:394,mask,mask,394,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['mask'],['mask']
Availability,"/// Returns the parents of the given node (within the traversal scope).; ///; /// Note that this will lazily compute the parents of all nodes; /// and store them for later retrieval. Thus, the first call is O(n); /// in the number of AST nodes.; ///; /// Caveats and FIXMEs:; /// Calculating the parent map over all AST nodes will need to load the; /// full AST. This can be undesirable in the case where the full AST is; /// expensive to create (for example, when using precompiled header; /// preambles). Thus, there are good opportunities for optimization here.; /// One idea is to walk the given node downwards, looking for references; /// to declaration contexts - once a declaration context is found, compute; /// the parent map for the declaration context; if that can satisfy the; /// request, loading the whole AST can be avoided. Note that this is made; /// more complex by statements in templates having multiple parents - those; /// problems can be solved by building closure over the templated parts of; /// the AST, which also avoids touching large parts of the AST.; /// Additionally, we will want to add an interface to already give a hint; /// where to search for the parents, for example when looking at a statement; /// inside a certain function.; ///; /// 'NodeT' can be one of Decl, Stmt, Type, TypeLoc,; /// NestedNameSpecifier or NestedNameSpecifierLoc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ParentMapContext.h:605,down,downwards,605,interpreter/llvm-project/clang/include/clang/AST/ParentMapContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ParentMapContext.h,1,['down'],['downwards']
Availability,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:614,avail,available,614,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['avail'],['available']
Availability,"/// Returns the previous system error message handler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/TError.h:32,error,error,32,core/foundation/inc/TError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/TError.h,1,['error'],['error']
Availability,/// Returns the raw contents of an object given by the LocationDescriptor. An; /// error is returned if the descriptor points outside of the minidump file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h:83,error,error,83,interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,1,['error'],['error']
Availability,"/// Returns the replacements corresponding to applying \p Replaces and; /// cleaning up the code after that on success; otherwise, return an llvm::Error; /// carrying llvm::StringError.; /// This also supports inserting/deleting C++ #include directives:; /// - If a replacement has offset UINT_MAX, length 0, and a replacement text; /// that is an #include directive, this will insert the #include into the; /// correct block in the \p Code.; /// - If a replacement has offset UINT_MAX, length 1, and a replacement text; /// that is the name of the header to be removed, the header will be removed; /// from \p Code if it exists.; /// The include manipulation is done via ``tooling::HeaderInclude``, see its; /// documentation for more details on how include insertion points are found and; /// what edits are produced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:147,Error,Error,147,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['Error'],['Error']
Availability,"/// Returns the replacements corresponding to applying and formatting; /// \p Replaces on success; otheriwse, return an llvm::Error carrying; /// llvm::StringError.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:126,Error,Error,126,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['Error'],['Error']
Availability,"/// Returns the result of the AssignmentTrackingAnalysis pass if it's; /// available, otherwise return nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:75,avail,available,75,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['avail'],['available']
Availability,/// Returns the set of bound architectures active for this offload kind.; /// If there are no bound architctures we return a set containing only the; /// empty string. The \p SuppressError option is used to suppress errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:216,error,errors,216,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['error'],['errors']
Availability,"/// Returns the size of the trailing data, if an object were; /// allocated with the given counts (The counts are in the same order; /// as the template arguments). This does not include the size of the; /// base object. The template arguments must be the same as those; /// used in the class; they are supplied here redundantly only so; /// that it's clear what the counts are counting in callers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h:317,redundant,redundantly,317,interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h,1,['redundant'],['redundantly']
Availability,/// Returns the source range for errors associated with this argument.; ///; /// May be invalid if the argument is not written in the source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h:33,error,errors,33,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,1,['error'],['errors']
Availability,"/// Returns the strongest permitted ordering on failure, given the; /// desired ordering on success.; ///; /// If the comparison in a cmpxchg operation fails, there is no atomic store; /// so release semantics cannot be provided. So this function drops explicit; /// Release requests from the AtomicOrdering. A SequentiallyConsistent; /// operation would remain SequentiallyConsistent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:48,failure,failure,48,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['failure'],['failure']
Availability,"/// Returns the symbol with the highest address not greater than the search; /// address, or an error if no such symbol exists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h:96,error,error,96,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,1,['error'],['error']
Availability,"/// Returns the thread list embedded in the ThreadList stream. An error is; /// returned if the file does not contain this stream, or if the stream is; /// not large enough to contain the number of threads declared in the stream; /// header. The consistency of the Thread entries themselves is not checked in; /// any way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h:66,error,error,66,interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,1,['error'],['error']
Availability,"/// Returns the total number of required to allocate all segments (with each; /// segment padded out to page size) for all standard segments, and all; /// finalize segments.; ///; /// This is a convenience function for the common case where the segments will; /// be allocated contiguously.; ///; /// This function will return an error if any segment has an alignment that; /// is higher than a page.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h:330,error,error,330,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,1,['error'],['error']
Availability,"/// Returns the unscaled load/store for the scaled load/store opcode,; /// if there is a corresponding unscaled variant available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:120,avail,available,120,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['avail'],['available']
Availability,"/// Returns the value alive at the end of the instruction, if any. This can; /// be a live-through value, a live def or a dead def.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:22,alive,alive,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,1,['alive'],['alive']
Availability,"/// Returns the vcall visibility of the given type. This is the scope in which; /// a virtual function call could be made which ends up being dispatched to a; /// member function of this class. This scope can be wider than the visibility; /// of the class itself when the class has a more-visible dynamic base class.; /// The client should pass in an empty Visited set, which is used to prevent; /// redundant recursive processing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:400,redundant,redundant,400,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['redundant'],['redundant']
Availability,"/// Returns true if A dominates B (within the same basic block).; /// Both iterators must be in the same basic block.; //; // TODO: Another approach for checking dominance is having two iterators and; // making them go towards each other until they meet or reach begin/end. Which; // approach is better? Should this even change dynamically? For G_CONSTANTS; // most of which will be at the top of the BB, the top down approach would be; // a better choice. Does IRTranslator placing constants at the beginning still; // make sense? Should this change based on Opcode?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h:413,down,down,413,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h,1,['down'],['down']
Availability,"/// Returns true if MI is a dependency breaking instruction for the subtarget.; ///; /// Similar in behavior to `isZeroIdiom`. However, it knows how to identify; /// all dependency breaking instructions (i.e. not just zero-idioms).; /// ; /// As for `isZeroIdiom`, this method returns a mask of ""broken"" dependencies.; /// (See method `isZeroIdiom` for a detailed description of Mask).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:287,mask,mask,287,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Returns true if MI is a dependency breaking instruction for the; /// subtarget associated with CPUID .; ///; /// The value computed by a dependency breaking instruction is not dependent; /// on the inputs. An example of dependency breaking instruction on X86 is; /// `XOR %eax, %eax`.; ///; /// If MI is a dependency breaking instruction for subtarget CPUID, then Mask; /// can be inspected to identify independent operands.; ///; /// Essentially, each bit of the mask corresponds to an input operand.; /// Explicit operands are laid out first in the mask; implicit operands follow; /// explicit operands. Bits are set for operands that are independent.; ///; /// Note that the number of bits in Mask may not be equivalent to the sum of; /// explicit and implicit operands in MI. Operands that don't have a; /// corresponding bit in Mask are assumed ""not independente"".; ///; /// The only exception is for when Mask is all zeroes. That means: explicit; /// input operands of MI are independent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h:368,Mask,Mask,368,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h,6,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Returns true if MI is a dependency breaking zero-idiom for the given; /// subtarget.; ///; /// Mask is used to identify input operands that have their dependency; /// broken. Each bit of the mask is associated with a specific input operand.; /// Bits associated with explicit input operands are laid out first in the; /// mask; implicit operands come after explicit operands.; /// ; /// Dependencies are broken only for operands that have their corresponding bit; /// set. Operands that have their bit cleared, or that don't have a; /// corresponding bit in the mask don't have their dependency broken. Note; /// that Mask may not be big enough to describe all operands. The assumption; /// for operands that don't have a correspondent bit in the mask is that those; /// are still data dependent.; /// ; /// The only exception to the rule is for when Mask has all zeroes.; /// A zero mask means: dependencies are broken for all explicit register; /// operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h:99,Mask,Mask,99,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h,8,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Returns true if MI is a dependency breaking zero-idiom instruction for the; /// subtarget.; ///; /// This function also sets bits in Mask related to input operands that; /// are not in a data dependency relationship. There is one bit for each; /// machine operand; implicit operands follow explicit operands in the bit; /// representation used for Mask. An empty (i.e. a mask with all bits; /// cleared) means: data dependencies are ""broken"" for all the explicit input; /// machine operands of MI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:137,Mask,Mask,137,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,3,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Returns true if \p F has hot function entry. If it returns false, it; /// either means it is not hot or it is unknown whether it is hot or not (for; /// example, no profile data is available).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:185,avail,available,185,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,1,['avail'],['available']
Availability,/// Returns true if \p I is an instruction which requires predication and; /// for which our chosen predication strategy is scalarization (i.e. we; /// don't have an alternate strategy such as masking available).; /// \p VF is the vectorization factor that will be used to vectorize \p I.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:193,mask,masking,193,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,"['avail', 'mask']","['available', 'masking']"
Availability,"/// Returns true if \p S is valid UTF-8, which is required for use as JSON.; /// If it returns false, \p Offset is set to a byte offset near the first error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:151,error,error,151,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['error'],['error']
Availability,"/// Returns true if all errors have been retrieved through makeError(), or; /// false if errors have been added since the last makeError() call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:24,error,errors,24,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,2,['error'],['errors']
Availability,/// Returns true if all loop blocks should be masked to fold tail loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:46,mask,masked,46,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masked']
Availability,/// Returns true if an artificially high cost for emulated masked memrefs; /// should be used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:59,mask,masked,59,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masked']
Availability,/// Returns true if an error has been recorded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:23,error,error,23,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['error'],['error']
Availability,/// Returns true if an error occurred while parsing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:23,error,error,23,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['error'],['error']
Availability,"/// Returns true if at least one of the register writes performed by; /// \param Inst implicitly clears the upper portion of all super-registers.; ///; /// Example: on X86-64, a write to EAX implicitly clears the upper half of; /// RAX. Also (still on x86) an XMM write perfomed by an AVX 128-bit; /// instruction implicitly clears the upper portion of the correspondent; /// YMM register.; ///; /// This method also updates an APInt which is used as mask of register; /// writes. There is one bit for every explicit/implicit write performed by; /// the instruction. If a write implicitly clears its super-registers, then; /// the corresponding bit is set (vic. the corresponding bit is cleared).; ///; /// The first bits in the APint are related to explicit writes. The remaining; /// bits are related to implicit writes. The sequence of writes follows the; /// machine operand sequence. For implicit writes, the sequence is defined by; /// the MCInstrDesc.; ///; /// The assumption is that the bit-width of the APInt is correctly set by; /// the caller. The default implementation conservatively assumes that none of; /// the writes clears the upper portion of a super-register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h:451,mask,mask,451,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h,1,['mask'],['mask']
Availability,/// Returns true if input verification is enabled and verification errors were; /// found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:67,error,errors,67,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,1,['error'],['errors']
Availability,"/// Returns true if is legal to hoist or sink this instruction disregarding the; /// possible introduction of faults. Reasoning about potential faulting; /// instructions is the responsibility of the caller since it is challenging to; /// do efficiently from within this routine.; /// \p TargetExecutesOncePerLoop is true only when it is guaranteed that the; /// target executes at most once per execution of the loop body. This is used; /// to assess the legality of duplicating atomic loads. Generally, this is; /// true when moving out of loop and not true when moving into loops.; /// If \p ORE is set use it to emit optimization remarks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:110,fault,faults,110,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,2,['fault'],"['faulting', 'faults']"
Availability,"/// Returns true if is possible to fold MUL and an idiom that has already been; /// recognized as ADDSUB/SUBADD(\p Opnd0, \p Opnd1) into; /// FMADDSUB/FMSUBADD(x, y, \p Opnd1). If (and only if) true is returned, the; /// operands of FMADDSUB/FMSUBADD are written to parameters \p Opnd0, \p Opnd1, \p Opnd2.; ///; /// Prior to calling this function it should be known that there is some; /// SDNode that potentially can be replaced with an X86ISD::ADDSUB operation; /// using \p Opnd0 and \p Opnd1 as operands. Also, this method is called; /// before replacement of such SDNode with ADDSUB operation. Thus the number; /// of \p Opnd0 uses is expected to be equal to 2.; /// For example, this function may be called for the following IR:; /// %AB = fmul fast <2 x double> %A, %B; /// %Sub = fsub fast <2 x double> %AB, %C; /// %Add = fadd fast <2 x double> %AB, %C; /// %Addsub = shufflevector <2 x double> %Sub, <2 x double> %Add,; /// <2 x i32> <i32 0, i32 3>; /// There is a def for %Addsub here, which potentially can be replaced by; /// X86ISD::ADDSUB operation:; /// %Addsub = X86ISD::ADDSUB %AB, %C; /// and such ADDSUB can further be replaced with FMADDSUB:; /// %Addsub = FMADDSUB %A, %B, %C.; ///; /// The main reason why this method is called before the replacement of the; /// recognized ADDSUB idiom with ADDSUB operation is that such replacement; /// is illegal sometimes. E.g. 512-bit ADDSUB is not available, while 512-bit; /// FMADDSUB is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:1412,avail,available,1412,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,/// Returns true if profile summary is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:39,avail,available,39,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,1,['avail'],['available']
Availability,"/// Returns true if register \p Reg is contained in the set. This also; /// works if only the super register of \p Reg has been defined, because; /// addReg() always adds all sub-registers to the set as well.; /// Note: Returns false if just some sub registers are live, use available(); /// when searching a free register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:275,avail,available,275,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,1,['avail'],['available']
Availability,/// Returns true if subregister liveness information is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:56,avail,available,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,1,['avail'],['available']
Availability,"/// Returns true if the CFG has no branches. Usually it boils down to the CFG; /// having exactly three blocks (entry, the actual code, exit), but sometimes; /// more blocks appear due to having control flow that can be fully; /// resolved in compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CFG.h:62,down,down,62,interpreter/llvm-project/clang/include/clang/Analysis/CFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CFG.h,1,['down'],['down']
Availability,/// Returns true if the alloca is alive after the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:34,alive,alive,34,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,1,['alive'],['alive']
Availability,"/// Returns true if the callee is an externally-visible function in the; /// top-level namespace, such as \c malloc.; ///; /// You can use this call to determine that a particular function really is; /// a library function and not, say, a C++ member function with the same name.; ///; /// If a name is provided, the function must additionally match the given; /// name.; ///; /// Note that this deliberately excludes C++ library functions in the \c std; /// namespace, but will include C library functions accessed through the; /// \c std namespace. This also does not check if the function is declared; /// as 'extern ""C""', or if it uses C++ name mangling.; // FIXME: Add a helper for checking namespaces.; // FIXME: Move this down to AnyFunctionCall once checkers have more; // precise callbacks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h:728,down,down,728,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,1,['down'],['down']
Availability,/// Returns true if the dynamic type info is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/DynamicTypeInfo.h:45,avail,available,45,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/DynamicTypeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/DynamicTypeInfo.h,1,['avail'],['available']
Availability,/// Returns true if the function contains operations which will lower down to; /// instructions which manipulate the stack pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:70,down,down,70,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['down'],['down']
Availability,"/// Returns true if the function's entry is a cold. If it returns false, it; /// either means it is not cold or it is unknown whether it is cold or not (for; /// example, no profile data is available).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp:190,avail,available,190,interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp,1,['avail'],['available']
Availability,"/// Returns true if the given Decl is mapped (or created) during an import; /// but there was an unrecoverable error (the AST node cannot be erased, it; /// is marked with an Error object in this case).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:111,error,error,111,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,2,"['Error', 'error']","['Error', 'error']"
Availability,/// Returns true if the index type for a masked gather/scatter requires; /// extending,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:41,mask,masked,41,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['mask'],['masked']
Availability,/// Returns true if the inline qualifier for \c Name is redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:56,redundant,redundant,56,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['redundant'],['redundant']
Availability,"/// Returns true if the operand type is exactly twice the native width, and; /// the corresponding cmpxchg8b or cmpxchg16b instruction is available.; /// Used to know whether to use cmpxchg8/16b when expanding atomic operations; /// (otherwise we leave them alone to become __sync_fetch_and_... calls).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:138,avail,available,138,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"/// Returns true if the parameter at \p ParamIdx is a pointer type. Returns; /// false if the parameter is not a pointer, or \p ParamIdx is greater than; /// the size of \p IS.ParamVTs.; ///; /// Note that this requires that \p IS.ParamVTs is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenIntrinsics.h:243,avail,available,243,interpreter/llvm-project/llvm/utils/TableGen/CodeGenIntrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenIntrinsics.h,1,['avail'],['available']
Availability,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:456,fault,fault,456,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['fault'],['fault']
Availability,"/// Returns true if the statement represents a configuration value.; ///; /// A configuration value is something usually determined at compile-time; /// to conditionally always execute some branch. Such guards are for; /// ""sometimes unreachable"" code. Such code is usually not interesting; /// to report as unreachable, and may mask truly unreachable code within; /// those blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:329,mask,mask,329,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,1,['mask'],['mask']
Availability,/// Returns true if the target machine can represent \p V as a masked gather; /// or scatter operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:63,mask,masked,63,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masked']
Availability,/// Returns true if the target machine supports masked load operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:48,mask,masked,48,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masked']
Availability,/// Returns true if the target machine supports masked store operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:48,mask,masked,48,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masked']
Availability,/// Returns true if there are no caller-saved registers available in class RC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:56,avail,available,56,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['avail'],['available']
Availability,/// Returns true if there is BasicBlock awaiting deletion.; /// The deletion will only happen until a flush event and; /// all available trees are up-to-date.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:127,avail,available,127,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,1,['avail'],['available']
Availability,/// Returns true if there is at least one function call in the loop which; /// has a vectorized variant available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:104,avail,available,104,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['avail'],['available']
Availability,"/// Returns true if this is a defined addressable, in which case you; /// can downcast this to a Block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:78,down,downcast,78,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['down'],['downcast']
Availability,"/// Returns true if this register write has been executed, and the new; /// register value is therefore available to users.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h:104,avail,available,104,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,1,['avail'],['available']
Availability,/// Returns true if vector representation of the instruction \p I; /// requires mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:80,mask,mask,80,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['mask'],['mask']
Availability,/// Returns true if we should continue scanning for entries or false if we've; /// reached the last (sentinel) entry of encountered a parsing error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h:142,error,error,142,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h,1,['error'],['error']
Availability,/// Returns true iff `AtomTy` is one of the atoms available in Entries of this; /// table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h:50,avail,available,50,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h,1,['avail'],['available']
Availability,/// Returns true iff the group of FMA opcodes holds any of k-masked opcodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h:61,mask,masked,61,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,1,['mask'],['masked']
Availability,/// Returns true iff the group of FMA opcodes holds k-merge-masked opcodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h:60,mask,masked,60,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,1,['mask'],['masked']
Availability,/// Returns true iff the group of FMA opcodes holds k-zero-masked opcodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h:59,mask,masked,59,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,1,['mask'],['masked']
Availability,"/// Returns true on error, false on success. If true is returned then the error; /// message is copied to OutStr and cleared in the ExecutionEngine instance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:20,error,error,20,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,2,['error'],['error']
Availability,"/// Returns true when successfully replaced \p I with a suitable function taking; /// vector arguments, based on available mappings in the \p TLI. Currently only; /// works when \p I is a call to vectorized intrinsic or the frem instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:113,avail,available,113,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,1,['avail'],['available']
Availability,/// Returns variable DIE for the address provided. The pointer is alive as; /// long as parsed compile unit DIEs are not cleared.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h:66,alive,alive,66,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h,1,['alive'],['alive']
Availability,/// Returns whether an error has been set on this list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:23,error,error,23,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,1,['error'],['error']
Availability,/// Returns whether or not the AArch64 SVE built-in types are; /// available on this target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:67,avail,available,67,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['avail'],['available']
Availability,/// Returns whether or not the RISC-V V built-in types are; /// available on this target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:64,avail,available,64,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['avail'],['available']
Availability,/// Returns whether or not type \c __builtin_ms_va_list type is; /// available on this target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:69,avail,available,69,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['avail'],['available']
Availability,"/// Returns whether the analyzed region contains at least one initialized; /// field. Note that this includes subfields as well, not just direct ones,; /// and will return false if an uninitialized pointee is found with; /// CheckPointeeInitialization enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:225,CheckPoint,CheckPointeeInitialization,225,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,1,['CheckPoint'],['CheckPointeeInitialization']
Availability,"/// Returs true if this resource is not reserved, and if there are at least; /// `NumUnits` available units.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:92,avail,available,92,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['avail'],['available']
Availability,/// Revert all errors that happened within this context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h:15,error,errors,15,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Diagnostics.h,1,['error'],['errors']
Availability,"/// Rewrite debug value intrinsics to conform to a new SSA form.; ///; /// This will scout out all the debug value instrinsics associated with; /// the instruction. Anything outside of its block will have its; /// value set to the new SSA value if available, and undef if not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:248,avail,available,248,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,1,['avail'],['available']
Availability,"/// Robust ray-node intersection routine. See ""Robust BVH Ray Traversal"", by T. Ize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/node.h:4,Robust,Robust,4,geom/geom/inc/bvh/v2/node.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/node.h,2,['Robust'],['Robust']
Availability,"/// Rounding mode.; ///; /// Enumerates supported rounding modes, as well as some special values. The set; /// of the modes must agree with IEEE-754, 4.3.1 and 4.3.2. The constants; /// assigned to the IEEE rounding modes must agree with the values used by; /// FLT_ROUNDS (C11, 5.2.4.2.2p8).; ///; /// This value is packed into bitfield in some cases, including \c FPOptions, so; /// the rounding mode values and the special value \c Dynamic must fit into the; /// the bit field (now - 3 bits). The value \c Invalid is used only in values; /// returned by intrinsics to indicate errors, it should never be stored as; /// rounding mode value, so it does not need to fit the bit fields.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:580,error,errors,580,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,1,['error'],['errors']
Availability,/// Rounds down each element of the 128-bit vector of [2 x double] to an; /// integer and returns the rounded values in a 128-bit vector of; /// [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_floor_pd(__m128d X);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD / ROUNDPD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double].; /// \returns A 128-bit vector of [2 x double] containing the rounded values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:11,down,down,11,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['down'],['down']
Availability,/// Rounds down each element of the 128-bit vector of [4 x float] to an; /// an integer and returns the rounded values in a 128-bit vector of; /// [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_floor_ps(__m128 X);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS / ROUNDPS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float] values to be rounded down.; /// \returns A 128-bit vector of [4 x float] containing the rounded values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:11,down,down,11,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['down'],['down']
Availability,/// Rounds down the values stored in a 256-bit vector of [4 x double].; /// The source values are rounded down to integer values and returned as; /// 64-bit double-precision floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_floor_pd(__m256d V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD </c> instruction.; ///; /// \param V; /// A 256-bit vector of [4 x double].; /// \returns A 256-bit vector of [4 x double] containing the rounded down; /// values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:11,down,down,11,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,3,['down'],['down']
Availability,/// Rounds down the values stored in a 256-bit vector of [8 x float]. The; /// source values are rounded down to integer values and returned as; /// floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_floor_ps(__m256 V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS </c> instruction.; ///; /// \param V; /// A 256-bit vector of [8 x float].; /// \returns A 256-bit vector of [8 x float] containing the rounded down values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:11,down,down,11,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,3,['down'],['down']
Availability,"/// Rounds each element of the 128-bit vector of [2 x double] to an; /// integer value according to the rounding control specified by the second; /// argument and returns the rounded values in a 128-bit vector of; /// [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_round_pd(__m128d X, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD / ROUNDPD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [2 x double] containing the rounded values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:943,Down,Downward,943,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['Down'],['Downward']
Availability,"/// Rounds each element of the 128-bit vector of [4 x float] to an; /// integer value according to the rounding control specified by the second; /// argument and returns the rounded values in a 128-bit vector of; /// [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_round_ps(__m128 X, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS / ROUNDPS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [4 x float] containing the rounded values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:938,Down,Downward,938,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['Down'],['Downward']
Availability,"/// Rounds the values in a 256-bit vector of [4 x double] as specified; /// by the byte operand. The source values are rounded to integer values and; /// returned as 64-bit double-precision floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_round_pd(__m256d V, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD </c> instruction.; ///; /// \param V; /// A 256-bit vector of [4 x double].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used. \n; /// 1: The PE field is not updated. \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M. \n; /// 1: Use the current MXCSR setting. \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest. \n; /// 01: Downward (toward negative infinity). \n; /// 10: Upward (toward positive infinity). \n; /// 11: Truncated.; /// \returns A 256-bit vector of [4 x double] containing the rounded values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:922,Down,Downward,922,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Down'],['Downward']
Availability,"/// Rounds the values stored in a 256-bit vector of [8 x float] as; /// specified by the byte operand. The source values are rounded to integer; /// values and returned as floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_round_ps(__m256 V, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS </c> instruction.; ///; /// \param V; /// A 256-bit vector of [8 x float].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used. \n; /// 1: The PE field is not updated. \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M. \n; /// 1: Use the current MXCSR setting. \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest. \n; /// 01: Downward (toward negative infinity). \n; /// 10: Upward (toward positive infinity). \n; /// 11: Truncated.; /// \returns A 256-bit vector of [8 x float] containing the rounded values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:901,Down,Downward,901,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Down'],['Downward']
Availability,"/// Rteurn this JITDylib and its transitive dependencies in reverse DFS order; /// based on linkage relationships.; ///; /// If any JITDylib in the order is defunct then this method will return an; /// error, otherwise returns the order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:202,error,error,202,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['error'],['error']
Availability,"/// Run - Minimize the DAG formed by the \p Changes vertices and the; /// \p Dependencies edges by executing \see ExecuteOneTest() on subsets of; /// changes and returning the smallest set which still satisfies the test; /// predicate and the input \p Dependencies.; ///; /// \param Changes The list of changes.; ///; /// \param Dependencies The list of dependencies amongst changes. For each; /// (x,y) in \p Dependencies, both x and y must be in \p Changes. The; /// minimization algorithm guarantees that for each tested changed set S,; /// \f$ x \in S \f$ implies \f$ y \in S \f$. It is an error to have cyclic; /// dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:594,error,error,594,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,1,['error'],['error']
Availability,/// Run call and deserialize an SPSError result. SPSError returns and; /// deserialization failures are merged into the returned error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:91,failure,failures,91,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,2,"['error', 'failure']","['error', 'failures']"
Availability,"/// Run finalize actions.; ///; /// If any finalize action fails then the corresponding dealloc actions will be; /// run in reverse order (not including the deallocation action for the failed; /// finalize action), and the error for the failing action will be returned.; ///; /// If all finalize actions succeed then a vector of deallocation actions will; /// be returned. The dealloc actions should be run by calling; /// runDeallocationActions. If this function succeeds then the AA argument will; /// be cleared before the function returns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/AllocationActions.h:223,error,error,223,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/AllocationActions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/AllocationActions.h,1,['error'],['error']
Availability,/// Run the clang invocation.; ///; /// \returns True if there were no errors during execution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:71,error,errors,71,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,1,['error'],['errors']
Availability,"/// Run the dependency scanning tool for a given clang driver command-line,; /// and report the discovered dependencies to the provided consumer. If \p; /// ModuleName isn't empty, this function reports the dependencies of module; /// \p ModuleName.; ///; /// \returns false if clang errors occurred (with diagnostics reported to; /// \c DiagConsumer), true otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:284,error,errors,284,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,1,['error'],['errors']
Availability,/// Run the safepoint verifier over a single function. Crashes on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/SafepointIRVerifier.h:66,failure,failure,66,interpreter/llvm-project/llvm/include/llvm/IR/SafepointIRVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/SafepointIRVerifier.h,1,['failure'],['failure']
Availability,"/// Run the wrapper pass to rebuild an aggregation over known AA passes.; ///; /// This is the legacy pass manager's interface to the new-style AA results; /// aggregation object. Because this is somewhat shoe-horned into the legacy; /// pass manager, we hard code all the specific alias analyses available into; /// it. While the particular set enabled is configured via commandline flags,; /// adding a new alias analysis to LLVM will require adding support for it to; /// this list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:297,avail,available,297,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,1,['avail'],['available']
Availability,/// RunProgramRemotelyWithTimeout - This function runs the given program; /// remotely using the given remote client and the sys::Program::ExecuteAndWait.; /// Returns the remote program exit code or reports a remote client error if it; /// fails. Remote client is required to return 255 if it failed or program exit; /// code otherwise.; /// @see sys::Program::ExecuteAndWait,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:224,error,error,224,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,1,['error'],['error']
Availability,"/// Runs a dataflow analysis over the given function and then runs `Diagnoser`; /// over the results. Returns a list of diagnostics for `FuncDecl` or an; /// error. Currently, errors can occur (at least) because the analysis requires; /// too many iterations over the CFG or the SAT solver times out.; ///; /// The default value of `MaxSATIterations` was chosen based on the following; /// observations:; /// - Non-pathological calls to the solver typically require only a few hundred; /// iterations.; /// - This limit is still low enough to keep runtimes acceptable (on typical; /// machines) in cases where we hit the limit.; ///; /// `MaxBlockVisits` caps the number of block visits during analysis. See; /// `runDataflowAnalysis` for a full description and explanation of the default; /// value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h:158,error,error,158,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h,2,['error'],"['error', 'errors']"
Availability,/// Runs an action over all files specified in the command line.; ///; /// \param Action Tool action.; ///; /// \returns 0 on success; 1 if any error occurred; 2 if there is no error but; /// some files are skipped due to missing compile commands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:144,error,error,144,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,2,['error'],['error']
Availability,"/// Runs the give refactoring function for each specified selection.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:99,error,error,99,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,1,['error'],['error']
Availability,"/// Runtime conditionally aborts, always need to support recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:57,recover,recovery,57,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['recover'],['recovery']
Availability,"/// RuntimeDyld invariant checker for verifying that RuntimeDyld has; /// correctly applied relocations.; ///; /// The RuntimeDyldChecker class evaluates expressions against an attached; /// RuntimeDyld instance to verify that relocations have been applied; /// correctly.; ///; /// The expression language supports basic pointer arithmetic and bit-masking,; /// and has limited disassembler integration for accessing instruction; /// operands and the next PC (program counter) address for each instruction.; ///; /// The language syntax is:; ///; /// check = expr '=' expr; ///; /// expr = binary_expr; /// | sliceable_expr; ///; /// sliceable_expr = '*{' number '}' load_addr_expr [slice]; /// | '(' expr ')' [slice]; /// | ident_expr [slice]; /// | number [slice]; ///; /// slice = '[' high-bit-index ':' low-bit-index ']'; ///; /// load_addr_expr = symbol; /// | '(' symbol '+' number ')'; /// | '(' symbol '-' number ')'; ///; /// ident_expr = 'decode_operand' '(' symbol ',' operand-index ')'; /// | 'next_pc' '(' symbol ')'; /// | 'stub_addr' '(' stub-container-name ',' symbol ')'; /// | 'got_addr' '(' stub-container-name ',' symbol ')'; /// | 'section_addr' '(' stub-container-name ',' symbol ')'; /// | symbol; ///; /// binary_expr = expr '+' expr; /// | expr '-' expr; /// | expr '&' expr; /// | expr '|' expr; /// | expr '<<' expr; /// | expr '>>' expr; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyldChecker.h:349,mask,masking,349,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyldChecker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyldChecker.h,1,['mask'],['masking']
Availability,/// SPS tag type for errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h:21,error,errors,21,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h,1,['error'],['errors']
Availability,"/// SPS tag type for expecteds, which are either a T or a string representing; /// an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h:86,error,error,86,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimplePackedSerialization.h,1,['error'],['error']
Availability,/// SU has had all predecessor dependencies resolved. Put it into; /// Available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:71,Avail,Available,71,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['Avail'],['Available']
Availability,"/// Same as Data, but avoids using the get.active.lane.mask intrinsic to; /// calculate the mask and instead implements this with a; /// splat/stepvector/cmp.; /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the; /// active.lane.mask intrinsic when it is not natively supported?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:55,mask,mask,55,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,3,['mask'],['mask']
Availability,"/// Same as above, except if ``IncompleteFormat`` is non-null, its value; /// will be set to true if any of the affected ranges were not formatted due to; /// a non-recoverable syntax error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:165,recover,recoverable,165,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,2,"['error', 'recover']","['error', 'recoverable']"
Availability,"/// Save a GSYM file to a stand alone file.; ///; /// \param Path The file path to save the GSYM file to.; /// \param ByteOrder The endianness to use when saving the file.; /// \param SegmentSize The size in bytes to segment the GSYM file into. If; /// this option is set this function will create N segments; /// that are all around \a SegmentSize bytes in size. This; /// allows a very large GSYM file to be broken up into; /// shards. Each GSYM file will have its own file table,; /// and string table that only have the files and strings; /// needed for the shared. If this argument has no value,; /// a single GSYM file that contains all function; /// information will be created.; /// \returns An error object that indicates success or failure of the save.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:703,error,error,703,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Save this GSYM file into segments that are roughly \a SegmentSize in size.; ///; /// When segemented GSYM files are saved to disk, they will use \a Path as a; /// prefix and then have the first function info address appended to the path; /// when each segment is saved. Each segmented GSYM file has a only the; /// strings and files that are needed to save the function infos that are in; /// each segment. These smaller files are easy to compress and download; /// separately and allow for efficient lookups with very large GSYM files and; /// segmenting them allows servers to download only the segments that are; /// needed.; ///; /// \param Path The path prefix to use when saving the GSYM files.; /// \param ByteOrder The endianness to use when saving the file.; /// \param SegmentSize The size in bytes to segment the GSYM file into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:456,down,download,456,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,2,['down'],['download']
Availability,/// Save this translation unit to a file with the given name.; ///; /// \returns true if there was a file error or false if the save was; /// successful.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:106,error,error,106,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['error'],['error']
Availability,/// Scale an individual branch count.; ///; /// Scale a 64-bit weight down to 32-bits using \c Scale.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h:70,down,down,70,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h,1,['down'],['down']
Availability,"/// Scale an individual branch weight (and add 1).; ///; /// Scale a 64-bit weight down to 32-bits using \c Scale.; ///; /// According to Laplace's Rule of Succession, it is better to compute the; /// weight based on the count plus 1, so universally add 1 to the value.; ///; /// \pre \c Scale was calculated by \a calculateWeightScale() with a weight no; /// greater than \c Weight.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:83,down,down,83,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,1,['down'],['down']
Availability,/// Scale down both weights to fit into uint32_t.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,down,down,10,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['down'],['down']
Availability,/// Scan a block scalar header.; ///; /// Return false if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:61,error,error,61,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['error'],['error']
Availability,/// Scan a block scalar style indicator and header.; ///; /// Note: This is distinct from scanBlockScalarHeader to mirror the fact that; /// YAML does not consider the style indicator to be a part of the header.; ///; /// Return false if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:241,error,error,241,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['error'],['error']
Availability,"/// Scan all symbols referenced by the constraints. If the symbol is not; /// alive, remove it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h:78,alive,alive,78,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h,1,['alive'],['alive']
Availability,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:65,avail,available,65,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,1,['avail'],['available']
Availability,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:68,avail,available,68,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,1,['avail'],['available']
Availability,/// Scan the indentation of a text line in a block scalar.; ///; /// Return false if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:88,error,error,88,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['error'],['error']
Availability,"/// Scans all tokens in input without outputting anything. This is used; /// for benchmarking the tokenizer.; /// \returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h:144,error,error,144,interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h,1,['error'],['error']
Availability,/// Scans the tuple and returns a valid \c Error if any of the values are; /// invalid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h:43,Error,Error,43,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h,1,['Error'],['Error']
Availability,"/// ScheduleNodeBottomUp - Add the node to the schedule. Decrement the pending; /// count of its predecessors. If a predecessor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:170,Avail,Available,170,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,2,['Avail'],['Available']
Availability,"/// ScheduleNodeTopDown - Add the node to the schedule. Decrement the pending; /// count of its successors. If a successor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:165,Avail,Available,165,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['Avail'],['Available']
Availability,"/// Search for a file with the specified name in the current directory or in; /// one of the IncludeDirs, and try to open it **without** adding to the; /// SourceMgr. If the opened file is intended to be added to the source; /// manager, prefer `AddIncludeFile` instead.; ///; /// If no file is found, this returns an Error, otherwise it returns the; /// buffer of the stacked file. The full path to the included file can be; /// found in \p IncludedFile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h:318,Error,Error,318,interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SourceMgr.h,1,['Error'],['Error']
Availability,/// Search for symbols in the target process.; ///; /// The result of the lookup is a 2-dimensional array of target addresses; /// that correspond to the lookup order. If a required symbol is not; /// found then this method will return an error. If a weakly referenced; /// symbol is not found then it be assigned a '0' value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h:239,error,error,239,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,1,['error'],['error']
Availability,/// Search for the specified successor of basic block BB and return its position; /// in the terminator instruction's list of successors. It is an error to call; /// this with a block that is not a successor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:147,error,error,147,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,1,['error'],['error']
Availability,"/// Search list of expected diagnostics for given arguments, and increase the receivedCount.; /// If no matching predefined diagnostic is found, this will trigger an unexpected diagnostic error on exit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/src/TestSupport.cxx:188,error,error,188,core/testsupport/src/TestSupport.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/src/TestSupport.cxx,1,['error'],['error']
Availability,"/// Search the loop header for a loop counter (anadd rec w/step of one); /// suitable for use by LFTR. If multiple counters are available, select the; /// ""best"" one based profitable heuristics.; ///; /// BECount may be an i8* pointer type. The pointer difference is already; /// valid count without scaling the address stride, so it remains a pointer; /// expression as far as SCEV is concerned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:128,avail,available,128,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['avail'],['available']
Availability,"/// Searches the buffer for the first prefix in the prefix regular expression.; ///; /// This searches the buffer using the provided regular expression, however it; /// enforces constraints beyond that:; /// 1) The found prefix must not be a suffix of something that looks like; /// a valid prefix.; /// 2) The found prefix must be followed by a valid check type suffix using \c; /// FindCheckType above.; ///; /// \returns a pair of StringRefs into the Buffer, which combines:; /// - the first match of the regular expression to satisfy these two is; /// returned,; /// otherwise an empty StringRef is returned to indicate failure.; /// - buffer rewound to the location right after parsed suffix, for parsing; /// to continue from; ///; /// If this routine returns a valid prefix, it will also shrink \p Buffer to; /// start at the beginning of the returned prefix, increment \p LineNumber for; /// each new line consumed from \p Buffer, and set \p CheckTy to the type of; /// check found by examining the suffix.; ///; /// If no valid prefix is found, the state of Buffer, LineNumber, and CheckTy; /// is unspecified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:624,failure,failure,624,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['failure'],['failure']
Availability,/// See class ShuffleVectorInst for a description of the mask representation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:57,mask,mask,57,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['mask'],['mask']
Availability,"/// Select the next instruction to issue from the ReadySet. Returns an invalid; /// instruction reference if there are no ready instructions, or if processor; /// resources are not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:181,avail,available,181,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['avail'],['available']
Availability,/// SelectBitfieldInsertInZeroOp - Match a UBFIZ instruction that is the; /// equivalent of a left shift by a constant amount followed by an and masking; /// out a contiguous set of bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:145,mask,masking,145,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['masking']
Availability,"/// Selects four double-precision values from the 256-bit operands of; /// [4 x double], as specified by the immediate value operand.; ///; /// The selected elements from the first 256-bit operand are copied to bits; /// [63:0] and bits [191:128] in the destination, and the selected elements; /// from the second 256-bit operand are copied to bits [127:64] and bits; /// [255:192] in the destination. For example, if bits [3:0] of the immediate; /// operand contain a value of 0xF, the 256-bit destination vector would; /// contain the following values: b[3], a[3], b[1], a[1].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_shuffle_pd(__m256d a, __m256d b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPD </c> instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double].; /// \param b; /// A 256-bit vector of [4 x double].; /// \param mask; /// An immediate value containing 8-bit values specifying which elements to; /// copy from \a a and \a b: \n; /// Bit [0]=0: Bits [63:0] are copied from \a a to bits [63:0] of the; /// destination. \n; /// Bit [0]=1: Bits [127:64] are copied from \a a to bits [63:0] of the; /// destination. \n; /// Bit [1]=0: Bits [63:0] are copied from \a b to bits [127:64] of the; /// destination. \n; /// Bit [1]=1: Bits [127:64] are copied from \a b to bits [127:64] of the; /// destination. \n; /// Bit [2]=0: Bits [191:128] are copied from \a a to bits [191:128] of the; /// destination. \n; /// Bit [2]=1: Bits [255:192] are copied from \a a to bits [191:128] of the; /// destination. \n; /// Bit [3]=0: Bits [191:128] are copied from \a b to bits [255:192] of the; /// destination. \n; /// Bit [3]=1: Bits [255:192] are copied from \a b to bits [255:192] of the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the shuffled values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:694,mask,mask,694,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,2,['mask'],['mask']
Availability,"/// Selects whether handling of failures should be done in the same way as; /// for regular crashes. When this is active, a crash would print the; /// callstack, clean-up any temporary files and create a coredump/minidump.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:32,failure,failures,32,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,1,['failure'],['failures']
Availability,/// SemaBuiltinPPCMMACall - Check the call to a PPC MMA builtin for validity.; /// Emit an error and return true on failure; return false on success.; /// TypeStr is a string containing the type descriptor of the value returned by; /// the builtin and the descriptors of the expected type of the arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:91,error,error,91,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// Serialize the availability attributes of a symbol.; ///; /// Availability information contains the introduced, deprecated, and obsoleted; /// versions of the symbol as semantic versions, if not default.; /// Availability information also contains flags to indicate if the symbol is; /// unconditionally unavailable or deprecated,; /// i.e. \c __attribute__((unavailable)) and \c __attribute__((deprecated)).; ///; /// \returns \c std::nullopt if the symbol has default availability attributes,; /// or an \c Array containing an object with the formatted availability; /// information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:18,avail,availability,18,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,5,"['Avail', 'avail']","['Availability', 'availability']"
Availability,"/// Serialize this translation unit with the given output stream.; ///; /// \returns True if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:96,error,error,96,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['error'],['error']
Availability,"/// Serializes error output, destructed by the gROOT destructor via ReleaseDefaultErrorHandler()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx:15,error,error,15,core/base/src/TErrorDefaultHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx,1,['error'],['error']
Availability,/// Set a pass filter based on a regex \p Filter.; /// Returns an error if the regex is invalid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/RemarkStreamer.h:66,error,error,66,interpreter/llvm-project/llvm/include/llvm/Remarks/RemarkStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/RemarkStreamer.h,1,['error'],['error']
Availability,/// Set an error reporter for this server.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.h:11,error,error,11,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.h,1,['error'],['error']
Availability,"/// Set convergence tolerance parameter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooBrentRootFinder.h:20,toler,tolerance,20,roofit/roofitcore/inc/RooBrentRootFinder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooBrentRootFinder.h,1,['toler'],['tolerance']
Availability,/// Set errno constraint at failure cases of standard functions.; /// Failure case: 'errno' becomes not equal to 0 and may or may not be checked; /// by the program. \c ErrnoChecker does not emit a bug report after such a; /// function call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:28,failure,failure,28,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,2,"['Failure', 'failure']","['Failure', 'failure']"
Availability,/// Set errno constraint at functions that indicate failure only with 'errno'.; /// In this case 'errno' is required to be observed.; /// \c ErrnoChecker can emit bug report after such a function call if errno; /// is overwritten without a read before.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:52,failure,failure,52,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['failure'],['failure']
Availability,"/// Set errno state for the common case when a standard function indicates; /// failure only by \c errno. Sets \c ErrnoCheckState to \c MustBeChecked, and; /// invalidates the errno region (clear of previous value).; /// \arg \c InvalE Expression that causes invalidation of \c errno.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h:80,failure,failure,80,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.h,1,['failure'],['failure']
Availability,/// Set error and error message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LockFileManager.h:8,error,error,8,interpreter/llvm-project/llvm/include/llvm/Support/LockFileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LockFileManager.h,2,['error'],['error']
Availability,/// Set error handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h:8,error,error,8,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h,1,['error'],['error']
Availability,/// Set of nodes which have been combined (at least once).; ///; /// This is used to allow us to reliably add any operands of a DAG node; /// which have not yet been combined to the worklist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:97,reliab,reliably,97,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reliab'],['reliably']
Availability,"/// Set the ""delayed"" diagnostic that will be emitted once; /// the current diagnostic completes.; ///; /// If a diagnostic is already in-flight but the front end must; /// report a problem (e.g., with an inconsistent file system; /// state), this routine sets a ""delayed"" diagnostic that will be; /// emitted after the current diagnostic completes. This should; /// only be used for fatal errors detected at inconvenient; /// times. If emitting a delayed diagnostic causes a second delayed; /// diagnostic to be introduced, that second delayed diagnostic; /// will be ignored.; ///; /// \param DiagID The ID of the diagnostic being delayed.; ///; /// \param Arg1 A string argument that will be provided to the; /// diagnostic. A copy of this string will be stored in the; /// DiagnosticsEngine object itself.; ///; /// \param Arg2 A string argument that will be provided to the; /// diagnostic. A copy of this string will be stored in the; /// DiagnosticsEngine object itself.; ///; /// \param Arg3 A string argument that will be provided to the; /// diagnostic. A copy of this string will be stored in the; /// DiagnosticsEngine object itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:390,error,errors,390,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['errors']
Availability,"/// Set the Minimization tolerance.; /// The Default value for Minuit and Minuit2 is 0.01",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h:25,toler,tolerance,25,math/mathcore/inc/Math/MinimizerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h,1,['toler'],['tolerance']
Availability,"/// Set the array size to \p N, which the current array must have enough; /// capacity for.; ///; /// This does not construct or destroy any elements in the vector.; ///; /// Clients can use this in conjunction with capacity() to write past the end; /// of the buffer when they know that more elements are available, and only; /// update the size later. This avoids the cost of value initializing elements; /// which will only be overwritten.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:306,avail,available,306,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['avail'],['available']
Availability,/// Set the banner string for any errors caught by operator().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:34,error,errors,34,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['error'],['errors']
Availability,/// Set the current error and return same.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h:20,error,error,20,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,1,['error'],['error']
Availability,/// Set the cursor to the new offset. This does not impact the error state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:63,error,error,63,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['error'],['error']
Availability,"/// Set the cv-qualifiers on the object type, for us in filtering; /// calls to member functions.; ///; /// When there are qualifiers in this set, they will be used to filter; /// out member functions that aren't available (because there will be a; /// cv-qualifier mismatch) or prefer functions with an exact qualifier; /// match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:213,avail,available,213,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['avail'],['available']
Availability,"/// Set the default level for computing the parameter errors.; /// For example for 1-sigma parameter errors; /// - up = 1 for a chi-squared function; /// - up = 0.5 for a negative log-likelihood function; ///; /// The value will be used also by Minos when computing the confidence interval",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h:54,error,errors,54,math/mathcore/inc/Math/MinimizerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h,2,['error'],['errors']
Availability,/// Set the diagnostic which caused the SFINAE failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:47,failure,failure,47,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,/// Set the error reporter function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:12,error,error,12,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['error'],['error']
Availability,"/// Set the error-as-fatal flag for the given diagnostic group.; ///; /// This function always only operates on the current diagnostic state.; ///; /// \returns True if the given group is unknown, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:12,error,error-as-fatal,12,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['error-as-fatal']
Availability,"/// Set the file modification and access time.; ///; /// @returns errc::success if the file times were successfully set, otherwise a; /// platform-specific error_code or errc::function_not_supported on; /// platforms where the functionality isn't available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:247,avail,available,247,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['avail'],['available']
Availability,/// Set the flag indicating that an output error has been encountered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:43,error,error,43,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['error'],['error']
Availability,"/// Set the flag read by has_error() to false. If the error flag is set at the; /// time when this raw_ostream's destructor is called, report_fatal_error is; /// called to report the error. Use clear_error() after handling the error to; /// avoid this behavior.; ///; /// ""Errors should never pass silently.; /// Unless explicitly silenced.""; /// - from The Zen of Python, by Tim Peters; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:54,error,error,54,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,4,"['Error', 'error']","['Errors', 'error']"
Availability,"/// Set the left side tail fraction. This will automatically configure the; /// MCMCInterval to find a tail-fraction interval.; /// Note: that `a' must be in the range 0 <= a <= 1; /// or the user will be notified of the error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/MCMCCalculator.h:221,error,error,221,roofit/roostats/inc/RooStats/MCMCCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/MCMCCalculator.h,1,['error'],['error']
Availability,"/// Set the link order to be used when fixing up definitions in JITDylib.; /// This will replace the previous link order, and apply to any symbol; /// resolutions made for definitions in this JITDylib after the call to; /// setLinkOrder (even if the definition itself was added before the; /// call).; ///; /// If LinkAgainstThisJITDylibFirst is true (the default) then this JITDylib; /// will add itself to the beginning of the LinkOrder (Clients should not; /// put this JITDylib in the list in this case, to avoid redundant lookups).; ///; /// If LinkAgainstThisJITDylibFirst is false then the link order will be used; /// as-is. The primary motivation for this feature is to support deliberate; /// shadowing of symbols in this JITDylib by a facade JITDylib. For example,; /// the facade may resolve function names to stubs, and the stubs may compile; /// lazily by looking up symbols in this dylib. Adding the facade dylib; /// as the first in the link order (instead of this dylib) ensures that; /// definitions within this dylib resolve to the lazy-compiling stubs,; /// rather than immediately materializing the definitions in this dylib.; ///; /// It is illegal to call this method on a defunct JITDylib and the client; /// is responsible for ensuring that they do not do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:517,redundant,redundant,517,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['redundant'],['redundant']
Availability,"/// Set the name of the current thread. Setting a thread's name can; /// be helpful for enabling useful diagnostics under a debugger or when; /// logging. The level of support for setting a thread's name varies; /// wildly across operating systems, and we only make a best effort to; /// perform the operation on supported platforms. No indication of success; /// or failure is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:367,failure,failure,367,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,1,['failure'],['failure']
Availability,"/// Set the next entry (or index of the TEntryList if that is set).; ///; /// \param entry If not TEntryList is set, the entry is a global entry (i.e.; /// not the entry number local to the chain's current tree).; /// \returns the `entry`'s read status, i.e. whether the entry is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:280,avail,available,280,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,1,['avail'],['available']
Availability,"/// Set the next local tree entry. If a TEntryList is set, this function is; /// equivalent to `SetEntry()`.; ///; /// \param entry Entry number of the TChain's current TTree. This is the; /// entry number passed for instance by `TSelector::Process(entry)`, i.e.; /// within `TSelector::Process()` always use `SetLocalEntry()` and not; /// `SetEntry()`!; /// \return the `entry`'s read status, i.e. whether the entry is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:420,avail,available,420,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,1,['avail'],['available']
Availability,"/// Set the path to a directory where to save generated object files. This; /// path can be used by a linker to request on-disk files instead of in-memory; /// buffers. When set, results are available through getProducedBinaryFiles(); /// instead of getProducedBinaries().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:191,avail,available,191,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['avail'],['available']
Availability,"/// Set the warning-as-error flag for the given diagnostic group.; ///; /// This function always only operates on the current diagnostic state.; ///; /// \returns True if the given group is unknown, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:23,error,error,23,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['error']
Availability,/// Set the working directory. This will affect all following operations on; /// this file system and may propagate down for nested file systems.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h:116,down,down,116,interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,1,['down'],['down']
Availability,"/// Set to initial state of ""no errors occurred"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:32,error,errors,32,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['errors']
Availability,"/// Set to true (only applicatable to ELF -fpic) if dso_local should be; /// dropped for a declaration.; ///; /// On ELF, the assembler is conservative and assumes a global default; /// visibility symbol can be interposable. No direct access relocation is; /// allowed, if the definition is not in the translation unit, even if the; /// definition is available in the linkage unit. Thus we need to clear; /// dso_local to disable direct access.; ///; /// This flag should not be set for -fno-pic or -fpie, which would; /// unnecessarily disable direct access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:351,avail,available,351,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,1,['avail'],['available']
Availability,/// Set verification handler used to report verification errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinkerBase.h:57,error,errors,57,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinkerBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinkerBase.h,1,['error'],['errors']
Availability,/// Set verification handler which would be used to report verification; /// errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h:77,error,errors,77,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,2,['error'],['errors']
Availability,"/// SetFPAccuracy - Set the minimum required accuracy of the given floating; /// point operation, expressed as the maximum relative error in ulp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:132,error,error,132,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['error'],['error']
Availability,/// SetMemberAccessSpecifier - Set the access specifier of a member.; /// Returns true on error (when the previous member decl access specifier; /// is different from the new member decl access specifier).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:90,error,error,90,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['error'],['error']
Availability,"/// SetValue -; /// Return true on error, false on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:35,error,error,35,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,/// Sets the failure ordering constraint of this cmpxchg instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:13,failure,failure,13,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['failure'],['failure']
Availability,"/// Sets the response to stream the file at FilePath, if available, and; /// otherwise an HTTP 404 error response.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPServer.h:57,avail,available,57,interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPServer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPServer.h,2,"['avail', 'error']","['available', 'error']"
Availability,"/// Sets value of register mask operand referencing Mask. The; /// operand does not take ownership of the memory referenced by Mask, it must; /// remain valid for the lifetime of the operand. See CreateRegMask().; /// Any physreg with a 0 bit in the mask is clobbered by the instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:27,mask,mask,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,4,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Sets whether an error message should be printed out if an action fails. By; /// default, if an action fails, a message is printed out to stderr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:20,error,error,20,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,1,['error'],['error']
Availability,"/// Short-hand method to throw an exception in the case of errors. Does nothing for; /// successful RResults.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:59,error,errors,59,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,1,['error'],['errors']
Availability,"/// Short-hand to return an RResult<T> in an error state (i.e. after checking)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:45,error,error,45,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,1,['error'],['error']
Availability,"/// Short-hand to return an RResult<T> in an error state; the RError is implicitly converted into RResult<T>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:45,error,error,45,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,1,['error'],['error']
Availability,/// Should we have mover and linker error diag info?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:36,error,error,36,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,1,['error'],['error']
Availability,"/// Should we tranform the IR-optimal check for whether given truncation; /// down into KeptBits would be truncating or not:; /// (add %x, (1 << (KeptBits-1))) srccond (1 << KeptBits); /// Into it's more traditional form:; /// ((%x << C) a>> C) dstcond %x; /// Return true if we should transform.; /// Return false if there is no preference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:78,down,down,78,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['down'],['down']
Availability,"/// ShouldPreferAnother - This callback may be invoked if getHazardType; /// returns NoHazard. If, even though there is no hazard, it would be better to; /// schedule another available instruction, this callback should return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:175,avail,available,175,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,1,['avail'],['available']
Availability,/// Shuffles \p Mask in accordance with the given \p SubMask.; /// \param ExtendingManyInputs Supports reshuffling of the mask with not only; /// one but two input vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,Mask,Mask,16,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Shut down the asmprinter. If you override this in your pass, you must make; /// sure to call it explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:9,down,down,9,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,1,['down'],['down']
Availability,"/// Sign extend to a new width.; ///; /// This operation sign extends the APInt to a new width. If the high order; /// bit is set, the fill on the left will be done with 1 bits, otherwise zero.; /// It is an error to specify a width that is less than the; /// current width.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:208,error,error,208,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['error'],['error']
Availability,/// SignBitIsZero - Return true if the sign bit of Op is known to be zero. We; /// use this predicate to simplify operations downstream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:125,down,downstream,125,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['down'],['downstream']
Availability,"/// Similar to RValue but manages an array of consecutive values. Bulks have to come from the same cluster.; /// Bulk I/O works with two bit masks: the mask of all the available entries in the current bulk and the mask; /// of the required entries in a bulk read. The idea is that a single bulk may serve multiple read operations; /// on the same range, where in each read operation a different subset of values is required.; /// The memory of the value array is managed by the RBulk class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:141,mask,masks,141,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,4,"['avail', 'mask']","['available', 'mask', 'masks']"
Availability,/// Similar to getICmpCode but for FCmpInst. This encodes a fcmp predicate; /// into a four bit mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h:96,mask,mask,96,interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,1,['mask'],['mask']
Availability,/// Similar to isShuffleMaskLegal. Return true is the given 'select with zero'; /// shuffle mask can be codegen'd directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h:92,mask,mask,92,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,1,['mask'],['mask']
Availability,"/// Similar to readCString, however read a null-terminated UTF16 string; /// instead.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:115,error,error,115,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,2,['error'],['error']
Availability,/// Simple diagnostic handler that prints diagnostics to standard error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp:66,error,error,66,interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp,1,['error'],['error']
Availability,/// Simpler version of equivalent for clients that don't need to; /// differentiate between an error and false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:95,error,error,95,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['error'],['error']
Availability,/// Simpler version of is_directory for clients that don't need to; /// differentiate between an error and false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:97,error,error,97,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['error'],['error']
Availability,/// Simpler version of is_local accepting an open file descriptor for; /// clients that don't need to differentiate between an error and false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:127,error,error,127,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['error'],['error']
Availability,/// Simpler version of is_local for clients that don't need to; /// differentiate between an error and false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:93,error,error,93,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['error'],['error']
Availability,/// Simpler version of is_regular_file for clients that don't need to; /// differentiate between an error and false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:100,error,error,100,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['error'],['error']
Availability,/// Simpler version of is_symlink_file for clients that don't need to; /// differentiate between an error and false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:100,error,error,100,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['error'],['error']
Availability,/// Simplifies the given expression tree; /// by getting rid of algebraically redundant operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h:78,redundant,redundant,78,interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,1,['redundant'],['redundant']
Availability,"/// Simplify a switch instruction by removing cases which can never fire. If the; /// uselessness of a case could be determined locally then constant propagation; /// would already have figured it out. Instead, walk the predecessors and; /// statically evaluate cases based on information available on that edge. Cases; /// that cannot fire no matter what the incoming edge can safely be removed. If; /// a case fires on every incoming edge then the entire switch can be removed; /// and replaced with a branch to the case destination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:289,avail,available,289,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['avail'],['available']
Availability,"/// Simplify the CFG without completely destroying it.; /// This is not well defined, but basically comes down to ""try to eliminate; /// unreachable blocks and constant fold terminators without deciding that; /// certain undefined behavior cuts off the program at the legs"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:106,down,down,106,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['down'],['down']
Availability,"/// Simplify the waitcnt, in the sense of removing redundant counts, and return; /// whether a waitcnt instruction is needed at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:51,redundant,redundant,51,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['redundant'],['redundant']
Availability,"/// Since the getErrorNode() or BugReport refers to the original ExplodedGraph,; /// we need to pair it to the error node of the constructed trimmed graph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:111,error,error,111,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['error'],['error']
Availability,"/// Single-threaded top-down builder that partitions primitives based on a binned approximation of; /// the Surface Area Heuristic (SAH). This builder is inspired by; /// ""On Fast Construction of SAH-based Bounding Volume Hierarchies"", by I. Wald.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/binned_sah_builder.h:24,down,down,24,geom/geom/inc/bvh/v2/binned_sah_builder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/binned_sah_builder.h,1,['down'],['down']
Availability,"/// Single-threaded top-down builder that partitions primitives based on the Surface; /// Area Heuristic (SAH). Primitives are only sorted once along each axis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/sweep_sah_builder.h:24,down,down,24,geom/geom/inc/bvh/v2/sweep_sah_builder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/sweep_sah_builder.h,1,['down'],['down']
Availability,/// Skip the current line table and go to the following line table (if; /// present) immediately.; ///; /// \param RecoverableErrorHandler - report any recoverable prologue; /// parsing issues via this handler.; /// \param UnrecoverableErrorHandler - report any unrecoverable prologue; /// parsing issues via this handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h:115,Recover,RecoverableErrorHandler,115,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h,2,"['Recover', 'recover']","['RecoverableErrorHandler', 'recoverable']"
Availability,"/// Skip to the end of the current statement, for error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h:50,error,error,50,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,2,"['error', 'recover']","['error', 'recovery']"
Availability,"/// Skip tokens until after the #include of the through header or; /// until after a #pragma hdrstop is seen. Tokens in the predefines file; /// and the main file may be skipped. If the end of the predefines file; /// is reached, skipping continues into the main file. If the end of the; /// main file is reached, it's a fatal error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:327,error,error,327,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['error'],['error']
Availability,"/// SkipBitcodeWrapperHeader - Some systems wrap bc files with a special; /// header for padding or other reasons. The format of this header is:; ///; /// struct bc_header {; /// uint32_t Magic; // 0x0B17C0DE; /// uint32_t Version; // Version, currently always 0.; /// uint32_t BitcodeOffset; // Offset to traditional bitcode file.; /// uint32_t BitcodeSize; // Size of traditional bitcode file.; /// ... potentially other gunk ...; /// };; ///; /// This function is called when we find a file with a matching magic number.; /// In this case, skip down to the subsection of the file that is actually a; /// BC file.; /// If 'VerifyBufferSize' is true, check that the buffer is large enough to; /// contain the whole bitcode file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:548,down,down,548,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,1,['down'],['down']
Availability,"/// Slice \p Inc according to the information contained within this slice.; /// This is cached, so if called multiple times for the same \p BB & \p Inc; /// pair, it returns the same Sliced value as well.; ///; /// Note this *intentionally* does not return the same value for, say,; /// [%bb.0, %0] & [%bb.1, %0] as:; /// - It could cause issues with dominance (e.g. if bb.1 is seen first, then; /// the value in bb.1 may not be reachable from bb.0 if it's its; /// predecessor.); /// - We also want to make our extract instructions as local as possible so; /// the DAG has better chances of folding them out. Duplicating them like; /// that is beneficial in that regard.; ///; /// This is both a minor optimization to avoid creating duplicate; /// instructions, but also a requirement for correctness. It is not forbidden; /// for a PHI node to have the same [BB, Val] pair multiple times. If we; /// returned a new value each time, those previously identical pairs would all; /// have different incoming values (from the same block) and it'd cause a ""PHI; /// node has multiple entries for the same basic block with different incoming; /// values!"" verifier error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:1160,error,error,1160,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['error'],['error']
Availability,"/// Smart pointer for the return type of actions; /**; \class ROOT::RDF::RResultPtr; \ingroup dataframe; \brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; \tparam T Type of the action result. A smart pointer which allows to access the result of a RDataFrame action. The; methods of the encapsulated object can be accessed via the arrow operator.; Upon invocation of the arrow operator or dereferencing (`operator*`), the; loop on the events and calculations of all scheduled actions are executed; if needed.; It is possible to iterate on the result proxy if the proxied object is a collection.; ~~~{.cpp}; for (auto& myItem : myResultProxy) { ... };; ~~~; If iteration is not supported by the type of the proxied object, a compilation error is thrown. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:780,error,error,780,tree/dataframe/inc/ROOT/RResultPtr.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx,1,['error'],['error']
Availability,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy signed truncation.; /// Folds: (MaskedBits is a constant.); /// ((%x << MaskedBits) a>> MaskedBits) SrcPred %x; /// Into:; /// (add %x, (1 << (KeptBits-1))) DstPred (1 << KeptBits); /// Where KeptBits = bitwidth(%x) - MaskedBits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:162,Mask,MaskedBits,162,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,4,['Mask'],['MaskedBits']
Availability,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy truncation.; /// Folds:; /// icmp SrcPred (x & Mask), x to icmp DstPred x, Mask; /// Where Mask is some pattern that produces all-ones in low bits:; /// (-1 >> y); /// ((-1 << y) >> y) <- non-canonical, has extra uses; /// ~(-1 << y); /// ((1 << y) + (-1)) <- non-canonical, has extra uses; /// The Mask can be a constant, too.; /// For some predicates, the operands are commutative.; /// For others, x can only be on a specific side.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:177,Mask,Mask,177,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,4,['Mask'],['Mask']
Availability,/// Some error which was already diagnosed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:9,error,error,9,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,/// Some kind of error has occurred and we could not legalize this; /// instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h:17,error,error,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,1,['error'],['error']
Availability,"/// Some of the values are stored in bitfields. Since this needs to be portable; /// across compilers and architectures (big / little endian in particular) we; /// can't use the actual structures below, but must instead do the shifting; /// and masking ourselves. The struct definitions are provided for reference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h:245,mask,masking,245,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h,1,['mask'],['masking']
Availability,"/// Sort the n elements of the array a of generic templated type Element.; /// In output the array index of type Index contains the indices of the sorted array.; /// If down is false sort in increasing order (default is decreasing order).; ///; /// NOTE that the array index must be created with a length >= n; /// before calling this function.; /// NOTE also that the size type for n must be the same type used for the index array; /// (templated type Index)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMathBase.h:169,down,down,169,core/base/inc/TMathBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMathBase.h,1,['down'],['down']
Availability,"/// Sort the n1 elements of the Short_t array defined by its; /// iterators. In output the array index contains the indices of; /// the sorted array. If down is false sort in increasing order; /// (default is decreasing order).; ///; /// NOTE that the array index must be created with a length bigger; /// or equal than the main array before calling this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMathBase.h:153,down,down,153,core/base/inc/TMathBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMathBase.h,1,['down'],['down']
Availability,"/// Sorted list of instructions with register mask operands. Always use the; /// 'r' slot, RegMasks are normal clobbers, not early clobbers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:46,mask,mask,46,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,1,['mask'],['mask']
Availability,/// Sorting functions for the Available queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:30,Avail,Available,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,2,['Avail'],['Available']
Availability,/// Source manager for better error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.h:30,error,error,30,interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.h,1,['error'],['error']
Availability,/// Space just below incoming stack pointer reserved for arguments being; /// passed on the stack during a tail call. This will be the difference; /// between the largest tail call argument space needed in this function and; /// what's already available by reusing space of incoming arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.h:244,avail,available,244,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.h,1,['avail'],['available']
Availability,/// Special ErrorInfo subclass representing a list of ErrorInfos.; /// Instances of this class are constructed by joinError.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:12,Error,ErrorInfo,12,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,2,['Error'],"['ErrorInfo', 'ErrorInfos']"
Availability,/// Specialization for functions of the form 'Error (std::unique_ptr<ErrT>)'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:46,Error,Error,46,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['Error']
Availability,"/// Specialized version of; /// shrinkToUses(LiveInterval *li, SmallVectorImpl<MachineInstr*> *dead); /// that works on a subregister live range and only looks at uses matching; /// the lane mask of the subregister range.; /// This may leave the subrange empty which needs to be cleaned up with; /// LiveInterval::removeEmptySubranges() afterwards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:191,mask,mask,191,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,1,['mask'],['mask']
Availability,/// Specifies the way the mask should be analyzed for undefs/poisonous elements; /// in the shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['mask'],['mask']
Availability,"/// Specifies whether a ModR/M byte is needed and (if so) which; /// instruction each possible value of the ModR/M byte corresponds to. Once; /// this information is known, we have narrowed down to a single instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerShared.h:190,down,down,190,interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerShared.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerShared.h,1,['down'],['down']
Availability,/// Specify a limit for the number of errors we should; /// emit before giving up.; ///; /// Zero disables the limit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:38,error,errors,38,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['errors']
Availability,"/// Specify the point at which code-completion will be performed.; ///; /// \param File the file in which code completion should occur. If; /// this file is included multiple times, code-completion will; /// perform completion the first time it is included. If NULL, this; /// function clears out the code-completion point.; ///; /// \param Line the line at which code completion should occur; /// (1-based).; ///; /// \param Column the column at which code completion should occur; /// (1-based).; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:528,error,error,528,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['error'],['error']
Availability,/// Specify under what conditions this check can be recovered,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:52,recover,recovered,52,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['recover'],['recovered']
Availability,"/// Specify whether hidden declarations are visible, e.g.,; /// for recovery reasons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:68,recover,recovery,68,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['recover'],['recovery']
Availability,/// Split mask operator of a VP intrinsic in a given location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h:10,mask,mask,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,1,['mask'],['mask']
Availability,/// Split mask operator of a VP intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h:10,mask,mask,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,1,['mask'],['mask']
Availability,"/// Split up the constraint string from the inline assembly value into the; /// specific constraints and their prefixes, and also tie in the associated; /// operand values. If this returns an empty vector, and if the constraint; /// string itself isn't empty, there was an error parsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:273,error,error,273,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['error'],['error']
Availability,"/// Split up the constraint string from the inline assembly value into the; /// specific constraints and their prefixes, and also tie in the associated; /// operand values.; /// If this returns an empty vector, and if the constraint string itself; /// isn't empty, there was an error parsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:278,error,error,278,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['error'],['error']
Availability,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:33,mask,mask,33,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,6,"['Mask', 'mask']","['Mask', 'mask', 'masks']"
Availability,/// Stack of potentially nested 'if (@available(...))'s.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:38,avail,available,38,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['available']
Availability,/// Start the allocation process.; ///; /// If the initial allocation is successful then the OnAllocated function will; /// be called with a std::unique_ptr<InFlightAlloc> value. If the assocation; /// is unsuccessful then the OnAllocated function will be called with an; /// Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h:276,Error,Error,276,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,1,['Error'],['Error']
Availability,/// Starting from \p Root find a top-down traversal order of the dominator; /// tree to visit all basic blocks containing the elements of \p Spills.; /// Redundant spills will be found and put into \p SpillsToRm at the same; /// time. \p SpillBBToSpill will be populated as part of the process and; /// maps a basic block to the first store occurring in the basic block.; /// \post SpillsToRm.union(Spills\@post) == Spills\@pre,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:37,down,down,37,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,2,"['Redundant', 'down']","['Redundant', 'down']"
Availability,"/// Starting from `fNextFileIndex`, opens the next `fNSlots` files. Calls `LoadStructure()` on the opened files.; /// The very first file is already available from the constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx:149,avail,available,149,tree/dataframe/inc/ROOT/RNTupleDS.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx,1,['avail'],['available']
Availability,/// State of the error flags.; /// Ignored in non-opened stream state but must be NoError.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,/// State of the stream error flags.; /// Sometimes it is not known to the checker what error flags are set.; /// This is indicated by setting more than one flag to true.; /// This is an optimization to avoid state splits.; /// A stream can either be in FEOF or FERROR but not both at the same time.; /// Multiple flags are set to handle the corresponding states together.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:24,error,error,24,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,2,['error'],['error']
Availability,"/// Status variable indicating if this diagnostic is still active.; ///; // NOTE: This field is redundant with DiagObj (IsActive iff (DiagObj == 0)),; // but LLVM is not currently smart enough to eliminate the null check that; // Emit() would end up with if we used that as our status variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:96,redundant,redundant,96,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['redundant'],['redundant']
Availability,/// Sticky flag set to \c true when a fatal error is emitted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:44,error,error,44,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['error']
Availability,"/// Sticky flag set to \c true when an ""uncompilable error"" occurs.; /// I.e. an error that was not upgraded from a warning by -Werror.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:53,error,error,53,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,2,['error'],['error']
Availability,/// Sticky flag set to \c true when an error is emitted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:39,error,error,39,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['error']
Availability,/// StorageClassSpecToVarDeclStorageClass - Maps a DeclSpec::SCS to; /// a VarDecl::StorageClass. Any error reporting is up to the caller:; /// illegal input values are mapped to SC_None.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:102,error,error,102,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"/// Store into a strong object. Sometimes calls this:; /// call void \@objc_storeStrong(i8** %addr, i8* %value); /// Other times, breaks it down into components.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:140,down,down,140,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['down'],['down']
Availability,"/// Store the location of a C++ object corresponding to a statement; /// until the statement is actually encountered. For example, if a DeclStmt; /// has CXXConstructExpr as its initializer, the object would be considered; /// to be ""under construction"" between CXXConstructExpr and DeclStmt.; /// This allows, among other things, to keep bindings to variable's fields; /// made within the constructor alive until its declaration actually; /// goes into scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h:402,alive,alive,402,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,1,['alive'],['alive']
Availability,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x i32].; /// \param __b; /// A 128-bit vector of [4 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:34,mask,mask,34,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,3,['mask'],['mask']
Availability,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x i32].; /// \param __b; /// A 256-bit vector of [8 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:34,mask,mask,34,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,3,['mask'],['mask']
Availability,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [16 x i32].; /// \param __b; /// A 512-bit vector of [16 x i32]; /// \param __m0; /// A pointer point to 16-bit mask; /// \param __m1; /// A pointer point to 16-bit mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:34,mask,mask,34,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,3,['mask'],['mask']
Availability,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x i64].; /// \param __b; /// A 128-bit vector of [2 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:34,mask,mask,34,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,3,['mask'],['mask']
Availability,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x i64].; /// \param __b; /// A 256-bit vector of [4 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:34,mask,mask,34,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,3,['mask'],['mask']
Availability,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [8 x i64].; /// \param __b; /// A 512-bit vector of [8 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:34,mask,mask,34,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,3,['mask'],['mask']
Availability,"/// StoredNameKind represent the kind of name that is actually stored in the; /// upper bits of the Ptr field. This is only used internally.; ///; /// NameKind, StoredNameKind, and DeclarationNameExtra::ExtraKind; /// must satisfy the following properties. These properties enable; /// efficient conversion between the various kinds.; ///; /// * The first seven enumerators of StoredNameKind must have the same; /// numerical value as the first seven enumerators of NameKind.; /// This enable efficient conversion between the two enumerations; /// in the usual case.; ///; /// * The enumerations values of DeclarationNameExtra::ExtraKind must start; /// at zero, and correspond to the numerical value of the first non-inline; /// enumeration values of NameKind minus an offset. This makes conversion; /// between DeclarationNameExtra::ExtraKind and NameKind possible with; /// a single addition/substraction.; ///; /// * The enumeration values of Selector::IdentifierInfoFlag must correspond; /// to the relevant enumeration values of StoredNameKind.; /// More specifically:; /// * ZeroArg == StoredObjCZeroArgSelector,; /// * OneArg == StoredObjCOneArgSelector,; /// * MultiArg == StoredDeclarationNameExtra; ///; /// * PtrMask must mask the low 3 bits of Ptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclarationName.h:1234,mask,mask,1234,interpreter/llvm-project/clang/include/clang/AST/DeclarationName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclarationName.h,1,['mask'],['mask']
Availability,/// Stores 8 packed 64-bit integer elements located in a and stores them in; /// memory locations starting at location \a base_addr at packed 32-bit integer; /// indices stored in \a vindex scaled by scale using writemask \a mask (elements; /// whose corresponding mask bit is not set are not written to memory).; ///; /// This intrinsic corresponds to the <c> VPSCATTERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// MEM[addr+63:addr] := a[i+63:i]; /// FI; /// ENDFOR; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:225,mask,mask,225,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,3,['mask'],['mask']
Availability,/// Stores 8 packed double-precision (64-bit) floating-point elements in \a v1; /// to memory locations starting at location \a base_addr at packed 32-bit; /// integer indices stored in \a vindex scaled by \a scale. Only those elements; /// whose corresponding mask bit is set in writemask \a mask are written to; /// memory.; ///; /// This intrinsic corresponds to the <c> VSCATTERDPD </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// MEM[addr+63:addr] := a[i+63:i]; /// FI; /// ENDFOR; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:261,mask,mask,261,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,3,['mask'],['mask']
Availability,/// Stores availability attributes of a symbol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/AvailabilityInfo.h:11,avail,availability,11,interpreter/llvm-project/clang/include/clang/ExtractAPI/AvailabilityInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/AvailabilityInfo.h,1,['avail'],['availability']
Availability,"/// Stores information about the 'fromPtr' symbol after reallocation.; ///; /// This is important because realloc may fail, and that needs special modeling.; /// Whether reallocation failed or not will not be known until later, so we'll; /// store whether upon failure 'fromPtr' will be freed, or needs to be freed; /// later, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:261,failure,failure,261,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['failure'],['failure']
Availability,"/// Stores text passed to the transformation methods to keep the string; /// ""alive"". Since the vast majority of text will be the same, we also unique; /// the strings using a StringMap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:78,alive,alive,78,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,2,['alive'],['alive']
Availability,/// Stores the extra dependencies between symbols: the data should be kept; /// alive as long as the key is live.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h:80,alive,alive,80,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,1,['alive'],['alive']
Availability,/// Struct representing the available call values in the scoped hash; /// table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['avail'],['available']
Availability,/// Struct representing the available values in the scoped hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['avail'],['available']
Availability,"/// Struct to store and manipulate GCC versions.; ///; /// We rely on assumptions about the form and structure of GCC version; /// numbers: they consist of at most three '.'-separated components, and each; /// component is a non-negative integer except for the last component. For; /// the last component we are very flexible in order to tolerate release; /// candidates or 'x' wildcards.; ///; /// Note that the ordering established among GCCVersions is based on the; /// preferred version string to use. For example we prefer versions without; /// a hard-coded patch number to those with a hard coded patch number.; ///; /// Currently this doesn't provide any logic for textual suffixes to patches; /// in the way that (for example) Debian's version format does. If that ever; /// becomes necessary, it can be added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:338,toler,tolerate,338,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,1,['toler'],['tolerate']
Availability,/// Struct used to represent the placement of a repairing point for; /// a given operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:48,repair,repairing,48,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,1,['repair'],['repairing']
Availability,"/// Structure with information about how a bitfield should be accessed.; ///; /// Often we layout a sequence of bitfields as a contiguous sequence of bits.; /// When the AST record layout does this, we represent it in the LLVM IR's type; /// as either a sequence of i8 members or a byte array to reserve the number of; /// bytes touched without forcing any particular alignment beyond the basic; /// character alignment.; ///; /// Then accessing a particular bitfield involves converting this byte array; /// into a single integer of that size (i24 or i40 -- may not be power-of-two; /// size), loading it, and shifting and masking to extract the particular; /// subsequence of bits which make up that particular bitfield. This structure; /// encodes the information used to construct the extraction code sequences.; /// The CGRecordLayout also has a field index which encodes which byte-sequence; /// this bitfield falls within. Let's assume the following C struct:; ///; /// struct S {; /// char a, b, c;; /// unsigned bits : 3;; /// unsigned more_bits : 4;; /// unsigned still_more_bits : 7;; /// };; ///; /// This will end up as the following LLVM type. The first array is the; /// bitfield, and the second is the padding out to a 4-byte alignment.; ///; /// %t = type { i8, i8, i8, i8, i8, [3 x i8] }; ///; /// When generating code to access more_bits, we'll generate something; /// essentially like this:; ///; /// define i32 @foo(%t* %base) {; /// %0 = gep %t* %base, i32 0, i32 3; /// %2 = load i8* %1; /// %3 = lshr i8 %2, 3; /// %4 = and i8 %3, 15; /// %5 = zext i8 %4 to i32; /// ret i32 %i; /// }; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayout.h:624,mask,masking,624,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayout.h,1,['mask'],['masking']
Availability,"/// Sub reg indexes for getRegSplitParts.; /// First index represents subreg size from 1 to 16 DWORDs.; /// The inner vector is sorted by bit offset.; /// Provided a register can be fully split with given subregs,; /// all elements of the inner vector combined give a full lane mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.h:278,mask,mask,278,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.h,1,['mask'],['mask']
Availability,/// Subclass of Error for the sole purpose of identifying the success path in; /// the type system. This allows to catch invalid conversion to Expected<T> at; /// compile time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:16,Error,Error,16,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['Error']
Availability,/// Subclasses \c clang::FixItRewriter to not count fixed errors/warnings; /// in the final error counts.; ///; /// This has the side-effect that clang-check -fixit exits with code 0 on; /// successfully fixing all errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp:58,error,errors,58,interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-check/ClangCheck.cpp,3,['error'],"['error', 'errors']"
Availability,"/// Subclasses of GCStrategy are made available for use during compilation by; /// adding them to the global GCRegistry. This can done either within the; /// LLVM source tree or via a loadable plugin. An example registeration; /// would be:; /// static GCRegistry::Add<CustomGC> X(""custom-name"",; /// ""my custom supper fancy gc strategy"");; ///; /// Note that to use a custom GCMetadataPrinter, you must also; /// register your GCMetadataPrinter subclass with the; /// GCMetadataPrinterRegistery as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GCStrategy.h:38,avail,available,38,interpreter/llvm-project/llvm/include/llvm/IR/GCStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GCStrategy.h,1,['avail'],['available']
Availability,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:26,avail,available,26,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,1,['avail'],['available']
Availability,"/// Substitute template arguments into the default template argument for; /// the given non-type template parameter.; ///; /// \param SemaRef the semantic analysis object for which we are performing; /// the substitution.; ///; /// \param Template the template that we are synthesizing template arguments; /// for.; ///; /// \param TemplateLoc the location of the template name that started the; /// template-id we are checking.; ///; /// \param RAngleLoc the location of the right angle bracket ('>') that; /// terminates the template-id.; ///; /// \param Param the non-type template parameter whose default we are; /// substituting into.; ///; /// \param Converted the list of template arguments provided for template; /// parameters that precede \p Param in the template parameter list.; ///; /// \returns the substituted template argument, or NULL if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:858,error,error,858,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['error'],['error']
Availability,"/// Substitute template arguments into the default template argument for; /// the given template template parameter.; ///; /// \param SemaRef the semantic analysis object for which we are performing; /// the substitution.; ///; /// \param Template the template that we are synthesizing template arguments; /// for.; ///; /// \param TemplateLoc the location of the template name that started the; /// template-id we are checking.; ///; /// \param RAngleLoc the location of the right angle bracket ('>') that; /// terminates the template-id.; ///; /// \param Param the template template parameter whose default we are; /// substituting into.; ///; /// \param Converted the list of template arguments provided for template; /// parameters that precede \p Param in the template parameter list.; ///; /// \param QualifierLoc Will be set to the nested-name-specifier (with; /// source-location information) that precedes the template name.; ///; /// \returns the substituted template argument, or NULL if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:1002,error,error,1002,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['error'],['error']
Availability,"/// Substitute template arguments into the default template argument for; /// the given template type parameter.; ///; /// \param SemaRef the semantic analysis object for which we are performing; /// the substitution.; ///; /// \param Template the template that we are synthesizing template arguments; /// for.; ///; /// \param TemplateLoc the location of the template name that started the; /// template-id we are checking.; ///; /// \param RAngleLoc the location of the right angle bracket ('>') that; /// terminates the template-id.; ///; /// \param Param the template template parameter whose default we are; /// substituting into.; ///; /// \param Converted the list of template arguments provided for template; /// parameters that precede \p Param in the template parameter list.; /// \returns the substituted template argument, or NULL if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:849,error,error,849,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['error'],['error']
Availability,"/// Substitute the explicitly-provided template arguments into the; /// given function template according to C++ [temp.arg.explicit].; ///; /// \param FunctionTemplate the function template into which the explicit; /// template arguments will be substituted.; ///; /// \param ExplicitTemplateArgs the explicitly-specified template; /// arguments.; ///; /// \param Deduced the deduced template arguments, which will be populated; /// with the converted and checked explicit template arguments.; ///; /// \param ParamTypes will be populated with the instantiated function; /// parameters.; ///; /// \param FunctionType if non-NULL, the result type of the function template; /// will also be instantiated and the pointed-to value will be updated with; /// the instantiated function type.; ///; /// \param Info if substitution fails for any reason, this object will be; /// populated with more information about the failure.; ///; /// \returns TDK_Success if substitution was successful, or some failure; /// condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:912,failure,failure,912,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,2,['failure'],['failure']
Availability,"/// Substitute the given template arguments into a list of; /// expressions, expanding pack expansions if required.; ///; /// \param Exprs The list of expressions to substitute into.; ///; /// \param IsCall Whether this is some form of call, in which case; /// default arguments will be dropped.; ///; /// \param TemplateArgs The set of template arguments to substitute.; ///; /// \param Outputs Will receive all of the substituted arguments.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:473,error,error,473,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,/// Substitution of the deduced template argument values; /// resulted in an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:77,error,error,77,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// Subtract two APFloats, rounding ties to the nearest even.; /// No error checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:70,error,error,70,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,1,['error'],['error']
Availability,"/// Support class for static dtor execution. For hosted (in-process) JITs; /// only!; ///; /// If a __cxa_atexit function isn't found C++ programs that use static; /// destructors will fail to link. However, we don't want to use the host; /// process's __cxa_atexit, because it will schedule JIT'd destructors to run; /// after the JIT has been torn down, which is no good. This class makes it easy; /// to override __cxa_atexit (and the related __dso_handle).; ///; /// To use, clients should manually call searchOverrides from their symbol; /// resolver. This should generally be done after attempting symbol resolution; /// inside the JIT, but before searching the host process's symbol table. When; /// the client determines that destructors should be run (generally at JIT; /// teardown or after a return from main), the runDestructors method should be; /// called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h:350,down,down,350,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,1,['down'],['down']
Availability,"/// Support for printing to std::ostream, for use with e.g. producing more; /// useful error messages with Google Test.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Testing/ADT/StringMap.h:87,error,error,87,interpreter/llvm-project/llvm/include/llvm/Testing/ADT/StringMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Testing/ADT/StringMap.h,1,['error'],['error']
Availability,/// Swap the operands and adjust the mask to preserve the semantics; /// of the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:37,mask,mask,37,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['mask'],['mask']
Availability,/// Swaps the values of N1 and N2. Swaps all indices in the shuffle mask M that; /// point at N1 to point at N2 and indices that point at N2 to point at N1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:68,mask,mask,68,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['mask']
Availability,/// Switch over the LLT on the specified instruction operand; /// - InsnID(ULEB128) - Instruction ID; /// - OpIdx(ULEB128) - Operand index; /// - LowerBound(2) - numerically minimum Type ID supported; /// - UpperBound(2) - numerically maximum + 1 Type ID supported; /// - Default(4) - failure jump target; /// - JumpTable(4)... - (UpperBound - LowerBound) (at least 2) jump targets,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h:285,failure,failure,285,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,1,['failure'],['failure']
Availability,/// Switch over the opcode on the specified instruction; /// - InsnID(ULEB128) - Instruction ID; /// - LowerBound(2) - numerically minimum opcode supported; /// - UpperBound(2) - numerically maximum + 1 opcode supported; /// - Default(4) - failure jump target; /// - JumpTable(4)... - (UpperBound - LowerBound) (at least 2) jump targets,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h:240,failure,failure,240,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,1,['failure'],['failure']
Availability,"/// Switches the message service to a different level while the instance is alive.; /// Can also temporarily activate / deactivate message topics.; /// Use as; /// ~~~{.cpp}; /// RooHelpers::LocalChangeMsgLevel changeMsgLvl(RooFit::WARNING);; /// [ statements that normally generate a lot of output ]; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooHelpers.h:76,alive,alive,76,roofit/roofitcore/inc/RooHelpers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooHelpers.h,1,['alive'],['alive']
Availability,/// SymbolMetadata - Represents path-dependent metadata about a specific region.; /// Metadata symbols remain live as long as they are marked as in use before; /// dead-symbol sweeping AND their associated regions are still alive.; /// Intended for use by checkers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h:224,alive,alive,224,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,1,['alive'],['alive']
Availability,"/// TLS_LOCAL_EXEC_MAT_ADDR = Materialize an address for TLS global address; /// when using local exec access models, and when prefixed instructions are; /// available. This is used with ADD_TLS to produce an add like PADDI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:158,avail,available,158,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['avail'],['available']
Availability,"/// Tagged union holding either a T or a Error.; ///; /// This class parallels ErrorOr, but replaces error_code with Error. Since; /// Error cannot be copied, this class replaces getError() with; /// takeError(). It also adds an bool errorIsA<ErrT>() method for testing the; /// error class type.; ///; /// Example usage of 'Expected<T>' as a function return type:; ///; /// @code{.cpp}; /// Expected<int> myDivide(int A, int B) {; /// if (B == 0) {; /// // return an Error; /// return createStringError(inconvertibleErrorCode(),; /// ""B must not be zero!"");; /// }; /// // return an integer; /// return A / B;; /// }; /// @endcode; ///; /// Checking the results of to a function returning 'Expected<T>':; /// @code{.cpp}; /// if (auto E = Result.takeError()) {; /// // We must consume the error. Typically one of:; /// // - return the error to our caller; /// // - toString(), when logging; /// // - consumeError(), to silently swallow the error; /// // - handleErrors(), to distinguish error types; /// errs() << ""Problem with division "" << toString(std::move(E)) << ""\n"";; /// return;; /// }; /// // use the result; /// outs() << ""The answer is "" << *Result << ""\n"";; /// @endcode; ///; /// For unit-testing a function returning an 'Expected<T>', see the; /// 'EXPECT_THAT_EXPECTED' macros in llvm/Testing/Support/Error.h",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:41,Error,Error,41,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,12,"['Error', 'error']","['Error', 'ErrorOr', 'error', 'errorIsA']"
Availability,/// Take an optional DWARFFormValue and extract a address.; ///; /// \param V and optional DWARFFormValue to attempt to extract the value from.; /// \param Default the default value to return in case of failure.; /// \returns the extracted address value or Default if the V doesn't have a; /// value or the form value's encoding wasn't an address form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h:203,failure,failure,203,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h,1,['failure'],['failure']
Availability,/// Take an optional DWARFFormValue and extract a reference.; ///; /// \param V and optional DWARFFormValue to attempt to extract the value from.; /// \param Default the default value to return in case of failure.; /// \returns the extracted reference value or Default if the V doesn't have a; /// value or the form value's encoding wasn't a reference form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h:205,failure,failure,205,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h,1,['failure'],['failure']
Availability,/// Take an optional DWARFFormValue and extract a section offset.; ///; /// \param V and optional DWARFFormValue to attempt to extract the value from.; /// \param Default the default value to return in case of failure.; /// \returns the extracted section offset value or Default if the V doesn't; /// have a value or the form value's encoding wasn't a section offset form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h:210,failure,failure,210,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h,1,['failure'],['failure']
Availability,/// Take an optional DWARFFormValue and extract a signed integer.; ///; /// \param V and optional DWARFFormValue to attempt to extract the value from.; /// \param Default the default value to return in case of failure.; /// \returns the extracted signed integer value or Default if the V doesn't; /// have a value or the form value's encoding wasn't a signed integer form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h:210,failure,failure,210,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h,1,['failure'],['failure']
Availability,/// Take an optional DWARFFormValue and extract a string value from it.; ///; /// \param V and optional DWARFFormValue to attempt to extract the value from.; /// \param Default the default value to return in case of failure.; /// \returns the string value or Default if the V doesn't have a value or the; /// form value's encoding wasn't a string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h:216,failure,failure,216,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h,1,['failure'],['failure']
Availability,/// Take an optional DWARFFormValue and extract a unsigned constant.; ///; /// \param V and optional DWARFFormValue to attempt to extract the value from.; /// \param Default the default value to return in case of failure.; /// \returns the extracted unsigned value or Default if the V doesn't have a; /// value or the form value's encoding wasn't an unsigned constant form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h:213,failure,failure,213,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFFormValue.h,1,['failure'],['failure']
Availability,/// Take ownership of the stored error.; /// After calling this the Expected<T> is in an indeterminate state that can; /// only be safely destructed. No further calls (beside the destructor) should; /// be made on the Expected<T> value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:33,error,error,33,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['error'],['error']
Availability,"/// Take the generated LLVM module, for use after the action has been run.; /// The result may be null on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenAction.h:106,failure,failure,106,interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenAction.h,1,['failure'],['failure']
Availability,"/// Take the specified pass list and create different combinations of passes; /// to compile the program with. Compile the program with each set and mark; /// test to see if it compiled correctly. If the passes compiled correctly; /// output nothing and rearrange the passes into a new order. If the passes; /// did not compile correctly, output the command required to recreate the; /// failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:388,failure,failure,388,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,1,['failure'],['failure']
Availability,/// Target the specified CPU.; ///; /// \return False on error (invalid CPU name).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:57,error,error,57,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['error'],['error']
Availability,"/// Targets can use this to indicate that they only support *some*; /// VECTOR_SHUFFLE operations, those with specific masks. By default, if a; /// target supports the VECTOR_SHUFFLE node, all mask values are assumed to be; /// legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:119,mask,masks,119,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['mask'],"['mask', 'masks']"
Availability,"/// Targets can use this to indicate that they only support *some*; /// VECTOR_SHUFFLE operations, those with specific masks. By default, if a; /// target supports the VECTOR_SHUFFLE node, all mask values are assumed to; /// be legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:119,mask,masks,119,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,2,['mask'],"['mask', 'masks']"
Availability,"/// Targets can use this to indicate that they only support *some*; /// VECTOR_SHUFFLE operations, those with specific masks.; /// By default, if a target supports the VECTOR_SHUFFLE node, all mask values; /// are assumed to be legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:119,mask,masks,119,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masks']"
Availability,"/// Tells if the field describes a user-defined class rather than a fundamental type, a collection, or one of the; /// natively supported stdlib classes.; /// The dictionary does not need to be available for this method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:194,avail,available,194,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,1,['avail'],['available']
Availability,"/// TemplateSpecCandidate - This is a generalization of OverloadCandidate; /// which keeps track of template argument deduction failure info, when; /// handling explicit specializations (and instantiations) of templates; /// beyond function overloading.; /// For now, assume that the candidates are non-matching specializations.; /// TODO: In the future, we may need to unify/generalize this with; /// OverloadCandidate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:128,failure,failure,128,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,"/// Ternary decode status. Most backends will just use Fail and; /// Success, however some have a concept of an instruction with; /// understandable semantics but which is architecturally; /// incorrect. An example of this is ARM UNPREDICTABLE instructions; /// which are disassemblable but cause undefined behaviour.; ///; /// Because it makes sense to disassemble these instructions, there; /// is a ""soft fail"" failure mode that indicates the MCInst& is; /// valid but architecturally incorrect.; ///; /// The enum numbers are deliberately chosen such that reduction; /// from Success->SoftFail ->Fail can be done with a simple; /// bitwise-AND:; ///; /// LEFT & TOP = | Success Unpredictable Fail; /// --------------+-----------------------------------; /// Success | Success Unpredictable Fail; /// Unpredictable | Unpredictable Unpredictable Fail; /// Fail | Fail Fail Fail; ///; /// An easy way of encoding this is as 0b11, 0b01, 0b00 for; /// Success, SoftFail, Fail respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCDisassembler.h:414,failure,failure,414,interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCDisassembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCDisassembler.h,1,['failure'],['failure']
Availability,"/// Test compilation failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/test/testTypedIteration.cxx:21,failure,failure,21,core/cont/test/testTypedIteration.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/test/testTypedIteration.cxx,1,['failure'],['failure']
Availability,"/// Test if \p LI is live across any register mask instructions, and; /// compute a bit mask of physical registers that are not clobbered by any; /// of them.; ///; /// Returns false if \p LI doesn't cross any register mask instructions. In; /// that case, the bit vector is not filled in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:46,mask,mask,46,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,3,['mask'],['mask']
Availability,"/// Test the availability of \a length bytes of data from \a offset.; ///; /// @return; /// \b true if \a offset is a valid offset and there are \a; /// length bytes available at that offset, \b false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:13,avail,availability,13,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['avail'],"['availability', 'available']"
Availability,"/// Test the availability of enough bytes of data for a pointer from; /// \a offset. The size of a pointer is \a getAddressSize().; ///; /// @return; /// \b true if \a offset is a valid offset and there are enough; /// bytes for a pointer available at that offset, \b false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:13,avail,availability,13,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,2,['avail'],"['availability', 'available']"
Availability,/// Test whether a shuffle mask is equivalent within each 128-bit lane.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,/// Test whether a shuffle mask is equivalent within each 256-bit lane.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"/// Test whether a shuffle mask is equivalent within each sub-lane.; ///; /// This checks a shuffle mask to see if it is performing the same; /// lane-relative shuffle in each sub-lane. This trivially implies; /// that it is also not lane-crossing. It may however involve a blend from the; /// same lane of a second vector.; ///; /// The specific repeated shuffle mask is populated in \p RepeatedMask, as it is; /// non-trivial to compute in the face of undef lanes. The representation is; /// suitable for use with existing 128-bit shuffles as entries from the second; /// vector have been remapped to [LaneSize, 2*LaneSize).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['mask'],['mask']
Availability,/// Test whether a target shuffle mask is equivalent within each sub-lane.; /// Unlike isRepeatedShuffleMask we must respect SM_SentinelZero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,/// Test whether elements in each LaneSizeInBits lane in this shuffle mask come; /// from multiple lanes - this is different to isLaneCrossingShuffleMask to; /// better support 'repeated mask + lane permute' style shuffles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:70,mask,mask,70,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,/// Test whether the specified input (0 or 1) is in-place blended by the; /// given mask.; ///; /// This returns true if the elements from a particular input are already in the; /// slot required by the given mask and require no permutation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:84,mask,mask,84,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,/// Test whether there are elements crossing 128-bit lanes in this; /// shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:80,mask,mask,80,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,/// Test whether there are elements crossing LaneSizeInBits lanes in this; /// shuffle mask.; ///; /// X86 divides up its shuffles into in-lane and cross-lane shuffle operations; /// and we routinely test for these.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:87,mask,mask,87,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,/// Tests if the function is both available and a candidate for optimized code; /// generation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:34,avail,available,34,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,1,['avail'],['available']
Availability,/// Tests whether a library function is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:40,avail,available,40,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,1,['avail'],['available']
Availability,"/// The ""async continuation"" lowering, where each suspend point creates a; /// single continuation function. The continuation function is available as an; /// intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:138,avail,available,138,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,1,['avail'],['available']
Availability,"/// The ( starting an argument list of a macro definition has just been read.; /// Lex the rest of the parameters and the closing ), updating \p MI with; /// what we learn and saving in \p LastTok the last token read.; /// Return true if an error occurs parsing the arg list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:241,error,error,241,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['error'],['error']
Availability,/// The 12-bit (potentially shifted) offset of the target within its page.; ///; /// Typically used to fix up LDR immediates.; ///; /// Fixup expression:; ///; /// Fixup <- ((Target + Addend) >> Shift) & 0xfff : uint12; ///; /// where Shift is encoded in the size field of the instruction.; ///; /// Errors:; /// - The result of the unshifted part of the fixup expression must be; /// aligned otherwise an alignment error will be returned.; /// - The result of the fixup expression must fit into a uint12 otherwise an; /// out-of-range error will be returned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h:300,Error,Errors,300,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h,3,"['Error', 'error']","['Errors', 'error']"
Availability,"/// The API notes manager helps find API notes associated with declarations.; ///; /// API notes are externally-provided annotations for declarations that can; /// introduce new attributes (covering availability, nullability of; /// parameters/results, and so on) for specific declarations without directly; /// modifying the headers that contain those declarations.; ///; /// The API notes manager is responsible for finding and loading the; /// external API notes files that correspond to a given header. Its primary; /// operation is \c findAPINotes(), which finds the API notes reader that; /// provides information about the declarations at that location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h:199,avail,availability,199,interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,1,['avail'],['availability']
Availability,/// The API to use for generating from the files at \p IgnoresFilePathList.; ///; /// \returns an initialized APIIgnoresList or an Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/APIIgnoresList.h:131,Error,Error,131,interpreter/llvm-project/clang/include/clang/ExtractAPI/APIIgnoresList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/APIIgnoresList.h,1,['Error'],['Error']
Availability,/// The AST file has errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:21,error,errors,21,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['error'],['errors']
Availability,"/// The Alignment, ContentSize and ZeroFillSize of each segment will be; /// pre-filled from the Graph. Clients must set the Addr and WorkingMem fields; /// prior to calling apply.; //; // FIXME: The C++98 initializer is an attempt to work around compile failures; // due to http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1397.; // We should be able to switch this back to member initialization once that; // issue is fixed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h:255,failure,failures,255,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,1,['failure'],['failures']
Availability,/// The Declaration of the function which could be called at runtime.; /// NULL if not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h:87,avail,available,87,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,1,['avail'],['available']
Availability,"/// The DirectoryWatcher that originated this event is no longer valid and; /// its behavior is unspecified.; ///; /// The prime case is kernel signalling to OS-specific implementation of; /// DirectoryWatcher some resource limit being hit.; /// *Usually* kernel starts dropping or squashing events together after; /// that and so would DirectoryWatcher. This means that *some* events; /// might still be passed to Receiver but this behavior is unspecified.; ///; /// Another case is after the watched directory itself is deleted.; /// WatcherGotInvalidated will be received at least once during; /// DirectoryWatcher instance lifetime - when handling errors this is done; /// on best effort basis, when an instance is being destroyed then this is; /// guaranteed.; ///; /// The only proper response to this kind of event is to destruct the; /// originating DirectoryWatcher instance and create a new one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h:652,error,errors,652,interpreter/llvm-project/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h,1,['error'],['errors']
Availability,/// The Error encountered during materialization. We use an Optional here to; /// avoid needing to manage an unconsumed success value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:8,Error,Error,8,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['Error'],['Error']
Availability,"/// The GlobalValue corresponding to this summary. This is only used in; /// per-module summaries and when the IR is available. E.g. when module; /// analysis is being run, or when parsing both the IR and the summary; /// from assembly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:117,avail,available,117,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['avail'],['available']
Availability,"/// The MVT::SimpleValueType for each parameter type. Note that this list is; /// only populated when in the context of a target .td file. When building; /// Intrinsics.td, this isn't available, because we don't know the target; /// pointer size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenIntrinsics.h:184,avail,available,184,interpreter/llvm-project/llvm/utils/TableGen/CodeGenIntrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenIntrinsics.h,1,['avail'],['available']
Availability,"/// The MVT::SimpleValueType for each return type. Note that this list is; /// only populated when in the context of a target .td file. When building; /// Intrinsics.td, this isn't available, because we don't know the target; /// pointer size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenIntrinsics.h:181,avail,available,181,interpreter/llvm-project/llvm/utils/TableGen/CodeGenIntrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenIntrinsics.h,1,['avail'],['available']
Availability,/// The NS error domain for this type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/Types.h:11,error,error,11,interpreter/llvm-project/clang/include/clang/APINotes/Types.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/Types.h,1,['error'],['error']
Availability,/// The OptimizationRemarkEmitter available for this compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:34,avail,available,34,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['avail'],['available']
Availability,/// The ScalableErrorAsWarning is a temporary measure to suppress errors from; /// using the wrong interface on a scalable vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/TypeSize.cpp:66,error,errors,66,interpreter/llvm-project/llvm/lib/Support/TypeSize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/TypeSize.cpp,1,['error'],['errors']
Availability,/// The TargetTransformInfo available for this compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['avail'],['available']
Availability,"/// The VE backend uses a two-staged process to lower and legalize vector; /// instructions:; //; /// 1. VP and standard vector SDNodes are lowered to SDNodes of the VVP_* layer.; //; // All VVP nodes have a mask and an Active Vector Length (AVL) parameter.; // The AVL parameters refers to the element position in the vector the VVP; // node operates on.; //; //; // 2. The VVP SDNodes are legalized. The AVL in a legal VVP node refers to; // chunks of 64bit. We track this by wrapping the AVL in a LEGALAVL node.; //; // The AVL mechanism in the VE architecture always refers to chunks of; // 64bit, regardless of the actual element type vector instructions are; // operating on. For vector types v256.32 or v256.64 nothing needs to be; // legalized since each element occupies a 64bit chunk - there is no; // difference between counting 64bit chunks or element positions. However,; // all vector types with > 256 elements store more than one logical element; // per 64bit chunk and need to be transformed.; // However legalization is performed, the resulting legal VVP SDNodes will; // have a LEGALAVL node as their AVL operand. The LEGALAVL nodes wraps; // around an AVL that refers to 64 bit chunks just as the architecture; // demands - that is, the wrapped AVL is the correct setting for the VL; // register for this VVP operation to get the desired behavior.; //; /// AVL Functions {; // The AVL operand position of this node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:208,mask,mask,208,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,1,['mask'],['mask']
Availability,"/// The XCore ABI includes a type information section that communicates symbol; /// type information to the linker. The linker uses this information to verify; /// safety/correctness of things such as array bound and pointers et al.; /// The ABI only requires C (and XC) language modules to emit TypeStrings.; /// This type information (TypeString) is emitted into meta data for all global; /// symbols: definitions, declarations, functions & variables.; ///; /// The TypeString carries type, qualifier, name, size & value details.; /// Please see 'Tools Development Guide' section 2.16.2 for format details:; /// https://www.xmos.com/download/public/Tools-Development-Guide%28X9114A%29.pdf; /// The output is tested by test/CodeGen/xcore-stringtype.c.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:635,down,download,635,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,1,['down'],['download']
Availability,"/// The \p MF_HUGE_HINT flag is used to indicate that the request for; /// a memory block should be satisfied with large pages if possible.; /// This is only a hint and small pages will be used as fallback.; ///; /// The presence or absence of this flag in the returned memory block; /// is (at least currently) *not* a reliable indicator that the memory; /// block will use or will not use large pages. On some systems a request; /// without this flag can be backed by large pages without this flag being; /// set, and on some other systems a request with this flag can fallback; /// to small pages without this flag being cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Memory.h:320,reliab,reliable,320,interpreter/llvm-project/llvm/include/llvm/Support/Memory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Memory.h,1,['reliab'],['reliable']
Availability,"/// The adaptor from a function pass to a loop pass computes these analyses and; /// makes them available to the loop passes ""for free"". Each loop pass is; /// expected to update these analyses if necessary to ensure they're; /// valid after it runs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:96,avail,available,96,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,1,['avail'],['available']
Availability,"/// The amount of stack space that Clang would like to be provided with.; /// If less than this much is available, we may be unable to reach our; /// template instantiation depth limit and other similar limits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Stack.h:104,avail,available,104,interpreter/llvm-project/clang/include/clang/Basic/Stack.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Stack.h,1,['avail'],['available']
Availability,"/// The argument is treated as potentially escaping, meaning that; /// even when its reference count hits 0 it should be treated as still; /// possibly being alive as someone else *may* be holding onto the object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h:158,alive,alive,158,interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h,1,['alive'],['alive']
Availability,/// The availability attribute for a specific platform was inferred from; /// an availability attribute for another platform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:8,avail,availability,8,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['avail'],['availability']
Availability,/// The availability attribute was applied using '#pragma clang attribute'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:8,avail,availability,8,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avail'],['availability']
Availability,/// The availability attribute was specified explicitly next to the; /// declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:8,avail,availability,8,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avail'],['availability']
Availability,/// The availability of this code-completion result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:8,avail,availability,8,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,2,['avail'],['availability']
Availability,/// The availability of this result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:8,avail,availability,8,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['avail'],['availability']
Availability,"/// The base class of CompilerInvocation. It keeps individual option objects; /// behind reference-counted pointers, which is useful for clients that want to; /// keep select option objects alive (even after CompilerInvocation gets; /// destroyed) without making a copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h:190,alive,alive,190,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,1,['alive'],['alive']
Availability,"/// The basic block for which we are generating the stack protector.; ///; /// As a result of stack protector generation, we will splice the; /// terminators of this basic block into the successor mbb SuccessMBB and; /// replace it with a compare/branch to the successor mbbs; /// SuccessMBB/FailureMBB depending on whether or not the stack protector; /// was violated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:292,Failure,FailureMBB,292,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,1,['Failure'],['FailureMBB']
Availability,/// The bit that flags that this function may read any global. This is; /// chosen to mix together with ModRefInfo bits.; /// FIXME: This assumes ModRefInfo lattice will remain 4 bits!; /// FunctionInfo.getModRefInfo() masks out everything except ModRef so; /// this remains correct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:219,mask,masks,219,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['mask'],['masks']
Availability,"/// The blend operation is a User of the incoming values and of their; /// respective masks, ordered [I0, M0, I1, M1, ...]. Note that a single value; /// might be incoming with a full mask for which there is no VPValue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:86,mask,masks,86,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,2,['mask'],"['mask', 'masks']"
Availability,"/// The callback used to produce a result.; ///; /// We use a completely opaque callback so that targets can provide whatever; /// mechanism they desire for constructing the TTI for a given function.; ///; /// FIXME: Should we really use std::function? It's relatively inefficient.; /// It might be possible to arrange for even stateful callbacks to outlive; /// the analysis and thus use a function_ref which would be lighter weight.; /// This may also be less error prone as the callback is likely to reference; /// the external TargetMachine, and that reference needs to never dangle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:462,error,error,462,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['error'],['error']
Availability,/// The client can't handle any AST loading failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:44,failure,failures,44,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['failure'],['failures']
Availability,"/// The control block was read successfully. Aside from failures,; /// the AST file is safe to read into the current context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:56,failure,failures,56,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['failure'],['failures']
Availability,"/// The conversion specifier and the argument type are compatible but still; /// seems likely to be an error. For instanace, ""%hhd"" and short.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/FormatString.h:103,error,error,103,interpreter/llvm-project/clang/include/clang/AST/FormatString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/FormatString.h,1,['error'],['error']
Availability,"/// The conversion specifier and the argument type are compatible, but still; /// seems likely to be an error. For instance, ""%hd"" and _Bool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/FormatString.h:104,error,error,104,interpreter/llvm-project/clang/include/clang/AST/FormatString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/FormatString.h,1,['error'],['error']
Availability,"/// The copy ctor does not allow copies where source object has either; /// a non-NULL Buffer or SourceLineCache. Ownership of allocated memory; /// is not transferred, so this is a logical error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:190,error,error,190,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['error'],['error']
Availability,/// The declaration if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:23,avail,available,23,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['avail'],['available']
Availability,"/// The default error handler function. It prints the message on stderr and; /// if abort is set it aborts the application. Replaces the minimal error handler; /// of TError.h as part of the gROOT construction. TError's minimal handler is put; /// back in place during the gROOT destruction.; /// @note `abort()` is only called if `abort_bool` is `true` and `level < gErrorIgnoreLevel`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx:16,error,error,16,core/base/src/TErrorDefaultHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx,2,['error'],['error']
Availability,"/// The default llvm calling convention, compatible with C. This convention; /// is the only one that supports varargs calls. As with typical C calling; /// conventions, the callee/caller have to tolerate certain amounts of; /// prototype mismatch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h:196,toler,tolerate,196,interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,1,['toler'],['tolerate']
Availability,/// The depth of the context stack at the point when the most recent; /// error or warning was produced.; ///; /// This value is used to suppress printing of redundant context stacks; /// when there are multiple errors or warnings in the same instantiation.; // FIXME: Does this belong in Sema? It's tough to implement it anywhere else.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:74,error,error,74,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,3,"['error', 'redundant']","['error', 'errors', 'redundant']"
Availability,/// The diagnostic client that performs the actual formatting; /// of error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h:70,error,error,70,interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,1,['error'],['error']
Availability,"/// The diagnostic is an access-control diagnostic, which will be; /// substitution failures in some contexts and reported in others.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h:84,failure,failures,84,interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,1,['failure'],['failures']
Availability,"/// The diagnostic should be reported.; ///; /// The diagnostic should be reported. Various fatal errors (e.g.,; /// template instantiation depth exceeded) fall into this category.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h:98,error,errors,98,interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,1,['error'],['errors']
Availability,"/// The diagnostic should not be reported, but it should cause; /// template argument deduction to fail.; ///; /// The vast majority of errors that occur during template argument; /// deduction fall into this category.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h:136,error,errors,136,interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,1,['error'],['errors']
Availability,"/// The diagnostic state for the parent file. This is strictly redundant,; /// as looking up the DecomposedIncludedLoc for the FileID in the Files; /// map would give us this, but we cache it here for performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:63,redundant,redundant,63,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['redundant'],['redundant']
Availability,"/// The diagnostic we should emit for \c D, and the declaration that; /// originated it, or \c AR_Available.; ///; /// \param D The declaration to check.; /// \param Message If non-null, this will be populated with the message from; /// the availability attribute that is selected.; /// \param ClassReceiver If we're checking the method of a class message; /// send, the class. Otherwise nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:241,avail,availability,241,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['availability']
Availability,/// The domain for which this availability info item applies,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/AvailabilityInfo.h:30,avail,availability,30,interpreter/llvm-project/clang/include/clang/ExtractAPI/AvailabilityInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/AvailabilityInfo.h,1,['avail'],['availability']
Availability,"/// The error on the ""confidence level"" of the alternative hypothesis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HybridResult.h:8,error,error,8,roofit/roostats/inc/RooStats/HybridResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HybridResult.h,2,['error'],['error']
Availability,"/// The error on the ""confidence level"" of the null hypothesis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HybridResult.h:8,error,error,8,roofit/roostats/inc/RooStats/HybridResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HybridResult.h,2,['error'],['error']
Availability,"/// The error on the Null p-value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestResult.h:8,error,error,8,roofit/roostats/inc/RooStats/HypoTestResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestResult.h,1,['error'],['error']
Availability,"/// The error on the ratio \f$CL_{s+b}/CL_{b}\f$",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HybridResult.h:8,error,error,8,roofit/roostats/inc/RooStats/HybridResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HybridResult.h,2,['error'],['error']
Availability,"/// The error on the significance, computed from NullPValueError via error propagation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestResult.h:8,error,error,8,roofit/roostats/inc/RooStats/HypoTestResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestResult.h,2,['error'],['error']
Availability,/// The fast qualifier mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:23,mask,mask,23,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['mask'],['mask']
Availability,"/// The file does not contain base relocations and must be loaded at its; /// preferred base. If this cannot be done, the loader will error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:134,error,error,134,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,1,['error'],['error']
Availability,/// The file name of the log file from the environment variable; /// AS_SECURE_LOG_FILE. Which must be set before the .secure_log_unique; /// directive is used or it is an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h:172,error,error,172,interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,1,['error'],['error']
Availability,"/// The first template argument to which the template; /// argument deduction failure refers.; ///; /// Depending on the result of the template argument deduction,; /// this template argument may have different meanings:; ///; /// TDK_IncompletePack: this is the number of arguments we deduced; /// for the pack.; ///; /// TDK_Inconsistent: this argument is the first value deduced; /// for the corresponding template parameter.; ///; /// TDK_SubstitutionFailure: this argument is the template; /// argument we were instantiating when we encountered an error.; ///; /// TDK_DeducedMismatch: this is the parameter type, after substituting; /// deduced arguments.; ///; /// TDK_NonDeducedMismatch: this is the component of the 'parameter'; /// of the deduction, directly provided in the source code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:78,failure,failure,78,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// The following stacks are used with dataTraverseStmtPre() and; /// dataTraverseStmtPost() to track the depth of nested logical operators in a; /// boolean expression in a function. The ultimate purpose is to keep track; /// of the number of leaf-level conditions in the boolean expression so that a; /// profile bitmap can be allocated based on that number.; ///; /// The stacks are also used to find error cases and notify the user. A; /// standard logical operator nest for a boolean expression could be in a form; /// similar to this: ""x = a && b && c && (d || f)""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:404,error,error,404,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,1,['error'],['error']
Availability,"/// The function definitions which were renamed as part of typo-correction; /// to match their respective declarations. We want to keep track of them; /// to ensure that we don't emit a ""redefinition"" error if we encounter a; /// correctly named definition after the renamed definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:201,error,error,201,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// The function is a secondary interface to the LLVM Assembly Parser. It parses; /// an ASCII string that (presumably) contains LLVM Assembly code for a module; /// summary. It returns a a ModuleSummaryIndex with the corresponding features.; /// Note that this does not verify that the generated Index is valid, so you; /// should run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a string; /// \param AsmString The string containing assembly; /// \param Err Error result info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:506,Error,Error,506,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,1,['Error'],['Error']
Availability,"/// The function is a secondary interface to the LLVM Assembly Parser. It parses; /// an ASCII string that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a string; /// \param AsmString The string containing assembly; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:502,Error,Error,502,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,1,['Error'],['Error']
Availability,"/// The function looks for the following string at the beginning of; /// the input string `ParseString`:; ///; /// <token> <number>; ///; /// <token> is one of ""ls"", ""Rs"", ""Us"" or ""Ls"".; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `StepOrPos` to; /// <number>, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:378,error,error,378,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,2,['error'],['error']
Availability,"/// The function looks for the following strings at the beginning of; /// the input string `ParseString`:; ///; /// <token> <number>; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `Pos` to; /// <number>, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.; ///; /// The function expects <token> to be one of ""ls"", ""Rs"", ""Us"" or; /// ""Ls"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:319,error,error,319,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,2,['error'],['error']
Availability,"/// The function looks for the following strings at the beginning of; /// the input string `ParseString`:; ///; /// <token> {""n""} <number>; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `LinearStep` to; /// <number>, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.; ///; /// The function expects <token> to be one of ""l"", ""R"", ""U"" or; /// ""L"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:332,error,error,332,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,2,['error'],['error']
Availability,"/// The function looks for the following strings at the beginning of; /// the input string `ParseString`:; ///; /// [""l"" | ""R"" | ""U"" | ""L""] {""n""} <number>; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `LinearStep` to; /// <number>, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:348,error,error,348,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,2,['error'],['error']
Availability,"/// The function overload candidate, available when; /// Kind == CK_Function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:37,avail,available,37,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['avail'],['available']
Availability,"/// The function template overload candidate, available when; /// Kind == CK_FunctionTemplate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:46,avail,available,46,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['avail'],['available']
Availability,/// The function will lower a register of various sizes (8/16/32/64); /// to a mask value of the expected size (v8i1/v16i1/v32i1/v64i1); /// \returns a DAG node contains the operand after lowering to mask type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:79,mask,mask,79,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,2,['mask'],['mask']
Availability,/// The function will remove redundant reinterprets casting in the presence; /// of the control flow,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:29,redundant,redundant,29,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['redundant'],['redundant']
Availability,"/// The given lookup names class member(s) and is not being used for; /// an address-of-member expression. Classify the type of access; /// according to whether it's possible that this reference names an; /// instance member. This is best-effort in dependent contexts; it is okay to; /// conservatively answer ""yes"", in which case some errors will simply; /// not be caught until template-instantiation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:336,error,errors,336,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['error'],['errors']
Availability,"/// The global settings depend on a global variable named R__ZipMode which can be; /// modified by a global function named R__SetZipMode. Both are defined in Bits.h.; ///; /// - The default is to use the global setting and the default of the global; /// setting is to use the ZLIB compression algorithm.; /// - The LZMA algorithm (from the XZ package) is also available. The LZMA; /// compression usually results in greater compression factors, but takes; /// more CPU time and memory when compressing. LZMA memory usage is particularly; /// high for compression levels 8 and 9.; /// - Finally, the LZ4 package results in worse compression ratios; /// than ZLIB but achieves much faster decompression rates.; ///; /// The current algorithms support level 1 to 9. The higher the level the greater; /// the compression and more CPU time and memory resources used during compression.; /// Level 0 means no compression.; ///; /// Recommendation for the compression algorithm's levels:; /// - ZLIB is recommended to be used with compression level 1 [101]; /// - LZMA is recommended to be used with compression level 7-8 (higher is better,; /// since in the case of LZMA we don't care about compression/decompression speed); /// [207 - 208]; /// - LZ4 is recommended to be used with compression level 4 [404]; /// - ZSTD is recommended to be used with compression level 5 [505]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/inc/Compression.h:360,avail,available,360,core/zip/inc/Compression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/inc/Compression.h,1,['avail'],['available']
Availability,"/// The goal of this function is to remove redundant calls to the SVE ptrue; /// intrinsic in each basic block within the given functions.; ///; /// SVE ptrues have two representations in LLVM IR:; /// - a logical representation -- an arbitrary-width scalable vector of i1s,; /// i.e. <vscale x N x i1>.; /// - a physical representation (svbool, <vscale x 16 x i1>) -- a 16-element; /// scalable vector of i1s, i.e. <vscale x 16 x i1>.; ///; /// The SVE ptrue intrinsic is used to create a logical representation of an SVE; /// predicate. Suppose that we have two SVE ptrue intrinsic calls: P1 and P2. If; /// P1 creates a logical SVE predicate that is at least as wide as the logical; /// SVE predicate created by P2, then all of the bits that are true in the; /// physical representation of P2 are necessarily also true in the physical; /// representation of P1. P1 'encompasses' P2, therefore, the intrinsic call to; /// P2 is redundant and can be replaced by an SVE reinterpret of P1 via; /// convert.{to,from}.svbool.; ///; /// Currently, this pass only coalesces calls to SVE ptrue intrinsics; /// if they match the following conditions:; ///; /// - the call to the intrinsic uses either the SV_ALL or SV_POW2 patterns.; /// SV_ALL indicates that all bits of the predicate vector are to be set to; /// true. SV_POW2 indicates that all bits of the predicate vector up to the; /// largest power-of-two are to be set to true.; /// - the result of the call to the intrinsic is not promoted to a wider; /// predicate. In this case, keeping the extra ptrue leads to better codegen; /// -- coalescing here would create an irreducible chain of SVE reinterprets; /// via convert.{to,from}.svbool.; ///; /// EXAMPLE:; ///; /// %1 = <vscale x 8 x i1> ptrue(i32 SV_ALL); /// ; Logical: <1, 1, 1, 1, 1, 1, 1, 1>; /// ; Physical: <1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0>; /// ...; ///; /// %2 = <vscale x 4 x i1> ptrue(i32 SV_ALL); /// ; Logical: <1, 1, 1, 1>; /// ; Physical: <1, 0, 0, 0, 1, 0, 0, 0,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp:43,redundant,redundant,43,interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,2,['redundant'],['redundant']
Availability,"/// The grammar doesn't allow a defining-type-specifier here, but we permit; /// one for error recovery purposes. Sema will reject.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:89,error,error,89,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,2,"['error', 'recover']","['error', 'recovery']"
Availability,/// The incomplete type that caused a failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:38,failure,failure,38,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['failure'],['failure']
Availability,/// The index of the function argument that caused a deduction; /// failure.; ///; /// TDK_DeducedMismatch: this is the index of the argument that had a; /// different argument type from its substituted parameter type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:68,failure,failure,68,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,/// The kind of errors that can occur when emitting the offload entries and; /// metadata.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:16,error,errors,16,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['error'],['errors']
Availability,"/// The kind of location in use for a variable, where Mem is the stack home,; /// Val is an SSA value or const, and None means that there is not one single; /// kind (either because there are multiple or because there is none; it may; /// prove useful to split this into two values in the future).; ///; /// LocKind is a join-semilattice with the partial order:; /// None > Mem, Val; ///; /// i.e.; /// join(Mem, Mem) = Mem; /// join(Val, Val) = Val; /// join(Mem, Val) = None; /// join(None, Mem) = None; /// join(None, Val) = None; /// join(None, None) = None; ///; /// Note: the order is not `None > Val > Mem` because we're using DIAssignID; /// to name assignments and are not tracking the actual stored values.; /// Therefore currently there's no way to ensure that Mem values and Val; /// values are the same. This could be a future extension, though it's not; /// clear that many additional locations would be recovered that way in; /// practice as the likelihood of this sitation arising naturally seems; /// incredibly low.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:918,recover,recovered,918,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['recover'],['recovered']
Availability,"/// The kind of message send this is, which is one of the; /// ReceiverKind values.; ///; /// We pad this out to a byte to avoid excessive masking and shifting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:139,mask,masking,139,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,1,['mask'],['masking']
Availability,"/// The kind of template that Template refers to. If this is; /// TNK_Non_template, an error was encountered and diagnosed; /// when parsing or looking up the template name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedTemplate.h:87,error,error,87,interpreter/llvm-project/clang/include/clang/Sema/ParsedTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedTemplate.h,1,['error'],['error']
Availability,"/// The lane masks returned by getSubRegIndexLaneMask() above can only be; /// used to determine if sub-registers overlap - they can't be used to; /// determine if a set of sub-registers completely cover another; /// sub-register.; ///; /// The X86 general purpose registers have two lanes corresponding to the; /// sub_8bit and sub_8bit_hi sub-registers. Both sub_32bit and sub_16bit have; /// lane masks '3', but the sub_16bit sub-register doesn't fully cover the; /// sub_32bit sub-register.; ///; /// On the other hand, the ARM NEON lanes fully cover their registers: The; /// dsub_0 sub-register is completely covered by the ssub_0 and ssub_1 lanes.; /// This is related to the CoveredBySubRegs property on register definitions.; ///; /// This function returns a bit mask of lanes that completely cover their; /// sub-registers. More precisely, given:; ///; /// Covering = getCoveringLanes();; /// MaskA = getSubRegIndexLaneMask(SubA);; /// MaskB = getSubRegIndexLaneMask(SubB);; ///; /// If (MaskA & ~(MaskB & Covering)) == 0, then SubA is completely covered by; /// SubB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:13,mask,masks,13,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,7,"['Mask', 'mask']","['MaskA', 'MaskB', 'mask', 'masks']"
Availability,"/// The leaf of the bug path. This isn't the same as the bug reports error; /// node, which refers to the *original* graph, not the bug path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:69,error,error,69,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['error'],['error']
Availability,"/// The level of severity associated with a \ref SarifResult.; ///; /// Of all the levels, \c None is the only one that is not associated with; /// a failure.; ///; /// A typical mapping for clang's DiagnosticKind to SarifResultLevel would look; /// like:; /// * \c None: \ref clang::DiagnosticsEngine::Level::Remark, \ref clang::DiagnosticsEngine::Level::Ignored; /// * \c Note: \ref clang::DiagnosticsEngine::Level::Note; /// * \c Warning: \ref clang::DiagnosticsEngine::Level::Warning; /// * \c Error could be generated from one of:; /// - \ref clang::DiagnosticsEngine::Level::Warning with \c -Werror; /// - \ref clang::DiagnosticsEngine::Level::Error; /// - \ref clang::DiagnosticsEngine::Level::Fatal when \ref clang::DiagnosticsEngine::ErrorsAsFatal is set.; ///; /// Reference:; /// 1. <a href=""https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317648"">level property</a>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sarif.h:150,failure,failure,150,interpreter/llvm-project/clang/include/clang/Basic/Sarif.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sarif.h,4,"['Error', 'failure']","['Error', 'ErrorsAsFatal', 'failure']"
Availability,"/// The list of rules associated with the most recent active run. These are; /// defined using the diagnostics passed to the SarifDocument. Each rule; /// need not be unique through the result set. E.g. there may be several; /// 'syntax' errors throughout code under analysis, each of which has its; /// own specific diagnostic message (and consequently, RuleId). Rules are; /// also known as ""reportingDescriptor"" objects in SARIF.; ///; /// Reference: <a href=""https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317556"">rules property</a>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sarif.h:238,error,errors,238,interpreter/llvm-project/clang/include/clang/Basic/Sarif.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sarif.h,1,['error'],['errors']
Availability,/// The location and description of the current error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmLexer.h:48,error,error,48,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmLexer.h,1,['error'],['error']
Availability,/// The location of the 'unavailable' keyword in an; /// availability attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:57,avail,availability,57,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['avail'],['availability']
Availability,"/// The location of the closing brace ('}') that completes; /// the lambda.; ///; /// The location of the brace is also available by looking up the; /// function call operator in the lambda class. However, it is; /// stored here to improve the performance of getSourceRange(), and; /// to avoid having to deserialize the function call operator from a; /// module file just to determine the source range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:120,avail,available,120,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['avail'],['available']
Availability,"/// The location of the error related to fMessage plus upper frames if the error is forwarded through the call stack",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:24,error,error,24,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,2,['error'],['error']
Availability,/// The lookup resulted in an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:30,error,error,30,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,/// The maximum size for the cache directory in bytes. A value over the amount; /// of available space on the disk will be reduced to the amount of available; /// space. A value of 0 disables the absolute size-based pruning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:87,avail,available,87,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,2,['avail'],['available']
Availability,"/// The merger will abort merging as soon as an error is encountered",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx:48,error,error,48,tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,1,['error'],['error']
Availability,"/// The minimum hotness value a diagnostic needs in order to be included in; /// optimization diagnostics.; ///; /// The threshold is an Optional value, which maps to one of the 3 states:; /// 1). 0 => threshold disabled. All emarks will be printed.; /// 2). positive int => manual threshold by user. Remarks with hotness exceed; /// threshold will be printed.; /// 3). None => 'auto' threshold by user. The actual value is not; /// available at command line, but will be synced with; /// hotness threhold from profile summary during; /// compilation.; ///; /// State 1 and 2 are considered as terminal states. State transition is; /// only allowed from 3 to 2, when the threshold is first synced with profile; /// summary. This ensures that the threshold is set only once and stays; /// constant.; ///; /// If threshold option is not specified, it is disabled (0) by default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:433,avail,available,433,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,1,['avail'],['available']
Availability,"/// The minimum hotness value a diagnostic needs in order to be included in; /// optimization diagnostics.; ///; /// The threshold is an Optional value, which maps to one of the 3 states:; /// 1. 0 => threshold disabled. All emarks will be printed.; /// 2. positive int => manual threshold by user. Remarks with hotness exceed; /// threshold will be printed.; /// 3. None => 'auto' threshold by user. The actual value is not; /// available at command line, but will be synced with; /// hotness threhold from profile summary during; /// compilation.; ///; /// If threshold option is not specified, it is disabled by default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:430,avail,available,430,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['avail'],['available']
Availability,"/// The minimum hotness value a diagnostic needs in order to be included in; /// optimization diagnostics.; ///; /// The threshold is an Optional value, which maps to one of the 3 states:; /// 1. 0 => threshold disabled. All remarks will be printed.; /// 2. positive int => manual threshold by user. Remarks with hotness exceed; /// threshold will be printed.; /// 3. None => 'auto' threshold by user. The actual value is not; /// available at command line, but will be synced with; /// hotness threshold from profile summary during; /// compilation.; ///; /// If threshold option is not specified, it is disabled by default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:431,avail,available,431,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,1,['avail'],['available']
Availability,"/// The nested name specifier that qualifies the template name.; ///; /// The bit is used to indicate whether the ""template"" keyword was; /// present before the template name itself. Note that the; /// ""template"" keyword is always redundant in this case (otherwise,; /// the template name would be a dependent name and we would express; /// this name with DependentTemplateName).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h:231,redundant,redundant,231,interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,1,['redundant'],['redundant']
Availability,/// The next available displacement value. Incremented when new entries into; /// the ADA are created.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.h:13,avail,available,13,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.h,1,['avail'],['available']
Availability,/// The next available function index for use with our .cv_* directives. Not; /// to be confused with type indices for LF_FUNC_ID records.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:13,avail,available,13,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,1,['avail'],['available']
Availability,/// The next available integer to assign to a \p MachineInstr that can; /// be outlined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:13,avail,available,13,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,1,['avail'],['available']
Availability,/// The next available integer to assign to a \p MachineInstr that; /// cannot be outlined.; ///; /// Set to -3 for compatability with \p DenseMapInfo<unsigned>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:13,avail,available,13,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,1,['avail'],['available']
Availability,/// The next available integer to assign to a legal Instruction to.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:13,avail,available,13,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,1,['avail'],['available']
Availability,"/// The number of elements written resp. available in the column",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx:41,avail,available,41,tree/ntuple/v7/inc/ROOT/RColumn.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx,1,['avail'],['available']
Availability,"/// The number of free lists we want to be sure to support; /// inline. This is just enough that availability attributes; /// don't surpass it. It's actually very unlikely we'll see an; /// attribute that needs more than that; on x86-64 you'd need 10; /// expression arguments, and on i386 you'd need 19.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:97,avail,availability,97,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['avail'],['availability']
Availability,/// The number of rewriter failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h:27,failure,failures,27,interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,1,['failure'],['failures']
Availability,"/// The number of the RLogDiagCount's emitted errors at construction time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx:46,error,errors,46,core/foundation/inc/ROOT/RLogger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx,1,['error'],['errors']
Availability,"/// The number of the RLogDiagCount's emitted fatal errors at construction time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx:52,error,errors,52,core/foundation/inc/ROOT/RLogger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx,1,['error'],['errors']
Availability,"/// The number of warnings that occurred while parsing the preamble.; ///; /// This value will be used to restore the state of the \c DiagnosticsEngine; /// object when re-using the precompiled preamble. Note that only the; /// number of warnings matters, since we will not save the preamble; /// when any errors are present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:306,error,errors,306,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['error'],['errors']
Availability,/// The only differences between FABS and FNEG are the mask and the logic op.; /// FNEG also has a folding opportunity for FNEG(FABS(x)).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,/// The operand of a unary address-of operator has special rules: it's; /// allowed to refer to a non-static member of a class even if there's no 'this'; /// object available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:165,avail,available,165,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['avail'],['available']
Availability,/// The operand position of the vector mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:39,mask,mask,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,['mask'],['mask']
Availability,"/// The page into which new elements are being written. The page will initially be small; /// (just enough to hold RNTupleWriteOptions::fInitialNElementsPerPage elements) and expand as needed and; /// as memory for page buffers is still available (RNTupleWriteOptions::fPageBufferBudget) or the maximum page; /// size is reached (RNTupleWriteOptions::fMaxUnzippedPageSize).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx:237,avail,available,237,tree/ntuple/v7/inc/ROOT/RColumn.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx,1,['avail'],['available']
Availability,/// The parent vectors and shuffle mask for the given list of inserts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,"/// The parser has parsed a '__super' nested-name-specifier.; ///; /// \param SuperLoc The location of the '__super' keyword.; ///; /// \param ColonColonLoc The location of the '::'.; ///; /// \param SS The nested-name-specifier, which will be updated in-place; /// to reflect the parsed nested-name-specifier.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:341,error,error,341,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// The parser has parsed a global nested-name-specifier '::'.; ///; /// \param CCLoc The location of the '::'.; ///; /// \param SS The nested-name-specifier, which will be updated in-place; /// to reflect the parsed nested-name-specifier.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:270,error,error,270,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// The parser has parsed a nested-name-specifier 'identifier::'.; ///; /// \param S The scope in which this nested-name-specifier occurs.; ///; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; ///; /// \param EnteringContext Whether we're entering the context nominated by; /// this nested-name-specifier.; ///; /// \param SS The nested-name-specifier, which is both an input; /// parameter (the nested-name-specifier before this type) and an; /// output parameter (containing the full nested-name-specifier,; /// including this new type).; ///; /// \param IsCorrectedToColon If not null, suggestions to replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to 'true'; /// if the identifier is treated as if it was followed by ':', not '::'.; ///; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:921,error,error,921,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// The parser has parsed a nested-name-specifier; /// 'template[opt] template-name < template-args >::'.; ///; /// \param S The scope in which this nested-name-specifier occurs.; ///; /// \param SS The nested-name-specifier, which is both an input; /// parameter (the nested-name-specifier before this type) and an; /// output parameter (containing the full nested-name-specifier,; /// including this new type).; ///; /// \param TemplateKWLoc the location of the 'template' keyword, if any.; /// \param TemplateName the template name.; /// \param TemplateNameLoc The location of the template name.; /// \param LAngleLoc The location of the opening angle bracket ('<').; /// \param TemplateArgs The template arguments.; /// \param RAngleLoc The location of the closing angle bracket ('>').; /// \param CCLoc The location of the '::'.; ///; /// \param EnteringContext Whether we're entering the context of the; /// nested-name-specifier.; ///; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:972,error,error,972,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,/// The path down to the current base class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:13,down,down,13,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['down'],['down']
Availability,/// The percentage of difference between profiling branch weights and; /// llvm.expect branch weights to tolerate when emiting MisExpect diagnostics,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:105,toler,tolerate,105,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,1,['toler'],['tolerate']
Availability,/// The range that corresponds to ErrorNode's program point. It is usually; /// highlighted in the report.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h:34,Error,ErrorNode,34,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,1,['Error'],['ErrorNode']
Availability,"/// The result of parsing a file specified by TestInputs.; ///; /// The ASTContext, Sema etc are valid as long as this object is alive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:129,alive,alive,129,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,1,['alive'],['alive']
Availability,"/// The result of parsing/analyzing an expression, statement etc.; ///; /// It may be:; /// - usable: a valid pointer to the result object; /// - unset (null but valid): for constructs that may legitimately be absent; /// (for example, the condition of a for loop); /// - invalid: indicating an error; /// (no detail is provided, usually the error has already been diagnosed)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Ownership.h:295,error,error,295,interpreter/llvm-project/clang/include/clang/Sema/Ownership.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Ownership.h,2,['error'],['error']
Availability,/// The root is the trivial Path to the root value.; /// It also stores the latest reported error and the path where it occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:92,error,error,92,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['error'],['error']
Availability,"/// The second template argument to which the template; /// argument deduction failure refers.; ///; /// TDK_Inconsistent: this argument is the second value deduced; /// for the corresponding template parameter.; ///; /// TDK_DeducedMismatch: this is the (adjusted) call argument type.; ///; /// TDK_NonDeducedMismatch: this is the mismatching component of the; /// 'argument' of the deduction, from which we are deducing arguments.; ///; /// FIXME: Finish documenting this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:79,failure,failure,79,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,/// The set of available SUs to schedule next.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:15,avail,available,15,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['avail'],['available']
Availability,"/// The set of diagnostics produced when failing to parse, e.g. due; /// to failure to load the PCH.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:76,failure,failure,76,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['failure'],['failure']
Availability,"/// The set of language features required to use this module.; ///; /// If any of these requirements are not available, the \c IsAvailable bit; /// will be false to indicate that this (sub)module is not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h:109,avail,available,109,interpreter/llvm-project/clang/include/clang/Basic/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h,2,['avail'],['available']
Availability,/// The signed 20-bit delta from the fixup page to the page containing the; /// target.; ///; /// Fixup expression:; /// Fixup <- (((Target + Addend + ((Target + Addend) & 0x800)) & ~0xfff); // - (Fixup & ~0xfff)) >> 12 : int20; ///; /// Notes:; /// For PCALAU12I fixups.; ///; /// Errors:; /// - The result of the fixup expression must fit into an int20 otherwise an; /// out-of-range error will be returned.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/loongarch.h:282,Error,Errors,282,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/loongarch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/loongarch.h,2,"['Error', 'error']","['Errors', 'error']"
Availability,/// The signed 21-bit delta from the fixup page to the page containing the; /// target.; ///; /// Fixup expression:; ///; /// Fixup <- (((Target + Addend) & ~0xfff) - (Fixup & ~0xfff)) >> 12 : int21; ///; /// Notes:; /// For ADRP fixups.; ///; /// Errors:; /// - The result of the fixup expression must fit into an int21 otherwise an; /// out-of-range error will be returned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h:248,Error,Errors,248,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h,2,"['Error', 'error']","['Errors', 'error']"
Availability,/// The signed 21-bit delta from the fixup to the target.; ///; /// Fixup expression:; ///; /// Fixup <- Target - Fixup + Addend : int21; ///; /// Notes:; /// For ADR fixups.; ///; /// Errors:; /// - The result of the fixup expression must fit into an int21 otherwise an; /// out-of-range error will be returned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h:185,Error,Errors,185,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h,2,"['Error', 'error']","['Errors', 'error']"
Availability,/// The signed 21-bit delta from the fixup to the target.; ///; /// Typically used to load a pointers at a PC-relative offset of +/- 1Mb. The; /// target must be 32-bit aligned.; ///; /// Fixup expression:; ///; /// Fixup <- (Target - Fixup) >> 2 : int19; ///; /// Errors:; /// - The result of the unshifted part of the fixup expression must be; /// 32-bit aligned otherwise an alignment error will be returned.; /// - The result of the fixup expression must fit into an int19 or an; /// out-of-range error will be returned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h:265,Error,Errors,265,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h,3,"['Error', 'error']","['Errors', 'error']"
Availability,"/// The source file column number, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/LogDiagnosticPrinter.h:38,avail,available,38,interpreter/llvm-project/clang/include/clang/Frontend/LogDiagnosticPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/LogDiagnosticPrinter.h,1,['avail'],['available']
Availability,"/// The source file line number, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/LogDiagnosticPrinter.h:36,avail,available,36,interpreter/llvm-project/clang/include/clang/Frontend/LogDiagnosticPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/LogDiagnosticPrinter.h,1,['avail'],['available']
Availability,"/// The source file name, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/LogDiagnosticPrinter.h:29,avail,available,29,interpreter/llvm-project/clang/include/clang/Frontend/LogDiagnosticPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/LogDiagnosticPrinter.h,1,['avail'],['available']
Availability,/// The source info for the template arguments as written.; /// FIXME: redundant with TypeAsWritten?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h:71,redundant,redundant,71,interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,2,['redundant'],['redundant']
Availability,"/// The stack of nodes visited when walking down the tree of fields",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:44,down,down,44,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['down'],['down']
Availability,"/// The staging area is relevant for chains of files, i.e. when fFileNames is not empty. In this case,; /// files are opened in the background in batches of size `fNSlots` and kept in the staging area.; /// The first file (chains or no chains) is always opened on construction in order to process the schema.; /// For all subsequent files, the corresponding page sources in the staging area only executed `LoadStructure()`,; /// i.e. they should have a compressed buffer of the meta-data available.; /// Concretely:; /// 1. We open the first file on construction to read the schema and then move the corresponding page source; /// in the staging area.; /// 2. On `Initialize()`, we start the I/O background thread, which in turn opens the first batch of files.; /// 3. At the beginning of `GetEntryRanges()`, we; /// a) wait for the I/O thread to finish,; /// b) call `PrepareNextRanges()` in the main thread to move the page sources from the staging area; /// into `fNextRanges`; this will also call `Attach()` on the page sources (i.e., deserialize the meta-data),; /// and; /// c) trigger staging of the next batch of files in the I/O background thread.; /// 4. On `Finalize()`, the I/O background thread is stopped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx:488,avail,available,488,tree/dataframe/inc/ROOT/RNTupleDS.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx,1,['avail'],['available']
Availability,/// The stream can be in state where none of the error flags set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:49,error,error,49,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,/// The stream can be in state where the error indicator is set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:41,error,error,41,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,"/// The tail-padding of a base class is always theoretically; /// available, even if it's POD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h:66,avail,available,66,interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,1,['avail'],['available']
Availability,"/// The template overload candidate, available when; /// Kind == CK_Template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:37,avail,available,37,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['avail'],['available']
Availability,"/// The template parameter to which a template argument; /// deduction failure refers.; ///; /// Depending on the result of template argument deduction, this; /// template parameter may have different meanings:; ///; /// TDK_Incomplete: this is the first template parameter whose; /// corresponding template argument was not deduced.; ///; /// TDK_IncompletePack: this is the expanded parameter pack for; /// which we deduced too few arguments.; ///; /// TDK_Inconsistent: this is the template parameter for which; /// two different template argument values were deduced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:71,failure,failure,71,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['failure'],['failure']
Availability,/// The top-down traversal uses this to merge information about predecessors to; /// form the initial state for a new block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:12,down,down,12,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['down'],['down']
Availability,/// The top-down traversal uses this to record information known about a; /// pointer at the bottom of each block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:12,down,down,12,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['down'],['down']
Availability,/// The transition being moved downwards.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:31,down,downwards,31,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['down'],['downwards']
Availability,"/// The type of the content, thus the type read/written, can be null if not; /// available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:81,avail,available,81,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['avail'],['available']
Availability,"/// The value in LI may be copies to other registers. Determine if; /// any of the copies are available at the kill points, and add defs if; /// possible.; ///; /// \param DbgValue Location number of LI->reg, and DIExpression.; /// \param LocIntervals Scan for copies of the value for each location in the; /// corresponding LiveInterval->reg.; /// \param KilledAt The point where the range of DbgValue could be extended.; /// \param [in,out] NewDefs Append (Idx, DbgValue) of inserted defs here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:94,avail,available,94,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['avail'],['available']
Availability,/// The value of the map is a bit mask of which icmp operands the alloca is; /// used in.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,"/// The value returned by this function can be returned from convertToErrorCode; /// for Error values where no sensible translation to std::error_code exists.; /// It should only be used in this situation, and should never be used where a; /// sensible conversion to std::error_code is available, as attempts to convert; /// to/from this error will result in a fatal error. (i.e. it is a programmatic; /// error to try to convert such a value).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:89,Error,Error,89,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,5,"['Error', 'avail', 'error']","['Error', 'available', 'error']"
Availability,"/// The value types of the registers. This is the same size as ValueVTs and it; /// records, for each value, what the type of the assigned register or; /// registers are. (Individual values are never synthesized from more than one; /// type of register.); ///; /// With virtual registers, the contents of RegVTs is redundant with TLI's; /// getRegisterType member function, however when with physical registers; /// it is necessary to have a separate record of the types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h:315,redundant,redundant,315,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,1,['redundant'],['redundant']
Availability,"/// The value, which represents no error return value for allocator functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:35,error,error,35,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['error'],['error']
Availability,"/// The verifier algorithm is phrased in terms of availability. The set of; /// values ""available"" at a given point in the control flow graph is the set of; /// correctly relocated value at that point, and is a subset of the set of; /// definitions dominating that point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:50,avail,availability,50,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,2,['avail'],"['availability', 'available']"
Availability,/// The version of the linker known to be available in the tool chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h:42,avail,available,42,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.h,1,['avail'],['available']
Availability,"/// The width of the ""fast"" qualifier mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:38,mask,mask,38,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['mask'],['mask']
Availability,/// There are two ways to clear extreme bits (either low or high):; /// Mask: x & (-1 << y) (the instcombine canonical form); /// Shifts: x >> y << y; /// Return true if the variant with 2 variable shifts is preferred.; /// Return false if there is no preference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:72,Mask,Mask,72,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Mask'],['Mask']
Availability,/// There has to be at least one document available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp:42,avail,available,42,interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,1,['avail'],['available']
Availability,"/// These are the errno constraints that can be passed to summary cases.; /// One of these should fit for a single summary case.; /// Usually if a failure return value exists for function, that function; /// needs different cases for success and failure with different errno; /// constraints (and different return value constraints).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:147,failure,failure,147,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,2,['failure'],['failure']
Availability,"/// These function return the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resou",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:659,DOWN,DOWN,659,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['DOWN'],['DOWN']
Availability,"/// These methods set the specified attribute of the DeclSpec and; /// return false if there was no error. If an error occurs (for; /// example, if we tried to set ""auto"" on a spec with ""extern""; /// already set), they return true and set PrevSpec and DiagID; /// such that; /// Diag(Loc, DiagID) << PrevSpec;; /// will yield a useful result.; ///; /// TODO: use a more general approach that still allows these; /// diagnostics to be ignored when desired.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h:100,error,error,100,interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,2,['error'],['error']
Availability,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:159,mask,mask,159,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,2,"['mask', 'redundant']","['mask', 'redundant']"
Availability,"/// This SDNode is used to implement the code generator; /// support for the llvm IR shufflevector instruction. It combines elements; /// from two input vectors into a new input vector, with the selection and; /// ordering of elements determined by an array of integers, referred to as; /// the shuffle mask. For input vectors of width N, mask indices of 0..N-1; /// refer to elements from the LHS input, and indices from N to 2N-1 the RHS.; /// An index of -1 is treated as undef, such that the code generator may put; /// any value in the corresponding element of the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:303,mask,mask,303,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,2,['mask'],['mask']
Availability,"/// This allows the client to specify that certain warnings are; /// ignored.; ///; /// Notes can never be mapped, errors can only be mapped to fatal, and; /// WARNINGs and EXTENSIONs can be mapped arbitrarily.; ///; /// \param Loc The source location that this change of diagnostic state should; /// take affect. It can be null if we are setting the latest state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:115,error,errors,115,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['errors']
Availability,"/// This approximately represents the ratio of the number of profile counters; /// of the program being built to the number of profile counters in the; /// partial sample profile. When 'Partial' is false, it is undefined. This is; /// currently only available under thin LTO mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ProfileSummary.h:250,avail,available,250,interpreter/llvm-project/llvm/include/llvm/IR/ProfileSummary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ProfileSummary.h,1,['avail'],['available']
Availability,/// This basic block visited on stack protector check failure that will; /// contain a call to __stack_chk_fail().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:54,failure,failure,54,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,1,['failure'],['failure']
Availability,/// This bit must be set in the 'Attributes' field of FMA group if such; /// group of FMA opcodes consists of AVX512 opcodes accepting a k-mask and; /// passing the elements from the 1st operand to the result of the operation; /// when the correpondings bits in the k-mask are unset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h:139,mask,mask,139,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFMA3Info.h,2,['mask'],['mask']
Availability,"/// This callback is invoked whenever the next top-down instruction to be; /// scheduled cannot issue in the current cycle, either because of latency; /// or resource conflicts. This should increment the internal state of the; /// hazard recognizer so that previously ""Hazard"" instructions will now not; /// be hazards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:51,down,down,51,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,1,['down'],['down']
Availability,/// This callback is used to infer the types for Class variables. This info is; /// used later to validate messages that sent to classes. Class variables are; /// initialized with by invoking the 'class' method on a class.; /// This method is also used to infer the type information for the return; /// types.; // TODO: right now it only tracks generic types. Extend this to track every; // type in the DynamicTypeMap and diagnose type errors!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:436,error,errors,436,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,1,['error'],['errors']
Availability,"/// This callback may be invoked if getHazardType returns NoHazard. If, even; /// though there is no hazard, it would be better to schedule another; /// available instruction, this callback should return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:153,avail,available,153,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,1,['avail'],['available']
Availability,"/// This class can make regularly spaced scans based on range stored in RooRealVars.; /// Choose number of steps for a rastor scan (common for each dimension); /// void SetNumSteps(Int_t);; /// This class can make regularly spaced scans based on range stored in RooRealVars.; /// Choose number of steps for a rastor scan (specific for each dimension); /// void SetNumSteps(std::map<RooAbsArg, Int_t>); /// Get the size of the test (eg. rate of Type I error)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/NeymanConstruction.h:451,error,error,451,roofit/roostats/inc/RooStats/NeymanConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/NeymanConstruction.h,1,['error'],['error']
Availability,"/// This class implements -Wunguarded-availability.; ///; /// This is done with a traversal of the AST of a function that makes reference; /// to a partially available declaration. Whenever we encounter an \c if of the; /// form: \c if(@available(...)), we use the version from the condition to visit; /// the then statement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:38,avail,availability,38,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,3,['avail'],"['availability', 'available']"
Availability,/// This class implements a trivial dead store elimination. We consider; /// only the redundant stores that are local to a single Basic Block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h:86,redundant,redundant,86,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h,1,['redundant'],['redundant']
Availability,"/// This class is a batch walker of all MemoryUse's in the program, and points; /// their defining access at the thing that actually clobbers them. Because it; /// is a batch walker that touches everything, it does not operate like the; /// other walkers. This walker is basically performing a top-down SSA renaming; /// pass, where the version stack is used as the cache. This enables it to be; /// significantly more time and memory efficient than using the regular walker,; /// which is walking bottom-up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:298,down,down,298,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['down'],['down']
Availability,"/// This class is a wrapper to associative container MapT<KeyT, ValueT> using; /// the hash value of the original key as the new key. This greatly improves the; /// performance of insert and query operations especially when hash values of; /// keys are available a priori, and reduces memory usage if KeyT has a large; /// size.; /// All keys with the same hash value are considered equivalent (i.e. hash; /// collision is silently ignored). Given such feature this class should only be; /// used where it does not affect compilation correctness, for example, when; /// loading a sample profile. The original key is not stored, so if the user; /// needs to preserve it, it should be stored in the mapped type.; /// Assuming the hashing algorithm is uniform, we use the formula; /// 1 - Permute(n, k) / n ^ k where n is the universe size and k is number of; /// elements chosen at random to calculate the probability of collision. With; /// 1,000,000 entries the probability is negligible:; /// 1 - (2^64)!/((2^64-1000000)!*(2^64)^1000000) ~= 3*10^-8.; /// Source: https://en.wikipedia.org/wiki/Birthday_problem; ///; /// \param MapT The underlying associative container type.; /// \param KeyT The original key type, which requires the implementation of; /// llvm::hash_value(KeyT).; /// \param ValueT The original mapped type, which has the same requirement as; /// the underlying container.; /// \param MapTArgs Additional template parameters passed to the underlying; /// container.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/HashKeyMap.h:253,avail,available,253,interpreter/llvm-project/llvm/include/llvm/ProfileData/HashKeyMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/HashKeyMap.h,1,['avail'],['available']
Availability,"/// This class is used to build a byte array containing overlapping bit sets. By; /// loading from indexed offsets into the byte array and applying a mask, a; /// program can test bits from the bit set with a relatively short instruction; /// sequence. For example, suppose we have 15 bit sets to lay out:; ///; /// A (16 bits), B (15 bits), C (14 bits), D (13 bits), E (12 bits),; /// F (11 bits), G (10 bits), H (9 bits), I (7 bits), J (6 bits), K (5 bits),; /// L (4 bits), M (3 bits), N (2 bits), O (1 bit); ///; /// These bits can be laid out in a 16-byte array like this:; ///; /// Byte Offset; /// 0123456789ABCDEF; /// Bit; /// 7 HHHHHHHHHIIIIIII; /// 6 GGGGGGGGGGJJJJJJ; /// 5 FFFFFFFFFFFKKKKK; /// 4 EEEEEEEEEEEELLLL; /// 3 DDDDDDDDDDDDDMMM; /// 2 CCCCCCCCCCCCCCNN; /// 1 BBBBBBBBBBBBBBBO; /// 0 AAAAAAAAAAAAAAAA; ///; /// For example, to test bit X of A, we evaluate ((bits[X] & 1) != 0), or to; /// test bit X of I, we evaluate ((bits[9 + X] & 0x80) != 0). This can be done; /// in 1-2 machine instructions on x86, or 4-6 instructions on ARM.; ///; /// This is a byte array, rather than (say) a 2-byte array or a 4-byte array,; /// because for one thing it gives us better packing (the more bins there are,; /// the less evenly they will be filled), and for another, the instruction; /// sequences can be slightly shorter, both on x86 and ARM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:150,mask,mask,150,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,1,['mask'],['mask']
Availability,"/// This class is used to track the amount of time spent between invocations of; /// its startTimer()/stopTimer() methods. Given appropriate OS support it can; /// also keep track of the RSS of the program at various points. By default,; /// the Timer will print the amount of time it has captured to standard error; /// when the last timer is destroyed, otherwise it is printed when its; /// TimerGroup is destroyed. Timers do not print their information if they are; /// never started.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Timer.h:310,error,error,310,interpreter/llvm-project/llvm/include/llvm/Support/Timer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Timer.h,1,['error'],['error']
Availability,"/// This class provides access to building LLVM's passes.; ///; /// Its members provide the baseline state available to passes during their; /// construction. The \c MachinePassRegistry.def file specifies how to construct; /// all of the built-in passes, and those may reference these members during; /// construction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:107,avail,available,107,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,1,['avail'],['available']
Availability,"/// This class provides access to building LLVM's passes.; ///; /// Its members provide the baseline state available to passes during their; /// construction. The \c PassRegistry.def file specifies how to construct all; /// of the built-in passes, and those may reference these members during; /// construction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:107,avail,available,107,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['avail'],['available']
Availability,/// This class provides an abstraction for a timeout around an operation; /// that must complete in a given amount of time. Failure to complete before; /// the timeout is an unrecoverable situation and no mechanisms to attempt; /// to handle it are provided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Watchdog.h:124,Failure,Failure,124,interpreter/llvm-project/llvm/include/llvm/Support/Watchdog.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Watchdog.h,1,['Failure'],['Failure']
Availability,"/// This class provides transaction based operation on the IR.; /// Every change made through this class is recorded in the internal state and; /// can be undone (rollback) until commit is called.; /// CGP does not check if instructions could be speculatively executed when; /// moved. Preserving the original location would pessimize the debugging; /// experience, as well as negatively impact the quality of sample PGO.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:163,rollback,rollback,163,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['rollback'],['rollback']
Availability,"/// This class represents an Operation in the Expression.; ///; /// An Operation can be in Error state (check with isError()). This; /// means that it couldn't be decoded successfully and if it is the; /// case, all others fields contain undefined values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h:91,Error,Error,91,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFExpression.h,1,['Error'],['Error']
Availability,"/// This class should be specialized by type that requires custom conversion; /// to/from a YAML literal block scalar. For example:; ///; /// template <>; /// struct BlockScalarTraits<MyType> {; /// static void output(const MyType &Value, void*, llvm::raw_ostream &Out); /// {; /// // stream out custom formatting; /// Out << Value;; /// }; /// static StringRef input(StringRef Scalar, void*, MyType &Value) {; /// // parse scalar and set `value`; /// // return empty string on success, or error string; /// return StringRef();; /// }; /// };",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:490,error,error,490,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['error'],['error']
Availability,"/// This class should be specialized by type that requires custom conversion; /// to/from a YAML scalar with optional tags. For example:; ///; /// template <>; /// struct TaggedScalarTraits<MyType> {; /// static void output(const MyType &Value, void*, llvm::raw_ostream; /// &ScalarOut, llvm::raw_ostream &TagOut); /// {; /// // stream out custom formatting including optional Tag; /// Out << Value;; /// }; /// static StringRef input(StringRef Scalar, StringRef Tag, void*, MyType; /// &Value) {; /// // parse scalar and set `value`; /// // return empty string on success, or error string; /// return StringRef();; /// }; /// static QuotingType mustQuote(const MyType &Value, StringRef) {; /// return QuotingType::Single;; /// }; /// };",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:577,error,error,577,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['error'],['error']
Availability,"/// This class should be specialized by type that requires custom conversion; /// to/from a yaml scalar. For example:; ///; /// template<>; /// struct ScalarTraits<MyType> {; /// static void output(const MyType &val, void*, llvm::raw_ostream &out) {; /// // stream out custom formatting; /// out << llvm::format(""%x"", val);; /// }; /// static StringRef input(StringRef scalar, void*, MyType &value) {; /// // parse scalar and set `value`; /// // return empty string on success, or error string; /// return StringRef();; /// }; /// static QuotingType mustQuote(StringRef) { return QuotingType::Single; }; /// };",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:481,error,error,481,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['error'],['error']
Availability,"/// This class wraps a filename and another Error.; ///; /// In some cases, an error needs to live along a 'source' name, in order to; /// show more detailed information to the user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:44,Error,Error,44,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,2,"['Error', 'error']","['Error', 'error']"
Availability,/// This class wraps a std::error_code in a Error.; ///; /// This is useful if you're writing an interface that returns a Error; /// (or Expected) and you want to call code that still returns; /// std::error_codes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:44,Error,Error,44,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,2,['Error'],['Error']
Availability,"/// This class wraps a string in an Error.; ///; /// StringError is useful in cases where the client is not expected to be able; /// to consume the specific error message programmatically (for example, if the; /// error message is to be presented to the user).; ///; /// StringError can also be used when additional information is to be printed; /// along with a error_code message. Depending on the constructor called, this; /// class can either display:; /// 1. the error_code message (ECError behavior); /// 2. a string; /// 3. the error_code message and a string; ///; /// These behaviors are useful when subtyping is required; for example, when a; /// specific library needs an explicit error type. In the example below,; /// PDBError is derived from StringError:; ///; /// @code{.cpp}; /// Expected<int> foo() {; /// return llvm::make_error<PDBError>(pdb_error_code::dia_failed_loading,; /// ""Additional information"");; /// }; /// @endcode; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:36,Error,Error,36,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,4,"['Error', 'error']","['Error', 'error']"
Availability,"/// This constructor is meaningless.; /// It just provides a default constructor that can be used at link time; /// when GlobalISel is not built.; /// That way, targets can still inherit from this class without doing; /// crazy gymnastic to avoid link time failures.; /// \note That works because the constructor is inlined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:257,failure,failures,257,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['failure'],['failures']
Availability,/// This determines which of three possible cases of a three source commute; /// the source indexes correspond to taking into account any mask operands.; /// All prevents commuting a passthru operand. Returns -1 if the commute isn't; /// possible.; /// Case 0 - Possible to commute the first and second operands.; /// Case 1 - Possible to commute the first and third operands.; /// Case 2 - Possible to commute the second and third operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:138,mask,mask,138,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['mask'],['mask']
Availability,"/// This ensures an ErrorCollector will treat unhandled errors as fatal.; /// This function should be called if errors that usually can be ignored; /// are suddenly of concern (i.e. attempt multiple things that return Error,; /// but only care about the Errors if no attempt succeeds).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:20,Error,ErrorCollector,20,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,5,"['Error', 'error']","['Error', 'ErrorCollector', 'Errors', 'errors']"
Availability,"/// This enum distinguishes between different kinds of lock actions. For; /// example, it is an error to write a variable protected by shared version of a; /// mutex.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h:96,error,error,96,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,1,['error'],['error']
Availability,/// This enum distinguishes between different kinds of operations that may; /// need to be protected by locks. We use this enum in error handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h:131,error,error,131,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,1,['error'],['error']
Availability,"/// This field is used to track resource units that are used (i.e. selected); /// by other groups other than the one associated with this strategy object.; ///; /// In LLVM processor resource groups are allowed to partially (or fully); /// overlap. That means, a same unit may be visible to multiple groups.; /// This field keeps track of uses that have originated from outside of; /// this group. The idea is to bias the selection strategy, so that resources; /// that haven't been used by other groups get prioritized.; ///; /// The end goal is to (try to) keep the resource distribution as much uniform; /// as possible. By construction, this mask only tracks one-level of resource; /// usage. Therefore, this strategy is expected to be less accurate when same; /// units are used multiple times by other groups within a single round of; /// select.; ///; /// Note: an LRU selector would have a better accuracy at the cost of being; /// slightly more expensive (mostly in terms of runtime cost). Methods; /// 'select' and 'used', are always in the hot execution path of llvm-mca.; /// Therefore, a slow implementation of 'select' would have a negative impact; /// on the overall performance of the tool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:646,mask,mask,646,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['mask'],['mask']
Availability,/// This function assumes that CI comes before Paired in a basic block. Return; /// an insertion point for the merged instruction or nullptr on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp:144,failure,failure,144,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,1,['failure'],['failure']
Availability,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:213,down,downstream,213,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,2,"['down', 'mask']","['downstream', 'mask']"
Availability,"/// This function builds an error message into \p ErrMsg using the \p prefix; /// string and the Unix error number given by \p errnum. If errnum is -1, the; /// default then the value of errno is used.; /// Make an error message; ///; /// If the error number can be converted to a string, it will be; /// separated from prefix by "": "".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Unix/Unix.h:28,error,error,28,interpreter/llvm-project/llvm/lib/Support/Unix/Unix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Unix/Unix.h,4,['error'],['error']
Availability,/// This function calls \p Iteration() until it returns false.; /// If number of iterations exceeds \p MaxCounter then an Error is returned.; /// This function should be used for loops which assumed to have number of; /// iterations significantly smaller than \p MaxCounter to avoid infinite; /// looping in error cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Utils.h:122,Error,Error,122,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Utils.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// This function determines if the standard error is connected to a; /// ""tty"" or ""console"" window. That is, the output would be displayed to; /// the user rather than being put on a pipe or stored in a file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h:45,error,error,45,interpreter/llvm-project/llvm/include/llvm/Support/Process.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h,1,['error'],['error']
Availability,"/// This function determines the number of columns in the window; /// if standard error is connected to a ""tty"" or ""console""; /// window. If standard error is not connected to a tty or; /// console, or if the number of columns cannot be determined,; /// this routine returns zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h:82,error,error,82,interpreter/llvm-project/llvm/include/llvm/Support/Process.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h,2,['error'],['error']
Availability,"/// This function determines the number of dynamic symbols. It reads section; /// headers first. If section headers are not available, the number of; /// symbols will be inferred by parsing dynamic hash tables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:124,avail,available,124,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,1,['avail'],['available']
Availability,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the load at DepLI.; ///; /// On success, it returns the offset into DepLI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:207,failure,failure,207,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,1,['failure'],['failure']
Availability,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the memory intrinsic at DepMI.; ///; /// On success, it returns the offset into DepMI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:219,failure,failure,219,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,1,['failure'],['failure']
Availability,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the store at DepSI.; ///; /// On success, it returns the offset into DepSI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:208,failure,failure,208,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,1,['failure'],['failure']
Availability,"/// This function determines whether the terminal connected to standard; /// error supports colors. If standard error is not connected to a; /// terminal, this function returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h:77,error,error,77,interpreter/llvm-project/llvm/include/llvm/Support/Process.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h,2,['error'],['error']
Availability,/// This function does the following:; /// - clean up any temporary files registered with RemoveFileOnSignal(); /// - dump the callstack from the exception context; /// - call any relevant interrupt/signal handlers; /// - create a core/mini dump of the exception context whenever possible; /// Context is a system-specific failure context: it is the signal type on; /// Unix; the ExceptionContext on Windows.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Signals.h:323,failure,failure,323,interpreter/llvm-project/llvm/include/llvm/Support/Signals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Signals.h,1,['failure'],['failure']
Availability,"/// This function executes the program using the arguments provided. The; /// invoked program will inherit the stdin, stdout, and stderr file; /// descriptors, the environment and other configuration settings of the; /// invoking program.; /// This function waits for the program to finish, so should be avoided in; /// library functions that aren't expected to block. Consider using; /// ExecuteNoWait() instead.; /// \returns an integer result code indicating the status of the program.; /// A zero or positive value indicates the result code of the program.; /// -1 indicates failure to execute; /// -2 indicates a crash during execution or timeout",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:579,failure,failure,579,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,1,['failure'],['failure']
Availability,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code for a module; /// summary. It returns a ModuleSummaryIndex with the corresponding features.; /// Note that this does not verify that the generated Index is valid, so you; /// should run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly Index from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:500,Error,Error,500,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,1,['Error'],['Error']
Availability,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code, including; /// a module summary. It returns a Module (intermediate representation) and; /// a ModuleSummaryIndex with the corresponding features. Note that this does; /// not verify that the generated Module or Index are valid, so you should; /// run the verifier after parsing the file to check that they are okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:563,Error,Error,563,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,1,['Error'],['Error']
Availability,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:492,Error,Error,492,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,1,['Error'],['Error']
Availability,"/// This function is called when we suspect that the update-chain of a phi node; /// (whose symbolic SCEV expression sin \p PhiScev) contains redundant casts,; /// that can be ignored. (This can happen when the PSCEV rewriter adds a runtime; /// predicate P under which the SCEV expression for the phi can be the; /// AddRecurrence \p AR; See createAddRecFromPHIWithCast). We want to find the; /// cast instructions that are involved in the update-chain of this induction.; /// A caller that adds the required runtime predicate can be free to drop these; /// cast instructions, and compute the phi using \p AR (instead of some scev; /// expression with casts).; ///; /// For example, without a predicate the scev expression can take the following; /// form:; /// (Ext ix (Trunc iy ( Start + i*Step ) to ix) to iy); ///; /// It corresponds to the following IR sequence:; /// %for.body:; /// %x = phi i64 [ 0, %ph ], [ %add, %for.body ]; /// %casted_phi = ""ExtTrunc i64 %x""; /// %add = add i64 %casted_phi, %step; ///; /// where %x is given in \p PN,; /// PSE.getSCEV(%x) is equal to PSE.getSCEV(%casted_phi) under a predicate,; /// and the IR sequence that ""ExtTrunc i64 %x"" represents can take one of; /// several forms, for example, such as:; /// ExtTrunc1: %casted_phi = and %x, 2^n-1; /// or:; /// ExtTrunc2: %t = shl %x, m; /// %casted_phi = ashr %t, m; ///; /// If we are able to find such sequence, we return the instructions; /// we found, namely %casted_phi and the instructions on its use-def chain up; /// to the phi (not including the phi).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:142,redundant,redundant,142,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,1,['redundant'],['redundant']
Availability,/// This function is design to compatible with the function def in other; /// targets and escape build error about the virtual function def in base; /// class TargetSubtargetInfo. Updeate me if AArch64 target need to use it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h:103,error,error,103,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,1,['error'],['error']
Availability,/// This function is the low-level interface to the LLVM Assembly Parser.; /// This is kept as an independent function instead of being inlined into; /// parseAssembly for the convenience of interactive users that want to add; /// recently parsed bits to an existing module.; ///; /// \param F The MemoryBuffer containing assembly; /// \param M The module to add data to.; /// \param Index The index to add data to.; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \return true on error.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:432,Error,Error,432,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,2,"['Error', 'error']","['Error', 'error']"
Availability,/// This function is the main interface to the MIR serialization format parser.; ///; /// It reads in a MIR file and returns a MIR parser that can parse the embedded; /// LLVM IR module and initialize the machine functions by parsing the machine; /// function's state.; ///; /// \param Filename - The name of the file to parse.; /// \param Error - Error result info.; /// \param Context - Context which will be used for the parsed LLVM IR module.; /// \param ProcessIRFunction - function to run on every IR function or stub; /// loaded from the MIR file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h:340,Error,Error,340,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h,2,['Error'],['Error']
Availability,/// This function is the one used to emit instruction data into the ELF; /// streamer. We override it to mask dangerous instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:105,mask,mask,105,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,1,['mask'],['mask']
Availability,"/// This function loads a definition from an external AST file.; ///; /// A definition with the same declaration will be looked up in the; /// index file which should be in the \p CrossTUDir directory, called; /// \p IndexName. In case the declaration is found in the index the; /// corresponding AST will be loaded. If the number of TUs imported; /// reaches \p CTULoadTreshold, no loading is performed.; ///; /// \return Returns a pointer to the ASTUnit that contains the definition of; /// the looked up name or an Error.; /// The returned pointer is never a nullptr.; ///; /// Note that the AST files should also be in the \p CrossTUDir.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:518,Error,Error,518,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['Error'],['Error']
Availability,"/// This function loads a function or variable definition from an; /// external AST file and merges it into the original AST.; ///; /// This method should only be used on functions that have no definitions or; /// variables that have no initializer in; /// the current translation unit. A function definition with the same; /// declaration will be looked up in the index file which should be in the; /// \p CrossTUDir directory, called \p IndexName. In case the declaration is; /// found in the index the corresponding AST will be loaded and the; /// definition will be merged into the original AST using the AST Importer.; ///; /// \return The declaration with the definition will be returned.; /// If no suitable definition is found in the index file or multiple; /// definitions found error will be returned.; ///; /// Note that the AST files should also be in the \p CrossTUDir.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:788,error,error,788,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['error'],['error']
Availability,"/// This function loads the dynamic library at the given path, using the; /// library load operation from the host operating system. The library; /// instance will be closed when closeLibrary is called or global destructors; /// are run, but there is no guarantee when the library will be unloaded.; ///; /// This returns a valid DynamicLibrary instance on success and an invalid; /// instance on failure (see isValid()). \p *Err will only be modified if the; /// library fails to load.; ///; /// It is safe to call this function multiple times for the same library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:397,failure,failure,397,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['failure'],['failure']
Availability,"/// This function may widen the current value -- replace it with an; /// approximation that can reach a fixed point more quickly than iterated; /// application of the transfer function alone. The previous value is; /// provided to inform the choice of widened value. The function must also; /// serve as a comparison operation, by indicating whether the widened value; /// is equivalent to the previous value.; ///; /// Returns either:; ///; /// `nullptr`, if this value is not of interest to the model, or; ///; /// `&Prev`, if the widened value is equivalent to `Prev`, or; ///; /// A non-null value that approximates `Current`. `Prev` is available to; /// inform the chosen approximation.; ///; /// `PrevEnv` and `CurrentEnv` can be used to query child values and path; /// condition implications of `Prev` and `Current`, respectively.; ///; /// Requirements:; ///; /// `Prev` and `Current` must model values of type `Type`.; ///; /// `Prev` and `Current` must be assigned to the same storage location in; /// `PrevEnv` and `CurrentEnv`, respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h:641,avail,available,641,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h,1,['avail'],['available']
Availability,/// This function merges a definition from a separate AST Unit into; /// the current one which was created by the compiler instance that; /// was passed to the constructor.; ///; /// \return Returns the resulting definition or an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:230,error,error,230,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['error'],['error']
Availability,"/// This function parses an index file that determines which; /// translation unit contains which definition. The IndexPath is not prefixed; /// with CTUDir, so an absolute path is expected for consistent results.; ///; /// The index file format is the following:; /// each line consists of an USR and a filepath separated by a space.; ///; /// \return Returns a map where the USR is the key and the filepath is the value; /// or an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:433,error,error,433,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['error'],['error']
Availability,"/// This function parses registers that appear in inline-asm constraints.; /// It returns pair (0, 0) on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:105,failure,failure,105,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,1,['failure'],['failure']
Availability,"/// This function permanently loads the dynamic library at the given path; /// using the library load operation from the host operating system. The; /// library instance will only be closed when global destructors run, and; /// there is no guarantee when the library will be unloaded.; ///; /// This returns a valid DynamicLibrary instance on success and an invalid; /// instance on failure (see isValid()). \p *errMsg will only be modified if; /// the library fails to load.; ///; /// It is safe to call this function multiple times for the same library.; /// Open a dynamic library permanently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:383,failure,failure,383,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['failure'],['failure']
Availability,/// This function provides an additional visitor that augments the bug report; /// with information relevant to memory errors caused by the misuse of; /// AF_InnerBuffer symbols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/AllocationState.h:119,error,errors,119,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/AllocationState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/AllocationState.h,1,['error'],['errors']
Availability,"/// This function takes an error, and appends a string of text to the end of; /// that error. Since ""appending"" to an Error isn't supported behavior of an; /// Error, this function technically creates a new error with the combined; /// message and consumes the old error.; ///; /// @param Err Source error.; /// @param After Text to append at the end of Err's error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:27,error,error,27,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,8,"['Error', 'error']","['Error', 'error']"
Availability,"/// This function will attempt to load an XRay Profiling Mode profile from the; /// provided |Filename|.; ///; /// For any errors encountered in the loading of the profile data from; /// |Filename|, this function will return an Error condition appropriately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:123,error,errors,123,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,2,"['Error', 'error']","['Error', 'errors']"
Availability,/// This hook is invoked after all the stores are found and inserted as; /// available values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:77,avail,available,77,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,1,['avail'],['available']
Availability,"/// This instruction constructs a fixed permutation of two; /// input vectors.; ///; /// For each element of the result vector, the shuffle mask selects an element; /// from one of the input vectors to copy to the result. Non-negative elements; /// in the mask represent an index into the concatenated pair of input vectors.; /// PoisonMaskElem (-1) specifies that the result element is poison.; ///; /// For scalable vectors, all the elements of the mask must be 0 or -1. This; /// requirement may be relaxed in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:140,mask,mask,140,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,3,['mask'],['mask']
Availability,"/// This intrinsic performs two rounds of SM3 operation using initial SM3 state; /// (C, D, G, H) from \a __A, an initial SM3 states (A, B, E, F); /// from \a __B and a pre-computed words from the \a __C. \a __A with; /// initial SM3 state of (C, D, G, H) assumes input of non-rotated left; /// variables from previous state. The updated SM3 state (A, B, E, F) is; /// written to \a __A. The \a imm8 should contain the even round number; /// for the first of the two rounds computed by this instruction. The; /// computation masks the \a imm8 value by AND’ing it with 0x3E so that only; /// even round numbers from 0 through 62 are used for this operation. The; /// calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3rnds2_epi32(__m128i __A, __m128i __B, __m128i __C, const int; /// imm8) \endcode; ///; /// This intrinsic corresponds to the \c VSM3RNDS2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \param imm8; /// A 8-bit constant integer.; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE P0(dword) {; /// 	RETURN dword ^ ROL32(dword, 9) ^ ROL32(dword, 17); /// }; /// DEFINE FF(x,y,z, round){; /// 	IF round < 16; /// 		RETURN (x ^ y ^ z); /// 	ELSE; /// 		RETURN (x & y) | (x & z) | (y & z); /// 	FI; /// }; /// DEFINE GG(x, y, z, round){; /// IF round < 16; /// 	RETURN (x ^ y ^ z); /// ELSE; /// 	RETURN (x & y) | (~x & z); /// FI; /// }; /// A[0] := __B.dword[3]; /// B[0] := __B.dword[2]; /// C[0] := __A.dword[3]; /// D[0] := __A.dword[2]; /// E[0] := __B.dword[1]; /// F[0] := __B.dword[0]; /// G[0] := __A.dword[1]; /// H[0] := __A.dword[0]; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[4] := __C.dword[2]; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:525,mask,masks,525,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,1,['mask'],['masks']
Availability,/// This inverts a canonicalization in IR that replaces a variable select arm; /// with an identity constant. Codegen improves if we re-use the variable; /// operand rather than load a constant. This can also be converted into a; /// masked vector operation if the target supports it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:234,mask,masked,234,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masked']
Availability,"/// This is a generic driver to narrow down miscompilations, either in an; /// optimization or a code generator.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:39,down,down,39,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['down'],['down']
Availability,/// This is a helper for \a grow() that's out of line to reduce code; /// duplication. This function will report a fatal error if it can't grow at; /// least to \p MinSize.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:121,error,error,121,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['error'],['error']
Availability,/// This is a helper for convertToThreeAddress for 8 and 16-bit instructions.; /// We use 32-bit LEA to form 3-address code by promoting to a 32-bit; /// super-register and then truncating back down to a 8/16-bit sub-register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:194,down,down,194,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,1,['down'],['down']
Availability,"/// This is a helper function for validating the optional refinement step; /// parameter in reciprocal argument strings. Return false if there is an error; /// parsing the refinement step. Otherwise, return true and set the Position; /// of the refinement step in the input string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:149,error,error,149,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['error'],['error']
Availability,"/// This is a public interface to the hardware address sanitizer pass for; /// instrumenting code to check for various memory errors at runtime, similar to; /// AddressSanitizer but based on partial hardware assistance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/HWAddressSanitizer.h:126,error,errors,126,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/HWAddressSanitizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/HWAddressSanitizer.h,1,['error'],['errors']
Availability,"/// This is a set of names for decls that we do not want to be; /// deserialized, and we emit an error if they are; for testing purposes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:97,error,error,97,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,1,['error'],['error']
Availability,"/// This is a static version that you can use without an instruction; /// available.; /// @returns the non-strict version of comparison provided in \p pred.; /// If \p pred is not a strict comparison predicate, returns \p pred.; /// Returns the non-strict version of strict comparisons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:74,avail,available,74,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['avail'],['available']
Availability,"/// This is a static version that you can use without an instruction; /// available.; /// @returns the strict version of comparison provided in \p pred.; /// If \p pred is not a strict comparison predicate, returns \p pred.; /// Returns the strict version of non-strict comparisons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:74,avail,available,74,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['avail'],['available']
Availability,"/// This is a static version that you can use without an instruction; /// available.; /// @returns true if the comparison predicate is non-strict, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:74,avail,available,74,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['avail'],['available']
Availability,"/// This is a static version that you can use without an instruction; /// available.; /// @returns true if the comparison predicate is strict, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:74,avail,available,74,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['avail'],['available']
Availability,/// This is a static version that you can use without an instruction; /// available.; /// Return the flipped strictness of predicate,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:74,avail,available,74,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['avail'],['available']
Availability,/// This is a static version that you can use without an instruction; /// available.; /// Return the predicate as if the operands were swapped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:74,avail,available,74,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['avail'],['available']
Availability,/// This is actually not an error but a marker to indicate that; /// the instruction stream is paused.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/Stage.h:28,error,error,28,interpreter/llvm-project/llvm/include/llvm/MCA/Stages/Stage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/Stage.h,1,['error'],['error']
Availability,"/// This is an alternative analysis pass to MachineBlockFrequencyInfo.; /// The difference is that with this pass, the block frequencies are not; /// computed when the analysis pass is executed but rather when the BFI result; /// is explicitly requested by the analysis client.; ///; /// This works by checking querying if MBFI is available and otherwise; /// generating MBFI on the fly. In this case the passes required for (LI, DT); /// are also queried before being computed on the fly.; ///; /// Note that it is expected that we wouldn't need this functionality for the; /// new PM since with the new PM, analyses are executed on demand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h:331,avail,available,331,interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h,1,['avail'],['available']
Availability,/// This is an implementation of the grow() method which only works; /// on POD-like data types and is out of line to reduce code duplication.; /// This function will report a fatal error if it cannot increase capacity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:182,error,error,182,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['error'],['error']
Availability,"/// This is an implementation of the grow() method which only works; /// on POD-like data types and is out of line to reduce code duplication.; /// This function will report a fatal error if it cannot increase capacity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:182,error,error,182,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['error'],['error']
Availability,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:386,mask,masked,386,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['masked']
Availability,"/// This is deprecated now and only used by the function API below.; /// \p PassName is the name of the pass emitting this diagnostic. If; /// this name matches the regular expression given in -Rpass-analysis=, then; /// the diagnostic will be emitted. \p Fn is the function where the diagnostic; /// is being emitted. \p Loc is the location information to use in the; /// diagnostic. If line table information is available, the diagnostic will; /// include the source code location. \p Msg is the message to show. Note that; /// this class does not copy this message, so this reference must be valid for; /// the whole life time of the diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:414,avail,available,414,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['avail'],['available']
Availability,"/// This is deprecated now and only used by the function API below.; /// \p PassName is the name of the pass emitting this diagnostic. If; /// this name matches the regular expression given in -Rpass-analysis=, then; /// the diagnostic will be emitted. \p Fn is the function where the diagnostic; /// is being emitted. \p Loc is the location information to use in the; /// diagnostic. If line table information is available, the diagnostic will; /// include the source code location. \p Msg is the message to show. The; /// front-end will append its own message related to options that address; /// floating-point non-commutativity. Note that this class does not copy this; /// message, so this reference must be valid for the whole life time of the; /// diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:414,avail,available,414,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['avail'],['available']
Availability,"/// This is deprecated now and only used by the function API below.; /// \p PassName is the name of the pass emitting this diagnostic. If; /// this name matches the regular expression given in -Rpass-analysis=, then; /// the diagnostic will be emitted. \p Fn is the function where the diagnostic; /// is being emitted. \p Loc is the location information to use in the; /// diagnostic. If line table information is available, the diagnostic will; /// include the source code location. \p Msg is the message to show. The; /// front-end will append its own message related to options that address; /// pointer aliasing legality. Note that this class does not copy this; /// message, so this reference must be valid for the whole life time of the; /// diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:414,avail,available,414,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['avail'],['available']
Availability,"/// This is deprecated now and only used by the function API below.; /// \p PassName is the name of the pass emitting this diagnostic. If; /// this name matches the regular expression given in -Rpass-missed=, then the; /// diagnostic will be emitted. \p Fn is the function where the diagnostic; /// is being emitted. \p Loc is the location information to use in the; /// diagnostic. If line table information is available, the diagnostic; /// will include the source code location. \p Msg is the message to show.; /// Note that this class does not copy this message, so this reference; /// must be valid for the whole life time of the diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:412,avail,available,412,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['avail'],['available']
Availability,"/// This is deprecated now and only used by the function API below.; /// \p PassName is the name of the pass emitting this diagnostic. If; /// this name matches the regular expression given in -Rpass=, then the; /// diagnostic will be emitted. \p Fn is the function where the diagnostic; /// is being emitted. \p Loc is the location information to use in the; /// diagnostic. If line table information is available, the diagnostic; /// will include the source code location. \p Msg is the message to show.; /// Note that this class does not copy this message, so this reference; /// must be valid for the whole life time of the diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:405,avail,available,405,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['avail'],['available']
Availability,/// This is the base ObjectCache type which can be provided to an; /// ExecutionEngine for the purpose of avoiding compilation for Modules that; /// have already been compiled and an object file is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ObjectCache.h:198,avail,available,198,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ObjectCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ObjectCache.h,1,['avail'],['available']
Availability,"/// This is the main entry point for the type legalizer. This does a top-down; /// traversal of the dag, legalizing types as it goes. Returns ""true"" if it made; /// any changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp:73,down,down,73,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp,1,['down'],['down']
Availability,"/// This is the main entry point for the type legalizer. This does a; /// top-down traversal of the dag, legalizing types as it goes. Returns; /// ""true"" if it made any changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h:78,down,down,78,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,1,['down'],['down']
Availability,"/// This is the main method. It parses BrainF from in1; /// and returns the module with a function; /// void brainf(); /// containing the resulting code.; /// On error, it calls abort.; /// The caller must delete the returned module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h:162,error,error,162,interpreter/llvm-project/llvm/examples/BrainF/BrainF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h,1,['error'],['error']
Availability,"/// This is the underlying implementation of all of the; /// ConstantDataSequential::get methods. They all thunk down to here, providing; /// the correct element type. We take the bytes in as a StringRef because; /// we *want* an underlying ""char*"" to avoid TBAA type punning violations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:113,down,down,113,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp,1,['down'],['down']
Availability,"/// This is used by foldAnyOrAllBitsSet() to capture a source value (Root) and; /// the bit indexes (Mask) needed by a masked compare. If we're matching a chain; /// of 'and' ops, then we also need to capture the fact that we saw an; /// ""and X, 1"", so that's an extra return value for that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:101,Mask,Mask,101,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,2,"['Mask', 'mask']","['Mask', 'masked']"
Availability,/// This map contains entries for each virtual register that is currently; /// available in a physical register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:79,avail,available,79,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['avail'],['available']
Availability,"/// This method allocates a block of memory that is suitable for loading; /// dynamically generated code (e.g. JIT). An attempt to allocate; /// \p NumBytes bytes of virtual memory is made.; /// \p NearBlock may point to an existing allocation in which case; /// an attempt is made to allocate more memory near the existing block.; /// The actual allocated address is not guaranteed to be near the requested; /// address.; /// \p Flags is used to set the initial protection flags for the block; /// of the memory.; /// \p EC [out] returns an object describing any error that occurs.; ///; /// This method may allocate more than the number of bytes requested. The; /// actual number of bytes allocated is indicated in the returned; /// MemoryBlock.; ///; /// The start of the allocated block must be aligned with the; /// system allocation granularity (64K on Windows, page size on Linux).; /// If the address following \p NearBlock is not so aligned, it will be; /// rounded up to the next allocation granularity boundary.; ///; /// \r a non-null MemoryBlock if the function was successful,; /// otherwise a null MemoryBlock is with \p EC describing the error.; ///; /// Allocate mapped memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Memory.h:564,error,error,564,interpreter/llvm-project/llvm/include/llvm/Support/Memory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Memory.h,2,['error'],['error']
Availability,"/// This method attempts to allocate \p NumBytes bytes of virtual memory for; /// \p Purpose. \p NearBlock may point to an existing allocation, in which; /// case an attempt is made to allocate more memory near the existing block.; /// The actual allocated address is not guaranteed to be near the requested; /// address. \p Flags is used to set the initial protection flags for the; /// block of the memory. \p EC [out] returns an object describing any error; /// that occurs.; ///; /// This method may allocate more than the number of bytes requested. The; /// actual number of bytes allocated is indicated in the returned; /// MemoryBlock.; ///; /// The start of the allocated block must be aligned with the system; /// allocation granularity (64K on Windows, page size on Linux). If the; /// address following \p NearBlock is not so aligned, it will be rounded up; /// to the next allocation granularity boundary.; ///; /// \r a non-null MemoryBlock if the function was successful, otherwise a; /// null MemoryBlock with \p EC describing the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h:454,error,error,454,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,2,['error'],['error']
Availability,"/// This method checks a requirement that must be satisfied by the value on the; /// given Side of a bitwise shift operator in well-defined code. If the; /// requirement is incompatible with prior knowledge, this method reports; /// failure by returning false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:233,failure,failure,233,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,1,['failure'],['failure']
Availability,"/// This method checks the availability of the load/store buffers.; ///; /// Returns LSU_AVAILABLE if there are enough load/store queue entries to; /// accomodate instruction IR. By default, LSU_AVAILABLE is returned if IR is; /// not a memory operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:27,avail,availability,27,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['avail'],['availability']
Availability,/// This method computes the appropriate section to emit the specified global; /// variable or function definition. This should not be passed external (or; /// available externally) globals.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetLoweringObjectFile.h:160,avail,available,160,interpreter/llvm-project/llvm/include/llvm/Target/TargetLoweringObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetLoweringObjectFile.h,4,['avail'],['available']
Availability,"/// This method determines which of the registers reported by; /// TargetRegisterInfo::getCalleeSavedRegs() should actually get saved.; /// The default implementation checks populates the \p SavedRegs bitset with; /// all registers which are modified in the function, targets may override; /// this function to save additional registers.; /// This method also sets up the register scavenger ensuring there is a free; /// register or a frameindex available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:446,avail,available,446,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,1,['avail'],['available']
Availability,"/// This method determines which of the registers reported by; /// TargetRegisterInfo::getCalleeSavedRegs() should actually get saved.; /// The default implementation checks populates the \p SavedRegs bitset with; /// all registers which are modified in the function, targets may override; /// this function to save additional registers.; /// This method also sets up the register scavenger ensuring there is a free; /// register or a frameindex available.; /// This method should not be called by any passes outside of PEI, because; /// it may change state passed in by \p MF and \p RS. The preferred; /// interface outside PEI is getCalleeSaves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:446,avail,available,446,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,1,['avail'],['available']
Availability,"/// This method executes the specified module and diffs the output against the; /// file specified by ReferenceOutputFile. If the output is different, 1 is; /// returned. If there is a problem with the code generator (e.g., llc; /// crashes), this will return -1 and set Error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:271,Error,Error,271,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,1,['Error'],['Error']
Availability,"/// This method expands the same instruction that MipsSEInstrInfo::; /// expandBuildPairF64 does, for the case when ABI is fpxx and mthc1 is not; /// available and the case where the ABI is FP64A. It is implemented here; /// because frame indexes are eliminated before MipsSEInstrInfo::; /// expandBuildPairF64 is called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:150,avail,available,150,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,1,['avail'],['available']
Availability,"/// This method expands the same instruction that MipsSEInstrInfo::; /// expandExtractElementF64 does, for the case when ABI is fpxx and mfhc1 is not; /// available and the case where the ABI is FP64A. It is implemented here; /// because frame indexes are eliminated before MipsSEInstrInfo::; /// expandExtractElementF64 is called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:155,avail,available,155,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,1,['avail'],['available']
Availability,"/// This method gets called from the constructor and is; /// where we setup the InstrWaitCntInfo vector.; /// The core logic for determining which CNTs an instruction; /// interacts with is taken from SIInsertWaitcnts::updateEventWaitcntAfter().; /// Unfortunately, some of the logic from that function is not available to us; /// in this scope so we conservatively end up assuming that some; /// instructions interact with more CNTs than they do in reality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.h:310,avail,available,310,interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.h,1,['avail'],['available']
Availability,"/// This method is called when object loading is complete and section page; /// permissions can be applied. It is up to the memory manager implementation; /// to decide whether or not to act on this method. The memory manager will; /// typically allocate all sections as read-write and then apply specific; /// permissions when this method is called. Code sections cannot be executed; /// until this function has been called. In addition, any cache coherency; /// operations needed to reliably use the memory are also performed.; ///; /// Returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:485,reliab,reliably,485,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,2,"['error', 'reliab']","['error', 'reliably']"
Availability,"/// This method releases a block of memory that was allocated with the; /// allocateMappedMemory method. It should not be used to release any memory; /// block allocated any other way.; /// \p Block describes the memory to be released.; ///; /// \r error_success if the function was successful, or an error_code; /// describing the failure if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h:332,failure,failure,332,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// This method releases a block of memory that was allocated with the; /// allocateMappedMemory method. It should not be used to release any; /// memory block allocated any other way.; /// \p Block describes the memory to be released.; ///; /// \r error_success if the function was successful, or an error_code; /// describing the failure if an error occurred.; ///; /// Release mapped memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Memory.h:332,failure,failure,332,interpreter/llvm-project/llvm/include/llvm/Support/Memory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Memory.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// This method sets the protection flags for a block of memory to the state; /// specified by \p Flags. The behavior is not specified if the memory was; /// not allocated using the allocateMappedMemory method.; /// \p Block describes the memory block to be protected.; /// \p Flags specifies the new protection state to be assigned to the block.; ///; /// If \p Flags is MF_WRITE, the actual behavior varies with the operating; /// system (i.e. MF_READ | MF_WRITE on Windows) and the target architecture; /// (i.e. MF_WRITE -> MF_READ | MF_WRITE on i386).; ///; /// \r error_success if the function was successful, or an error_code; /// describing the failure if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h:653,failure,failure,653,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// This method sets the protection flags for a block of memory to the; /// state specified by /p Flags. The behavior is not specified if the; /// memory was not allocated using the allocateMappedMemory method.; /// \p Block describes the memory block to be protected.; /// \p Flags specifies the new protection state to be assigned to the block.; ///; /// If \p Flags is MF_WRITE, the actual behavior varies; /// with the operating system (i.e. MF_READ | MF_WRITE on Windows) and the; /// target architecture (i.e. MF_WRITE -> MF_READ | MF_WRITE on i386).; ///; /// \r error_success if the function was successful, or an error_code; /// describing the failure if an error occurred.; ///; /// Set memory protection state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Memory.h:653,failure,failure,653,interpreter/llvm-project/llvm/include/llvm/Support/Memory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Memory.h,2,"['error', 'failure']","['error', 'failure']"
Availability,"/// This node is generated when a using-declaration that was annotated with; /// __attribute__((using_if_exists)) failed to resolve to a known declaration.; /// In that case, Sema builds a UsingShadowDecl whose target is an instance of; /// this declaration, adding it to the current scope. Referring to this; /// declaration in any way is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:343,error,error,343,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['error'],['error']
Availability,/// This operation is completely unsupported on the target. A programming; /// error has occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h:79,error,error,79,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h,2,['error'],['error']
Availability,/// This overload provides a more efficient implementation of; /// FindAvailableLoadedValue() for the case where we are not interested in; /// finding the closest clobbering instruction if no available load is found.; /// This overload cannot be used to scan across multiple blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:192,avail,available,192,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,1,['avail'],['available']
Availability,/// This parameter (which must have pointer-to-pointer type) uses; /// the special Swift error-result ABI treatment. There can be at; /// most one parameter on a given function that uses this treatment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Specifiers.h:89,error,error-result,89,interpreter/llvm-project/clang/include/clang/Basic/Specifiers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Specifiers.h,1,['error'],['error-result']
Availability,/// This pass adds keep-alive edge from SEH frame sections; /// to the parent function content block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h:24,alive,alive,24,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h,1,['alive'],['alive']
Availability,/// This pass expands the vector predication intrinsics into unpredicated; /// instructions with selects or just the explicit vector length into the; /// predicate mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:164,mask,mask,164,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['mask'],['mask']
Availability,"/// This performs an expansion of the integer result for a fixed point; /// multiplication. The default expansion performs rounding down towards; /// negative infinity, though targets that do care about rounding should specify; /// a target hook for rounding and provide their own expansion or lowering of; /// fixed point multiplication to be consistent with rounding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:132,down,down,132,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['down'],['down']
Availability,"/// This placement form of operator new[] uses the MCContext's allocator for; /// obtaining memory. It is a non-throwing new[], which means that it returns; /// null on error.; /// Usage looks like this (assuming there's an MCContext 'Context' in scope):; /// \code; /// // Default alignment (8); /// char *data = new (Context) char[10];; /// // Specific alignment; /// char *data = new (Context, 4) char[10];; /// \endcode; /// Please note that you cannot use delete on the pointer; it must be; /// deallocated using an explicit destructor call followed by; /// \c Context.Deallocate(Ptr).; ///; /// \param Bytes The number of bytes to allocate. Calculated by the compiler.; /// \param C The MCContext that provides the allocator.; /// \param Alignment The alignment of the allocated memory (if the underlying; /// allocator supports it).; /// \return The allocated memory. Could be NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h:169,error,error,169,interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,1,['error'],['error']
Availability,"/// This reads the \p Size bytes into a buffer pointed by \p Ptr.; ///; /// \param Ptr The start of the buffer to hold data to be read.; ///; /// \param Size The number of bytes to be read.; ///; /// On success, the number of bytes read is returned, and the file position is; /// advanced by this number. On error, -1 is returned, use error() to get the; /// error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:308,error,error,308,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,3,['error'],['error']
Availability,/// This removes the temporary file (unless it already was committed); /// but keeps the memory mapping alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileOutputBuffer.h:104,alive,alive,104,interpreter/llvm-project/llvm/include/llvm/Support/FileOutputBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileOutputBuffer.h,1,['alive'],['alive']
Availability,/// This represents '#pragma omp error' directive.; ///; /// \code; /// #pragma omp error; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:33,error,error,33,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,2,['error'],['error']
Availability,"/// This represents '#pragma omp masked taskloop simd' directive.; ///; /// \code; /// #pragma omp masked taskloop simd private(a,b) grainsize(val) num_tasks(num); /// \endcode; /// In this example directive '#pragma omp masked taskloop simd' has clauses; /// 'private' with the variables 'a' and 'b', 'grainsize' with expression 'val'; /// and 'num_tasks' with expression 'num'.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:33,mask,masked,33,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,3,['mask'],['masked']
Availability,"/// This represents '#pragma omp masked taskloop' directive.; ///; /// \code; /// #pragma omp masked taskloop private(a,b) grainsize(val) num_tasks(num); /// \endcode; /// In this example directive '#pragma omp masked taskloop' has clauses; /// 'private' with the variables 'a' and 'b', 'grainsize' with expression 'val'; /// and 'num_tasks' with expression 'num'.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:33,mask,masked,33,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,3,['mask'],['masked']
Availability,/// This represents '#pragma omp masked' directive.; /// \code; /// #pragma omp masked filter(tid); /// \endcode; /// This example shows a directive '#pragma omp masked' with a filter clause; /// with variable 'tid'.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:33,mask,masked,33,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,3,['mask'],['masked']
Availability,"/// This represents '#pragma omp parallel masked taskloop simd' directive.; ///; /// \code; /// #pragma omp parallel masked taskloop simd private(a,b) grainsize(val); /// num_tasks(num); /// \endcode; /// In this example directive '#pragma omp parallel masked taskloop simd' has; /// clauses 'private' with the variables 'a' and 'b', 'grainsize' with; /// expression 'val' and 'num_tasks' with expression 'num'.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:42,mask,masked,42,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,3,['mask'],['masked']
Availability,"/// This represents '#pragma omp parallel masked taskloop' directive.; ///; /// \code; /// #pragma omp parallel masked taskloop private(a,b) grainsize(val); /// num_tasks(num); /// \endcode; /// In this example directive '#pragma omp parallel masked taskloop' has clauses; /// 'private' with the variables 'a' and 'b', 'grainsize' with expression 'val'; /// and 'num_tasks' with expression 'num'.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:42,mask,masked,42,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,3,['mask'],['masked']
Availability,/// This represents '#pragma omp parallel masked' directive.; ///; /// \code; /// #pragma omp parallel masked filter(tid); /// \endcode; /// In this example directive '#pragma omp parallel masked' has a clause; /// 'filter' with the variable tid; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:42,mask,masked,42,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,3,['mask'],['masked']
Availability,/// This represents 'at' clause in the '#pragma omp error' directive; ///; /// \code; /// #pragma omp error at(compilation); /// \endcode; /// In this example directive '#pragma omp error' has simple; /// 'at' clause with kind 'complilation'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:52,error,error,52,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,3,['error'],['error']
Availability,/// This represents 'filter' clause in the '#pragma omp ...' directive.; ///; /// \code; /// #pragma omp masked filter(tid); /// \endcode; /// In this example directive '#pragma omp masked' has 'filter' clause with; /// thread id.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:105,mask,masked,105,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,2,['mask'],['masked']
Availability,"/// This represents 'message' clause in the '#pragma omp error' directive; ///; /// \code; /// #pragma omp error message(""GNU compiler required.""); /// \endcode; /// In this example directive '#pragma omp error' has simple; /// 'message' clause with user error message of ""GNU compiler required."".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:57,error,error,57,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,4,['error'],['error']
Availability,/// This represents 'severity' clause in the '#pragma omp error' directive; ///; /// \code; /// #pragma omp error severity(fatal); /// \endcode; /// In this example directive '#pragma omp error' has simple; /// 'severity' clause with kind 'fatal'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:58,error,error,58,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,3,['error'],['error']
Availability,"/// This represents an ""assembler immediate"".; ///; /// In its most general form, this can hold "":Kind:(SymbolA - SymbolB +; /// imm64)"". Not all targets supports relocations of this general form, but we; /// need to represent this anyway.; ///; /// In general both SymbolA and SymbolB will also have a modifier; /// analogous to the top-level Kind. Current targets are not expected; /// to make use of both though. The choice comes down to whether; /// relocation modifiers apply to the closest symbol or the whole; /// expression.; ///; /// Note that this class must remain a simple POD value class, because we need; /// it to live in unions etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCValue.h:433,down,down,433,interpreter/llvm-project/llvm/include/llvm/MC/MCValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCValue.h,1,['down'],['down']
Availability,"/// This returns a reference to a raw_ostream for standard error.; /// Use it like: errs() << ""foo"" << ""bar"";; /// By default, the stream is tied to stdout to ensure stdout is flushed before; /// stderr is written, to ensure the error messages are written in their; /// expected place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:59,error,error,59,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,2,['error'],['error']
Availability,"/// This routine notifies the Scheduler that a new cycle just started.; ///; /// It notifies the underlying ResourceManager that a new cycle just started.; /// Vector `Freed` is populated with resourceRef related to resources that; /// have changed in state, and that are now available to new instructions.; /// Instructions executed are added to vector Executed, while vector Ready is; /// populated with instructions that have become ready in this new cycle.; /// Vector Pending is popluated by instructions that have transitioned through; /// the pending stat during this cycle. The Pending and Ready sets may not be; /// disjoint. An instruction is allowed to transition from the WAIT state to; /// the READY state (going through the PENDING state) within a single cycle.; /// That means, instructions may appear in both the Pending and Ready set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:276,avail,available,276,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['avail'],['available']
Availability,"/// This should be called whenever the preprocessor encounters include; /// directives. It does not say whether the file has been included, but it; /// provides more information about the directive (hash location instead; /// of location inside the included file). It is assumed that the matching; /// FileChanged() or FileSkipped() is called after this (or neither is; /// called if this #include results in an error or does not textually include; /// anything).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:412,error,error,412,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,1,['error'],['error']
Availability,/// This struct defines the shadow mapping using the rule:; /// shadow = ((mem & mask) >> Scale) ADD DynamicShadowOffset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:81,mask,mask,81,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,1,['mask'],['mask']
Availability,/// This switch disables formation of double/multi instructions that could; /// potentially lead to (new) alignment traps even with CCR.UNALIGN_TRP; /// disabled. This can be used to create libraries that are robust even when; /// users provoke undefined behaviour by supplying misaligned pointers.; /// \see mayCombineMisaligned(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:209,robust,robust,209,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['robust'],['robust']
Availability,"/// This test shows how push-pull is unsuited for load balancing; messages are just sent to the first available pull; /// socket without any dynamic load balancing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ_load_balancing.cxx:102,avail,available,102,roofit/roofitZMQ/test/test_ZMQ_load_balancing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ_load_balancing.cxx,1,['avail'],['available']
Availability,"/// This vector is parallel to RegMaskSlots, it holds a pointer to the; /// corresponding register mask. This pointer can be recomputed as:; ///; /// MI = Indexes->getInstructionFromIndex(RegMaskSlot[N]);; /// unsigned OpNum = findRegMaskOperand(MI);; /// RegMaskBits[N] = MI->getOperand(OpNum).getRegMask();; ///; /// This is kept in a separate vector partly because some standard; /// libraries don't support lower_bound() with mixed objects, partly to; /// improve locality when searching in RegMaskSlots.; /// Also see the comment in LiveInterval::find().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:99,mask,mask,99,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,1,['mask'],['mask']
Availability,"/// This wrapper is used to ensure that only StringRefs originating from the; /// CheckerRegistry are used as check names. We want to make sure all checker; /// name strings have a lifetime that keeps them alive at least until the path; /// diagnostics have been processed, since they are expected to be constexpr; /// string literals (most likely generated by TblGen).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h:206,alive,alive,206,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h,1,['alive'],['alive']
Availability,"/// This writes the current ""Program"" to the named bitcode file. If an error; /// occurs, true is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:71,error,error,71,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,2,['error'],['error']
Availability,"/// To create a buffer resource from a 64-bit pointer, mask off the upper 32; /// bits of the pointer and replace them with the stride argument, then; /// merge_values everything together. In the common case of a raw buffer (the; /// stride component is 0), we can just AND off the upper half.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['mask'],['mask']
Availability,"/// Track expression value back to its point of origin.; ///; /// \param E The expression value which we are tracking; /// \param N A node ""downstream"" from the evaluation of the statement.; /// \param Opts Tracking options specifying how we want to track the value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h:140,down,downstream,140,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h,1,['down'],['downstream']
Availability,"/// Track the current register pressure at some position in the instruction; /// stream, and remember the high water mark within the region traversed. This; /// does not automatically consider live-through ranges. The client may; /// independently adjust for global liveness.; ///; /// Each RegPressureTracker only works within a MachineBasicBlock. Pressure can; /// be tracked across a larger region by storing a RegisterPressure result at; /// each block boundary and explicitly adjusting pressure to account for block; /// live-in and live-out register sets.; ///; /// RegPressureTracker holds a reference to a RegisterPressure result that it; /// computes incrementally. During downward tracking, P.BottomIdx or P.BottomPos; /// is invalid until it reaches the end of the block or closeRegion() is; /// explicitly called. Similarly, P.TopIdx is invalid during upward; /// tracking. Changing direction has the side effect of closing region, and; /// traversing past TopIdx or BottomIdx reopens it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:682,down,downward,682,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,1,['down'],['downward']
Availability,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:937,avail,available,937,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avail'],['available']
Availability,"/// Tracker for what values are in machine locations. Listens to the Things; /// being Done by various instructions, and maintains a table of what machine; /// locations have what values (as defined by a ValueIDNum).; ///; /// There are potentially a much larger number of machine locations on the; /// target machine than the actual working-set size of the function. On x86 for; /// example, we're extremely unlikely to want to track values through control; /// or debug registers. To avoid doing so, MLocTracker has several layers of; /// indirection going on, described below, to avoid unnecessarily tracking; /// any location.; ///; /// Here's a sort of diagram of the indexes, read from the bottom up:; ///; /// Size on stack Offset on stack; /// \ /; /// Stack Idx (Where in slot is this?); /// /; /// /; /// Slot Num (%stack.0) /; /// FrameIdx => SpillNum /; /// \ /; /// SpillID (int) Register number (int); /// \ /; /// LocationID => LocIdx; /// |; /// LocIdx => ValueIDNum; ///; /// The aim here is that the LocIdx => ValueIDNum vector is just an array of; /// values in numbered locations, so that later analyses can ignore whether the; /// location is a register or otherwise. To map a register / spill location to; /// a LocIdx, you have to use the (sparse) LocationID => LocIdx map. And to; /// build a LocationID for a stack slot, you need to combine identifiers for; /// which stack slot it is and where within that slot is being described.; ///; /// Register mask operands cause trouble by technically defining every register;; /// various hacks are used to avoid tracking registers that are never read and; /// only written by regmasks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:1476,mask,mask,1476,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['mask'],['mask']
Availability,"/// Tracks responsibility for materialization, and mediates interactions between; /// MaterializationUnits and JDs.; ///; /// An instance of this class is passed to MaterializationUnits when their; /// materialize method is called. It allows MaterializationUnits to resolve and; /// emit symbols, or abandon materialization by notifying any unmaterialized; /// symbols of an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:375,error,error,375,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['error'],['error']
Availability,"/// Tracks the expressions that are a control dependency of the node that was; /// supplied to the constructor.; /// For example:; ///; /// cond = 1;; /// if (cond); /// 10 / 0;; ///; /// An error is emitted at line 3. This visitor realizes that the branch; /// on line 2 is a control dependency of line 3, and tracks it's condition via; /// trackExpressionValue().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:191,error,error,191,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['error'],['error']
Availability,"/// Transfer the name from V to this value.; ///; /// After taking V's name, sets V's name to empty.; ///; /// \note It is an error to call V->takeName(V).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h:126,error,error,126,interpreter/llvm-project/llvm/include/llvm/IR/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h,1,['error'],['error']
Availability,"/// Transform a lanemask given for a virtual register to the corresponding; /// lanemask before using subregister with index \p IdxA.; /// This is the reverse of composeSubRegIndexLaneMask(), assuming Mask is a; /// valie lane mask (no invalid bits set) the following holds:; /// X0 = composeSubRegIndexLaneMask(Idx, Mask); /// X1 = reverseComposeSubRegIndexLaneMask(Idx, X0); /// => X1 == Mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:201,Mask,Mask,201,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,4,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Transform a shuffle mask's output demanded element mask into demanded; /// element masks for the 2 operands, returns false if the mask isn't valid.; /// Both \p DemandedLHS and \p DemandedRHS are initialised to [SrcWidth].; /// \p AllowUndefElts permits ""-1"" indices to be treated as undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:24,mask,mask,24,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,4,['mask'],"['mask', 'masks']"
Availability,"/// Transform the given list of expressions.; ///; /// This routine transforms a list of expressions by invoking; /// \c TransformExpr() for each subexpression. However, it also provides; /// support for variadic templates by expanding any pack expansions (if the; /// derived class permits such expansion) along the way. When pack expansions; /// are present, the number of outputs may not equal the number of inputs.; ///; /// \param Inputs The set of expressions to be transformed.; ///; /// \param NumInputs The number of expressions in \c Inputs.; ///; /// \param IsCall If \c true, then this transform is being performed on; /// function-call arguments, and any arguments that should be dropped, will; /// be.; ///; /// \param Outputs The transformed input expressions will be added to this; /// vector.; ///; /// \param ArgChanged If non-NULL, will be set \c true if any argument changed; /// due to transformation.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:953,error,error,953,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['error'],['error']
Availability,"/// Transform the given set of template arguments.; ///; /// By default, this operation transforms all of the template arguments; /// in the input set using \c TransformTemplateArgument(), and appends; /// the transformed arguments to the output list.; ///; /// Note that this overload of \c TransformTemplateArguments() is merely; /// a convenience function. Subclasses that wish to override this behavior; /// should override the iterator-based member template version.; ///; /// \param Inputs The set of template arguments to be transformed.; ///; /// \param NumInputs The number of template arguments in \p Inputs.; ///; /// \param Outputs The set of transformed template arguments output by this; /// routine.; ///; /// Returns true if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:744,error,error,744,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['error'],['error']
Availability,"/// Transform the given set of template arguments.; ///; /// By default, this operation transforms all of the template arguments; /// in the input set using \c TransformTemplateArgument(), and appends; /// the transformed arguments to the output list.; ///; /// \param First An iterator to the first template argument.; ///; /// \param Last An iterator one step past the last template argument.; ///; /// \param Outputs The set of transformed template arguments output by this; /// routine.; ///; /// Returns true if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:520,error,error,520,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['error'],['error']
Availability,"/// Transform the given template argument.; ///; /// By default, this operation transforms the type, expression, or; /// declaration stored within the template argument and constructs a; /// new template argument from the transformed result. Subclasses may; /// override this function to provide alternate behavior.; ///; /// Returns true if there was an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:355,error,error,355,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['error'],['error']
Availability,/// Transforms a single function-type parameter. Return null; /// on error.; ///; /// \param indexAdjustment - A number to add to the parameter's; /// scope index; can be negative,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,error,error,69,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['error'],['error']
Availability,/// Transforms mask \p CommonMask per given \p Mask to make proper set after; /// shuffle emission.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,4,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Transforms the parameters of a function type into the; /// given vectors.; ///; /// The result vectors should be kept in sync; null entries in the; /// variables vector are acceptable.; ///; /// LastParamTransformed, if non-null, will be set to the index of the last; /// parameter on which transfromation was started. In the event of an error,; /// this will contain the parameter which failed to instantiate.; ///; /// Return true on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:342,error,error,342,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['error'],['error']
Availability,"/// Traverse all matching ELFT::Rel relocation records in the given section.; /// The handler function Func should be callable with this signature:; /// Error(const typename ELFT::Rel &,; /// const typename ELFT::Shdr &, Section &); ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h:153,Error,Error,153,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,1,['Error'],['Error']
Availability,"/// Traverse all matching ELFT::Rela relocation records in the given section.; /// The handler function Func should be callable with this signature:; /// Error(const typename ELFT::Rela &,; /// const typename ELFT::Shdr &, Section &); ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h:154,Error,Error,154,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,1,['Error'],['Error']
Availability,"/// Traverse all matching relocation records in the given section. The handler; /// function Func should be callable with this signature:; /// Error(const object::RelocationRef&,; /// const object::SectionRef&, Section &); ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.h:143,Error,Error,143,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.h,1,['Error'],['Error']
Availability,/// Tries to build a legal vector shuffle using the provided parameters; /// or equivalent variations. The Mask argument maybe be modified as the; /// function tries different variations.; /// Returns an empty SDValue if the operation fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:107,Mask,Mask,107,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Mask'],['Mask']
Availability,"/// Tries to combine 2 different masks into single one.; /// \param LocalVF Vector length of the permuted input vector. \p Mask may; /// change the size of the vector, \p LocalVF is the original size of the; /// shuffled vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,mask,masks,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Mask', 'mask']","['Mask', 'masks']"
Availability,/// Tries to constant fold a vector binop with sources \p Op1 and \p Op2.; /// Returns an empty vector on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h:106,failure,failure,106,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h,1,['failure'],['failure']
Availability,"/// Tries to evaluate the __builtin_object_size for @p E. If successful,; /// returns true and stores the result in @p Size.; ///; /// If @p WasError is non-null, this will report whether the failure to evaluate; /// is to be treated as an Error in IntExprEvaluator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:192,failure,failure,192,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,2,"['Error', 'failure']","['Error', 'failure']"
Availability,"/// Tries to find the node under this \c FileMatchTrieNode that best; /// matches 'FileName'.; ///; /// If multiple paths fit 'FileName' equally well, \c IsAmbiguous is set to; /// \c true and an empty string is returned. If no path fits 'FileName', an; /// empty string is returned. \c ConsumedLength denotes the number of; /// \c Filename's trailing characters already consumed during recursion.; ///; /// To find the best matching node for a given path 'p', the; /// \c findEquivalent() function is called recursively for each path segment; /// (back to front) of 'p' until a node 'n' is reached that does not ..; /// - .. have children. In this case it is checked; /// whether the stored path is equivalent to 'p'. If yes, the best match is; /// found. Otherwise continue with the parent node as if this node did not; /// exist.; /// - .. a child matching the next path segment. In this case, all children of; /// 'n' are an equally good match for 'p'. All children are of 'n' are found; /// recursively and their equivalence to 'p' is determined. If none are; /// equivalent, continue with the parent node as if 'n' didn't exist. If one; /// is equivalent, the best match is found. Otherwise, report and ambigiuity; /// error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp:1225,error,error,1225,interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,1,['error'],['error']
Availability,"/// Tries to hide the latency of runtime calls that involve host to; /// device memory transfers by splitting them into their ""issue"" and ""wait""; /// versions. The ""issue"" is moved upwards as much as possible. The ""wait"" is; /// moved downards as much as possible. The ""issue"" issues the memory transfer; /// asynchronously, returning a handle. The ""wait"" waits in the returned; /// handle for the memory transfer to finish.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:235,down,downards,235,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['down'],['downards']
Availability,/// Tries to infer the deployment target from the SDK specified by -isysroot; /// (or SDKROOT). Uses the version specified in the SDKSettings.json file if; /// it's available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:165,avail,available,165,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['avail'],['available']
Availability,/// Tries to load options from configuration files.; ///; /// \returns true if error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:79,error,error,79,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['error'],['error']
Availability,/// Tries to load options from default configuration files (deduced from; /// executable filename).; ///; /// \returns true if error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:127,error,error,127,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['error'],['error']
Availability,"/// Tries to lock the underlying file within the specified period.; ///; /// @returns RAII object that releases the lock upon leaving the scope, if the; /// locking was successful. Otherwise returns corresponding; /// error code.; ///; /// It is used as @ref lock.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:218,error,error,218,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['error'],['error']
Availability,"/// Tries to remove the given symbols.; ///; /// If any symbols are not defined in this JITDylib this method will return; /// a SymbolsNotFound error covering the missing symbols.; ///; /// If all symbols are found but some symbols are in the process of being; /// materialized this method will return a SymbolsCouldNotBeRemoved error.; ///; /// On success, all symbols are removed. On failure, the JITDylib state is; /// left unmodified (no symbols are removed).; ///; /// It is illegal to call this method on a defunct JITDylib and the client; /// is responsible for ensuring that they do not do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:144,error,error,144,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,3,"['error', 'failure']","['error', 'failure']"
Availability,"/// Trigger the invalidation of some other analysis pass if not already; /// handled and return whether it was in fact invalidated.; ///; /// This is expected to be called from within a given analysis result's \c; /// invalidate method to trigger a depth-first walk of all inter-analysis; /// dependencies. The same \p IR unit and \p PA passed to that result's \c; /// invalidate method should in turn be provided to this routine.; ///; /// The first time this is called for a given analysis pass, it will call; /// the corresponding result's \c invalidate method. Subsequent calls will; /// use a cache of the results of that initial call. It is an error to form; /// cyclic dependencies between analysis results.; ///; /// This returns true if the given analysis's result is invalid. Any; /// dependecies on it will become invalid as a result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:650,error,error,650,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['error'],['error']
Availability,"/// True if GV can be left out of the object symbol table. This is the case; /// for linkonce_odr values whose address is not significant. While legal, it; /// is not normally profitable to omit them from the .o symbol table. Using; /// this analysis makes sense when the information can be passed down to the; /// linker or we are in LTO.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:298,down,down,298,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,1,['down'],['down']
Availability,/// True if an error has occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:15,error,error,15,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['error'],['error']
Availability,/// True if the function contains operations which will lower down to; /// instructions which manipulate the stack pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:62,down,down,62,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['down'],['down']
Availability,"/// True if the function recovers from an SEH exception, and therefore needs; /// to spill and restore the frame pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MachineFunctionInfo.h:25,recover,recovers,25,interpreter/llvm-project/llvm/lib/Target/X86/X86MachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MachineFunctionInfo.h,1,['recover'],['recovers']
Availability,/// True if this attribute is only available for certain targets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ParsedAttrInfo.h:35,avail,available,35,interpreter/llvm-project/clang/include/clang/Basic/ParsedAttrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ParsedAttrInfo.h,1,['avail'],['available']
Availability,/// True if this has the extra information associated with an; /// availability attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:67,avail,availability,67,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['avail'],['availability']
Availability,/// True if this symbol has sanitizer metadata available. Should only happen; /// if sanitizers were enabled when building the translation unit which; /// contains this GV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:47,avail,available,47,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,1,['avail'],['available']
Availability,"/// True if this value is determined to be identical to OtherVNI; /// (in valuesIdentical). This is used with CR_Erase where the erased; /// copy is redundant, i.e. the source value is already the same as; /// the destination. In such cases the subranges need to be updated; /// properly. See comment at pruneSubRegValues for more info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:149,redundant,redundant,149,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['redundant'],['redundant']
Availability,/// True to avoid tearing down the lexer etc on EOF,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:26,down,down,26,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['down'],['down']
Availability,/// True when visible conversion functions are already computed; /// and are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:77,avail,available,77,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['avail'],['available']
Availability,"/// Truncate using inreg zero extension (AND mask) and X86ISD::PACKUS.; /// e.g. trunc <8 x i32> X to <8 x i16> -->; /// MaskX = X & 0xffff (clear high bits to prevent saturation); /// packus (extract_subv MaskX, 0), (extract_subv MaskX, 1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,4,"['Mask', 'mask']","['MaskX', 'mask']"
Availability,"/// Try parsing a type-constraint at the current location.; ///; /// type-constraint:; /// nested-name-specifier[opt] concept-name; /// nested-name-specifier[opt] concept-name; /// '<' template-argument-list[opt] '>'[opt]; ///; /// \returns true if an error occurred, and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:252,error,error,252,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['error'],['error']
Availability,"/// Try recover parser when module annotation appears where it must not; /// be found.; /// \returns false if the recover was successful and parsing may be continued, or; /// true if parser must bail out to top level and handle the token there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:8,recover,recover,8,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,2,['recover'],['recover']
Availability,"/// Try to break down \p OrigTy into \p NarrowTy sized pieces.; ///; /// Returns the number of \p NarrowTy elements needed to reconstruct \p OrigTy,; /// with any leftover piece as type \p LeftoverTy; ///; /// Returns -1 in the first element of the pair if the breakdown is not; /// satisfiable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:17,down,down,17,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['down'],['down']
Availability,"/// Try to build PrecompiledPreamble for \p Invocation. See; /// BuildPreambleError for possible error codes.; ///; /// \param Invocation Original CompilerInvocation with options to compile the; /// file.; ///; /// \param MainFileBuffer Buffer with the contents of the main file.; ///; /// \param Bounds Bounds of the preamble, result of calling; /// ComputePreambleBounds.; ///; /// \param Diagnostics Diagnostics engine to be used while building the; /// preamble.; ///; /// \param VFS An instance of vfs::FileSystem to be used for file; /// accesses.; ///; /// \param PCHContainerOps An instance of PCHContainerOperations.; ///; /// \param StoreInMemory Store PCH in memory. If false, PCH will be stored in; /// a temporary file.; ///; /// \param StoragePath The path to a directory, in which to create a temporary; /// file to store PCH in. If empty, the default system temporary directory is; /// used. This parameter is ignored if \p StoreInMemory is true.; ///; /// \param Callbacks A set of callbacks to be executed when building; /// the preamble.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h:97,error,error,97,interpreter/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h,1,['error'],['error']
Availability,"/// Try to capture the given variable.; ///; /// \param Var The variable to capture.; ///; /// \param Loc The location at which the capture occurs.; ///; /// \param Kind The kind of capture, which may be implicit (for either a; /// block or a lambda), or explicit by-value or by-reference (for a lambda).; ///; /// \param EllipsisLoc The location of the ellipsis, if one is provided in; /// an explicit lambda capture.; ///; /// \param BuildAndDiagnose Whether we are actually supposed to add the; /// captures or diagnose errors. If false, this routine merely check whether; /// the capture can occur without performing the capture itself or complaining; /// if the variable cannot be captured.; ///; /// \param CaptureType Will be set to the type of the field used to capture; /// this variable in the innermost block or lambda. Only valid when the; /// variable can be captured.; ///; /// \param DeclRefType Will be set to the type of a reference to the capture; /// from within the current scope. Only valid when the variable can be; /// captured.; ///; /// \param FunctionScopeIndexToStopAt If non-null, it points to the index; /// of the FunctionScopeInfo stack beyond which we do not attempt to capture.; /// This is useful when enclosing lambdas must speculatively capture; /// variables that may or may not be used in certain specializations of; /// a nested generic lambda.; ///; /// \returns true if an error occurred (i.e., the variable cannot be; /// captured) and false if the capture succeeded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:523,error,errors,523,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['error'],"['error', 'errors']"
Availability,"/// Try to compile the specified module, returning false and setting Error if an; /// error occurs. This is used for code generation crash testing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:69,Error,Error,69,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// Try to convert a value of non-vector type to a vector type by converting; /// the type to the element type of the vector and then performing a splat.; /// If the language is OpenCL, we only use conversions that promote scalar; /// rank; for C, Obj-C, and C++ we allow any real scalar conversion except; /// for float->int.; ///; /// OpenCL V2.0 6.2.6.p2:; /// An error shall occur if any scalar operand type has greater rank; /// than the type of the vector element.; ///; /// \param scalar - if non-null, actually perform the conversions; /// \return true if the operation fails (but without diagnosing the failure)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:367,error,error,367,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,/// Try to create a StaticLibraryDefinitionGenerator from the given path.; ///; /// This call will succeed if the file at the given path is a static library; /// or a MachO universal binary containing a static library that is compatible; /// with the ExecutionSession's triple. Otherwise it will return an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h:306,error,error,306,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,1,['error'],['error']
Availability,"/// Try to create a StaticLibrarySearchGenerator from the given memory buffer.; /// This call will succeed if the buffer contains a valid archive, otherwise; /// it will return an error.; ///; /// This call will succeed if the buffer contains a valid static library or a; /// MachO universal binary containing a static library that is compatible; /// with the ExecutionSession's triple. Otherwise it will return an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h:180,error,error,180,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,2,['error'],['error']
Availability,"/// Try to emit a blend instruction for a shuffle.; ///; /// This doesn't do any checks for the availability of instructions for blending; /// these values. It relies on the availability of the X86ISD::BLENDI pattern to; /// be matched in the backend with the type given. What it does check for is; /// that the shuffle mask is a blend, or convertible into a blend with zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:96,avail,availability,96,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,"['avail', 'mask']","['availability', 'mask']"
Availability,"/// Try to ensure that the alignment of \p V is at least \p PrefAlign bytes. If; /// the owning object can be modified and has an alignment less than \p; /// PrefAlign, it will be increased and \p PrefAlign returned. If the alignment; /// cannot be increased, the known alignment of the value is returned.; ///; /// It is not always possible to modify the alignment of the underlying object,; /// so if alignment is important, a more reliable approach is to simply align; /// all global variables and allocation instructions to their preferred; /// alignment from the beginning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:434,reliab,reliable,434,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,1,['reliab'],['reliable']
Availability,"/// Try to evaluate the expression to a relocatable value, i.e. an; /// expression of the fixed form (a - b + constant).; ///; /// \param Res - The relocatable value, if evaluation succeeds.; /// \param Layout - The assembler layout object to use for evaluating values.; /// \param Fixup - The Fixup object if available.; /// \return - True on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h:310,avail,available,310,interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h,1,['avail'],['available']
Availability,"/// Try to evaluate the expression to the form (a - b + constant) where; /// neither a nor b are variables.; ///; /// This is a more aggressive variant of evaluateAsRelocatable. The intended; /// use is for when relocations are not available, like the .size directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h:232,avail,available,232,interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h,1,['avail'],['available']
Availability,"/// Try to find redundant insertvalue instructions, like the following ones:; /// %0 = insertvalue { i8, i32 } undef, i8 %x, 0; /// %1 = insertvalue { i8, i32 } %0, i8 %y, 0; /// Here the second instruction inserts values at the same indices, as the; /// first one, making the first one redundant.; /// It should be transformed to:; /// %0 = insertvalue { i8, i32 } undef, i8 %y, 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,redundant,redundant,16,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['redundant'],['redundant']
Availability,"/// Try to find the next source that share the same register file; /// for the value defined by \p Reg and \p SubReg.; /// When true is returned, the \p RewriteMap can be used by the client to; /// retrieve all Def -> Use along the way up to the next source. Any found; /// Use that is not itself a key for another entry, is the next source to; /// use. During the search for the next source, multiple sources can be found; /// given multiple incoming sources of a PHI instruction. In this case, we; /// look in each PHI source for the next source; all found next sources must; /// share the same register file as \p Reg and \p SubReg. The client should; /// then be capable to rewrite all intermediate PHIs to get the next source.; /// \return False if no alternative sources are available. True otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:781,avail,available,781,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['avail'],['available']
Availability,"/// Try to fold ((icmp X u< P) & (icmp(X & M) != M)) or ((icmp X s> -1) &; /// (icmp(X & M) != M)) into (icmp X u< M). Where P is a power of 2, M < P, and; /// M is a contiguous shifted mask starting at the right most significant zero; /// bit in P. SGT is supported as when P is the largest representable power of; /// 2, an earlier optimization converts the expression into (icmp X s> -1).; /// Parameter P supports masking using undef/poison in either scalar or vector; /// values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:186,mask,mask,186,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,2,['mask'],"['mask', 'masking']"
Availability,"/// Try to fold (icmp(A & B) == 0) & (icmp(A & D) != E) into (icmp A u< D) iff; /// B is a contiguous set of ones starting from the most significant bit; /// (negative power of 2), D and E are equal, and D is a contiguous set of ones; /// starting at the most significant zero bit in B. Parameter B supports masking; /// using undef/poison in either scalar or vector values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:308,mask,masking,308,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['masking']
Availability,"/// Try to fold (icmp(A & B) ==/!= 0) &/| (icmp(A & D) ==/!= E) into a single; /// (icmp(A & X) ==/!= Y), where the left-hand side and the right hand side; /// aren't of the common mask pattern type.; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:181,mask,mask,181,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['mask']
Availability,/// Try to fold an extract+insert element into an existing identity shuffle by; /// changing the shuffle's mask to include the index of this insert element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:107,mask,mask,107,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,/// Try to fold an insert element into an existing splat shuffle by changing; /// the shuffle's mask to include the index of this insert element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:96,mask,mask,96,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"/// Try to get the section at the given index. Will return an error if the; /// given index is out of range, or if no section has been added for the given; /// index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h:62,error,error,62,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,1,['error'],['error']
Availability,"/// Try to get the symbol at the given index. Will return an error if the; /// given index is out of range, or if no symbol has been added for the given; /// index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h:61,error,error,61,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,1,['error'],['error']
Availability,"/// Try to locks the file during the specified time.; ///; /// This function implements advisory locking on entire file. If it returns; /// <em>errc::success</em>, the file is locked by the calling process. Until the; /// process unlocks the file by calling \a unlockFile, all attempts to lock the; /// same file will fail/block. The process that locked the file may assume that; /// none of other processes read or write this file, provided that all processes; /// lock the file prior to accessing its content.; ///; /// @param FD The descriptor representing the file to lock.; /// @param Timeout Time in milliseconds that the process should wait before; /// reporting lock failure. Zero value means try to get lock only; /// once.; /// @returns errc::success if lock is successfully obtained,; /// errc::no_lock_available if the file cannot be locked, or platform-specific; /// error_code otherwise.; ///; /// @note Care should be taken when using this function in a multithreaded; /// context, as it may not prevent other threads in the same process from; /// obtaining a lock on the same file, even if they are using a different file; /// descriptor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:675,failure,failure,675,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['failure'],['failure']
Availability,"/// Try to lower a vector shuffle as a bit shift (shifts in zeros).; ///; /// Attempts to match a shuffle mask against the PSLL(W/D/Q/DQ) and; /// PSRL(W/D/Q/DQ) SSE2 and AVX2 logical bit-shift instructions. The function; /// matches elements from one of the input vectors shuffled to the left or; /// right with zeroable elements 'shifted in'. It handles both the strictly; /// bit-wise element shifts and the byte shift across an entire 128-bit double; /// quad word lane.; ///; /// PSHL : (little-endian) left bit shift.; /// [ zz, 0, zz, 2 ]; /// [ -1, 4, zz, -1 ]; /// PSRL : (little-endian) right bit shift.; /// [ 1, zz, 3, zz]; /// [ -1, -1, 7, zz]; /// PSLLDQ : (little-endian) left byte shift; /// [ zz, 0, 1, 2, 3, 4, 5, 6]; /// [ zz, zz, -1, -1, 2, 3, 4, -1]; /// [ zz, zz, zz, zz, zz, zz, -1, 1]; /// PSRLDQ : (little-endian) right byte shift; /// [ 5, 6, 7, zz, zz, zz, zz, zz]; /// [ -1, 5, 6, 7, zz, zz, zz, zz]; /// [ 1, 2, -1, -1, -1, -1, zz, zz]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:106,mask,mask,106,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"/// Try to lower a vector shuffle as a byte rotation.; ///; /// SSSE3 has a generic PALIGNR instruction in x86 that will do an arbitrary; /// byte-rotation of the concatenation of two vectors; pre-SSSE3 can use; /// a PSRLDQ/PSLLDQ/POR pattern to get a similar effect. This routine will; /// try to generically lower a vector shuffle through such an pattern. It; /// does not check for the profitability of lowering either as PALIGNR or; /// PSRLDQ/PSLLDQ/POR, only whether the mask is valid to lower in that form.; /// This matches shuffle vectors that look like:; ///; /// v8i16 [11, 12, 13, 14, 15, 0, 1, 2]; ///; /// Essentially it concatenates V1 and V2, shifts right by some number of; /// elements, and takes the low elements as the result. Note that while this is; /// specified as a *right shift* because x86 is little-endian, it is a *left; /// rotate* of the vector lanes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:478,mask,mask,478,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"/// Try to lower a vector shuffle as a zero extension on any microarch.; ///; /// This routine will try to do everything in its power to cleverly lower; /// a shuffle which happens to match the pattern of a zero extend. It doesn't; /// check for the profitability of this lowering, it tries to aggressively; /// match this pattern. It will use all of the micro-architectural details it; /// can to emit an efficient lowering. It handles both blends with all-zero; /// inputs to explicitly zero-extend and undef-lanes (sometimes undef due to; /// masking out later).; ///; /// The reason we have dedicated lowering for zext-style shuffles is that they; /// are both incredibly common and often quite performance sensitive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:546,mask,masking,546,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masking']
Availability,"/// Try to match Instruction ""I"" as a comparison against a constant and; /// populates the array Vals with the set of values that match (or do not; /// match depending on isEQ).; /// Return false on failure. On success, the Value the comparison matched; /// against is placed in CompValue.; /// If CompValue is already set, the function is expected to fail if a match; /// is found but the value compared to is different.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:199,failure,failure,199,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['failure'],['failure']
Availability,"/// Try to match M68kISD::Wrapper and M68kISD::WrapperPC nodes into an; /// addressing mode. These wrap things that will resolve down into a symbol; /// reference. If no match is possible, this returns true, otherwise it returns; /// false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:129,down,down,129,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,1,['down'],['down']
Availability,"/// Try to match X86ISD::Wrapper and X86ISD::WrapperRIP nodes into an addressing; /// mode. These wrap things that will resolve down into a symbol reference.; /// If no match is possible, this returns true, otherwise it returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:128,down,down,128,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['down'],['down']
Availability,/// Try to parse an Objective-C runtime specification from the given; /// string.; ///; /// \return true on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h:108,error,error,108,interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,1,['error'],['error']
Availability,/// Try to parse module and verify it. May output verification errors to the; /// errs().; /// \return New module or nullptr in case of error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FuzzMutate/IRMutator.h:63,error,errors,63,interpreter/llvm-project/llvm/include/llvm/FuzzMutate/IRMutator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FuzzMutate/IRMutator.h,2,['error'],"['error', 'errors']"
Availability,/// Try to parse the optional LLVM module and the machine functions in the MIR; /// file.; ///; /// Return null if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:118,error,error,118,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,1,['error'],['error']
Availability,"/// Try to recolor broken hints.; /// Broken hints may be repaired by recoloring when an evicted variable; /// freed up a register for a larger live-range.; /// Consider the following example:; /// BB1:; /// a =; /// b =; /// BB2:; /// ...; /// = b; /// = a; /// Let us assume b gets split:; /// BB1:; /// a =; /// b =; /// BB2:; /// c = b; /// ...; /// d = c; /// = d; /// = a; /// Because of how the allocation work, b, c, and d may be assigned different; /// colors. Now, if a gets evicted later:; /// BB1:; /// a =; /// st a, SpillSlot; /// b =; /// BB2:; /// c = b; /// ...; /// d = c; /// = d; /// e = ld SpillSlot; /// = e; /// This is likely that we can assign the same register for b, c, and d,; /// getting rid of 2 copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:58,repair,repaired,58,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['repair'],['repaired']
Availability,/// Try to recover by turning the given expression into a; /// call. Returns true if recovery was attempted or an error was; /// emitted; this may also leave the ExprResult invalid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:11,recover,recover,11,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,3,"['error', 'recover']","['error', 'recover', 'recovery']"
Availability,"/// Try to recover from invalid function values. When invalid function values; /// are encountered, a penalty term is returned to the minimiser to make it; /// back off. This sets the strength of this penalty. \note A strength of zero; /// is equivalent to a constant penalty (= the gradient vanishes, ROOT < 6.24).; /// Positive values lead to a gradient pointing away from the undefined; /// regions. Use ~10 to force the minimiser away from invalid function values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx:11,recover,recover,11,roofit/roofitcore/src/RooMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx,1,['recover'],['recover']
Availability,"/// Try to register the new write page size for the given column. Flush large columns to make space, if necessary.; /// If not enough space is available after all (sum of write pages would be larger than fMaxAllocatedBytes),; /// return false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:143,avail,available,143,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['avail'],['available']
Availability,/// Try to remove redundant dbg.value instructions from given basic block.; /// Returns true if at least one instruction was removed. Remove redundant; /// pseudo ops when RemovePseudoOp is true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:18,redundant,redundant,18,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,2,['redundant'],['redundant']
Availability,"/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.; /// For a target with a bit test, this is expected to become test + set and save; /// at least 1 instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,mask,mask,65,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"/// Try to shorten an expression with an initial constant operand.; /// Returns a new expression and constant on success, or the original; /// expression and constant on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h:170,failure,failure,170,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,1,['failure'],['failure']
Availability,/// Try to shrink a sdiv/srem's width down to the smallest power of two that's; /// sufficient to contain its operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:38,down,down,38,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['down'],['down']
Availability,/// Try to shrink a udiv/urem's width down to the smallest power of two that's; /// sufficient to contain its operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:38,down,down,38,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['down'],['down']
Availability,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:31,mask,mask,31,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,7,"['down', 'mask']","['down', 'mask']"
Availability,"/// Try to turn a call to \@llvm.objectsize into an integer value of the given; /// Type. Returns null on failure. If MustSucceed is true, this function will; /// not return null, and may return conservative values governed by the second; /// argument of the call to objectsize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:106,failure,failure,106,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,1,['failure'],['failure']
Availability,"/// Try to vectorize interleaved access group \p Group with the base address; /// given in \p Addr, optionally masking the vector operations if \p; /// BlockInMask is non-null. Use \p State to translate given VPValues to IR; /// values in the vectorized loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:111,mask,masking,111,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masking']
Availability,"/// TryAnnotateScopeToken - Like TryAnnotateTypeOrScopeToken but only; /// annotates C++ scope specifiers and template-ids. This returns; /// true if there was an error that could not be recovered from.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:163,error,error,163,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,3,"['error', 'recover']","['error', 'recovered']"
Availability,"/// TryAnnotateTypeOrScopeToken - If the current token position is on a; /// typename (possibly qualified in C++) or a C++ scope specifier not followed; /// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens; /// with a single annotation token representing the typename or C++ scope; /// respectively.; /// This simplifies handling of C++ scope specifiers and allows efficient; /// backtracking without the need to re-parse and resolve nested-names and; /// typenames.; /// It will mainly be called when we expect to treat identifiers as typenames; /// (if they are typenames). For example, in C we do not expect identifiers; /// inside expressions to be treated as typenames so it will not be called; /// for expressions in C.; /// The benefit for C/ObjC is that a typename will be annotated and; /// Actions.getTypeName will not be needed to be called again (e.g. getTypeName; /// will not be called twice, once to check whether we have a declaration; /// specifier, and another one to get the actual type inside; /// ParseDeclarationSpecifiers).; ///; /// This returns true if an error occurred.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:1107,error,error,1107,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,2,['error'],['error']
Availability,"/// TryImplicitConversion - Attempt to perform an implicit conversion; /// from the given expression (Expr) to the given type (ToType). This; /// function returns an implicit conversion sequence that can be used; /// to perform the initialization. Given; ///; /// void f(float f);; /// void g(int i) { f(i); }; ///; /// this routine would produce an implicit conversion sequence to; /// describe the initialization of f from i, which will be a standard; /// conversion sequence containing an lvalue-to-rvalue conversion (C++; /// 4.1) followed by a floating-integral conversion (C++ 4.9).; //; /// Note that this routine only determines how the conversion can be; /// performed; it does not actually perform the conversion. As such,; /// it will not produce any diagnostics if no conversion is available,; /// but will instead return an implicit conversion sequence of kind; /// ""BadConversion"".; ///; /// If @p SuppressUserConversions, then user-defined conversions are; /// not permitted.; /// If @p AllowExplicit, then explicit user-defined conversions are; /// permitted.; ///; /// \param AllowObjCWritebackConversion Whether we allow the Objective-C; /// writeback conversion, which allows __autoreleasing id* parameters to; /// be initialized with __strong id* or __weak id* arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:794,avail,available,794,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['avail'],['available']
Availability,"/// TryParseFunctionDeclarator - We parsed a '(' and we want to try to continue; /// parsing as a function declarator.; /// If TryParseFunctionDeclarator fully parsed the function declarator, it will; /// return TPResult::Ambiguous, otherwise it will return either False() or; /// Error().; ///; /// '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; /// exception-specification[opt]; ///; /// exception-specification:; /// 'throw' '(' type-id-list[opt] ')'; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:281,Error,Error,281,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['Error'],['Error']
Availability,/// TryStaticDowncast - Common functionality of TryStaticReferenceDowncast and; /// TryStaticPointerDowncast. Tests whether a static downcast from SrcType to; /// DestType is possible and allowed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:133,down,downcast,133,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['down'],['downcast']
Availability,"/// Turn ""(a cond b) ? 1.0f : 2.0f"" into ""load (tmp + ((a cond b) ? 0 : 4)""; /// where ""tmp"" is a constant pool entry containing an array with 1.0 and 2.0; /// in it. This may be a win when the constant is not otherwise available; /// because it replaces two constant pool loads with one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:220,avail,available,220,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avail'],['available']
Availability,/// Turn an or of two masked values into the rotate left word immediate then; /// mask insert (rlwimi) instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:22,mask,masked,22,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,2,['mask'],"['mask', 'masked']"
Availability,/// Turns an ISD::CondCode into a value suitable for SSE floating-point mask; /// CMPs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:72,mask,mask,72,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"/// Type inference based on static type information that is available for the; /// cast and the tracked type information for the given symbol. When the tracked; /// symbol and the destination type of the cast are unrelated, report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:60,avail,available,60,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,2,"['avail', 'error']","['available', 'error']"
Availability,"/// Type info obtained through TypeName2TypeID based on the column type name.; /// The expectation is that this always compares equal to fConcreteDefine->GetTypeId() (which however is only; /// available after jitting). It can be null if TypeName2TypeID failed to figure out this type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx:194,avail,available,194,tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx,1,['avail'],['available']
Availability,"/// Type tag information is stored immediately following the arguments, if; /// any, at the end of the object. They are mutually exclusive with; /// availability slots.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:149,avail,availability,149,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['avail'],['availability']
Availability,/// Types of redundant parentheses to remove.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:13,redundant,redundant,13,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['redundant'],['redundant']
Availability,/// TypoExpr - Internal placeholder for expressions where typo correction; /// still needs to be performed and/or an error diagnostic emitted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:117,error,error,117,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['error'],['error']
Availability,/// UBSANTRAP - Trap with an immediate describing the kind of sanitizer; /// failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:77,failure,failure,77,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['failure'],['failure']
Availability,/// Union of enum attributes available at any index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h:29,avail,available,29,interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h,1,['avail'],['available']
Availability,/// Update LR to reflect an instruction has been moved downwards from OldIdx; /// to NewIdx (OldIdx < NewIdx).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:55,down,downwards,55,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['down'],['downwards']
Availability,"/// Update section-specific memory permissions and other attributes.; ///; /// This method is called when object loading is complete and section page; /// permissions can be applied. It is up to the memory manager implementation; /// to decide whether or not to act on this method. The memory manager will; /// typically allocate all sections as read-write and then apply specific; /// permissions when this method is called. Code sections cannot be executed; /// until this function has been called. In addition, any cache coherency; /// operations needed to reliably use the memory are also performed.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h:560,reliab,reliably,560,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,2,"['error', 'reliab']","['error', 'reliably']"
Availability,"/// Update the PHI nodes in OrigBB to include the values coming from NewBB.; /// This also updates AliasAnalysis, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:117,avail,available,117,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['avail'],['available']
Availability,"/// Update the attribute index and attempt to read the attribute value. If the; /// attribute is able to be read, update AttrValue and the Index member; /// variable. If the attribute value is not able to be read, an appropriate; /// error will be set if the Err member variable is non-NULL and the iterator; /// will be set to the end value so iteration stops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h:234,error,error,234,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h,1,['error'],['error']
Availability,/// Update the attributes of the current profile from the attributes; /// specified. An error is returned if IR and FE profiles are mixed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfWriter.h:88,error,error,88,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfWriter.h,1,['error'],['error']
Availability,"/// UpdateNodeType - Set the node type of N to VT if VT contains; /// information. If N already contains a conflicting type, then flag an; /// error. This returns true if any information was updated.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:143,error,error,143,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['error'],['error']
Availability,/// Updates MemProf attributes (and metadata) based on whether the index; /// has recorded that we are linking with allocation libraries containing; /// the necessary APIs for downstream transformations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h:176,down,downstream,176,interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,1,['down'],['downstream']
Availability,"/// Updates the number of available free registers, returns; /// true if any registers were allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:26,avail,available,26,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['avail'],['available']
Availability,"/// Upon destruction, an ErrorCollector will crash if UseFatalErrors=true and; /// there are remaining errors that haven't been fetched by makeError().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:25,Error,ErrorCollector,25,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,2,"['Error', 'error']","['ErrorCollector', 'errors']"
Availability,"/// Upon errors, the merger will skip the current source and continue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx:9,error,errors,9,tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,1,['error'],['errors']
Availability,/// Use a set of temporal profile traces to create a list of balanced; /// partitioning function nodes used by BalancedPartitioning to generate a; /// function order that reduces page faults during startup,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:184,fault,faults,184,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,1,['fault'],['faults']
Availability,"/// Use predicate only to mask operations on data in the loop.; /// When the VL is not known to be a power-of-2, this method requires a; /// runtime overflow check for the i + VL in the loop because it compares the; /// scalar induction variable against the tripcount rounded up by VL which may; /// overflow. When the VL is a power-of-2, both the increment and uprounded; /// tripcount will overflow to 0, which does not require a runtime check; /// since the loop is exited when the loop induction variable equals the; /// uprounded trip-count, which are both 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:26,mask,mask,26,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['mask']
Availability,"/// Use predicate to control both data and control flow.; /// This method always requires a runtime overflow check for the i + VL; /// increment inside the loop, because it uses the result direclty in the; /// active.lane.mask to calculate the mask for the next iteration. If the; /// increment overflows, the mask is no longer correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:222,mask,mask,222,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,3,['mask'],['mask']
Availability,"/// Use the CC1 tool callback when available, to avoid creating a new process",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Job.h:35,avail,available,35,interpreter/llvm-project/clang/include/clang/Driver/Job.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Job.h,1,['avail'],['available']
Availability,/// Use the specified ABI.; ///; /// \return False on error (invalid ABI name).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:54,error,error,54,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['error'],['error']
Availability,/// Use the specified unit for FP math.; ///; /// \return False on error (invalid unit name).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:67,error,error,67,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['error'],['error']
Availability,"/// Used by R__FORWARD_RESULT in order to keep track of the stack trace in case of errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:83,error,errors,83,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,2,['error'],['errors']
Availability,"/// Used by an unclaimed option with the TargetSpecific flag. If set, report; /// an ""argument unused"" warning instead of an ""unsupported option"" error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/Arg.h:146,error,error,146,interpreter/llvm-project/llvm/include/llvm/Option/Arg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/Arg.h,1,['error'],['error']
Availability,"/// Used for cases where we expect an identifier-like token, but don't want to; /// give awkward error messages in cases where it is accidentially a keyword.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:97,error,error,97,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['error'],['error']
Availability,"/// Used for cases where we have a token we want to check against an; /// 'identifier-like' token, but don't want to give awkward error messages in; /// cases where it is accidentially a keyword.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:130,error,error,130,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['error'],['error']
Availability,"/// Used from the RNTuple class to build a datasource if the anchor is already available.; /// Requires the RNTuple object to be streamed from a file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx:79,avail,available,79,tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,1,['avail'],['available']
Availability,"/// Used in RFieldBase::Check() to record field creation failures.; /// Also used when deserializing a field that contains unknown values that may come from; /// future RNTuple versions (e.g. an unknown Structure)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField.hxx:57,failure,failures,57,tree/ntuple/v7/inc/ROOT/RField.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField.hxx,1,['failure'],['failures']
Availability,/// Used only in unittests to verify the behaviour of the error handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:58,error,error,58,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['error'],['error']
Availability,"/// Used to create reference output with the ""safe"" backend, if reference; /// output is not provided. If there is a problem with the code generator; /// (e.g., llc crashes), this will return false and set Error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:206,Error,Error,206,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,1,['Error'],['Error']
Availability,/// Used to determine if errors occurred in this function or block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h:25,error,errors,25,interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,1,['error'],['errors']
Availability,/// Used to determine if errors occurred in this scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Scope.h:25,error,errors,25,interpreter/llvm-project/clang/include/clang/Sema/Scope.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Scope.h,1,['error'],['errors']
Availability,"/// Used to encode a step in a register lane mask transformation.; /// Mask the bits specified in Mask, then rotate them Rol bits to the left; /// assuming a wraparound at 32bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h:45,mask,mask,45,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,3,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// Used to implement to perform semantic checking on; /// attribute((section(""foo""))) specifiers.; ///; /// In this case, ""foo"" is passed in to be checked. If the section; /// specifier is invalid, return an Error that indicates the problem.; ///; /// This is a simple quality of implementation feature to catch errors; /// and give good diagnostics in cases when the assembler or code generator; /// would otherwise reject the section specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:209,Error,Error,209,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,2,"['Error', 'error']","['Error', 'errors']"
Availability,"/// Used to notify the internal state of a processor resource.; ///; /// A processor resource is available if it is not reserved, and there are; /// available slots in the buffer. A processor resource is unavailable if it; /// is either reserved, or the associated buffer is full. A processor resource; /// with a buffer size of -1 is always available if it is not reserved.; ///; /// Values of type ResourceStateEvent are returned by method; /// ResourceManager::canBeDispatched(); ///; /// The naming convention for resource state events is:; /// * Event names start with prefix RS_; /// * Prefix RS_ is followed by a string describing the actual resource state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:97,avail,available,97,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,3,['avail'],['available']
Availability,"/// User-facing error message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:16,error,error,16,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,1,['error'],['error']
Availability,/// Uses amdgpu-arch tool to get arch of the system GPU. Will return error; /// if unable to find one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.h:69,error,error,69,interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.h,1,['error'],['error']
Availability,/// Uses nvptx-arch tool to get arch of the system GPU. Will return error; /// if unable to find one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:68,error,error,68,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,1,['error'],['error']
Availability,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:190,mask,mask,190,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['mask'],['mask']
Availability,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:196,mask,mask,196,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['mask'],['mask']
Availability,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpestrm(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for b",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:231,mask,mask,231,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['mask'],['mask']
Availability,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Re",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:204,mask,mask,204,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['mask'],['mask']
Availability,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:190,mask,mask,190,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,5,['mask'],['mask']
Availability,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1643,mask,mask,1643,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,3,['mask'],['mask']
Availability,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1643,mask,mask,1643,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,3,['mask'],['mask']
Availability,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:204,mask,mask,204,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,5,['mask'],['mask']
Availability,"/// Uses the specified value, regardless of the behavior or value of the; /// other module. If both modules specify **Override**, but the values; /// differ, an error will be emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:161,error,error,161,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['error'],['error']
Availability,"/// UsualArithmeticConversions - Performs various conversions that are common to; /// binary operators (C99 6.3.1.8). If both operands aren't arithmetic, this; /// routine returns the first non-arithmetic type found. The client is; /// responsible for emitting appropriate error diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:273,error,error,273,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"/// Utility function to decode a SLEB128 value.; ///; /// If \p error is non-null, it will point to a static error message,; /// if an error occured. It will not be modified on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LEB128.h:64,error,error,64,interpreter/llvm-project/llvm/include/llvm/Support/LEB128.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LEB128.h,3,['error'],['error']
Availability,"/// Utility function to decode a ULEB128 value.; ///; /// If \p error is non-null, it will point to a static error message,; /// if an error occured. It will not be modified on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LEB128.h:64,error,error,64,interpreter/llvm-project/llvm/include/llvm/Support/LEB128.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LEB128.h,3,['error'],['error']
Availability,/// Utility to convert a regex error code into a human-readable string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Regex.cpp:31,error,error,31,interpreter/llvm-project/llvm/lib/Support/Regex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Regex.cpp,1,['error'],['error']
Availability,/// VP Intrinsics whose vector operands are both splat values may be simplified; /// into the scalar version of the operation and the result splatted. This; /// can lead to scalarization down the line.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:187,down,down,187,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['down'],['down']
Availability,"/// VPInterleaveRecipe is a recipe for transforming an interleave group of load; /// or stores into one wide load/store and shuffles. The first operand of a; /// VPInterleave recipe is the address, followed by the stored values, followed; /// by an optional mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:258,mask,mask,258,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['mask'],['mask']
Availability,/// VPPredInstPHIRecipe is a recipe for generating the phi nodes needed when; /// control converges back from a Branch-on-Mask. The phi nodes are needed in; /// order to merge values that are set under such a branch and feed their uses.; /// The phi nodes can be scalar or vector depending on the users of the value.; /// This recipe works in concert with VPBranchOnMaskRecipe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:122,Mask,Mask,122,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['Mask'],['Mask']
Availability,"/// VPTransformState holds information passed down when ""executing"" a VPlan,; /// needed for generating the output IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:46,down,down,46,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['down'],['down']
Availability,"/// Validate any DPMarkers / DPValues attached to instructions in this block,; /// and block-level stored data too (TrailingDPValues).; /// \p Assert Should this method fire an assertion if a problem is found?; /// \p Msg Should this method print a message to errs() if a problem is found?; /// \p OS Output stream to write errors to.; /// \returns True if a problem is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h:324,error,errors,324,interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,1,['error'],['errors']
Availability,"/// Validate availability spec list, emitting diagnostics if necessary. Returns; /// true if invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:13,avail,availability,13,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['avail'],['availability']
Availability,"/// Validates ObjCInterfaceDecl availability.; /// ObjCInterfaceDecl, used to create ObjC literals, should be defined; /// if clang not in a debugger mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:32,avail,availability,32,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['avail'],['availability']
Availability,/// Validates the CompressPattern and create operand mapping.; /// These are the checks to validate a CompressPat pattern declarations.; /// Error out with message under these conditions:; /// - Dag Input opcode is an expanded instruction and Dag Output opcode is a; /// compressed instruction.; /// - Operands in Dag Input must be all used in Dag Output.; /// Register Operand type in Dag Input Type must be contained in the; /// corresponding Source Instruction type.; /// - Register Operand type in Dag Input must be the same as in Dag Ouput.; /// - Register Operand type in Dag Output must be the same as the; /// corresponding Destination Inst type.; /// - Immediate Operand type in Dag Input must be the same as in Dag Ouput.; /// - Immediate Operand type in Dag Ouput must be the same as the corresponding; /// Destination Instruction type.; /// - Fixed register must be contained in the corresponding Source Instruction; /// type.; /// - Fixed register must be contained in the corresponding Destination; /// Instruction type.; /// Warning message printed under these conditions:; /// - Fixed immediate in Dag Input or Dag Ouput cannot be checked at this time; /// and generate warning.; /// - Immediate operand type in Dag Input differs from the corresponding Source; /// Instruction type and generate a warning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp:141,Error,Error,141,interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,1,['Error'],['Error']
Availability,"/// Value handle that tracks a Value across RAUW.; ///; /// TrackingVH is designed for situations where a client needs to hold a handle; /// to a Value (or subclass) across some operations which may move that value,; /// but should never destroy it or replace it with some unacceptable type.; ///; /// It is an error to attempt to replace a value with one of a type which is; /// incompatible with any of its outstanding TrackingVHs.; ///; /// It is an error to read from a TrackingVH that does not point to a valid; /// value. A TrackingVH is said to not point to a valid value if either it; /// hasn't yet been assigned a value yet or because the value it was tracking; /// has since been deleted.; ///; /// Assigning a value to a TrackingVH is always allowed, even if said TrackingVH; /// no longer points to a valid value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ValueHandle.h:311,error,error,311,interpreter/llvm-project/llvm/include/llvm/IR/ValueHandle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ValueHandle.h,2,['error'],['error']
Availability,/// Value of the Mask for this operand.; /// It may be SDValue().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,Mask,Mask,17,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// VarInfo - This represents the regions where a virtual register is live in; /// the program. We represent this with three different pieces of; /// information: the set of blocks in which the instruction is live; /// throughout, the set of blocks in which the instruction is actually used,; /// and the set of non-phi instructions that are the last users of the value.; ///; /// In the common case where a value is defined and killed in the same block,; /// There is one killing instruction, and AliveBlocks is empty.; ///; /// Otherwise, the value is live out of the block. If the value is live; /// throughout any blocks, these blocks are listed in AliveBlocks. Blocks; /// where the liveness range ends are not included in AliveBlocks, instead; /// being captured by the Kills set. In these blocks, the value is live into; /// the block (unless the value is defined and killed in the same block) and; /// lives until the specified instruction. Note that there cannot ever be a; /// value whose Kills set contains two instructions from the same basic block.; ///; /// PHI nodes complicate things a bit. If a PHI node is the last user of a; /// value in one of its predecessor blocks, it is not listed in the kills set,; /// but does include the predecessor block in the AliveBlocks set (unless that; /// block also defines the value). This leads to the (perfectly sensical); /// situation where a value is defined in a block, and the last use is a phi; /// node in the successor. In this case, AliveBlocks is empty (the value is; /// not live across any blocks) and Kills is empty (phi nodes are not; /// included). This is sensical because the value must be live to the end of; /// the block, but is not live in any successor blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:498,Alive,AliveBlocks,498,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,5,['Alive'],['AliveBlocks']
Availability,"/// VarStreamArrayExtractor is intended to be specialized to provide customized; /// extraction logic. On input it receives a BinaryStreamRef pointing to the; /// beginning of the next record, but where the length of the record is not yet; /// known. Upon completion, it should return an appropriate Error instance if; /// a record could not be extracted, or if one could be extracted it should; /// return success and set Len to the number of bytes this record occupied in; /// the underlying stream, and it should fill out the fields of the value type; /// Item appropriately to represent the current record.; ///; /// You can specialize this template for your own custom value types to avoid; /// having to specify a second template argument to VarStreamArray (documented; /// below).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamArray.h:300,Error,Error,300,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamArray.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamArray.h,1,['Error'],['Error']
Availability,/// Variant that reports a fatal error if the offset is not computable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmLayout.h:33,error,error,33,interpreter/llvm-project/llvm/include/llvm/MC/MCAsmLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmLayout.h,1,['error'],['error']
Availability,"/// Vector commit of preprocessed pages. The `ranges` array specifies a range of sealed pages to be; /// committed for each column. The returned vector contains, in order, the RNTupleLocator for each; /// page on each range in `ranges`, i.e. the first N entries refer to the N pages in `ranges[0]`,; /// followed by M entries that refer to the M pages in `ranges[1]`, etc.; /// The mask allows to skip writing out certain pages. The vector has the size of all the pages.; /// For every `false` value in the mask, the corresponding locator is skipped (missing) in the output vector.; /// The default is to call `CommitSealedPageImpl` for each page; derived classes may provide an; /// optimized implementation though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:382,mask,mask,382,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,2,['mask'],['mask']
Availability,/// Vector comparison generating mask bits for fp and; /// integer signed and unsigned data types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:33,mask,mask,33,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,2,['mask'],['mask']
Availability,"/// Vector types are broken down into some number of legal first class types.; /// For example, EVT::v8f32 maps to 2 EVT::v4f32 with Altivec or SSE1, or 8; /// promoted EVT::f64 values with the X86 FP stack. Similarly, EVT::v2i64; /// turns into 4 EVT::i32 values with both PPC and X86.; ///; /// This method returns the number of registers needed, and the VT for each; /// register. It also returns the VT and quantity of the intermediate values; /// before they are promoted/expanded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:28,down,down,28,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['down'],['down']
Availability,/// Verifies that a call site entry is nested within a subprogram with a; /// DW_AT_call attribute.; ///; /// \returns Number of errors that occurred during verification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:129,error,errors,129,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,/// Verifies that none of the strings in \p NotStrings are found in the given; /// \p Buffer. Errors are reported against \p SM and diagnostics recorded in; /// \p Diags according to the verbosity level set in \p Req.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:94,Error,Errors,94,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['Error'],['Errors']
Availability,/// Verifies that there is a single line in the given \p Buffer. Errors are; /// reported against \p SM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:65,Error,Errors,65,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['Error'],['Errors']
Availability,/// Verifies that there is no newline in the given \p Buffer. Errors are; /// reported against \p SM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:62,Error,Errors,62,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['Error'],['Errors']
Availability,/// Verifies the abbreviations section.; ///; /// This function currently checks that:; /// --No abbreviation declaration has more than one attributes with the same; /// name.; ///; /// \param Abbrev Pointer to the abbreviations section we are verifying; /// Abbrev can be a pointer to either .debug_abbrev or debug_abbrev.dwo.; ///; /// \returns The number of errors that occurred during verification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:361,error,errors,361,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,"/// Verifies the all valid references that were found when iterating through; /// all of the DIE attributes.; ///; /// This function will verify that all references point to DIEs whose DIE; /// offset matches. This helps to ensure if a DWARF link phase moved things; /// around, that it doesn't create invalid references by failing to relocate; /// CU relative and absolute references.; ///; /// \returns NumErrors The number of errors occurred during verification of; /// references for the .debug_info and .debug_types sections",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:429,error,errors,429,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,/// Verifies the attribute's DWARF attribute and its value.; ///; /// This function currently checks for:; /// - DW_AT_ranges values is a valid .debug_ranges offset; /// - DW_AT_stmt_list is a valid .debug_line offset; ///; /// \param Die The DWARF DIE that owns the attribute value; /// \param AttrValue The DWARF attribute value to check; ///; /// \returns NumErrors The number of errors occurred during verification of; /// attributes' values in a unit,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:383,error,errors,383,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,/// Verifies the attribute's DWARF form.; ///; /// This function currently checks for:; /// - All DW_FORM_ref values that are CU relative have valid CU offsets; /// - All DW_FORM_ref_addr values have valid section offsets; /// - All DW_FORM_strp values have valid .debug_str offsets; ///; /// \param Die The DWARF DIE that owns the attribute value; /// \param AttrValue The DWARF attribute value to check; ///; /// \returns NumErrors The number of errors occurred during verification of; /// attributes' forms in a unit,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:448,error,errors,448,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,"/// Verifies the header of a unit in a .debug_info or .debug_types section.; ///; /// This function currently verifies:; /// - The debug info attributes.; /// - The debug info form=s.; /// - The presence of a root DIE.; /// - That the root DIE is a unit DIE.; /// - If a unit type is provided, that the unit DIE matches the unit type.; /// - The DIE ranges.; /// - That call site entries are only nested within subprograms with a; /// DW_AT_call attribute.; ///; /// \param Unit The DWARF Unit to verify.; ///; /// \returns The number of errors that occurred during verification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:538,error,errors,538,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,/// Verifies the unit headers and contents in a .debug_info or .debug_types; /// section.; ///; /// \param S The DWARF Section to verify.; ///; /// \returns The number of errors that occurred during verification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:171,error,errors,171,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,/// Verify if the intrinsic has variable arguments. This method is intended to; /// be called after all the fixed arguments have been matched first.; ///; /// This method returns true on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Intrinsics.h:187,error,error,187,interpreter/llvm-project/llvm/include/llvm/IR/Intrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Intrinsics.h,1,['error'],['error']
Availability,/// Verify that all Die ranges are valid.; ///; /// This function currently checks for:; /// - cases in which lowPC >= highPC; ///; /// \returns Number of errors that occurred during verification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:155,error,errors,155,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,"/// Verify that an Apple-style accelerator table is valid.; ///; /// This function currently checks that:; /// - The fixed part of the header fits in the section; /// - The size of the section is as large as what the header describes; /// - There is at least one atom; /// - The form for each atom is valid; /// - The tag for each DIE in the table is valid; /// - The buckets have a valid index, or they are empty; /// - Each hashdata offset is valid; /// - Each DIE is valid; ///; /// \param AccelSection pointer to the section containing the acceleration table; /// \param StrData pointer to the string section; /// \param SectionName the name of the table we're verifying; ///; /// \returns The number of errors occurred during verification",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:708,error,errors,708,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,/// Verify that assumption cache isn't stale after a region is extracted.; /// Returns true when verifier finds errors. AssumptionCache is passed as; /// parameter to make this function stateless.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:112,error,errors,112,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,1,['error'],['errors']
Availability,/// Verify that given node is of a certain type. Return true on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:64,error,error,64,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,1,['error'],['error']
Availability,"/// Verify that the DWARF v5 accelerator table is valid.; ///; /// This function currently checks that:; /// - Headers individual Name Indices fit into the section and can be parsed.; /// - Abbreviation tables can be parsed and contain valid index attributes; /// with correct form encodings.; /// - The CU lists reference existing compile units.; /// - The buckets have a valid index, or they are empty.; /// - All names are reachable via the hash table (they have the correct hash,; /// and the hash is in the correct bucket).; /// - Information in the index entries is complete (all required entries are; /// present) and consistent with the debug_info section DIEs.; ///; /// \param AccelSection section containing the acceleration table; /// \param StrData string section; ///; /// \returns The number of errors occurred during verification",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:810,error,errors,810,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,"/// Verify the information in accelerator tables, if they exist.; ///; /// Any errors are reported to the stream that was this object was; /// constructed with.; ///; /// \returns true if the existing Apple-style accelerator tables verify; /// successfully, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:79,error,errors,79,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,"/// Verify the information in any of the following sections, if available:; /// .debug_abbrev, debug_abbrev.dwo; ///; /// Any errors are reported to the stream that was this object was; /// constructed with.; ///; /// \returns true if .debug_abbrev and .debug_abbrev.dwo verify successfully,; /// false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:64,avail,available,64,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,2,"['avail', 'error']","['available', 'errors']"
Availability,"/// Verify the information in the .debug_cu_index section.; ///; /// Any errors are reported to the stream that was this object was; /// constructed with.; ///; /// \returns true if the .debug_cu_index verifies successfully, false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:73,error,errors,73,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,"/// Verify the information in the .debug_info and .debug_types sections.; ///; /// Any errors are reported to the stream that this object was; /// constructed with.; ///; /// \returns true if all sections verify successfully, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:87,error,errors,87,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,"/// Verify the information in the .debug_line section.; ///; /// Any errors are reported to the stream that was this object was; /// constructed with.; ///; /// \returns true if the .debug_line verifies successfully, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:69,error,errors,69,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,"/// Verify the information in the .debug_str_offsets[.dwo].; ///; /// Any errors are reported to the stream that was this object was; /// constructed with.; ///; /// \returns true if the .debug_line verifies successfully, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:74,error,errors,74,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,"/// Verify the information in the .debug_tu_index section.; ///; /// Any errors are reported to the stream that was this object was; /// constructed with.; ///; /// \returns true if the .debug_tu_index verifies successfully, false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h:73,error,errors,73,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFVerifier.h,1,['error'],['errors']
Availability,"/// Version of getValue that returns ResVal directly, or 0 if there is an; /// error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:79,error,error,79,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['error'],['error']
Availability,/// Version of parse() that converts the parsed value to the type T.; /// RootName describes the root object and is used in error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:124,error,error,124,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['error'],['error']
Availability,/// Virtual destructor.; ///; /// Need a virtual destructor to mask the compiler warning about; /// getBlockName().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:63,mask,mask,63,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,1,['mask'],['mask']
Availability,/// Visit a type entry. CheckPointer is true if the type has; /// one of its predecessors as one struct/union member. SeenPointer; /// is true if CheckPointer is true and one of its predecessors; /// is a pointer. The goal of CheckPointer and SeenPointer is to; /// do pruning for struct/union types so some of these types; /// will not be emitted in BTF and rather forward declarations; /// will be generated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:24,CheckPoint,CheckPointer,24,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,3,['CheckPoint'],['CheckPointer']
Availability,/// Visits the type records in Data. Sets the error flag on parse failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/CVTypeVisitor.cpp:46,error,error,46,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/CVTypeVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/CVTypeVisitor.cpp,4,"['error', 'failure']","['error', 'failures']"
Availability,"/// Walk the set of potential results of an expression and mark them all as; /// non-odr-uses if they satisfy the side-conditions of the NonOdrUseReason.; ///; /// \return A new expression if we found any potential results, ExprEmpty() if; /// not, and ExprError() if we diagnosed an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:284,error,error,284,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"/// Warn about an unlock function call that attempts to unlock a lock with; /// the incorrect lock kind. For instance, a shared lock being unlocked; /// exclusively, or vice versa.; /// \param LockName -- A StringRef name for the lock expression, to be printed; /// in the error message.; /// \param Kind -- the capability's name parameter (role, mutex, etc).; /// \param Expected -- the kind of lock expected.; /// \param Received -- the kind of lock received.; /// \param LocLocked -- The SourceLocation of the Lock.; /// \param LocUnlock -- The SourceLocation of the Unlock.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h:273,error,error,273,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,1,['error'],['error']
Availability,"/// Warn about lock function calls for locks which are already held.; /// \param Kind -- the capability's name parameter (role, mutex, etc).; /// \param LockName -- A StringRef name for the lock expression, to be printed; /// in the error message.; /// \param LocLocked -- The location of the first lock expression.; /// \param LocDoubleLock -- The location of the second lock expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h:233,error,error,233,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,1,['error'],['error']
Availability,"/// Warn about situations where a mutex is sometimes held and sometimes not.; /// The three situations are:; /// 1. a mutex is locked on an ""if"" branch but not the ""else"" branch,; /// 2, or a mutex is only held at the start of some loop iterations,; /// 3. or when a mutex is locked but not unlocked inside a function.; /// \param Kind -- the capability's name parameter (role, mutex, etc).; /// \param LockName -- A StringRef name for the lock expression, to be printed; /// in the error message.; /// \param LocLocked -- The location of the lock expression where the mutex is; /// locked; /// \param LocEndOfScope -- The location of the end of the scope where the; /// mutex is no longer held; /// \param LEK -- which of the three above cases we should warn for",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h:483,error,error,483,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,1,['error'],['error']
Availability,"/// Warn about unlock function calls that do not have a prior matching lock; /// expression.; /// \param Kind -- the capability's name parameter (role, mutex, etc).; /// \param LockName -- A StringRef name for the lock expression, to be printed; /// in the error message.; /// \param Loc -- The SourceLocation of the Unlock; /// \param LocPreviousUnlock -- If valid, the location of a previous Unlock.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h:257,error,error,257,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,1,['error'],['error']
Availability,/// Warn about use-while-consumed errors.; /// \param MethodName -- The name of the method that was incorrectly; /// invoked.; ///; /// \param State -- The state the object was used in.; ///; /// \param Loc -- The SourceLocation of the method invocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/Consumed.h:34,error,errors,34,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/Consumed.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/Consumed.h,1,['error'],['errors']
Availability,/// Warn about use-while-consumed errors.; /// \param MethodName -- The name of the method that was incorrectly; /// invoked.; ///; /// \param State -- The state the object was used in.; ///; /// \param VariableName -- The name of the variable that holds the unique; /// value.; ///; /// \param Loc -- The SourceLocation of the method invocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/Consumed.h:34,error,errors,34,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/Consumed.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/Consumed.h,1,['error'],['errors']
Availability,/// Warn on logical operator errors in CFGBuilder,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:29,error,errors,29,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['error'],['errors']
Availability,"/// Warn when a function is called while an excluded mutex is locked. For; /// example, the mutex may be locked inside the function.; /// \param Kind -- the capability's name parameter (role, mutex, etc).; /// \param FunName -- The name of the function; /// \param LockName -- A StringRef name for the lock expression, to be printed; /// in the error message.; /// \param Loc -- The location of the function call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h:345,error,error,345,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,1,['error'],['error']
Availability,"/// Warn when a mutex is held exclusively and shared at the same point. For; /// example, if a mutex is locked exclusively during an if branch and shared; /// during the else branch.; /// \param Kind -- the capability's name parameter (role, mutex, etc).; /// \param LockName -- A StringRef name for the lock expression, to be printed; /// in the error message.; /// \param Loc1 -- The location of the first lock expression.; /// \param Loc2 -- The location of the second lock expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h:347,error,error,347,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,1,['error'],['error']
Availability,"/// Warn when a protected operation occurs while the specific mutex protecting; /// the operation is not locked.; /// \param Kind -- the capability's name parameter (role, mutex, etc).; /// \param D -- The decl for the protected variable or function; /// \param POK -- The kind of protected operation (e.g. variable access); /// \param LockName -- A StringRef name for the lock expression, to be printed; /// in the error message.; /// \param LK -- The kind of access (i.e. read or write) that occurred; /// \param Loc -- The location of the protected operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h:416,error,error,416,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,1,['error'],['error']
Availability,/// Was there an error parsing the inline assembly?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:17,error,error,17,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['error'],['error']
Availability,"/// Was this argument used to affect compilation?; ///; /// This is used to generate an ""argument unused"" warning (without; /// clang::driver::options::TargetSpecific) or ""unsupported option"" error; /// (with TargetSpecific).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/Arg.h:192,error,error,192,interpreter/llvm-project/llvm/include/llvm/Option/Arg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/Arg.h,1,['error'],['error']
Availability,/// Was this directive mapped from an another directive?; /// e.g. 1) omp loop bind(parallel) is mapped to OMPD_for; /// 2) omp loop bind(teams) is mapped to OMPD_distribute; /// 3) omp loop bind(thread) is mapped to OMPD_simd; /// It was necessary to note it down in the Directive because of; /// clang::TreeTransform::TransformOMPExecutableDirective() pass in; /// the frontend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:260,down,down,260,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,1,['down'],['down']
Availability,"/// We are building a shuffle to create V, which is a sequence of insertelement,; /// extractelement pairs. If PermittedRHS is set, then we must either use it or; /// not rely on the second vector source. Return a std::pair containing the; /// left and right vectors of the proposed shuffle (or 0), and set the Mask; /// parameter as required.; ///; /// Note: we intentionally don't try to fold earlier shuffles since they have; /// often been chosen carefully to be efficiently implementable on the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:311,Mask,Mask,311,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['Mask'],['Mask']
Availability,"/// We do not know whether the block is fully available or not,; /// but we are currently speculating that it will be.; /// If it would have turned out that the block was, in fact, not fully; /// available, this would have been cleaned up into an Unavailable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:46,avail,available,46,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,['avail'],['available']
Availability,/// We don't want to treat 'case x : y' as a potential typo for 'case x::y'.; /// Disable this form of error recovery while we're parsing the case; /// expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:103,error,error,103,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"/// We know that a debug info condition should be true, if not print; /// an error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:77,error,error,77,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['error'],['error']
Availability,/// We know the block *is not* fully available. This is a fixpoint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:37,avail,available,37,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,/// We know the block *is* fully available. This is a fixpoint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:33,avail,available,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,"/// We only fold functions with finite arguments. Folding NaN and inf is; /// likely to be aborted with an exception anyway, and some host libms; /// have known errors raising exceptions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:161,error,errors,161,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['error'],['errors']
Availability,"/// We only use `shared library` mode in cases where the static library form; /// of the components provided are not available; note however that this is; /// skipped if we're run from within the build dir. However, once installed,; /// we still need to provide correct output when the static archives are; /// removed or, as in the case of CMake's `BUILD_SHARED_LIBS`, never present; /// in the first place. This can't be done at configure/build time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:117,avail,available,117,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['avail'],['available']
Availability,"/// We use this class to visit different types of expressions in; /// CFGBlocks, and build up the lockset.; /// An expression may cause us to add or remove locks from the lockset, or else; /// output error messages related to missing locks.; /// FIXME: In future, we may be able to not inherit from a visitor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:200,error,error,200,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,1,['error'],['error']
Availability,"/// We want to produce a diagnostic at location IncLoc concerning an; /// unreachable effect at location MLoc (eg, where a desired entity was; /// declared or defined). Determine whether the right way to make MLoc; /// reachable is by #include, and if so, what header should be included.; ///; /// This is not necessarily fast, and might load unexpected module maps, so; /// should only be called by code that intends to produce an error.; ///; /// \param IncLoc The location at which the missing effect was detected.; /// \param MLoc A location within an unimported module at which the desired; /// effect occurred.; /// \return A file that can be #included to provide the desired effect. Null; /// if no such file could be determined or if a #include is not; /// appropriate (eg, if a module should be imported instead).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:432,error,error,432,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['error'],['error']
Availability,"/// We want to trust developer annotations and consider all 'nonnull' parameters; /// as non-null indeed. Each marked parameter will get a corresponding; /// constraint.; ///; /// This approach will not only help us to get rid of some false positives, but; /// remove duplicates and shorten warning traces as well.; ///; /// \code; /// void foo(int *x) [[gnu::nonnull]] {; /// // . . .; /// *x = 42; // we don't want to consider this as an error...; /// // . . .; /// }; ///; /// foo(nullptr); // ...and report here instead; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:440,error,error,440,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,1,['error'],['error']
Availability,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), 0, (shl [nsw/nuw] X, C2));; /// iff C1 is a mask and the number of its leading zeros is equal to C2; /// into:; /// shl X, C2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:104,mask,mask,104,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['mask'],['mask']
Availability,"/// We will prefer importing the prevailing candidate, if not, we'll; /// still pick the first available candidate. The reason we want to make; /// sure we do import the prevailing candidate is because the goal of; /// workload-awareness is to enable optimizations specializing the call; /// graph of that workload. Suppose a function is already defined in the; /// module, but it's not the prevailing variant. Suppose also we do not; /// inline it (in fact, if it were interposable, we can't inline it),; /// but we could specialize it to the workload in other ways. However,; /// the linker would drop it in the favor of the prevailing copy.; /// Instead, by importing the prevailing variant (assuming also the use; /// of `-avail-extern-to-local`), we keep the specialization. We could; /// alteranatively make the non-prevailing variant local, but the; /// prevailing one is also the one for which we would have previously; /// collected profiles, making it preferrable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:95,avail,available,95,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,2,['avail'],"['avail-extern-to-local', 'available']"
Availability,"/// We'd like to check the predicate on every iteration of the most dominated; /// loop between loops used in LHS and RHS.; /// To do this we use the following list of steps:; /// 1. Collect set S all loops on which either LHS or RHS depend.; /// 2. If S is non-empty; /// a. Let PD be the element of S which is dominated by all other elements.; /// b. Let E(LHS) be value of LHS on entry of PD.; /// To get E(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their entry values.; /// Define E(RHS) in the same way.; /// c. Let B(LHS) be value of L on backedge of PD.; /// To get B(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their backedge values.; /// Define B(RHS) in the same way.; /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,; /// so we can assert on that.; /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&; /// isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:827,avail,available,827,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['avail'],['available']
Availability,"/// What actually happened. This would be 'false' in the case of an inline; /// error, even if AdvisedDecision were true, otherwise it agrees with; /// AdvisedDecision.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:80,error,error,80,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,1,['error'],['error']
Availability,"/// What type of match result does this diagnostic describe?; ///; /// A directive's supplied pattern is said to be either expected or excluded; /// depending on whether the pattern must have or must not have a match in; /// order for the directive to succeed. For example, a CHECK directive's; /// pattern is expected, and a CHECK-NOT directive's pattern is excluded.; ///; /// There might be more than one match result for a single pattern. For; /// example, there might be several discarded matches; /// (MatchFoundButDiscarded) before either a good match; /// (MatchFoundAndExpected) or a failure to match (MatchNoneButExpected),; /// and there might be a fuzzy match (MatchFuzzy) after the latter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h:593,failure,failure,593,interpreter/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h,1,['failure'],['failure']
Availability,/// When CodeGen is created the first llvm::Module gets cached in many places; /// and we must keep it alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:103,alive,alive,103,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,1,['alive'],['alive']
Availability,"/// When \p RepairPt involves splitting to repair \p MO for the; /// given \p ValMapping, try to change the way we repair such that; /// the splitting is not required anymore.; ///; /// \pre \p RepairPt.hasSplit(); /// \pre \p MO == MO.getParent()->getOperand(\p RepairPt.getOpIdx()); /// \pre \p ValMapping is the mapping of \p MO for MO.getParent(); /// that implied \p RepairPt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:12,Repair,RepairPt,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,6,"['Repair', 'repair']","['RepairPt', 'repair']"
Availability,"/// When all predecessor dependencies have been resolved, free this node for; /// top-down scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:86,down,down,86,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['down'],['down']
Availability,"/// When an MBB is added to an MF, we need to update the parent pointer of the; /// MBB, the MBB numbering, and any instructions in the MBB to be on the right; /// operand list for registers.; ///; /// MBBs start out as #-1. When a MBB is added to a MachineFunction, it; /// gets the next available unique MBB number. If it is removed from a; /// MachineFunction, it goes back to being #-1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:289,avail,available,289,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,1,['avail'],['available']
Availability,"/// When an error signal (such as SIGABRT or SIGSEGV) is delivered to the; /// process, print a stack trace and then exit.; /// Print a stack trace if a fatal signal occurs.; /// \param Argv0 the current binary name, used to find the symbolizer; /// relative to the current binary before searching $PATH; can be; /// StringRef(), in which case we will only search $PATH.; /// \param DisableCrashReporting if \c true, disable the normal crash; /// reporting mechanisms on the underlying operating system.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Signals.h:12,error,error,12,interpreter/llvm-project/llvm/include/llvm/Support/Signals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Signals.h,1,['error'],['error']
Availability,"/// When available, always prefer lookup with a CallEvent! This function; /// exists only when that is not available, for example, when _only_; /// syntactic check is done on a piece of code.; ///; /// Also, StdLibraryFunctionsChecker::Signature is likely a better candicade; /// for syntactic only matching if you are writing a new checker. This is; /// handy if a CallDescriptionMap is already there.; ///; /// The function is imprecise because CallEvent may know path sensitive; /// information, such as the precise argument count (see comments for; /// CallEvent::getNumArgs), the called function if it was called through a; /// function pointer, and other information not available syntactically.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h:9,avail,available,9,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h,6,['avail'],['available']
Availability,"/// When calculating availability, handle an instruction; /// by inserting it into the appropriate sets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:21,avail,availability,21,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['availability']
Availability,"/// When clobbering register masks, we chose to not believe the machine model; /// and don't clobber SP. Do the same for SP aliases, and for efficiency,; /// keep a set of them here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:29,mask,masks,29,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['mask'],['masks']
Availability,"/// When enabling loop hints are provided we allow the vectorizer to change; /// the order of operations that is given by the scalar loop. This is not; /// enabled by default because can be unsafe or inefficient. For example,; /// reordering floating-point operations will change the way round-off; /// error accumulates in the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:303,error,error,303,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['error'],['error']
Availability,"/// When performing a comparison against a constant, it is possible that not all; /// the bits in the LHS are demanded. This helper method computes the mask that; /// IS demanded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:152,mask,mask,152,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,"/// When printing type to be inserted into code in specific context, this; /// callback can be used to avoid printing the redundant part of the; /// qualifier. For example, when inserting code inside namespace foo, we; /// should print bar::SomeType instead of foo::bar::SomeType.; /// To do this, shouldPrintScope should return true on ""foo"" NamespaceDecl.; /// The printing stops at the first isScopeVisible() == true, so there will; /// be no calls with outer scopes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/PrettyPrinter.h:122,redundant,redundant,122,interpreter/llvm-project/clang/include/clang/AST/PrettyPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/PrettyPrinter.h,1,['redundant'],['redundant']
Availability,"/// When regcall calling convention compiled to 32 bit arch, special treatment; /// is required for 64 bit masks.; /// The value should be assigned to two GPRs.; /// \return true if registers were allocated and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:107,mask,masks,107,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['mask'],['masks']
Availability,/// When resolving duplicate ivars from Objective-C extensions we don't error; /// out immediately but check if can merge identical extensions. Not checking; /// extensions for equality immediately because ivar deserialization isn't; /// over yet at that point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:72,error,error,72,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['error'],['error']
Availability,/// When set to true mask warnings that come from system headers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:21,mask,mask,21,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['mask'],['mask']
Availability,"/// When set to true, any error reported is made a fatal error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:26,error,error,26,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,2,['error'],['error']
Availability,"/// When set to true, any warnings reported are issued as errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:58,error,errors,58,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['errors']
Availability,"/// When the MSVC runtime transfers control to us, either to an outlined; /// function or when returning to a parent frame after catching an exception, we; /// recover the parent frame pointer by doing arithmetic on the incoming EBP.; /// Here's the math:; /// RegNodeBase = EntryEBP - RegNodeSize; /// ParentFP = RegNodeBase - ParentFrameOffset; /// Subtracting RegNodeSize takes us to the offset of the registration node, and; /// subtracting the offset (negative on x86) takes us back to the parent FP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:160,recover,recover,160,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['recover'],['recover']
Availability,"/// When the shortest interval using Keys PDF could not be found to have; /// the desired confidence level +/- the accuracy (see; /// SetKeysConfidenceAccuracy()), the interval determination algorithm; /// will have to terminate with an unsatisfactory confidence level when; /// the bottom and top of the cutoff search range are very close to being; /// equal. This scenario comes into play when there seems to be an error; /// in the accuracy of the Keys PDF integration, so the search range; /// continues to shrink without converging to a cutoff value that will; /// give an acceptable confidence level. To choose how small to allow the; /// search range to be before terminating, set the fraction delta such; /// that the search will terminate when topCutoff (a) and bottomCutoff (b); /// satisfy this condition:; ///; /// std::abs(a - b) < std::abs(delta * (a + b)/2)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/MCMCCalculator.h:417,error,error,417,roofit/roostats/inc/RooStats/MCMCCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/MCMCCalculator.h,1,['error'],['error']
Availability,"/// When this InstructionPattern is used as the match root, returns the; /// operands that must be redefined in the 'apply' pattern for the rule to be; /// valid.; ///; /// For most patterns, this just returns the defs.; /// For PatFrag this only returns the root of the PF.; ///; /// Returns an empty array on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISel/Patterns.h:311,error,error,311,interpreter/llvm-project/llvm/utils/TableGen/GlobalISel/Patterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISel/Patterns.h,1,['error'],['error']
Availability,"/// When true, a PCH with compiler errors will not be rejected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:35,error,errors,35,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,1,['error'],['errors']
Availability,"/// When true, access checking violations are treated as SFINAE; /// failures rather than hard errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:69,failure,failures,69,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['error', 'failure']","['errors', 'failures']"
Availability,"/// When true, print the built-in wchar_t type as __wchar_t. For use in; /// Microsoft mode when wchar_t is not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/PrettyPrinter.h:112,avail,available,112,interpreter/llvm-project/clang/include/clang/AST/PrettyPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/PrettyPrinter.h,1,['avail'],['available']
Availability,"/// When we are reconstructing a PHI inside \p PHIBlock with incoming values; /// from predecessors \p Incomings, we have a chance to mark the available value; /// from some blocks as undefined. The function will find out all such blocks; /// and return in \p UndefBlks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:143,avail,available,143,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,1,['avail'],['available']
Availability,"/// When we if-convert we need to create edge masks. We have to cache values; /// so that we don't end up with exponential recursion/IR. Note that; /// if-conversion currently takes place during VPlan-construction, so these; /// caches are only used at that stage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:46,mask,masks,46,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,1,['mask'],['masks']
Availability,/// Whether an error during the parsing of the input args.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h:15,error,error,15,interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,1,['error'],['error']
Availability,/// Whether an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:15,error,error,15,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['error'],['error']
Availability,"/// Whether an error was encountered in the template arguments.; /// If so, NumArgs and the trailing arguments are best-effort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedTemplate.h:15,error,error,15,interpreter/llvm-project/clang/include/clang/Sema/ParsedTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedTemplate.h,1,['error'],['error']
Availability,/// Whether each block is an irreducible loop header.; /// This is used downstream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:72,down,downstream,72,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,1,['down'],['downstream']
Availability,/// Whether lane masks should get tracked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:17,mask,masks,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['mask'],['masks']
Availability,"/// Whether the RLogDiagCount has emitted an error (fatal or not) since construction time of *this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx:45,error,error,45,core/foundation/inc/ROOT/RLogger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx,1,['error'],['error']
Availability,"/// Whether the RLogDiagCount has emitted an error or a warning since construction time of *this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx:45,error,error,45,core/foundation/inc/ROOT/RLogger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx,1,['error'],['error']
Availability,/// Whether the consumer should treat consumed diagnostics as hard errors.; /// Useful for breaking your build when issues are found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h:67,error,errors,67,interpreter/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h,1,['error'],['errors']
Availability,/// Whether the error and entry specify a file/directory that was not found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:16,error,error,16,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['error'],['error']
Availability,"/// Whether the file should be cached before reading. Only available for; /// ""remote"" file protocols. If the download fails, the file will be opened; /// remotely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:59,avail,available,59,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,2,"['avail', 'down']","['available', 'download']"
Availability,"/// Whether the file should be opened asynchronously, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:57,avail,available,57,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,1,['avail'],['available']
Availability,/// Whether the type constraint has been initialized. This can be false if the; /// constraint was not initialized yet or if there was an error forming the; /// type constraint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h:138,error,error,138,interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,1,['error'],['error']
Availability,"/// Whether this expression contains subexpressions which had errors, e.g. a; /// TypoExpr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:62,error,errors,62,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['error'],['errors']
Availability,"/// Whether this expression is instantiation-dependent, meaning that; /// it depends in some way on; /// - a template parameter (even if neither its type nor (constant) value; /// can change due to the template instantiation); /// - or an error; ///; /// In the following example, the expression \c sizeof(sizeof(T() + T())) is; /// instantiation-dependent (since it involves a template parameter \c T), but; /// is neither type- nor value-dependent, since the type of the inner; /// \c sizeof is known (\c std::size_t) and therefore the size of the outer; /// \c sizeof is known.; ///; /// \code; /// template<typename T>; /// void f(T x, T y) {; /// sizeof(sizeof(T() + T());; /// }; /// \endcode; ///; /// \code; /// void func(int) {; /// func(); // the expression is instantiation-dependent, because it depends; /// // on an error.; /// }; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:239,error,error,239,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,2,['error'],['error']
Availability,/// Whether this header is available in the module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:27,avail,available,27,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['avail'],['available']
Availability,/// Whether this list can be empty in syntactically and semantically correct; /// code.; ///; /// This list may be empty when the source code has errors even if; /// canBeEmpty() returns false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:146,error,errors,146,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,1,['error'],['errors']
Availability,"/// Whether this mapping attempted to map the diagnostic to a warning, but; /// was overruled because the diagnostic was already mapped to an error or; /// fatal error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h:142,error,error,142,interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,2,['error'],['error']
Availability,/// Whether this module is available in the current translation unit.; ///; /// If the module is missing headers or does not meet all requirements then; /// this bit will be 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h:27,avail,available,27,interpreter/llvm-project/clang/include/clang/Basic/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h,1,['avail'],['available']
Availability,/// Whether this nested name specifier contains an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h:51,error,error,51,interpreter/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h,1,['error'],['error']
Availability,/// Whether this type is an error type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:28,error,error,28,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['error'],['error']
Availability,"/// Whether this type references an error, e.g. decltype(err-expression); /// yields an error type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:36,error,error,36,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,2,['error'],['error']
Availability,"/// Whether this type somehow involves; /// - a template parameter, even if the resolution of the type does not; /// depend on a template parameter.; /// - or an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:162,error,error,162,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['error'],['error']
Availability,"/// Whether this type; /// - is a dependent type (C++ [temp.dep.type]); /// - or it somehow involves an error, e.g. decltype(recovery-expr)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:104,error,error,104,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,2,"['error', 'recover']","['error', 'recovery-expr']"
Availability,/// Whether to abort fixing a file when not all errors could be fixed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h:48,error,errors,48,interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,1,['error'],['errors']
Availability,/// Whether to accept an AST file with compiler errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:48,error,errors,48,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['error'],['errors']
Availability,"/// Whether to attempt to produce a non-null (possibly incorrect) invocation; /// if any errors were encountered.; /// By default, always return null on errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h:89,error,errors,89,interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,2,['error'],['errors']
Availability,/// Whether to complain about failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h:30,failure,failures,30,interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,1,['failure'],['failures']
Availability,/// Whether to only fix warnings and not errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h:41,error,errors,41,interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,1,['error'],['errors']
Availability,/// Whether to treat broken debug info as an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:45,error,error,45,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['error'],['error']
Availability,/// Whether uncompilable error has occurred. This includes error happens; /// in deferred diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:25,error,error,25,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['error'],['error']
Availability,/// Whether warn or error on tag type mismatches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h:20,error,error,20,interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,1,['error'],['error']
Availability,/// Whether we can use the global module index if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h:50,avail,available,50,interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,1,['avail'],['available']
Availability,/// Whether we hit an error due to reaching max allowed include depth. Allows; /// to avoid hitting the same error over and over again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:22,error,error,22,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,2,['error'],['error']
Availability,/// Whether we've started finishing and tearing down this instance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp:48,down,down,48,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp,1,['down'],['down']
Availability,"/// Which attributes cannot be applied to a type. The argument \p ASK indicates,; /// if only attributes that are known to be safely droppable are contained in; /// the mask; only attributes that might be unsafe to drop (e.g., ABI-related; /// attributes) are in the mask; or both.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h:169,mask,mask,169,interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,2,['mask'],['mask']
Availability,"/// While alive, includes the current analysis stack in a crash trace.; ///; /// Example:; /// \code; /// 0. Program arguments: ...; /// 1. <eof> parser at end of file; /// 2. While analyzing stack:; /// #0 void inlined(); /// #1 void test(); /// 3. crash-trace.c:6:3: Error evaluating statement; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h:10,alive,alive,10,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PrettyStackTraceLocationContext.h,2,"['Error', 'alive']","['Error', 'alive']"
Availability,/// While vectorizing these instructions we have to generate a; /// call to the appropriate masked intrinsic or drop them in case of; /// conditional assumes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:92,mask,masked,92,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['mask'],['masked']
Availability,/// Widen a mask vector to a minimum of v8i1/v16i1 to allow use of KSHIFT and; /// bitcast with integer types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,/// Widen a mask vector type to a minimum of v8i1/v16i1 to allow use of KSHIFT; /// and bitcast with integer types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"/// Works similar to checkForManualIssues but instead of checking, it; /// applies automatic modifications to source files to conform to ARC.; ///; /// \returns false if no error is produced, true otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ARCMigrate/ARCMT.h:173,error,error,173,interpreter/llvm-project/clang/include/clang/ARCMigrate/ARCMT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ARCMigrate/ARCMT.h,1,['error'],['error']
Availability,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:43,FAULT,FAULTING,43,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,4,"['FAULT', 'fault']","['FAULTING', 'faults']"
Availability,"/// Wrap predicated VPReplicateRecipes with a mask operand in an if-then; /// region block and remove the mask operand. Optimize the created regions by; /// iteratively sinking scalar operands into the region, followed by merging; /// regions until no improvements are remaining.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:46,mask,mask,46,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,2,['mask'],['mask']
Availability,/// Wrapper function for readFileAndProcessRemarks which handles errors.; ///; /// \param[in] InputFileName - Name of file to read from.; /// \param[out] FuncNameToSizeInfo - Populated with information from size; /// remarks in the input file.; ///; /// \returns true if readFileAndProcessRemarks returned no errors. False; /// otherwise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkSizeDiff.cpp:65,error,errors,65,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkSizeDiff.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkSizeDiff.cpp,2,['error'],['errors']
Availability,/// Wraps the destination register name with AVX512 mask/maskz filtering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp:52,mask,mask,52,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,2,['mask'],"['mask', 'maskz']"
Availability,/// Write a human readable form of \p Mask to \p OS,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:38,Mask,Mask,38,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,1,['Mask'],['Mask']
Availability,"/// Write a precompiled header for the given semantic analysis.; ///; /// \param SemaRef a reference to the semantic analysis object that processed; /// the AST to be written into the precompiled header.; ///; /// \param WritingModule The module that we are writing. If null, we are; /// writing a precompiled header.; ///; /// \param isysroot if non-empty, write a relocatable file whose headers; /// are relative to the given system root. If we're writing a module, its; /// build directory will be used in preference to this if both are available.; ///; /// \return the module signature, which eventually will be a hash of; /// the module but currently is merely a random 32-bit number.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h:540,avail,available,540,interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,1,['avail'],['available']
Availability,"/// Write a sequence of optimal nops to the output, covering \p Count bytes.; /// \return - true on success, false on failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp:118,failure,failure,118,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp,1,['failure'],['failure']
Availability,"/// Write a sequence of optimal nops to the output, covering \p Count; /// bytes.; /// \return - true on success, false on failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:123,failure,failure,123,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,1,['failure'],['failure']
Availability,"/// Write a single modified source file.; ///; /// \returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h:81,error,error,81,interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,1,['error'],['error']
Availability,/// Write all error messages (if any) in E to a string. The newline character; /// is used to separate error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:14,error,error,14,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,4,['error'],['error']
Availability,"/// Write an (optimal) nop sequence of Count bytes to the given output. If the; /// target cannot generate such a sequence, it should return an error.; ///; /// \return - True on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmBackend.h:144,error,error,144,interpreter/llvm-project/llvm/include/llvm/MC/MCAsmBackend.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmBackend.h,1,['error'],['error']
Availability,"/// Write profiling data to a file.; /// The function will write to \p PreferredFileName if provided, if not; /// then will write to \p FallbackFileName appending .time-trace.; /// Returns a StringError indicating a failure if the function is; /// unable to open the file for writing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TimeProfiler.h:216,failure,failure,216,interpreter/llvm-project/llvm/include/llvm/Support/TimeProfiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TimeProfiler.h,1,['failure'],['failure']
Availability,"/// Write the bytes specified in \p Buffer to the underlying stream.; /// On success, updates the offset so that subsequent writes will occur; /// at the next unwritten position.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:208,error,error,208,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,2,['error'],['error']
Availability,"/// Write the index to the given bitstream.; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:69,error,error,69,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,1,['error'],['error']
Availability,"/// Write the integer \p Value to the underlying stream in the; /// specified endianness. On success, updates the offset so that; /// subsequent writes occur at the next unwritten position.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:219,error,error,219,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,2,['error'],['error']
Availability,"/// Write the modified source files.; ///; /// \returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h:77,error,error,77,interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,1,['error'],['error']
Availability,"/// Write the string \p Str to the underlying stream followed by a null; /// terminator. On success, updates the offset so that subsequent writes; /// occur at the next unwritten position. \p Str need not be null terminated; /// on input.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:268,error,error,268,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,2,['error'],['error']
Availability,"/// Write the string \p Str to the underlying stream without a null; /// terminator. On success, updates the offset so that subsequent writes; /// occur at the next unwritten position.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:214,error,error,214,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,2,['error'],['error']
Availability,"/// Write the unsigned integer Value to the underlying stream using ULEB128; /// encoding.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:120,error,error,120,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,4,['error'],['error']
Availability,"/// WriteNopData - Write an (optimal) nop sequence of Count bytes; /// to the given output. If the target cannot generate such a sequence,; /// it should return an error.; ///; /// \return - True on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp:164,error,error,164,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp,1,['error'],['error']
Availability,"/// Writes all data from the array \p Array to the underlying stream.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:99,error,error,99,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,2,['error'],['error']
Availability,"/// Writes all elements from the array \p Array to the underlying stream.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:103,error,error,103,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,2,['error'],['error']
Availability,"/// Writes an array of objects of type T to the underlying stream, as if by; /// using memcpy. It is up to the caller to ensure that type of \p Obj can; /// be safely copied in this fashion, as no checks are made to ensure that; /// this is safe.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:276,error,error,276,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,2,['error'],['error']
Availability,"/// Writes name for \p D to \p OS.; /// \returns true on failure, false on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Mangle.h:57,failure,failure,57,interpreter/llvm-project/clang/include/clang/AST/Mangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Mangle.h,1,['failure'],['failure']
Availability,"/// Writes the block containing the serialized form of the; /// source manager.; ///; /// TODO: We should probably use an on-disk hash table (stored in a; /// blob), indexed based on the file name, so that we only create; /// entries for files that we actually need. In the common case (no; /// errors), we probably won't have to create file entries for any of; /// the files in the AST.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:295,error,errors,295,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['error'],['errors']
Availability,"/// Writes the object \p Obj to the underlying stream, as if by using memcpy.; /// It is up to the caller to ensure that type of \p Obj can be safely copied; /// in this fashion, as no checks are made to ensure that this is safe.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:259,error,error,259,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,2,['error'],['error']
Availability,"/// X = FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating point type; /// down to the precision of the destination VT. TRUNC is a flag, which is; /// always an integer that is zero or one. If TRUNC is 0, this is a; /// normal rounding, if it is 1, this FP_ROUND is known to not change the; /// value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// FP_EXTEND(FP_ROUND(X,1)) -> X which are not safe for; /// FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren't removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:81,down,down,81,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['down'],['down']
Availability,"/// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating; /// point type down to the precision of the destination VT. TRUNC is a; /// flag, which is always an integer that is zero or one. If TRUNC is 0,; /// this is a normal rounding, if it is 1, this FP_ROUND is known to not; /// change the value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't; /// removed.; /// It is used to limit optimizations while the DAG is being optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:88,down,down,88,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['down'],['down']
Availability,"/// X86 FP SETCC, similar to above, but with output as an i1 mask and; /// and a version with SAE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:61,mask,mask,61,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['mask'],['mask']
Availability,/// XRay traces all have a header providing some top-matter information useful; /// to help tools determine how to interpret the information available in the; /// trace.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:141,avail,available,141,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,1,['avail'],['available']
Availability,/// Zero extend to a new width.; ///; /// This operation zero extends the APInt to a new width. The high order bits; /// are filled with 0 bits. It is an error to specify a width that is less; /// than the current width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:154,error,error,154,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['error'],['error']
Availability,/// Zero out the discriminator bits higher than bit MaskedBitFrom (0 based).; /// The default is to keep all the bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h:52,Mask,MaskedBitFrom,52,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,1,['Mask'],['MaskedBitFrom']
Availability,/// \#pragma GCC error has been invoked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PPCallbacks.h:17,error,error,17,interpreter/llvm-project/clang/include/clang/Lex/PPCallbacks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PPCallbacks.h,1,['error'],['error']
Availability,/// \brief A return type requirement was specified but it was a; /// substitution failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprConcepts.h:82,failure,failure,82,interpreter/llvm-project/clang/include/clang/AST/ExprConcepts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprConcepts.h,1,['failure'],['failure']
Availability,"/// \brief Check whether the given declaration's associated constraints are; /// at least as constrained than another declaration's according to the; /// partial ordering of constraints.; ///; /// \param Result If no error occurred, receives the result of true if D1 is; /// at least constrained than D2, and false otherwise.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:217,error,error,217,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['error'],['error']
Availability,"/// \brief Check whether the given list of constraint expressions are; /// satisfied (as if in a 'conjunction') given template arguments.; /// Additionally, takes an empty list of Expressions which is populated with; /// the instantiated versions of the ConstraintExprs.; /// \param Template the template-like entity that triggered the constraints; /// check (either a concept or a constrained entity).; /// \param ConstraintExprs a list of constraint expressions, treated as if; /// they were 'AND'ed together.; /// \param ConvertedConstraints a out parameter that will get populated with; /// the instantiated version of the ConstraintExprs if we successfully checked; /// satisfaction.; /// \param TemplateArgList the multi-level list of template arguments to; /// substitute into the constraint expression. This should be relative to the; /// top-level (hence multi-level), since we need to instantiate fully at the; /// time of checking.; /// \param TemplateIDRange The source range of the template id that; /// caused the constraints check.; /// \param Satisfaction if true is returned, will contain details of the; /// satisfaction, with enough information to diagnose an unsatisfied; /// expression.; /// \returns true if an error occurred and satisfaction could not be checked,; /// false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:1233,error,error,1233,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// \brief Check whether the given list of constraint expressions are; /// satisfied (as if in a 'conjunction') given template arguments.; /// \param Template the template-like entity that triggered the constraints; /// check (either a concept or a constrained entity).; /// \param ConstraintExprs a list of constraint expressions, treated as if; /// they were 'AND'ed together.; /// \param TemplateArgLists the list of template arguments to substitute into; /// the constraint expression.; /// \param TemplateIDRange The source range of the template id that; /// caused the constraints check.; /// \param Satisfaction if true is returned, will contain details of the; /// satisfaction, with enough information to diagnose an unsatisfied; /// expression.; /// \returns true if an error occurred and satisfaction could not be checked,; /// false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:780,error,error,780,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// \brief Check whether the given non-dependent constraint expression is; /// satisfied. Returns false and updates Satisfaction with the satisfaction; /// verdict if successful, emits a diagnostic and returns true if an error; /// occurred and satisfaction could not be determined.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:221,error,error,221,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['error'],['error']
Availability,"/// \brief Checks if a column is present in the dataset.; /// \return true if the column is available, false otherwise; ///; /// This method checks if a column is part of the input ROOT dataset, has; /// been defined or can be provided by the data source.; ///; /// Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame base(1);; /// auto rdf = base.Define(""definedColumn"", [](){return 0;});; /// rdf.HasColumn(""definedColumn""); // true: we defined it; /// rdf.HasColumn(""rdfentry_""); // true: it's always there; /// rdf.HasColumn(""foo""); // false: it is not there; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx:92,avail,available,92,tree/dataframe/src/RInterfaceBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx,1,['avail'],['available']
Availability,"/// \brief Checks if there are more training batches available; /// \return",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchLoader.hxx:53,avail,available,53,tmva/tmva/inc/TMVA/RBatchLoader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchLoader.hxx,2,['avail'],['available']
Availability,"/// \brief Construct a compound requirement whose expression was a; /// substitution failure. The requirement is not satisfied.; /// \param E the diagnostic emitted while instantiating the original; /// expression.; /// \param IsSimple whether this was a simple requirement in source.; /// \param NoexceptLoc the location of the noexcept keyword, if it was; /// specified, otherwise an empty location.; /// \param Req the requirement for the type of the checked expression (omit; /// if no requirement was specified).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprConcepts.h:85,failure,failure,85,interpreter/llvm-project/clang/include/clang/AST/ExprConcepts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprConcepts.h,1,['failure'],['failure']
Availability,/// \brief Emit diagnostics explaining why a constraint expression was deemed; /// unsatisfied.; /// \param First whether this is the first time an unsatisfied constraint is; /// diagnosed for this error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:198,error,error,198,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// \brief Enables shadowing of definitions, as per https://github.com/root-project/cling/issues/259.; ///; /// A top-level declaration typed in the Cling prompt is nested in a; /// `__cling_N5xxx' inline namespace, so that the newly provided definition; /// doesn't clash, e.g. in unmodified Cling, \code unsigned i = 0U;; /// double i = 1.0; \endcode fails to compile (error: redefinition of 'i' with; /// a different type: 'double' vs 'unsigned int'). To support that, the; /// previous code is transformed into:; /// \code; /// inline namespace __cling_N50 { unsigned i = 0U; }; /// inline namespace __cling_N51 { double i = 1.0; }; /// \endcode; ///; /// While this works for providing a new definition, any non-qualified lookup,; /// i.e. using the name `i` instead of `__cling___N50::i` would be ambiguous.; /// To allow the use of unqualified names, and therefore make this; /// transformation transparent to the user, any previous definition that can; /// be found from the TU scope is hidden from SemaLookup.; ///; /// It is still possible to reach previous definitions through the qualified; /// name `__cling_N5xxx::yyy'.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DefinitionShadower.h:371,error,error,371,interpreter/cling/lib/Interpreter/DefinitionShadower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DefinitionShadower.h,1,['error'],['error']
Availability,/// \brief Enumerates the available kinds for capturing diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:26,avail,available,26,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['avail'],['available']
Availability,/// \brief Enumerates the available scopes for skipping function bodies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:26,avail,available,26,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['avail'],['available']
Availability,"/// \brief Generate the TClass and TStreamerInfo for the requested pair.; /// This creates a TVirtualStreamerInfo for the pair and trigger the BuildCheck/Old to; /// provokes the creation of the corresponding TClass. This relies on the dictionary for; /// std::pair<const int, int> to already exist (or the interpreter information being available); /// as it is used as a template.; /// \note The returned object is owned by the caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TVirtualStreamerInfo.h:337,avail,available,337,core/meta/inc/TVirtualStreamerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TVirtualStreamerInfo.h,2,['avail'],['available']
Availability,"/// \brief Import the given object, returns the result.; ///; /// \param To Import the object into this variable.; /// \param From Object to import.; /// \return Error information (success or error).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:162,Error,Error,162,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// \brief In order to implement the runtime type binding and expression; /// evaluation we need to be able to compile code which contains unknown; /// symbols (undefined variables, types, functions, etc.). This cannot be done; /// by a compiler like clang, because it is not valid C++ code.; ///; /// DynamicExprTransformer transforms these unknown symbols into valid C++; /// code at AST (abstract syntax tree) level. Thus it provides an opportunity; /// their evaluation to happen at runtime. Several steps are performed:; ///; /// 1. Skip compiler's error diagnostics - if a compiler encounters unknown; /// symbol, by definition, it must output an error and it mustn't produce; /// machine code. Cling implements an extension to Clang semantic analyzer; /// that allows the compiler to recover even an unknown symbol is encountered.; /// For instance if the compiler sees a symbol it looks for its definition in; /// a internal structure (symbol table) and it is not found it asks whether; /// somebody else could provide the missing symbol. That is the place where; /// the DynamicIDHandler, which is controlled by DynamicExprTransformer comes; /// into play. It marks all unknown symbols as dependent as if they are; /// templates and are going to be resolved at first instantiation, with the; /// only difference that an instantiation never happens. The advantage is that; /// the unknown symbols are not diagnosed but the disadvantage is that; /// somebody needs to transform them into valid expressions with valid types.; ///; /// 2. Replace all dependent symbols - all artificially dependent symbols need; /// to be replaced with appropriate valid symbols in order the compiler to; /// produce executable machine code. The DynamicExprTransformer walks up all; /// statements and declarations that might be possibly marked earlier as; /// dependent and replaces them with valid expression, which preserves the; /// meant behavior. Main implementation goal is to replace the as little; /// as",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.h:554,error,error,554,interpreter/cling/lib/Interpreter/DynamicLookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.h,3,"['error', 'recover']","['error', 'recover']"
Availability,/// \brief Kind of error when importing an AST component.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImportError.h:19,error,error,19,interpreter/llvm-project/clang/include/clang/AST/ASTImportError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImportError.h,1,['error'],['error']
Availability,"/// \brief Produce all required systematic variations for the given result.; /// \param[in] resPtr The result for which variations should be produced.; /// \return A \ref ROOT::RDF::Experimental::RResultMap ""RResultMap"" object with full variation names as strings; /// (e.g. ""pt:down"") and the corresponding varied results as values.; ///; /// A given input RResultPtr<T> produces a corresponding RResultMap<T> with a ""nominal""; /// key that will return a value identical to the one contained in the original RResultPtr.; /// Other keys correspond to the varied values of this result, one for each variation; /// that the result depends on.; /// VariationsFor does not trigger the event loop. The event loop is only triggered; /// upon first access to a valid key, similarly to what happens with RResultPtr.; ///; /// If the result does not depend, directly or indirectly, from any registered systematic variation, the; /// returned RResultMap will contain only the ""nominal"" key.; ///; /// See RDataFrame's \ref ROOT::RDF::RInterface::Vary() ""Vary"" method for more information and example usages.; ///; /// \note Currently, producing variations for the results of \ref ROOT::RDF::RInterface::Display() ""Display"",; /// \ref ROOT::RDF::RInterface::Report() ""Report"" and \ref ROOT::RDF::RInterface::Snapshot() ""Snapshot""; /// actions is not supported.; //; // An overview of how systematic variations work internally. Given N variations (including the nominal):; //; // RResultMap owns RVariedAction; // N results N action helpers; // N previous filters; // N*#input_cols column readers; //; // ...and each RFilter and RDefine knows for what universe it needs to construct column readers (""nominal"" by default).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:279,down,down,279,tree/dataframe/inc/ROOT/RDFHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx,1,['down'],['down']
Availability,"/// \brief Provides last resort lookup for failed unqualified lookups.; ///; /// This gets translated into InterpreterCallback's call.; ///; ///\param[out] R The recovered symbol.; ///\param[in] S The scope in which the lookup failed.; ///; ///\returns true if a suitable declaration is found.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/InterpreterCallbacks.cpp:162,recover,recovered,162,interpreter/cling/lib/Interpreter/InterpreterCallbacks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/InterpreterCallbacks.cpp,1,['recover'],['recovered']
Availability,"/// \brief Register systematic variations for a single existing column using custom variation tags.; /// \param[in] colName name of the column for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:666,down,down,666,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['down'],['down']
Availability,"/// \brief Register systematic variations for a single existing column using custom variation tags.; /// \param[in] colName name of the column for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec containing the varied; /// values for the specified column.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; /// compiled. The example below shows how Vary() is used while dealing with a single column. The variation tags are; /// defined as `{""down"", ""up""}`.; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", ""ROOT::RVecD{pt*0.9, pt*1.1}"", {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:414,down,down,414,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,4,['down'],['down']
Availability,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; /// is avoided.; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:677,down,down,677,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['down'],['down']
Availability,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`; ///; /// This overload of Vary takes a list of column names as first argument and; /// requires that the expression returns an RVec of RVecs of values: one inner RVec for the variations of each; /// affected column. The `variationTags` are defined as `{""down"", ""up""}`.; ///; /// Example usage:; /// ~~~{.cpp}; /// // produce variations ""ptAndEta:down"" and ""ptAndEta:up""; /// auto nominal_hx =; /// df.Vary({""pt"", ""eta""}, // the columns that will vary simultaneously; /// [](double pt, double eta) { return RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}; },; /// {""pt"", ""eta""}, // inputs to the Vary expression, independent of what columns are varied; /// {""down"", ""up""}, // variation tags; /// ""ptAndEta"") // variation name; /// .Histo1D(""pt"", ""eta"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""ptAndEta:down""].Draw(""SAME"");; /// hx[""ptAndEta:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:677,down,down,677,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,5,['down'],['down']
Availability,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec or RVecs containing the varied; /// values for the specified columns.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; /// compiled. The example below shows how Vary() is used while dealing with multiple columns. The tags are defined as; /// `{""down"", ""up""}`.; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary({""x"", ""y""}, ""ROOT::RVec<ROOT::RVecD>{{x*0.9, x*1.1}, {y*0.9, y*1.1}}"", {""down"", ""up""}, ""xy""); /// .Histo1D(""x"", ""y"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""xy:down""].Draw(""SAME"");; /// hx[""xy:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:435,down,down,435,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,4,['down'],['down']
Availability,"/// \brief Release event data from queue.; /// \return 0 on success; a DAOS error code otherwise (< 0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:76,error,error,76,tree/ntuple/v7/inc/ROOT/RDaos.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx,1,['error'],['error']
Availability,"/// \brief Report diagnostics to the ROOT error handler (see TError.h).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h:42,error,error,42,core/meta/inc/TInterpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h,1,['error'],['error']
Availability,"/// \brief Reserve event in queue, optionally tied to a parent event.; /// \return 0 on success; a DAOS error code otherwise (< 0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:104,error,error,104,tree/ntuple/v7/inc/ROOT/RDaos.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx,1,['error'],['error']
Availability,"/// \brief Retrieves the clang CC1 specific flags out of the compilation's; /// jobs. Returns NULL on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:102,error,error,102,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['error'],['error']
Availability,"/// \brief Returns the next batch of training data if available.; /// Returns empty RTensor otherwise.; /// \return",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx:54,avail,available,54,tmva/tmva/inc/TMVA/RBatchGenerator.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx,1,['avail'],['available']
Availability,"/// \brief Returns the next batch of validation data if available.; /// Returns empty RTensor otherwise.; /// \return",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx:56,avail,available,56,tmva/tmva/inc/TMVA/RBatchGenerator.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx,1,['avail'],['available']
Availability,"/// \brief Sets event barrier for a given parent event and waits for the completion of all children launched before; /// the barrier (must have at least one child).; /// \return 0 on success; a DAOS error code otherwise (< 0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:199,error,error,199,tree/ntuple/v7/inc/ROOT/RDaos.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx,1,['error'],['error']
Availability,"/// \brief This callback is invoked whenever the interpreter failed to load a library.; ///; /// \param[in] - Error message and parameters passed to loadLibrary; /// \returns true if the error was handled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/InterpreterCallbacks.h:110,Error,Error,110,interpreter/cling/include/cling/Interpreter/InterpreterCallbacks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/InterpreterCallbacks.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// \brief Underlying DAOS container. An internal `std::shared_ptr` keep the pool connection alive.; /// ISO C++ ensures the correct destruction order, i.e., `~RDaosContainer` is invoked first; /// (which calls `daos_cont_close()`; the destructor for the `std::shared_ptr<RDaosPool>` is invoked; /// after (which calls `daos_pool_disconect()`).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx:93,alive,alive,93,tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,1,['alive'],['alive']
Availability,"/// \brief Used to stores the declarations, which are going to be; /// available only at runtime. These are cling runtime builtins",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/RuntimeUniverse.h:71,avail,available,71,interpreter/cling/include/cling/Interpreter/RuntimeUniverse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/RuntimeUniverse.h,1,['avail'],['available']
Availability,"/// \brief When set to true, any fatal error reported is made an error.; ///; /// This setting takes precedence over the setErrorsAsFatal setting above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:39,error,error,39,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,2,['error'],['error']
Availability,"/// \copydoc Sema::CorrectTypo; /// \note LookupKind must correspond to a valid Sema::LookupNameKind; ///; /// ExternalSemaSource::CorrectTypo is always given the first chance to; /// correct a typo (really, to offer suggestions to repair a failed lookup).; /// It will even be called when SpellChecking is turned off or after a; /// fatal error has already been detected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h:232,repair,repair,232,interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,2,"['error', 'repair']","['error', 'repair']"
Availability,/// \file RemoveRedundantDebugValues.cpp; ///; /// The RemoveRedundantDebugValues pass removes redundant DBG_VALUEs that; /// appear in MIR after the register allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:95,redundant,redundant,95,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,1,['redundant'],['redundant']
Availability,"/// \file; /// \ingroup tutorial_webcanv; /// \notebook -js; /// Drawing primitives inside and outside of the frame.; ///; /// In normal ROOT graphics all objects drawn on the pad and therefore; /// requires special treatment to be able drawn only inside frame borders.; /// In web-based graphics objects automatically clipped by frame border - if drawn inside frame.; /// Macro demonstrates usage of ""frame"" draw option for TLine, TBox, TMarker and TLatex classes.; /// If user interactively change zooming range ""in-frame"" objects automatically clipped.; ///; /// Functionality available only in web-based graphics; ///; /// \macro_image (tcanvas_js); /// \macro_code; ///; /// \author Sergey Linev",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/inframe.cxx:580,avail,available,580,tutorials/webcanv/inframe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/inframe.cxx,1,['avail'],['available']
Availability,"/// \file; /// \ingroup tutorial_webcanv; /// \notebook -js; /// Logarithmic scales support in web canvas.; ///; /// Shows support of log2, ln, log8 and log25 scales; /// Any integer base for logarithm can be specified as well; ///; /// Functionality available only in web-based graphics; ///; /// \macro_image (tcanvas_js); /// \macro_code; ///; /// \author Sergey Linev",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/logN.cxx:251,avail,available,251,tutorials/webcanv/logN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/logN.cxx,1,['avail'],['available']
Availability,"/// \file; /// \ingroup tutorial_webcanv; /// \notebook -js; /// Swap X/Y axes drawing and use to draw TH1 as bar and as markers.; ///; /// Option ""haxisg;y+"" draw histogram axis as for ""hbar"" plus allow to draw grids plus draw Y labels on other side; /// Option ""bar,base0,same"" draws histogram as bars with 0 as reference value; /// Option ""P,same"" draws histogram as markers; /// Macro also shows how frame margins can be configured and poly-line drawing like filled arrow can be; /// placed relative to frame.; ///; /// Functionality available only in web-based graphics; ///; /// \macro_image (tcanvas_js); /// \macro_code; ///; /// \author Sergey Linev",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/haxis.cxx:538,avail,available,538,tutorials/webcanv/haxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/haxis.cxx,1,['avail'],['available']
Availability,"/// \file; /// \ingroup tutorial_webcanv; /// \notebook -js; /// Two fully interactive scales in web canvas.; ///; /// Shows two scales drawing for X or Y axis; /// Several objects can be drawn on the frame and one can select which axis is used for drawing; /// Y+ means that Y drawn on right frame side, X+ - X will be drawn on top frame side; /// Several objects can be add to the frame and associated with normal or opposite axis drawing -; /// like using ""same,Y+"" option; ///; /// Functionality available only in web-based graphics; ///; /// \macro_image (tcanvas_js); /// \macro_code; ///; /// \author Sergey Linev",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/twoscales.cxx:500,avail,available,500,tutorials/webcanv/twoscales.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/twoscales.cxx,1,['avail'],['available']
Availability,"/// \file; /// \ingroup tutorial_webcanv; /// \notebook -js; /// Usage of TTF fonts in web canvas.; ///; /// One can load TTF font file and specify it for usage in the web canvas; /// Produced drawing also can be saved in PDF files.; ///; /// Functionality available only in web-based graphics; ///; /// \macro_image (tcanvas_js); /// \macro_code; ///; /// \author Sergey Linev",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/fonts_ttf.cxx:257,avail,available,257,tutorials/webcanv/fonts_ttf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/fonts_ttf.cxx,1,['avail'],['available']
Availability,"/// \file; /// \ingroup tutorial_webcanv; /// \notebook -js; /// Use of interactive URL links inside TLatex.; ///; /// JSROOT now supports '#url[link]{label}' syntax; /// It can be combined with any other latex commands like color ot font.; /// While TLatex used in many places, one can add external links to histogram title,; /// axis title, legend entry and so on.; ///; /// Functionality available only in web-based graphics; ///; /// \macro_image (tcanvas_js); /// \macro_code; ///; /// \author Sergey Linev",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/latex_url.cxx:391,avail,available,391,tutorials/webcanv/latex_url.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/latex_url.cxx,1,['avail'],['available']
Availability,"/// \file; /// \ingroup tutorial_webgui; /// \ingroup webwidgets; /// Test suite for RWebWindow communication performance; ///; /// On the first place latency of round-trip (ping-pong) packet is measured; /// File ping.cxx implements server-side code of RWebWindow; /// In ping.html client code plus visualization is provided.; ///; /// \macro_code; ///; /// \author Sergey Linev",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx:174,ping,ping-pong,174,tutorials/webgui/ping/ping.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx,3,['ping'],"['ping', 'ping-pong']"
Availability,"/// \internal; /// An artifact location is SARIF's way of describing the complete location; /// of an artifact encountered during analysis. The \c artifactLocation object; /// typically consists of a URI, and/or an index to reference the artifact it; /// locates.; ///; /// This builder makes an additional assumption: that every artifact encountered; /// by \c clang will be a physical, top-level artifact. Which is why the static; /// creation method \ref SarifArtifactLocation::create takes a mandatory URI; /// parameter. The official standard states that either a \c URI or \c Index; /// must be available in the object, \c clang picks the \c URI as a reasonable; /// default, because it intends to deal in physical artifacts for now.; ///; /// Reference:; /// 1. <a href=""https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317427"">artifactLocation object</a>; /// 2. \ref SarifArtifact",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sarif.h:601,avail,available,601,interpreter/llvm-project/clang/include/clang/Basic/Sarif.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sarif.h,1,['avail'],['available']
Availability,"/// \macro LLVM_PLUGIN_API_VERSION; /// Identifies the API version understood by this plugin.; ///; /// When a plugin is loaded, the driver will check it's supported plugin version; /// against that of the plugin. A mismatch is an error. The supported version; /// will be incremented for ABI-breaking changes to the \c PassPluginLibraryInfo; /// struct, i.e. when callbacks are added, removed, or reordered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h:231,error,error,231,interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,1,['error'],['error']
Availability,/// \name API for IR modification with state keeping to support rollback.; /// @{; /// Same as Instruction::setOperand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,rollback,rollback,64,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['rollback'],['rollback']
Availability,"/// \p Context, \p SM, and \p Traits can be null. This is because we want; /// to be able to call \p dump() in a debugger without having to pass the; /// \p ASTContext to \p dump. Not all parts of the AST dump output will be; /// available without the \p ASTContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TextNodeDumper.h:230,avail,available,230,interpreter/llvm-project/clang/include/clang/AST/TextNodeDumper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TextNodeDumper.h,1,['avail'],['available']
Availability,"/// \p Fn is the function where the diagnostic is being emitted. \p Loc is; /// the location information to use in the diagnostic. If line table; /// information is available, the diagnostic will include the source code; /// location. \p Msg is the message to show. Note that this class does not; /// copy this message, so this reference must be valid for the whole life time; /// of the diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:165,avail,available,165,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,2,['avail'],['available']
Availability,"/// \p PassName is the name of the pass emitting this diagnostic. \p; /// RemarkName is a textual identifier for the remark (single-word,; /// camel-case). \p Fn is the function where the diagnostic is being emitted.; /// \p Loc is the location information to use in the diagnostic. If line table; /// information is available, the diagnostic will include the source code; /// location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:317,avail,available,317,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['avail'],['available']
Availability,"/// \p PassName is the name of the pass emitting this diagnostic. \p; /// RemarkName is a textual identifier for the remark (single-word,; /// camel-case). \p Fn is the function where the diagnostic is being emitted.; /// \p Loc is the location information to use in the diagnostic. If line table; /// information is available, the diagnostic will include the source code; /// location. \p CodeRegion is IR value (currently basic block) that the; /// optimization operates on. This is currently used to provide run-time; /// hotness information with PGO.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:317,avail,available,317,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['avail'],['available']
Availability,"/// \param Consumer receives all rewrites and the associated metadata for a; /// single match, or an error. Will always be called for each match, even if; /// the rule generates no edits. Note that clients are responsible for; /// handling the case that independent \c AtomicChanges conflict with each; /// other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:101,error,error,101,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,1,['error'],['error']
Availability,"/// \param Consumer receives all rewrites for a single match, or an error.; /// Will not necessarily be called for each match; for example, if the rule; /// generates no edits but does not fail. Note that clients are responsible; /// for handling the case that independent \c AtomicChanges conflict with each; /// other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:68,error,error,68,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,1,['error'],['error']
Availability,"/// \param[in] callingClass Class that's calling. Needed to include name and type name of the class in error message.; /// \param[in] pars List of all parameters to be checked.; /// \param[in] min Minimum of allowed range. `min` itself counts as disallowed.; /// \param[in] max Maximum of allowed range. `max` itself counts as disallowed.; /// \param[in] limitsInAllowedRange If true, the limits passed as parameters are part of the allowed range.; /// \param[in] extraMessage Message that should be appended to the warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHelpers.cxx:103,error,error,103,roofit/roofitcore/src/RooHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHelpers.cxx,1,['error'],['error']
Availability,"/// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; /// RDataFrame computes all variations as part of a single loop over the data.; /// In particular, this means that I/O and computation of values shared; /// among variations only happen once for all variations. Thus, the event loop; /// run-time typically scales much better than linearly with the number of; /// variations.; ///; /// RDataFrame lazily computes the varied values requir",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1577,down,down,1577,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['down'],['down']
Availability,"/// \return STOREcnt or VScnt bit mask for given isa \p Version.; /// returns 0 for versions that do not support STOREcnt or VScnt.; /// STOREcnt and VScnt are the same counter, the name used; /// depends on the ISA version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['mask'],['mask']
Availability,"/// \return The associativity of the cache level, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:53,avail,available,53,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['avail'],['available']
Availability,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:318,mask,mask,318,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['mask']
Availability,"/// \return The cost of a shuffle instruction of kind Kind and of type Tp.; /// The exact mask may be passed as Mask, or else the array will be empty.; /// The index and subtype parameters are used by the subvector insertion and; /// extraction shuffle kinds to show the insert/extract point and the type of; /// the subvector being inserted/extracted. The operands of the shuffle can be; /// passed through \p Args, which helps improve the cost estimation in some; /// cases, like in broadcast loads.; /// NOTE: For subvector extractions Tp represents the source type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:90,mask,mask,90,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,/// \return The cost of masked Load and Store instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:24,mask,masked,24,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['masked']
Availability,"/// \return The cost of replication shuffle of \p VF elements typed \p EltTy; /// \p ReplicationFactor times.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:137,mask,mask,137,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['mask']
Availability,/// \return The cost of the interleaved memory operation.; /// \p Opcode is the memory operation code; /// \p VecTy is the vector type of the interleaved access.; /// \p Factor is the interleave factor; /// \p Indices is the indices for interleaved load members (as interleaved; /// load allows gaps); /// \p Alignment is the alignment of the memory operation; /// \p AddressSpace is address space of the pointer.; /// \p UseMaskForCond indicates if the memory access is predicated.; /// \p UseMaskForGaps indicates if gaps should be masked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:534,mask,masked,534,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['masked']
Availability,"/// \return The expected cost of vector Insert and Extract.; /// This is used when instruction is available, and implementation; /// asserts 'I' is not nullptr.; ///; /// A typical suitable use case is cost estimation when vector instruction; /// exists (e.g., from basic blocks during transformation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:98,avail,available,98,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['avail'],['available']
Availability,/// \return The expected cost of vector Insert and Extract.; /// Use -1 to indicate that there is no information on the index value.; /// This is used when the instruction is not available; a typical use; /// case is to provision the cost of vectorization/scalarization in; /// vectorizer passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:179,avail,available,179,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['avail'],['available']
Availability,/// \return The mask parameter or nullptr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h:16,mask,mask,16,interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,1,['mask'],['mask']
Availability,"/// \return The size of the cache level in bytes, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:53,avail,available,53,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['avail'],['available']
Availability,/// \return true if 'V & Mask' is known to be zero in DemandedElts. We use; /// this predicate to simplify operations downstream.; /// Mask is known to be zero for bits that V cannot have.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GISelKnownBits.h:25,Mask,Mask,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GISelKnownBits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GISelKnownBits.h,3,"['Mask', 'down']","['Mask', 'downstream']"
Availability,/// \return true if \p M is a zip mask for a shuffle vector of \p NumElts.; /// Whether or not G_ZIP1 or G_ZIP2 should be used is stored in \p WhichResult.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,1,['mask'],['mask']
Availability,/// \return true if the sign bit of Op is known to be zero. We use this; /// predicate to simplify operations downstream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GISelKnownBits.h:110,down,downstream,110,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GISelKnownBits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GISelKnownBits.h,1,['down'],['downstream']
Availability,"/// \returns A MemoryBuffer for the input file on success, and an Error; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkUtilHelpers.cpp:66,Error,Error,66,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkUtilHelpers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkUtilHelpers.cpp,1,['Error'],['Error']
Availability,"/// \returns A ToolOutputFile which can be used for writing remarks on success,; /// and an Error otherwise.; /// \p OutputFileName is the desired destination.; /// \p OutputFormat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkUtilHelpers.cpp:92,Error,Error,92,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkUtilHelpers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkUtilHelpers.cpp,1,['Error'],['Error']
Availability,"/// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, success otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:66,error,errors,66,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,1,['error'],['errors']
Availability,"/// \returns A pair of integer values requested using \p F's \p Name attribute; /// in ""first[,second]"" format (""second"" is optional unless \p OnlyFirstRequired; /// is false).; ///; /// \returns \p Default if attribute is not present.; ///; /// \returns \p Default and emits error if one of the requested values cannot be; /// converted to integer, or \p OnlyFirstRequired is false and ""second"" value is; /// not present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:276,error,error,276,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['error'],['error']
Availability,/// \returns Bit mask for given bit \p Shift and bit \p Width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,1,['mask'],['mask']
Availability,/// \returns Bvhcnt bit mask for given isa \p Version.; /// Returns 0 for versions that do not support BVHcnt,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['mask'],['mask']
Availability,/// \returns Common mask for reorder indices and reused scalars.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,/// \returns Conditions flags used after \p CmpInstr in its MachineBB if NZCV; /// flags are not alive in successors of the same \p CmpInstr and \p MI parent.; /// \returns std::nullopt otherwise.; ///; /// Collect instructions using that flags in \p CCUseInstrs if provided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:97,alive,alive,97,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,2,['alive'],['alive']
Availability,/// \returns Dscnt bit mask for given isa \p Version.; /// Returns 0 for versions that do not support DScnt,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['mask'],['mask']
Availability,/// \returns Dscnt bit mask for given isa \p Version.; /// Returns 0 for versions that do not support KMcnt,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['mask'],['mask']
Availability,/// \returns Expcnt bit mask for given isa \p Version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['mask'],['mask']
Availability,/// \returns Failure ordering constraint of the machine instruction used to; /// create this SIMemOpInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:13,Failure,Failure,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,1,['Failure'],['Failure']
Availability,/// \returns Integer value requested using \p F's \p Name attribute.; ///; /// \returns \p Default if attribute is not present.; ///; /// \returns \p Default and emits error if requested value cannot be converted; /// to integer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:168,error,error,168,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['error'],['error']
Availability,/// \returns Lgkmcnt bit mask for given isa \p Version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['mask'],['mask']
Availability,/// \returns Samplecnt bit mask for given isa \p Version.; /// Returns 0 for versions that do not support SAMPLEcnt,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['mask'],['mask']
Availability,"/// \returns The cost, if any, of keeping values of the given types alive; /// over a callsite.; ///; /// Some types may require the use of register classes that do not have; /// any callee-saved registers, so would require a spill and fill.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:68,alive,alive,68,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['alive'],['alive']
Availability,/// \returns The error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:17,error,error,17,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['error'],['error']
Availability,"/// \returns The scanned preprocessor directive tokens of the file that are; /// used to speed up preprocessing, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:116,avail,available,116,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['avail'],['available']
Availability,/// \returns True if \p Reg is available from the end of the block to the; /// beginning of the sequence.; ///; /// This query considers the following range:; ///; /// in_seq_1; /// in_seq_2; /// ...; /// in_seq_n; /// not_in_seq_1; /// ...; /// <end of block>,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:31,avail,available,31,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,1,['avail'],['available']
Availability,/// \returns True if \p Reg is available within the sequence itself.; ///; /// This query considers the following range:; ///; /// in_seq_1; /// in_seq_2; /// ...; /// in_seq_n,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:31,avail,available,31,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,1,['avail'],['available']
Availability,/// \returns True if the entry is a filesystem error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:47,error,error,47,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['error'],['error']
Availability,"/// \returns True if the target prefers reductions select kept in the loop; /// when tail folding. i.e.; /// loop:; /// p = phi (0, s); /// a = add (p, x); /// s = select (mask, a, p); /// vecreduce.add(s); ///; /// As opposed to the normal scheme of p = phi (0, a) which allows the select; /// to be pulled out of the loop. If the select(.., add, ..) can be predicated; /// by the target, this can lead to cleaner code generation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:172,mask,mask,172,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['mask'],['mask']
Availability,"/// \returns True on success, false on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUTargetStreamer.h:39,failure,failure,39,interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUTargetStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUTargetStreamer.h,13,['failure'],['failure']
Availability,/// \returns Waitcnt bit mask for given isa \p Version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['mask'],['mask']
Availability,"/// \returns a string containing the result of evaluating the expression in; /// this substitution, or an error if evaluation failed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:106,error,error,106,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,/// \returns a string containing the result of the substitution represented; /// by this class instance or an error if substitution failed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:110,error,error,110,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,"/// \returns a wildcard regular expression string that matches any value in; /// the format represented by this instance and no other value, or an error; /// if the format is NoFormat.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:147,error,error,147,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,"/// \returns the compare predicate type if the test performed by; /// llvm.is.fpclass(x, \p Mask) is equivalent to fcmp o__ x, 0.0 with the; /// floating-point environment assumed for \p F for type \p Ty",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:92,Mask,Mask,92,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['Mask'],['Mask']
Availability,/// \returns the mask of all the call preserved registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.h:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.h,1,['mask'],['mask']
Availability,"/// \returns the relocation offset with the base address of the containing; /// section as zero, or InvalidRelocOffset on errors (such as a relocation; /// that does not refer to an address in any section).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:122,error,errors,122,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['error'],['errors']
Availability,"/// \returns the string representation of \p Value in the format represented; /// by this instance, or an error if conversion to this format failed or the; /// format is NoFormat.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:106,error,error,106,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,"/// \returns the text that the string variable in this substitution matched; /// when defined, or an error if the variable is undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:101,error,error,101,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,/// \returns the value of string variable \p VarName or an error if no such; /// variable has been defined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:59,error,error,59,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['error'],['error']
Availability,/// \returns true if mask policy is valid for the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,1,['mask'],['mask']
Availability,/// \returns true if this is a masked instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h:31,mask,masked,31,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,1,['mask'],['masked']
Availability,/// \returns true if this is a merge masked instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h:37,mask,masked,37,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,1,['mask'],['masked']
Availability,"/// \see Rewriter::getNextRewritableSource(); /// Here CopyLike has the following form:; /// dst = REG_SEQUENCE Src1.src1SubIdx, subIdx1, Src2.src2SubIdx, subIdx2.; /// Each call will return a different source, walking all the available; /// source.; ///; /// The first call returns:; /// (SrcReg, SrcSubReg) = (Src1, src1SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx1).; ///; /// The second call returns:; /// (SrcReg, SrcSubReg) = (Src2, src2SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx2).; ///; /// And so on, until all the sources have been traversed, then; /// it returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:227,avail,available,227,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['avail'],['available']
Availability,"/// \}; // TODO: Ideally, what we'd like is to have a switch that allows emitting; // synchronous (precise at call-sites only) CFA into .eh_frame. However,; // even under this switch, we'd like .debug_frame to be precise when using; // -g. At this moment, there's no way to specify that some CFI directives; // go into .eh_frame only, while others go into .debug_frame only.; /// True if debugging information is available in this module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h:413,avail,available,413,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h,1,['avail'],['available']
Availability,"/// \}; /// Collect debug info quality metrics for an entire DIContext.; ///; /// Do the impossible and reduce the quality of the debug info down to a few; /// numbers. The idea is to condense the data into numbers that can be tracked; /// over time to identify trends in newer compiler versions and gauge the effect; /// of particular optimizations. The raw numbers themselves are not particularly; /// useful, only the delta between compiling the same program with different; /// compilers is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:141,down,down,141,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,1,['down'],['down']
Availability,/// __builtin_va_list as defined by the Power ABI:; /// https://www.power.org; /// /resources/downloads/Power-Arch-32-bit-ABI-supp-1.0-Embedded.pdf,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:94,down,downloads,94,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['down'],['downloads']
Availability,"/// absolute tolerance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h:13,toler,tolerance,13,math/mathcore/inc/Math/IntegratorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h,3,['toler'],['tolerance']
Availability,"/// access to parameters and errors in column-wise representation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserParameters.h:29,error,errors,29,math/minuit2/inc/Minuit2/MnUserParameters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserParameters.h,2,['error'],['errors']
Availability,/// add masking operations to stencil out a subregister.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:8,mask,masking,8,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,1,['mask'],['masking']
Availability,/// addPhysRegsUsedFromRegMask - Mark any registers not in RegMask as used.; /// This corresponds to the bit mask attached to register mask operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:109,mask,mask,109,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,2,['mask'],['mask']
Availability,"/// addResultFile - Add a file to remove on failure, and returns its; /// argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h:44,failure,failure,44,interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,1,['failure'],['failure']
Availability,/// adjustLiveRegs - Kill and revive registers such that exactly the FP; /// registers with a bit in Mask are live.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:101,Mask,Mask,101,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,1,['Mask'],['Mask']
Availability,"/// adjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:114,avail,available,114,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,3,['avail'],['available']
Availability,"/// after the setting is changed.; /// In case the file does not exist or is not a valid ROOT file,; /// it is made a Zombie. One can detect this situation with a code like:; /// ~~~{.cpp}; /// TFile f(""file.root"");; /// if (f.IsZombie()) {; /// std::cout << ""Error opening file"" << std::endl;; /// exit(-1);; /// }; /// ~~~; /// If you open a file instead with TFile::Open(""file.root"") use rather; /// the following code as a nullptr is returned.; /// ~~~{.cpp}; /// TFile* f = TFile::Open(""file.root"");; /// if (!f) {; /// std::cout << ""Error opening file"" << std::endl;; /// exit(-1);; /// }; /// ~~~; /// When opening the file, the system checks the validity of this directory.; /// If something wrong is detected, an automatic Recovery is performed. In; /// this case, the file is scanned sequentially reading all logical blocks; /// and attempting to rebuild a correct directory (see TFile::Recover).; /// One can disable the automatic recovery procedure when reading one; /// or more files by setting the environment variable ""TFile.Recover: 0""; /// in the system.rootrc file.; ///; /// A bit `TFile::kReproducible` can be enabled specifying; /// the `""reproducible""` url option when creating the file:; /// ~~~{.cpp}; /// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; /// ~~~; /// Unlike regular `TFile`s, the content of such file has reproducible binary; /// content when writing exactly same data. This achieved by writing pre-defined; /// values for creation and modification date of TKey/TDirectory objects and; /// null value for TUUID objects inside TFile. As drawback, TRef objects stored; /// in such file cannot be read correctly.; ///; /// In case the name of the file is not reproducible either (in case of; /// creating temporary filenames) a value can be passed to the reproducible; /// option to replace the name stored in the file.; /// ~~~{.cpp}; /// TFile *f = TFile::Open(""tmpname.root?reproducible=fixedname"",""RECREATE"",""File title"");; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:5489,Recover,Recover,5489,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['Recover'],['Recover']
Availability,/// allUsesAvailableAt - Return true if all registers used by OrigMI at; /// OrigIdx are also available with the same value at UseIdx.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:94,avail,available,94,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,2,['avail'],['available']
Availability,"/// and (shl/srl/sra, x, c), mask --> shl (srl/sra, x, c1), c2; /// to select more shifted register",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"/// but instead of having a single backedge mass, there will be one; /// backedge per loop header. In these cases, each backedge will carry; /// a mass proportional to the edge weights along the corresponding; /// path.; ///; /// At the end of propagation, the full mass assigned to the loop will be; /// distributed among the loop headers proportionally according to the; /// mass flowing through their backedges.; ///; /// Finally, calculate the loop scale from the accumulated backedge mass.; ///; /// 3. Distribute mass in the function (\a computeMassInFunction()).; ///; /// Finally, distribute mass through the DAG resulting from packaging all; /// loops in the function. This uses the same algorithm as distributing; /// mass in a loop, except that there are no exit or backedge edges.; ///; /// 4. Unpackage loops (\a unwrapLoops()).; ///; /// Initialize each block's frequency to a floating point representation of; /// its mass.; ///; /// Visit loops top-down, scaling the frequencies of its immediate members; /// by the loop's pseudo-node's frequency.; ///; /// 5. Convert frequencies to a 64-bit range (\a finalizeMetrics()).; ///; /// Using the min and max frequencies as a guide, translate floating point; /// frequencies to an appropriate range in uint64_t.; ///; /// It has some known flaws.; ///; /// - The model of irreducible control flow is a rough approximation.; ///; /// Modelling irreducible control flow exactly involves setting up and; /// solving a group of infinite geometric series. Such precision is; /// unlikely to be worthwhile, since most of our algorithms give up on; /// irreducible control flow anyway.; ///; /// Nevertheless, we might find that we need to get closer. Here's a sort; /// of TODO list for the model with diminishing returns, to be completed as; /// necessary.; ///; /// - The headers for the \a LoopData representing an irreducible SCC; /// include non-entry blocks. When these extra blocks exist, they; /// indicate a self-contained irreducible s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:5402,down,down,5402,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,1,['down'],['down']
Availability,"/// calculate one side (negative or positive Error) of the Parameter; /// give as input (optionally) maxcalls and tolerance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnMinos.h:45,Error,Error,45,math/minuit2/inc/Minuit2/MnMinos.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnMinos.h,2,"['Error', 'toler']","['Error', 'tolerance']"
Availability,/// canReasonAbout - Not all ConstraintManagers can accurately reason about; /// all SVal values. This method returns true if the ConstraintManager can; /// reasonably handle a given SVal value. This is typically queried by; /// ExprEngine to determine if the value should be replaced with a; /// conjured symbolic value in order to recover some precision.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h:333,recover,recover,333,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h,1,['recover'],['recover']
Availability,"/// canSimplifyCallFramePseudos - If there is a reserved call frame, the; /// call frame pseudos can be simplified. Unlike most targets, having a FP; /// is not sufficient here since we still may reference some objects via SP; /// even when FP is available in Thumb2 mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:247,avail,available,247,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['avail'],['available']
Availability,"/// case of WINDOWS - problem using Expression ( C1001: INTERNAL COMPILER ERROR ); //==============================================================================; // TensorProd (SVector x SVector); //==============================================================================",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/MatrixFunctions.h:74,ERROR,ERROR,74,math/smatrix/inc/Math/MatrixFunctions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/MatrixFunctions.h,1,['ERROR'],['ERROR']
Availability,"/// cast<X> - Return the argument parameter cast to the specified type. This; /// casting operator asserts that the type is correct, so it does not return; /// null on failure. It does not allow a null argument (use cast_if_present for; /// that). It is typically used like this:; ///; /// cast<Instruction>(myVal)->getParent()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:168,failure,failure,168,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,1,['failure'],['failure']
Availability,"/// changeVectorFPCCToAArch64CC - Convert a DAG fp condition code to an AArch64; /// CC usable with the vector instructions. Fewer operations are available; /// without a real NZCV register, so we have to use less efficient combinations; /// to get the same effect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:146,avail,available,146,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,"/// checkBuiltinArgument - Given a call to a builtin function, perform; /// normal type-checking on the given argument, updating the call in; /// place. This is useful when a builtin function requires custom; /// type-checking for some of its arguments but not necessarily all of; /// them.; ///; /// Returns true on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:317,error,error,317,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"/// checkPlaceholderForOverload - Do any interesting placeholder-like; /// preprocessing on the given expression.; ///; /// \param unbridgedCasts a collection to which to add unbridged casts;; /// without this, they will be immediately diagnosed as errors; ///; /// Return true on unrecoverable error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:249,error,errors,249,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['error'],"['error', 'errors']"
Availability,"/// clearBitsInMask - Clear any bits in this vector that are set in Mask.; /// Don't resize. This computes ""*this &= ~Mask"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:68,Mask,Mask,68,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,2,['Mask'],['Mask']
Availability,"/// clearBitsNotInMask - Clear a bit in this vector for every '0' bit in Mask.; /// Don't resize. This computes ""*this &= Mask"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:73,Mask,Mask,73,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,2,['Mask'],['Mask']
Availability,/// clobbersPhysReg - Returns true if this RegMask clobbers PhysReg.; /// It is sometimes necessary to detach the register mask pointer from its; /// machine operand. This static method can be used for such detached bit; /// mask pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:123,mask,mask,123,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,2,['mask'],['mask']
Availability,"/// collectUpperBound - All subscripts are the same type (on my machine,; /// an i64). The loop bound may be a smaller type. collectUpperBound; /// find the bound, if available, and zero extends it to the Type T.; /// (I zero extend since the bound should always be >= 0.); /// If no upper bound is available, return NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:167,avail,available,167,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,2,['avail'],['available']
Availability,/// computeKnownBitsForTargetNode - Determine which of the bits specified in; /// Mask are known to be either zero or one and return them Known.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:82,Mask,Mask,82,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Mask'],['Mask']
Availability,/// computeKnownBitsForTargetNode - Determine which of the bits specified; /// in Mask are known to be either zero or one and return them in the; /// KnownZero/KnownOne bitsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:82,Mask,Mask,82,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,1,['Mask'],['Mask']
Availability,"/// constructor taking error code, hint on operation (msg)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:23,error,error,23,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,1,['error'],['error']
Availability,/// create a mapping for the specifed virtual register to; /// the next available stack slot,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h:72,avail,available,72,interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h,1,['avail'],['available']
Availability,/// createVLIWDAGScheduler - Scheduler for VLIW targets. This creates top down; /// DFA driven list scheduler with clustering heuristic to control; /// register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:74,down,down,74,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,1,['down'],['down']
Availability,"/// debugCodeGenerator - This method narrows down a module to a function or; /// set of functions, using the CBE as a ``safe'' code generator for other; /// functions that are not under consideration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:45,down,down,45,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,1,['down'],['down']
Availability,"/// debugCodeGenerator - debug errors in LLC, LLI, or CBE.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:31,error,errors,31,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['error'],['errors']
Availability,"/// debugOptimizerCrash - This method is called when some optimizer pass; /// crashes on input. It attempts to prune down the testcase to something; /// reasonable, and figure out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:117,down,down,117,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,1,['down'],['down']
Availability,"/// debugOptimizerCrash - This method is called when some pass crashes on input.; /// It attempts to prune down the testcase to something reasonable, and figure; /// out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:107,down,down,107,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['down'],['down']
Availability,"/// defineBB - Define the specified basic block, which is either named or; /// unnamed. If there is an error, this returns null otherwise it returns; /// the block being defined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:103,error,error,103,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['error'],['error']
Availability,"/// deletes the given scope, and all outer scopes, down to the; /// given outermost scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h:51,down,down,51,interpreter/llvm-project/clang/include/clang/Sema/Template.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h,1,['down'],['down']
Availability,/// dump - Debugger convenience method; writes trace to standard error; /// output stream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h:65,error,error,65,interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h,2,['error'],['error']
Availability,/// dump - Print this implicit conversion sequence to standard; /// error. Useful for debugging overloading issues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:68,error,error,68,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,/// dump - Print this standard conversion sequence to standard; /// error. Useful for debugging overloading issues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:68,error,error,68,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,/// dump - Print this user-defined conversion sequence to standard; /// error. Useful for debugging overloading issues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:72,error,error,72,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,/// eliminateRedundantSpills - SLI:VNI is known to be on the stack. Remove any; /// redundant spills of this value in SLI.reg and sibling copies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:84,redundant,redundant,84,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['redundant'],['redundant']
Availability,"/// emitArrayLength - Compute the length of an array, even if it's a; /// VLA, and drill down to the base element type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:89,down,down,89,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['down'],['down']
Availability,"/// emitContextTable - Prints the table that is used to translate from an; /// instruction attribute mask to an instruction context. This table is; /// printed as:; ///; /// InstructionContext CONTEXTS_STR[256] = {; /// IC, /* 0x00 */; /// ...; /// };; ///; /// IC is the context corresponding to the mask 0x00, and there are 256; /// possible masks.; ///; /// @param o - The output stream to which the context table should be written.; /// @param i - The indent level for use with the stream.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.h:101,mask,mask,101,interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.h,3,['mask'],"['mask', 'masks']"
Availability,"/// emitError - Emit an error message to the currently installed error handler; /// with optional location information. This function returns, so code should; /// be prepared to drop the erroneous construct on the floor and ""not crash"".; /// The generated code need not be correct. The error message will be; /// implicitly prefixed with ""error: "" and should not end with a ""."".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:24,error,error,24,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,4,['error'],['error']
Availability,"/// emitPrologue - Push callee-saved registers onto the stack, which; /// automatically adjust the stack pointer. Adjust the stack pointer to allocate; /// space for local variables. Also emit labels used by the exception handler to; /// generate the exception handling frames.; /*; Here's a gist of what gets emitted:. ; Establish frame pointer, if needed; [if needs FP]; push %rbp; .cfi_def_cfa_offset 16; .cfi_offset %rbp, -16; .seh_pushreg %rpb; mov %rsp, %rbp; .cfi_def_cfa_register %rbp. ; Spill general-purpose registers; [for all callee-saved GPRs]; pushq %<reg>; [if not needs FP]; .cfi_def_cfa_offset (offset from RETADDR); .seh_pushreg %<reg>. ; If the required stack alignment > default stack alignment; ; rsp needs to be re-aligned. This creates a ""re-alignment gap""; ; of unknown size in the stack frame.; [if stack needs re-alignment]; and $MASK, %rsp. ; Allocate space for locals; [if target is Windows and allocated space > 4096 bytes]; ; Windows needs special care for allocations larger; ; than one page.; mov $NNN, %rax; call ___chkstk_ms/___chkstk; sub %rax, %rsp; [else]; sub $NNN, %rsp. [if needs FP]; .seh_stackalloc (size of XMM spill slots); .seh_setframe %rbp, SEHFrameOffset ; = size of all spill slots; [else]; .seh_stackalloc NNN. ; Spill XMMs; ; Note, that while only Windows 64 ABI specifies XMMs as callee-preserved,; ; they may get spilled on any platform, if the current function; ; calls @llvm.eh.unwind.init; [if needs FP]; [for all callee-saved XMM registers]; movaps %<xmm reg>, -MMM(%rbp); [for all callee-saved XMM registers]; .seh_savexmm %<xmm reg>, (-MMM + SEHFrameOffset); ; i.e. the offset relative to (%rbp - SEHFrameOffset); [else]; [for all callee-saved XMM registers]; movaps %<xmm reg>, KKK(%rsp); [for all callee-saved XMM registers]; .seh_savexmm %<xmm reg>, KKK. .seh_endprologue. [if needs base pointer]; mov %rsp, %rbx; [if needs to restore base pointer]; mov %rsp, -MMM(%rbp). ; Emit CFI info; [if needs FP]; [for all callee-saved registers]; .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:856,MASK,MASK,856,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['MASK'],['MASK']
Availability,/// empty - Return true if there is any lexical scope information available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:66,avail,available,66,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,1,['avail'],['available']
Availability,"/// error - If this is the first error in the current resolution step,; /// print it and set the error flag. Otherwise, continue silently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:4,error,error,4,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,3,['error'],['error']
Availability,"/// error definition",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h:4,error,error,4,math/mathcore/inc/Math/MinimizerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h,1,['error'],['error']
Availability,"/// exp(x) -1 with error cancellation when x is small",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Math.h:19,error,error,19,math/mathcore/inc/Math/Math.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Math.h,1,['error'],['error']
Availability,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:1200,down,down,1200,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['down'],['down']
Availability,"/// ferrs() - This returns a reference to a formatted_raw_ostream for; /// standard error. Use it like: ferrs() << ""foo"" << ""bar"";",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormattedStream.h:84,error,error,84,interpreter/llvm-project/llvm/include/llvm/Support/FormattedStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormattedStream.h,2,['error'],['error']
Availability,"/// finalizeObject - ensure the module is fully processed and is usable.; ///; /// It is the user-level function for completing the process of making the; /// object usable for execution. It should be called after sections within an; /// object have been relocated using mapSectionAddress. When this method is; /// called the MCJIT execution engine will reapply relocations for a loaded; /// object. This method has no effect for the interpreter.; ///; /// Returns true on success, false on failure. Error messages can be retrieved; /// by calling getError();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:491,failure,failure,491,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,2,"['Error', 'failure']","['Error', 'failure']"
Availability,"/// flag to check if errors are normalized",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h:21,error,errors,21,math/mathcore/inc/Fit/FitResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h,1,['error'],['errors']
Availability,"/// flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h:57,error,error,57,math/mathcore/inc/Math/Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h,1,['error'],['error']
Availability,"/// formatted_raw_ostream - Open the specified file for; /// writing. If an error occurs, information about the error is; /// put into ErrorInfo, and the stream should be immediately; /// destroyed; the string will be empty if no error occurred.; ///; /// As a side effect, the given Stream is set to be Unbuffered.; /// This is because formatted_raw_ostream does its own buffering,; /// so it doesn't want another layer of buffering to be happening; /// underneath it.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormattedStream.h:76,error,error,76,interpreter/llvm-project/llvm/include/llvm/Support/FormattedStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormattedStream.h,4,"['Error', 'error']","['ErrorInfo', 'error']"
Availability,"/// function to return the estimated error on the value of the confidence level for the i^th entry in the results",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverterResult.h:37,error,error,37,roofit/roostats/inc/RooStats/HypoTestInverterResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverterResult.h,1,['error'],['error']
Availability,"/// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to; /// get analysis information that might be around, for example to update it.; /// This is different than getAnalysis in that it can fail (if the analysis; /// results haven't been computed), so should only be used if you can handle; /// the case when the analysis is not available. This method is often used by; /// transformation APIs to update analysis results for a pass automatically as; /// the transform is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:349,avail,available,349,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,2,['avail'],['available']
Availability,/// getAsmParserVariantCount - Return the AssemblyParserVariant definition; /// available for this target.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenTarget.cpp:80,avail,available,80,interpreter/llvm-project/llvm/utils/TableGen/CodeGenTarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenTarget.cpp,2,['avail'],['available']
Availability,"/// getCompressedMask - Turn a 16-bit uncompressed mask (where each elt uses 4; /// bits) into a compressed 13-bit mask, where each elt is multiplied by 9.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,2,['mask'],['mask']
Availability,/// getDecisionType - Determines whether a ModRM decision with 255 entries can; /// be compacted by eliminating redundant information.; ///; /// @param decision - The decision to be compacted.; /// @return - The compactest available representation for the decision.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.cpp:112,redundant,redundant,112,interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.cpp,2,"['avail', 'redundant']","['available', 'redundant']"
Availability,"/// getDwarfFile - takes a file name and number to place in the dwarf file and; /// directory tables. If the file number has already been allocated it is an; /// error and zero is returned and the client reports the error, else the; /// allocated file number is returned. The file numbers may be in any order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:162,error,error,162,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,2,['error'],['error']
Availability,/// getFunctionOrMethodNumParams - Return number of function or method; /// parameters. It is an error to call this on a K&R function (use; /// hasFunctionProto first).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:97,error,error,97,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['error'],['error']
Availability,"/// getHazardType - Return the hazard type of emitting this node. There are; /// three possible results. Either:; /// * NoHazard: it is legal to issue this instruction on this cycle.; /// * Hazard: issuing this instruction would stall the machine. If some; /// other instruction is available, issue it first.; /// * NoopHazard: issuing this instruction would break the program. If; /// some other instruction can be issued, do so, otherwise issue a noop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:282,avail,available,282,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,1,['avail'],['available']
Availability,"/// getITMaskOpValue - Return the architectural encoding of an IT; /// predication mask, given the MCOperand format.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:83,mask,mask,83,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,1,['mask'],['mask']
Availability,/// getImmediatePredicateCode - Return the code that evaluates this pattern if; /// this is an immediate predicate. It is an error to call this on a; /// non-immediate pattern.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:125,error,error,125,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['error'],['error']
Availability,"/// getImmediateSpellingLoc - Given a SourceLocation object, return the; /// spelling location referenced by the ID. This is the first level down; /// towards the place where the characters that make up the lexed token can be; /// found. This should not generally be used by clients.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:141,down,down,141,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['down'],['down']
Availability,"/// getIndirectResult - Give a source type \arg Ty, return a suitable result; /// such that the argument will be passed in memory.; ///; /// \param freeIntRegs - The number of free integer registers remaining; /// available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:214,avail,available,214,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['avail'],['available']
Availability,"/// getInstrTimingClassLatency - Compute the instruction latency of a given; /// instruction using Timing Class information, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:128,avail,available,128,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,1,['avail'],['available']
Availability,"/// getLHSOnlyMask - Given a mask that refers to its LHS and RHS, modify it to; /// refer to the LHS only (for when one argument value is passed into the same; /// function twice).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,1,['mask'],['mask']
Availability,"/// getLLVMArchSuffixForARM - Get the LLVM arch name to use for a particular; /// CPU (or Arch, if CPU is generic).; // FIXME: This is redundant with -mcpu, why does LLVM use this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:135,redundant,redundant,135,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,1,['redundant'],['redundant']
Availability,"/// getLeaderValue - Return the leader for the specified value that is in the; /// set. It is an error to call this method for a value that is not yet in; /// the set. For that, call getOrInsertLeaderValue(V).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h:97,error,error,97,interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,1,['error'],['error']
Availability,/// getMaskElt - Return element N of the specified mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,1,['mask'],['mask']
Availability,"/// getMutableDeclSpec - Return a non-const version of the DeclSpec. This; /// should be used with extreme care: declspecs can often be shared between; /// multiple declarators, so mutating the DeclSpec affects all of the; /// Declarators. This should only be done when the declspec is known to not; /// be shared or when in error recovery etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h:325,error,error,325,interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,2,"['error', 'recover']","['error', 'recovery']"
Availability,"/// getNodeIfExists - Get the specified node if it's already available, or; /// else return NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:61,avail,available,61,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['avail'],['available']
Availability,"/// getNodeRegMask - Returns the register mask attached to an SDNode, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['mask'],['mask']
Availability,"/// getOffsetOfStringByte - This function returns the offset of the; /// specified byte of the string data represented by Token. This handles; /// advancing over escape sequences in the string.; ///; /// If the Diagnostics pointer is non-null, then this will do semantic; /// checking of the string literal and emit errors and warnings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/LiteralSupport.h:316,error,errors,316,interpreter/llvm-project/clang/include/clang/Lex/LiteralSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/LiteralSupport.h,1,['error'],['errors']
Availability,/// getOrCreateLexicalScope - Find lexical scope for the given DebugLoc. If; /// not available then create new lexical scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp:85,avail,available,85,interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp,1,['avail'],['available']
Availability,/// getOrCreateLexicalScope - Find lexical scope for the given Scope/IA. If; /// not available then create new lexical scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:85,avail,available,85,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,1,['avail'],['available']
Availability,"/// getPointerToFunctionOrStub - If the specified function has been; /// code-gen'd, return a pointer to the function. If not, compile it, or use; /// a stub to implement lazy compilation if available. See; /// getPointerToFunction for the requirements on destroying F.; ///; /// This function is deprecated for the MCJIT execution engine. Use; /// getFunctionAddress instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:191,avail,available,191,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['avail'],['available']
Availability,/// getRegLiveOut - Returns a bit mask of live-out registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:34,mask,mask,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,1,['mask'],['mask']
Availability,/// getRegMask - Returns a bit mask of registers preserved by this RegMask; /// operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:31,mask,mask,31,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,1,['mask'],['mask']
Availability,"/// getRegisterInfo - If register information is available, return it. If; /// not, return null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:49,avail,available,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['avail'],['available']
Availability,/// getSystemGPUArchs - Use a tool to detect the user's availible GPUs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:56,avail,availible,56,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['avail'],['availible']
Availability,/// getThisReturnPreservedMask - Returns a call preserved mask specific to the; /// case that 'returned' is on an i32 first argument if the calling convention; /// is one that can (partially) model this attribute with a preserved mask; /// (i.e. it is a calling convention that uses the same register for the first; /// i32 argument and an i32 return value); ///; /// Should return NULL in the case that the calling convention does not have; /// this property,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.h:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.h,2,['mask'],['mask']
Availability,/// getThisReturnPreservedMask - Returns a call preserved mask specific to the; /// case that 'returned' is on an i64 first argument if the calling convention; /// is one that can (partially) model this attribute with a preserved mask; /// (i.e. it is a calling convention that uses the same register for the first; /// i64 argument and an i64 return value); ///; /// Should return NULL in the case that the calling convention does not have; /// this property,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.h:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.h,2,['mask'],['mask']
Availability,"/// getVectorTypeBreakdown - Vector types are broken down into some number of; /// legal first class types. For example, MVT::v8f32 maps to 2 MVT::v4f32; /// with Altivec or SSE1, or 8 promoted MVT::f64 values with the X86 FP stack.; /// Similarly, MVT::v2i64 turns into 4 MVT::i32 values with both PPC and X86.; ///; /// This method returns the number of registers needed, and the VT for each; /// register. It also returns the VT and quantity of the intermediate values; /// before they are promoted/expanded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:53,down,down,53,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['down'],['down']
Availability,/// guessInstructionProperties - Return true if it's OK to guess instruction; /// properties instead of raising an error.; ///; /// This is configurable as a temporary migration aid. It will eventually be; /// permanently false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenTarget.cpp:115,error,error,115,interpreter/llvm-project/llvm/utils/TableGen/CodeGenTarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenTarget.cpp,1,['error'],['error']
Availability,/// hasDesugaredTA - Returns true if there is another TemplateArgument; /// available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:76,avail,available,76,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,1,['avail'],['available']
Availability,/// hasError - True if the currently processed nodes have unresolvable types; /// or other non-fatal errors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:101,error,errors,101,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['error'],['errors']
Availability,"/// hasOrderedMemoryRef - Return true if this instruction may have an ordered; /// or volatile memory reference, or if the information describing the memory; /// reference is not available. Return false if it is known to have no ordered; /// memory references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:179,avail,available,179,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,1,['avail'],['available']
Availability,/// hasUndefElements - Return true if any of the elements in the mask are undefs; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp:65,mask,mask,65,interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,1,['mask'],['mask']
Availability,"/// hoistStep - Attempt to hoist a simple IV increment above InsertPos to make; /// it available to other uses in this loop. Recursively hoist any operands,; /// until we reach a value that dominates InsertPos.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:87,avail,available,87,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['avail'],['available']
Availability,/// identifying the operation that represents a complex number repeated in a; /// Splat vector. There are two possible types of splats: ConstantExpr with; /// the opcode ShuffleVector and ShuffleVectorInstr. Both should have an; /// initialization mask with all values set to zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:248,mask,mask,248,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['mask'],['mask']
Availability,/// insertTranslatedSubExpr - Insert a computation of the PHI translated; /// version of 'V' for the edge PredBB->CurBB into the end of the PredBB; /// block. All newly created instructions are added to the NewInsts list.; /// This returns null on failure.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:248,failure,failure,248,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,2,['failure'],['failure']
Availability,"/// insertelt (shufflevector X, CVec, Mask|insertelt X, C1, CIndex1), C, CIndex; /// --> shufflevector X, CVec', Mask'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:38,Mask,Mask,38,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['Mask'],['Mask']
Availability,"/// install_fatal_error_handler - Installs a new error handler to be used; /// whenever a serious (non-recoverable) error is encountered by LLVM.; ///; /// If no error handler is installed the default is to print the error message; /// to stderr, and call exit(1). If an error handler is installed then it is; /// the handler's responsibility to log the message, it will no longer be; /// printed to stderr. If the error handler returns, then exit(1) will be; /// called.; ///; /// It is dangerous to naively use an error handler which throws an exception.; /// Even though some applications desire to gracefully recover from arbitrary; /// faults, blindly throwing exceptions through unfamiliar code isn't a way to; /// achieve this.; ///; /// \param user_data - An argument which will be passed to the install error; /// handler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:49,error,error,49,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,11,"['error', 'fault', 'recover']","['error', 'faults', 'recover', 'recoverable']"
Availability,/// is RISC-V RVV fixed-length mask vector,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:31,mask,mask,31,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['mask'],['mask']
Availability,"/// isAllocatable - Returns true when PhysReg belongs to an allocatable; /// register class and it hasn't been reserved.; ///; /// Allocatable registers may show up in the allocation order of some virtual; /// register, so a register allocator needs to track its liveness and; /// availability.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:281,avail,availability,281,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,1,['avail'],['availability']
Availability,"/// isBuiltinExtensionDiag - Determine whether the given built-in diagnostic; /// ID is for an extension of some sort. This also returns EnabledByDefault,; /// which is set to indicate whether the diagnostic is ignored by default (in; /// which case -pedantic enables it) or treated as a warning/error by default.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:296,error,error,296,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,1,['error'],['error']
Availability,"/// isCXXDeclarationSpecifier - Returns TPResult::True if it is a declaration; /// specifier, TPResult::False if it is not, TPResult::Ambiguous if it could; /// be either a decl-specifier or a function-style cast, and TPResult::Error; /// if a parsing error was found and reported.; ///; /// If InvalidAsDeclSpec is not null, some cases that would be ill-formed as; /// declaration specifiers but possibly valid as some other kind of construct; /// return TPResult::Ambiguous instead of TPResult::False. When this happens,; /// the intent is to keep trying to disambiguate, on the basis that we might; /// find a better reason to treat this construct as a declaration later on.; /// When this happens and the name could possibly be valid in some other; /// syntactic context, *InvalidAsDeclSpec is set to 'true'. The current cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-spec",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:228,Error,Error,228,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// isCXXDeclarationSpecifier - Returns TPResult::True if it is a; /// declaration specifier, TPResult::False if it is not,; /// TPResult::Ambiguous if it could be either a decl-specifier or a; /// function-style cast, and TPResult::Error if a parsing error was; /// encountered. If it could be a braced C++11 function-style cast, returns; /// BracedCastResult.; /// Doesn't consume tokens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:233,Error,Error,233,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"/// isCXXFunctionDeclarator - Disambiguates between a function declarator or; /// a constructor-style initializer, when parsing declaration statements.; /// Returns true for function declarator and false for constructor-style; /// initializer. Sets 'IsAmbiguous' to true to indicate that this declaration; /// might be a constructor-style initializer.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:404,error,error,404,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['error'],['error']
Availability,"/// isCXXFunctionDeclarator - Disambiguates between a function declarator or; /// a constructor-style initializer, when parsing declaration statements.; /// Returns true for function declarator and false for constructor-style; /// initializer.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; ///; /// '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; /// exception-specification[opt]; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:296,error,error,296,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['error'],['error']
Availability,"/// isCXXSimpleDeclaration - C++-specialized function that disambiguates; /// between a simple-declaration or an expression-statement.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; /// Returns false if the statement is disambiguated as expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:187,error,error,187,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['error'],['error']
Availability,"/// isCXXSimpleDeclaration - C++-specialized function that disambiguates; /// between a simple-declaration or an expression-statement.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; /// Returns false if the statement is disambiguated as expression.; ///; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer ';' [C++17]; ///; /// (if AllowForRangeDecl specified); /// for ( for-range-declaration : for-range-initializer ) statement; ///; /// for-range-declaration:; /// decl-specifier-seq declarator; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; ///; /// In any of the above cases there can be a preceding attribute-specifier-seq,; /// but the caller is expected to handle that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:187,error,error,187,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['error'],['error']
Availability,"/// isCoalescableExtInstr - Return true if the instruction is a ""coalescable""; /// extension instruction. That is, it's like a copy where it's legal for the; /// source to overlap the destination. e.g. X86::MOVSX64rr32. If this returns; /// true, then it's expected the pre-extension value is available as a subreg; /// of the result register. This also returns the sub-register index in; /// SubIdx.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:293,avail,available,293,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,1,['avail'],['available']
Availability,/// isEnd - Returns true if no more TemplateArguments are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:58,avail,available,58,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,1,['avail'],['available']
Availability,/// isFuncParamTypeConvertible - Return true if the specified type in a; /// function parameter or result position can be converted to an IR type at this; /// point. This boils down to being whether it is complete.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp:177,down,down,177,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,1,['down'],['down']
Availability,/// isLoadFromStackSlotPostFE - Check for post-frame ptr elimination; /// stack locations as well. This uses a heuristic so it isn't; /// reliable for correctness.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:138,reliab,reliable,138,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,1,['reliab'],['reliable']
Availability,/// isMaskedValueZeroForTargetNode - Return true if 'Op & Mask' is known to; /// be zero. Op is expected to be a target specific node. Used by DAG; /// combiner.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:58,Mask,Mask,58,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// isMicrosoftMissingTypename - In Microsoft mode, within class scope,; /// if a CXXScopeSpec's type is equal to the type of one of the base classes; /// then downgrade the missing typename error to a warning.; /// This is needed for MSVC compatibility; Example:; /// @code; /// template<class T> class A {; /// public:; /// typedef int TYPE;; /// };; /// template<class T> class B : public A<T> {; /// public:; /// A<T>::TYPE a; // no typename required because A<T> is a base class.; /// };; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,down,downgrade,160,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,"['down', 'error']","['downgrade', 'error']"
Availability,/// isNotObjectErrorInvalidFileType() is used when looping through the children; /// of an archive after calling getAsBinary() on the child and it returns an; /// llvm::Error. In the cases we want to loop through the children and ignore the; /// non-objects in the archive this is used to test the error to see if an; /// error() function needs to called on the llvm::Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Error.h:169,Error,Error,169,interpreter/llvm-project/llvm/include/llvm/Object/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Error.h,4,"['Error', 'error']","['Error', 'error']"
Availability,/// isNullPointerConstant - C99 6.3.2.3p3 - Test if this reduces down to; /// a Null pointer constant. The return value can further distinguish the; /// kind of NULL pointer constant that was detected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:65,down,down,65,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['down'],['down']
Availability,"/// isOnlyLHSMask - Return true if this mask only refers to its LHS, not; /// including undef values..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,1,['mask'],['mask']
Availability,"/// isRedundantFlagInstr - check whether the first instruction, whose only; /// purpose is to update flags, can be made redundant.; /// CMPrr can be made redundant by SUBrr if the operands are the same.; /// CMPri can be made redundant by SUBri if the operands are the same.; /// CMPrr(r0, r1) can be made redundant by ADDr[ri](r0, r1, X).; /// This function can be extended later on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:120,redundant,redundant,120,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,4,['redundant'],['redundant']
Availability,/// isRotateAndMask - Returns true if Mask and Shift can be folded into a; /// rotate and mask opcode and mask operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:38,Mask,Mask,38,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,3,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"/// isShuffleMaskLegal - Targets can use this to indicate that they only; /// support *some* VECTOR_SHUFFLE operations, those with specific masks.; /// By default, if a target supports the VECTOR_SHUFFLE node, all mask values; /// are assumed to be legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:140,mask,masks,140,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['mask'],"['mask', 'masks']"
Availability,/// isStoreToStackSlotPostFE - Check for post-frame ptr elimination; /// stack locations as well. This uses a heuristic so it isn't; /// reliable for correctness.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:137,reliab,reliable,137,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,1,['reliab'],['reliable']
Availability,"/// isSuitableForMask - Identify a suitable 'and' instruction that; /// operates on the given source register and applies the same mask; /// as a 'tst' instruction. Provide a limited look-through for copies.; /// When successful, MI will hold the found instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:131,mask,mask,131,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['mask'],['mask']
Availability,"/// isTRN_v_undef_Mask - Special case of isTRNMask for canonical form of; /// ""vector_shuffle v, v"", i.e., ""vector_shuffle v, undef"".; /// Mask is e.g., <0, 0, 2, 2> instead of <0, 4, 2, 6>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:139,Mask,Mask,139,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// isTagName() - This method is called *for error recovery purposes only*; /// to determine if the specified name is a valid tag name (""struct foo""). If; /// so, this returns the TST for the tag corresponding to it (TST_enum,; /// TST_union, TST_struct, TST_interface, TST_class). This is used to diagnose; /// cases in C where the user forgot to specify the tag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,error,error,45,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"/// isUZP_v_undef_Mask - Special case of isUZPMask for canonical form of; /// ""vector_shuffle v, v"", i.e., ""vector_shuffle v, undef"".; /// Mask is e.g., <0, 2, 0, 2> instead of <0, 2, 4, 6>,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:139,Mask,Mask,139,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Mask'],['Mask']
Availability,/// isVMRGEOShuffleMask - Return true if this is a shuffle mask suitable for; /// a VMRGEW or VMRGOW instruction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:59,mask,mask,59,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,"/// isVMRGHShuffleMask - Return true if this is a shuffle mask suitable for; /// a VMRGH* instruction with the specified unit size (1,2 or 4 bytes).; /// The ShuffleKind distinguishes between big-endian merges with two; /// different inputs (0), either-endian merges with two identical inputs (1),; /// and little-endian merges with two different inputs (2). For the latter,; /// the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"/// isVMRGHShuffleMask - Return true if this is a shuffle mask suitable for; /// a VRGH* instruction with the specified unit size (1,2 or 4 bytes).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,"/// isVMRGLShuffleMask - Return true if this is a shuffle mask suitable for; /// a VMRGL* instruction with the specified unit size (1,2 or 4 bytes).; /// The ShuffleKind distinguishes between big-endian merges with two; /// different inputs (0), either-endian merges with two identical inputs (1),; /// and little-endian merges with two different inputs (2). For the latter,; /// the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"/// isVMRGLShuffleMask - Return true if this is a shuffle mask suitable for; /// a VRGL* instruction with the specified unit size (1,2 or 4 bytes).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,"/// isVPKUDUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUDUM instruction, AND the VPKUDUM instruction exists for the; /// current subtarget.; ///; /// The ShuffleKind distinguishes between big-endian operations with; /// two different inputs (0), either-endian operations with two identical; /// inputs (1), and little-endian operations with two different inputs (2).; /// For the latter, the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,mask,mask,62,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,/// isVPKUDUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUDUM instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:62,mask,mask,62,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,/// isVPKUHUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUHUM instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:62,mask,mask,62,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,"/// isVPKUHUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUHUM instruction.; /// The ShuffleKind distinguishes between big-endian operations with; /// two different inputs (0), either-endian operations with two identical; /// inputs (1), and little-endian operations with two different inputs (2).; /// For the latter, the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,mask,mask,62,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,/// isVPKUWUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUWUM instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:62,mask,mask,62,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,"/// isVPKUWUMShuffleMask - Return true if this is the shuffle mask for a; /// VPKUWUM instruction.; /// The ShuffleKind distinguishes between big-endian operations with; /// two different inputs (0), either-endian operations with two identical; /// inputs (1), and little-endian operations with two different inputs (2).; /// For the latter, the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,mask,mask,62,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"/// isVSLDOIShuffleMask - If this is a vsldoi shuffle mask, return the shift; /// amount, otherwise return -1.; /// The ShuffleKind distinguishes between big-endian operations with two; /// different inputs (0), either-endian operations with two identical inputs; /// (1), and little-endian operations with two different inputs (2). For the; /// latter, the input operands are swapped (see PPCInstrAltivec.td).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"/// isVSLDOIShuffleMask - If this is a vsldoi shuffle mask, return the; /// shift amount, otherwise return -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:54,mask,mask,54,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,"/// isVTRN_v_undef_Mask - Special case of isVTRNMask for canonical form of; /// ""vector_shuffle v, v"", i.e., ""vector_shuffle v, undef"".; /// Mask is e.g., <0, 0, 2, 2> instead of <0, 4, 2, 6>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:141,Mask,Mask,141,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// isVUZP_v_undef_Mask - Special case of isVUZPMask for canonical form of; /// ""vector_shuffle v, v"", i.e., ""vector_shuffle v, undef"".; /// Mask is e.g., <0, 2, 0, 2> instead of <0, 2, 4, 6>,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:141,Mask,Mask,141,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// isVZIP_v_undef_Mask - Special case of isVZIPMask for canonical form of; /// ""vector_shuffle v, v"", i.e., ""vector_shuffle v, undef"".; /// Mask is e.g., <0, 0, 1, 1> instead of <0, 4, 1, 5>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:141,Mask,Mask,141,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// isValid - returns the error encountered during regex compilation, if; /// any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Regex.h:26,error,error,26,interpreter/llvm-project/llvm/include/llvm/Support/Regex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Regex.h,1,['error'],['error']
Availability,/// isXXBRDShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXBRD instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,/// isXXBRHShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXBRH instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,/// isXXBRQShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXBRQ instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,/// isXXBRWShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXBRW instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,/// isXXPERMDIShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXPERMDI instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:61,mask,mask,61,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,/// isXXSLDWIShuffleMask - Return true if this is a shuffle mask suitable; /// for a XXSLDWI instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:60,mask,mask,60,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['mask'],['mask']
Availability,"/// isZIP_v_undef_Mask - Special case of isZIPMask for canonical form of; /// ""vector_shuffle v, v"", i.e., ""vector_shuffle v, undef"".; /// Mask is e.g., <0, 0, 1, 1> instead of <0, 4, 1, 5>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:139,Mask,Mask,139,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"/// lintModule - Check a module for errors, printing messages on stderr.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:36,error,errors,36,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,1,['error'],['errors']
Availability,/// listScheduleTopDown - The main loop of list scheduling for top-down; /// schedulers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp:67,down,down,67,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,1,['down'],['down']
Availability,/// llvm fatal_error if \param Path doesn't exist or isn't a directory.; /// Returns llvm::Expected Error if OS kernel API told us we can't start; /// watching. In such case it's unclear whether just retrying has any chance; /// to succeed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h:100,Error,Error,100,interpreter/llvm-project/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h,1,['Error'],['Error']
Availability,"/// lookupTarget - Lookup a target based on a target triple.; ///; /// \param Triple - The triple to use for finding a target.; /// \param Error - On failure, an error string describing why no target was; /// found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h:139,Error,Error,139,interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h,3,"['Error', 'error', 'failure']","['Error', 'error', 'failure']"
Availability,"/// lookupTarget - Lookup a target based on an architecture name; /// and a target triple. If the architecture name is non-empty,; /// then the lookup is done by architecture. Otherwise, the target; /// triple is used.; ///; /// \param ArchName - The architecture to use for finding a target.; /// \param TheTriple - The triple to use for finding a target. The; /// triple is updated with canonical architecture name if a lookup; /// by architecture is done.; /// \param Error - On failure, an error string describing why no target was; /// found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h:471,Error,Error,471,interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h,3,"['Error', 'error', 'failure']","['Error', 'error', 'failure']"
Availability,"/// lower Minos error. If Minos has not run for parameter i return the parabolic error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h:16,error,error,16,math/mathcore/inc/Fit/FitResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h,2,['error'],['error']
Availability,/// lowerAcrossUnwindEdges - Find all variables which are alive across an unwind; /// edge and spill them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:58,alive,alive,58,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,1,['alive'],['alive']
Availability,"/// makeUnavailableInSystemHeader - There is an error in the current; /// context. If we're still in a system header, and we can plausibly; /// make the relevant declaration unavailable instead of erroring, do; /// so and return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:48,error,error,48,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,2,['error'],"['error', 'erroring']"
Availability,"/// matches - Match the regex against a given \p String.; ///; /// \param Matches - If given, on a successful match this will be filled in; /// with references to the matched group expressions (inside \p String),; /// the first group is always the entire pattern.; ///; /// \param Error - If non-null, any errors in the matching will be recorded; /// as a non-empty string. If there is no error, it will be an empty string.; ///; /// This returns true on a successful match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Regex.h:281,Error,Error,281,interpreter/llvm-project/llvm/include/llvm/Support/Regex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Regex.h,3,"['Error', 'error']","['Error', 'error', 'errors']"
Availability,"/// matrix is an alternative to the default matrix, the errors are the difference to the original matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h:56,error,errors,56,hist/unfold/inc/TUnfoldSys.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldSys.h,1,['error'],['errors']
Availability,"/// mergeAliasSetsForMemoryLocation - Given a memory location, merge all alias; /// sets that may alias it. Return the unified set, or nullptr if no aliasing; /// set was found. A known existing alias set for the pointer value of the; /// memory location can be passed in (or nullptr if not available). MustAliasAll; /// is updated to true/false if the memory location is found to MustAlias all; /// the sets it merged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:291,avail,available,291,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,1,['avail'],['available']
Availability,"/// minimizer provides error and error matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/inc/TFumiliMinimizer.h:23,error,error,23,math/fumili/inc/TFumiliMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/inc/TFumiliMinimizer.h,14,['error'],['error']
Availability,"/// minos error for variable i, return false if Minos failed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TMinuitMinimizer.h:10,error,error,10,math/minuit/inc/TMinuitMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TMinuitMinimizer.h,1,['error'],['error']
Availability,"/// number of free variables (real dimension of the problem); /// this is <= Function().NDim() which is the total; // virtual unsigned int NFree() const { return fNFree; }; /// minimizer provides error and error matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLNLSMinimizer.h:196,error,error,196,math/mathmore/inc/Math/GSLNLSMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLNLSMinimizer.h,2,['error'],['error']
Availability,"/// number of input bins which are dropped because they have error=nullptr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h:61,error,error,61,hist/unfold/inc/TUnfold.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h,1,['error'],['error']
Availability,"/// numerical integral in these limits including error estimation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/SamplingDistribution.h:49,error,error,49,roofit/roostats/inc/RooStats/SamplingDistribution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/SamplingDistribution.h,1,['error'],['error']
Availability,"/// optimizeCompareInstr - Convert the instruction supplying the argument to the; /// comparison into one that sets the zero bit in the flags register;; /// Remove a redundant Compare instruction if an earlier instruction can set the; /// flags in the same way as Compare.; /// E.g. SUBrr(r1,r2) and CMPrr(r1,r2). We also handle the case where two; /// operands are swapped: SUBrr(r1,r2) and CMPrr(r2,r1), by updating the; /// condition code of instructions which use the flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:166,redundant,redundant,166,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['redundant'],['redundant']
Availability,"/// optimizeCompareInstr - Convert the instruction to set the zero flag so; /// that we can remove a ""comparison with zero""; Remove a redundant CMP; /// instruction if the flags can be updated in the same way by an earlier; /// instruction such as SUB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h:134,redundant,redundant,134,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,1,['redundant'],['redundant']
Availability,/// overwriteChangedFiles - Save all changed files to disk.; ///; /// Returns true if any files were not saved successfully.; /// Outputs diagnostics via the source manager's diagnostic engine; /// in case of an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Core/Rewriter.h:212,error,error,212,interpreter/llvm-project/clang/include/clang/Rewrite/Core/Rewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Core/Rewriter.h,1,['error'],['error']
Availability,"/// parameter error by index",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h:14,error,error,14,math/mathcore/inc/Fit/FitResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h,1,['error'],['error']
Availability,"/// parameter error by index; // (NOTE: this due to conflict with TObject::Error cannot used in derived class which; // inherits from TObject. Use instead ParError (or Errors()[i] )",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h:14,error,error,14,math/mathcore/inc/Fit/FitResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h,3,"['Error', 'error']","['Error', 'Errors', 'error']"
Availability,"/// parameter errors (return const pointer)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h:14,error,errors,14,math/mathcore/inc/Fit/FitResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h,1,['error'],['errors']
Availability,"/// parameter errors (return st::vector)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h:14,error,errors,14,math/mathcore/inc/Fit/FitResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h,1,['error'],['errors']
Availability,/// parseAssemblyFile and parseAssemblyString are wrappers around this function.; /// Parse LLVM Assembly from a MemoryBuffer.; /// \param F The MemoryBuffer containing assembly; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:194,Error,Error,194,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,1,['Error'],['Error']
Availability,"/// parseDirectiveEcho; /// ::= ""echo"" message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:33,echo,echo,33,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['echo'],['echo']
Availability,/// parseDirectiveError; /// ::= .err; /// ::= .error [string],MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:48,error,error,48,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['error'],['error']
Availability,/// parseMSRMaskOperand - Try to parse mask flags from MSR instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:39,mask,mask,39,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['mask'],['mask']
Availability,"/// query if parameter i has the Minos error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h:39,error,error,39,math/mathcore/inc/Fit/FitResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h,1,['error'],['error']
Availability,/// raw_os_ostream - A raw_ostream that writes to an std::ostream. This is a; /// simple adaptor class. It does not check for output errors; clients should; /// use the underlying stream to detect errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_os_ostream.h:133,error,errors,133,interpreter/llvm-project/llvm/include/llvm/Support/raw_os_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_os_ostream.h,2,['error'],['errors']
Availability,"/// renderGraphFromBottomUp - If this function returns true, the graph is; /// emitted bottom-up instead of top-down. This requires graphviz 2.0 to work; /// though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DOTGraphTraits.h:112,down,down,112,interpreter/llvm-project/llvm/include/llvm/Support/DOTGraphTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DOTGraphTraits.h,1,['down'],['down']
Availability,"/// reserveReg -- Mark a register as reserved so checks like isAllocatable ; /// will not suggest using it. This should not be used during the middle; /// of a function walk, or when liveness info is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:200,avail,available,200,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,1,['avail'],['available']
Availability,"/// retrieve error matrix from TMinuit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TMinuitMinimizer.h:13,error,error,13,math/minuit/inc/TMinuitMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TMinuitMinimizer.h,1,['error'],['error']
Availability,"/// retrieve minimum parameters and errors from TMinuit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TMinuitMinimizer.h:36,error,errors,36,math/minuit/inc/TMinuitMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TMinuitMinimizer.h,1,['error'],['errors']
Availability,"/// return BinData used in the fit (return a nullptr in case a different fit is done; /// or the data are not available; /// Pointer is managed internally, it must not be deleted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h:110,avail,available,110,math/mathcore/inc/Fit/FitResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h,1,['avail'],['available']
Availability,"/// return errors at the minimum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/inc/TFumiliMinimizer.h:11,error,errors,11,math/fumili/inc/TFumiliMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/inc/TFumiliMinimizer.h,8,['error'],['errors']
Availability,"/// return integration error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h:23,error,error,23,math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,2,['error'],['error']
Availability,"/// return relative error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h:20,error,error,20,math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,1,['error'],['error']
Availability,"/// return status of integration; /// - status = 0 successful integration; /// - status = 1; /// MAXPTS is too small for the specified accuracy EPS.; /// The result contain the values; /// obtainable for the specified value of MAXPTS.; /// - status = 2; /// size is too small for the specified number MAXPTS of function evaluations.; /// - status = 3; /// wrong dimension , N<2 or N > 15. Returned result and error are zero",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h:409,error,error,409,math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,1,['error'],['error']
Availability,"/// return the 2D-contour points for the given subset of parameters; /// by default make the contour using 30 points. The User has to preallocate the x and y array which will return; /// the set of x and y points defining the contour.; /// The return value of the function specify the number of contour point found.; /// In case of error a zero is returned",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/LikelihoodInterval.h:332,error,error,332,roofit/roostats/inc/RooStats/LikelihoodInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/LikelihoodInterval.h,1,['error'],['error']
Availability,"/// return the Error Status of the last Integral calculation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h:15,Error,Error,15,math/mathcore/inc/Math/IntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h,1,['Error'],['Error']
Availability,"/// return the statistical scale used for calculate the error; /// is typically 1 for Chi2 and 0.5 for likelihood minimization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h:56,error,error,56,math/mathcore/inc/Math/Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h,1,['error'],['error']
Availability,"/// return vector of parameter indices for which the Minos Error will be computed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitConfig.h:59,Error,Error,59,math/mathcore/inc/Fit/FitConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitConfig.h,1,['Error'],['Error']
Availability,"/// returns the negative (pair.first) and the positive (pair.second); /// Minos Error of the Parameter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnMinos.h:80,Error,Error,80,math/minuit2/inc/Minuit2/MnMinos.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnMinos.h,1,['Error'],['Error']
Availability,"/// rough estimation of the error on the computed bound of the confidence interval; /// Estimate of lower limit error; ///function evaluates only a rough error on the lower limit. Be careful when using this estimation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverterResult.h:28,error,error,28,roofit/roostats/inc/RooStats/HypoTestInverterResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverterResult.h,3,['error'],['error']
Availability,"/// runOnFunction - Run down all loops in the CFG (recursively, but we could do; /// it in any convenient order) inserting preheaders...; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:24,down,down,24,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,1,['down'],['down']
Availability,"/// scheduleNodeTopDown - Add the node to the schedule. Decrement the pending; /// count of its successors. If a successor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp:165,Avail,Available,165,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,1,['Avail'],['Available']
Availability,"/// set absolute tolerance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h:17,toler,tolerance,17,math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,2,['toler'],['tolerance']
Availability,"/// set error def",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h:8,error,error,8,math/mathcore/inc/Math/MinimizerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h,1,['error'],['error']
Availability,"/// set numerical error in test statistic evaluation (default is zero)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverter.h:18,error,error,18,roofit/roostats/inc/RooStats/HypoTestInverter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverter.h,1,['error'],['error']
Availability,"/// set relative tolerance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h:17,toler,tolerance,17,math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,1,['toler'],['tolerance']
Availability,"/// set scale for calculating the errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h:34,error,errors,34,math/mathcore/inc/Math/Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h,1,['error'],['errors']
Availability,"/// set the Minos errors for parameter i (called by the Fitter class when running Minos)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h:18,error,errors,18,math/mathcore/inc/Fit/FitResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h,1,['error'],['errors']
Availability,"/// set the acceptable level or error for Keys interval determination",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/MCMCInterval.h:32,error,error,32,roofit/roostats/inc/RooStats/MCMCInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/MCMCInterval.h,1,['error'],['error']
Availability,"/// set the options; /// (should be re-implemented by derived classes -if more options than tolerance exist",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/VirtualIntegrator.h:92,toler,tolerance,92,math/mathcore/inc/Math/VirtualIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/VirtualIntegrator.h,1,['toler'],['tolerance']
Availability,"/// set the relative tolerance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h:21,toler,tolerance,21,math/mathcore/inc/Math/IntegratorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h,1,['toler'],['tolerance']
Availability,"/// set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/BayesianCalculator.h:45,error,error,45,roofit/roostats/inc/RooStats/BayesianCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/BayesianCalculator.h,8,['error'],['error']
Availability,"/// set the size of the test (rate of Type I error) ( e.g. 0.05 for a 95% Confidence Interval)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/IntervalCalculator.h:45,error,error,45,roofit/roostats/inc/RooStats/IntervalCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/IntervalCalculator.h,1,['error'],['error']
Availability,"/// set the size of the test (rate of Type I error) (eg. 0.05 for a 95% Confidence Interval)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverterResult.h:45,error,error,45,roofit/roostats/inc/RooStats/HypoTestInverterResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverterResult.h,1,['error'],['error']
Availability,"/// set the tolerance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h:12,toler,tolerance,12,math/mathcore/inc/Math/Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h,2,['toler'],['tolerance']
Availability,"/// setBitsNotInMask - Add a bit to this vector for every '0' bit in Mask.; /// Don't resize. This computes ""*this |= ~Mask"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:69,Mask,Mask,69,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,2,['Mask'],['Mask']
Availability,/// setErrorStr - Set the error string to write to on error. This option; /// defaults to NULL.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:26,error,error,26,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,2,['error'],['error']
Availability,/// setInvalidDecl - Indicates the Decl had a semantic error. This; /// allows for graceful error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:55,error,error,55,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,3,"['error', 'recover']","['error', 'recovery']"
Availability,"/// setIsPoisoned - Mark this identifier as poisoned. After poisoning, the; /// Preprocessor will emit an error every time this token is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:106,error,error,106,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['error'],['error']
Availability,"/// setMCJITMemoryManager - Sets the MCJIT memory manager to use. This allows; /// clients to customize their memory allocation policies for the MCJIT. This; /// is only appropriate for the MCJIT; setting this and configuring the builder; /// to create anything other than MCJIT will cause a runtime error. If create(); /// is called and is successful, the created engine takes ownership of the; /// memory manager. This option defaults to NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:300,error,error,300,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['error'],['error']
Availability,"/// setTableFields - Uses a ModRMFilter to set the appropriate entries in a; /// ModRMDecision to refer to a particular instruction ID.; ///; /// @param decision - The ModRMDecision to populate.; /// @param filter - The filter to use in deciding which entries to populate.; /// @param uid - The unique ID to set matching entries to.; /// @param opcode - The opcode of the instruction, for error reporting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.h:389,error,error,389,interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.h,1,['error'],['error']
Availability,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:77,redundant,redundant,77,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redundant'],['redundant']
Availability,"/// sub - Return the result of replacing the first match of the regex in; /// \p String with the \p Repl string. Backreferences like ""\0"" and ""\g<1>""; /// in the replacement string are replaced with the appropriate match; /// substring.; ///; /// Note that the replacement string has backslash escaping performed on; /// it. Invalid backreferences are ignored (replaced by empty strings).; ///; /// \param Error If non-null, any errors in the substitution (invalid; /// backreferences, trailing backslashes) will be recorded as a non-empty; /// string. If there is no error, it will be an empty string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Regex.h:406,Error,Error,406,interpreter/llvm-project/llvm/include/llvm/Support/Regex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Regex.h,3,"['Error', 'error']","['Error', 'error', 'errors']"
Availability,"/// test using abs and relative tolerance; /// |dx| < absTol + relTol*|x| for every component",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiFit.h:32,toler,tolerance,32,math/mathmore/src/GSLMultiFit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiFit.h,2,['toler'],['tolerance']
Availability,"/// test using abs tolerance; /// Sum |f|_i < absTol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootSolver.h:19,toler,tolerance,19,math/mathmore/src/GSLMultiRootSolver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootSolver.h,1,['toler'],['tolerance']
Availability,"/// the following ""Check"" methods will return a valid/converted QualType; /// or a null QualType (indicating an error diagnostic was issued).; /// type checking binary operators (subroutines of CreateBuiltinBinOp).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:112,error,error,112,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"/// translateMaskRegister - Translates a 3-bit mask register number to; /// LLVM form, and appends it to an MCInst.; ///; /// @param mcInst - The MCInst to append to.; /// @param maskRegNum - Number of mask register from 0 to 7.; /// @return - false on success; true otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp:47,mask,mask,47,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,3,['mask'],"['mask', 'maskRegNum']"
Availability,"/// translateWithInsertion - PHI translate this value into the specified; /// predecessor block, inserting a computation of the value if it is; /// unavailable.; ///; /// All newly created instructions are added to the NewInsts list. This; /// returns null on failure.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:260,failure,failure,260,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,1,['failure'],['failure']
Availability,"/// tryLastChanceRecoloring - Try to assign a color to \p VirtReg by recoloring; /// its interferences.; /// Last chance recoloring chooses a color for \p VirtReg and recolors every; /// virtual register that was using it. The recoloring process may recursively; /// use the last chance recoloring. Therefore, when a virtual register has been; /// assigned a color by this mechanism, it is marked as Fixed, i.e., it cannot; /// be last-chance-recolored again during this recoloring ""session"".; /// E.g.,; /// Let; /// vA can use {R1, R2 }; /// vB can use { R2, R3}; /// vC can use {R1 }; /// Where vA, vB, and vC cannot be split anymore (they are reloads for; /// instance) and they all interfere.; ///; /// vA is assigned R1; /// vB is assigned R2; /// vC tries to evict vA but vA is already done.; /// Regular register allocation fails.; ///; /// Last chance recoloring kicks in:; /// vC does as if vA was evicted => vC uses R1.; /// vC is marked as fixed.; /// vA needs to find a color.; /// None are available.; /// vA cannot evict vC: vC is a fixed virtual register now.; /// vA does as if vB was evicted => vA uses R2.; /// vB needs to find a color.; /// R3 is available.; /// Recoloring => vC = R1, vA = R2, vB = R3; ///; /// \p Order defines the preferred allocation order for \p VirtReg.; /// \p NewRegs will contain any new virtual register that have been created; /// (split, spill) during the process and that must be assigned.; /// \p FixedRegisters contains all the virtual registers that cannot be; /// recolored.; ///; /// \p RecolorStack tracks the original assignments of successfully recolored; /// registers.; ///; /// \p Depth gives the current depth of the last chance recoloring.; /// \return a physical register that can be used for VirtReg or ~0u if none; /// exists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:1004,avail,available,1004,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,2,['avail'],['available']
Availability,"/// upper Minos error. If Minos has not run for parameter i return the parabolic error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h:16,error,error,16,math/mathcore/inc/Fit/FitResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitResult.h,2,['error'],['error']
Availability,"/// use fast FMA if available, fall back to normal arithmetic if not",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h:20,avail,available,20,roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,1,['avail'],['available']
Availability,"/// verify - Check internal consistency of this data structure. If the; /// structure is valid, it returns true. If invalid, it prints errors and; /// returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:135,error,errors,135,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,2,['error'],['errors']
Availability,"/// visitUserOp1 - User defined operators shouldn't live beyond the lifetime of; /// a pass, if any exist, it's an error.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:115,error,error,115,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['error'],['error']
Availability,"/// x86 hardware interrupt context. Callee may take one or two parameters,; /// where the 1st represents a pointer to hardware context frame and the 2nd; /// represents hardware error code, the presence of the later depends on the; /// interrupt vector taken. Valid for both 32- and 64-bit subtargets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h:178,error,error,178,interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,1,['error'],['error']
Availability,"///!< if buffered data available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpLongPollEngine.h:23,avail,available,23,net/http/src/THttpLongPollEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpLongPollEngine.h,1,['avail'],['available']
Availability,"//// same algorithm as crc32_bitwise; //for (int i = 0; i <= 0xFF; i++); //{; // uint32_t crc = i;; // for (int j = 0; j < 8; j++); // crc = (crc >> 1) ^ ((crc & 1) * Polynomial);; // Crc32Lookup[0][i] = crc;; //}; //// ... and the following slicing-by-8 algorithm (from Intel):; //// http://www.intel.com/technology/comms/perfnet/download/CRC_generators.pdf; //// http://sourceforge.net/projects/slicing-by-8/; //for (int slice = 1; slice < MaxSlice; slice++); // Crc32Lookup[slice][i] = (Crc32Lookup[slice - 1][i] >> 8) ^ Crc32Lookup[0][Crc32Lookup[slice - 1][i] & 0xFF];",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c:331,down,download,331,builtins/zlib/deflate_cf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c,1,['down'],['download']
Availability,///// Helpers {; /// \returns Whether the vector mask \p MaskVal has all lane bits set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:49,mask,mask,49,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,2,"['Mask', 'mask']","['MaskVal', 'mask']"
Availability,"////// static functions providing interface to raw WinNT ////////////////////; //---- RPC -------------------------------------------------------------------; //*-* Error codes set by the Windows Sockets implementation are not made available; //*-* via the errno variable. Additionally, for the getXbyY class of functions,; //*-* error codes are NOT made available via the h_errno variable. Instead, error; //*-* codes are accessed by using the WSAGetLastError . This function is provided; //*-* in Windows Sockets as a precursor (and eventually an alias) for the Win32; //*-* function GetLastError. This is intended to provide a reliable way for a thread; //*-* in a multithreaded process to obtain per-thread error information.; /////////////////////////////////////////////////////////////////////////////; /// Receive exactly length bytes into buffer. Returns number of bytes; /// received. Returns -1 in case of error, -2 in case of MSG_OOB; /// and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL; /// and -4 in case of kNonBlock and errno == EWOULDBLOCK.; /// Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:165,Error,Error,165,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,8,"['Error', 'avail', 'error', 'reliab']","['Error', 'available', 'error', 'reliable']"
Availability,"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////; /// \brief Checks two matrices for element-wise equality.; /// \tparam AReal An architecture-specific floating point number type.; /// \param A The first matrix.; /// \param B The second matrix.; /// \param epsilon Equality tolerance, needed to address floating point arithmetic.; /// \return Whether the two matrices can be considered equal element-wise; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Arithmetic.hxx:346,toler,tolerance,346,tmva/tmva/src/DNN/Architectures/Cpu/Arithmetic.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Arithmetic.hxx,1,['toler'],['tolerance']
Availability,"/////////////////////////////////////////////////////////////////////////////////////////////////////////////; // ExpectedErrorPruneTool - a helper class to prune a decision tree using the expected error (C4.5) method //; // //; // Uses an upper limit on the error made by the classification done by each node. If the S/S+B of the node //; // is f, then according to the training sample, the error rate (fraction of misclassified events by this //; // node) is (1-f). Now f has a statistical error according to the binomial distribution hence the error on //; // f can be estimated (same error as the binomial error for efficiency calculations //; // ( sigma = sqrt(eff(1-eff)/nEvts ) ) //; // //; // This tool prunes branches from a tree if the expected error of a node is less than that of the sum of //; // the error in its descendants. //; // //; /////////////////////////////////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/ExpectedErrorPruneTool.h:198,error,error,198,tmva/tmva/inc/TMVA/ExpectedErrorPruneTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/ExpectedErrorPruneTool.h,9,['error'],['error']
Availability,"///////////////////////////////////////////////////////////////////////////////////////////////////; /// Process system events until browser content is available; /// Used in headless mode for batch production like chrome --dump-dom is doing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/RCefWebDisplayHandle.cxx:152,avail,available,152,gui/cefdisplay/src/RCefWebDisplayHandle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/RCefWebDisplayHandle.cxx,1,['avail'],['available']
Availability,"///////////////////////////////////////////////////////////////////////////////////////////////////; /// Show web window in specified location.; ///; /// \param[inout] win web window by reference; /// \param user_args specifies where and how display web window; ///; /// As display args one can use string like ""firefox"" or ""chrome"" - these are two main supported web browsers.; /// See RWebDisplayArgs::SetBrowserKind() for all available options. Default value for the browser can be configured; /// when starting root with --web argument like: ""root --web=chrome"". When root started in web server mode ""root --web=server"",; /// no any web browser will be started - just URL will be printout, which can be entered in any running web browser; ///; /// If allowed, same window can be displayed several times (like for RCanvas or TCanvas); ///; /// Following parameters can be configured in rootrc file:; ///; /// WebGui.Display: kind of display like chrome or firefox or browser, can be overwritten by --web=value command line argument; /// WebGui.OnetimeKey: if configured requires unique key every time window is connected (default yes); /// WebGui.Chrome: full path to Google Chrome executable; /// WebGui.ChromeBatch: command to start chrome in batch, used for image production, like ""$prog --headless --disable-gpu $geometry $url""; /// WebGui.ChromeHeadless: command to start chrome in headless mode, like ""fork: --headless --disable-gpu $geometry $url""; /// WebGui.ChromeInteractive: command to start chrome in interactive mode, like ""$prog $geometry --app=\'$url\' &""; /// WebGui.Firefox: full path to Mozilla Firefox executable; /// WebGui.FirefoxHeadless: command to start Firefox in headless mode, like ""fork:--headless --private-window --no-remote $profile $url""; /// WebGui.FirefoxInteractive: command to start Firefox in interactive mode, like ""$prog --private-window \'$url\' &""; /// WebGui.FirefoxProfile: name of Firefox profile to use; /// WebGui.FirefoxProfilePath: file path to Firef",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx:429,avail,available,429,gui/webdisplay/src/RWebWindowsManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx,1,['avail'],['available']
Availability,"/////////////////////////////////////////////////////////////////////////////////////////////////; /// Apply attributes changes to the drawable; /// Return mask with actions which were really applied",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/RCanvas.cxx:156,mask,mask,156,graf2d/gpadv7/src/RCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/RCanvas.cxx,1,['mask'],['mask']
Availability,"////////////////////////////////////////////////////////////////////////////////////////////////; /// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:167,error,error,167,tree/dataframe/src/RSqliteDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx,2,['error'],['error']
Availability,"///////////////////////////////////////////////////////////////////////////////////////////////; // Absolute Deviation loss function for regression error calculations; ///////////////////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h:148,error,error,148,tmva/tmva/inc/TMVA/LossFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////////////////////////////////////////; // Data Structure used by LossFunction and LossFunctionBDT to calculate errors, targets, etc; ///////////////////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h:169,error,errors,169,tmva/tmva/inc/TMVA/LossFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h,1,['error'],['errors']
Availability,"///////////////////////////////////////////////////////////////////////////////////////////////; // Huber loss function for regression error calculations; ///////////////////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h:135,error,error,135,tmva/tmva/inc/TMVA/LossFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////////////////////////////////////////; // LeastSquares loss function for regression error calculations; ///////////////////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h:142,error,error,142,tmva/tmva/inc/TMVA/LossFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////////////////////////////////////////; // Loss Function interface defining base class for general error calculations in; // regression/classification; ///////////////////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h:156,error,error,156,tmva/tmva/inc/TMVA/LossFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h,1,['error'],['error']
Availability,"//////////////////////////////////////////////////////////////////////////////////////////; /*; This is where the actual work is done - this method parses the XML file tag by tag; and for every tag extracts the atrributes. Here is done some error checking as well -; mostly conserning missing or excessive closing tags, nesting problems, etc.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx:241,error,error,241,core/dictgen/src/XMLReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx,1,['error'],['error']
Availability,"//////////////////////////////////////////////////////////////////////////////////////////; /// Creates http server, if required - with real http engine (civetweb); /// One could configure concrete HTTP port, which should be used for the server,; /// provide following entry in rootrc file:; ///; /// WebGui.HttpPort: 8088; ///; /// or specify range of http ports, which can be used:; ///; /// WebGui.HttpPortMin: 8800; /// WebGui.HttpPortMax: 9800; ///; /// By default range [8800..9800] is used; ///; /// One also can bind HTTP server socket to loopback address,; /// In that case only connection from localhost will be available:; ///; /// WebGui.HttpLoopback: yes; ///; /// Or one could specify hostname which should be used for binding of server socket; ///; /// WebGui.HttpBind: hostname | ipaddress; ///; /// To use secured protocol, following parameter should be specified; ///; /// WebGui.UseHttps: yes; /// WebGui.ServerCert: sertificate_filename.pem; ///; /// Alternatively, one can specify unix socket to handle requests:; ///; /// WebGui.UnixSocket: /path/to/unix/socket; /// WebGui.UnixSocketMode: 0700; ///; /// Typically one used unix sockets together with server mode like `root --web=server:/tmp/root.socket` and; /// then redirect it via ssh tunnel (e.g. using `rootssh`) to client node; ///; /// All incoming requests processed in THttpServer in timer handler with 10 ms timeout.; /// One may decrease value to improve latency or increase value to minimize CPU load; ///; /// WebGui.HttpTimer: 10; ///; /// To processing incoming http requests and websockets, THttpServer allocate 10 threads; /// One have to increase this number if more simultaneous connections are expected:; ///; /// WebGui.HttpThrds: 10; ///; /// One also can configure usage of special thread of processing of http server requests; ///; /// WebGui.HttpThrd: no; ///; /// Extra threads can be used to send data to different clients via websocket (default no); ///; /// WebGui.SenderThrds: no; ///; /// If requi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx:622,avail,available,622,gui/webdisplay/src/RWebWindowsManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx,1,['avail'],['available']
Availability,"/////////////////////////////////////////////////////////////////////////////////////////; /*; We Get the attributes (if any) of the tag as {attribute_name, attribute_value} couples; If there are no attributes, I don't fill the out vector and after that in the Parse(); method check if out is empty. All the error handling conserning attributes is done here; and this is the reason why the logic is somtimes a bit obscure.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx:308,error,error,308,core/dictgen/src/XMLReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx,1,['error'],['error']
Availability,"/////////////////////////////////////////////////////////////////////////////////////////; /// \brief Draw expression varexp for entries and objects that pass a (optional) selection.; ///; /// \return -1 in case of error or number of selected events in case of success.; ///; /// \param [in] varexp; /// \parblock; /// A string that takes one of these general forms:; /// - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; /// - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; /// on the y-axis versus ""e2"" on the x-axis; /// - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; /// vs ""e2"" vs ""e3"" on the z-, y-, x-axis, respectively; /// - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; /// vs ""e2"" vs ""e3"" and ""e4"" mapped on the current color palette.; /// (to create histograms in the 2, 3, and 4 dimensional case,; /// see section ""Saving the result of Draw to an histogram""); /// - ""e1:e2:e3:e4:e5"" with option ""GL5D"" produces a 5D plot using OpenGL. `gStyle->SetCanvasPreferGL(true)` is needed.; /// - Any number of variables no fewer than two can be used with the options ""CANDLE"" and ""PARA""; /// - An arbitrary number of variables can be used with the option ""GOFF""; ///; /// Examples:; /// - ""x"": the simplest case, it draws a 1-Dim histogram of column x; /// - ""sqrt(x)"", ""x*y/z"": draw histogram with the values of the specified numerical expression across TTree events; /// - ""y:sqrt(x)"": 2-Dim histogram of y versus sqrt(x); /// - ""px:py:pz:2.5*E"": produces a 3-d scatter-plot of px vs py ps pz; /// and the color number of each marker will be 2.5*E.; /// If the color number is negative it is set to 0.; /// If the color number is greater than the current number of colors; /// it is set to the highest color number. The default number of; /// colors is 50. See TStyle::SetPalette for setting a new color palette.; ///; /// The expressions can use all the operations and built-in functions; /// supported by TF",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:215,error,error,215,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['error'],['error']
Availability,"//////////////////////////////////////////////////////////////////////////////////; /// \brief Utility function which checks if a given key is present in a Python; /// dictionary object and returns the associated value or throws runtime; /// error.; ///; /// \param[in] listObject Python Dict object; /// \return Associated value PyObject",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/PyMethodBase.cxx:242,error,error,242,tmva/pymva/src/PyMethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/PyMethodBase.cxx,1,['error'],['error']
Availability,"/////////////////////////////////////////////////////////////////////////////////; // This function calculates error function of x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrumFit.cxx:111,error,error,111,hist/spectrum/src/TSpectrumFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrumFit.cxx,1,['error'],['error']
Availability,"/////////////////////////////////////////////////////////////////////////////////; /// Returns nodeid for given stack array, returns -1 in case of failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx:147,failure,failure,147,geom/webviewer/src/RGeomData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx,1,['failure'],['failure']
Availability,"////////////////////////////////////////////////////////////////////////////////; /*! \class TGraphPainter; \ingroup Histpainter; \brief The graph painter class. Implements all graphs' drawing's options. - [Introduction](\ref GrP0); - [Graphs' plotting options](\ref GrP1); - [Exclusion graphs](\ref GrP2); - [Graphs with error bars](\ref GrP3); - [TGraphErrors](\ref GrP3a); - [TGraphAsymmErrors](\ref GrP3b); - [TGraphBentErrors](\ref GrP3c); - [TGraphMultiErrors](\ref GrP3d); - [TGraphPolar options](\ref GrP4); - [Colors automatically picked in palette](\ref GrP5); - [Reverse graphs' axis](\ref GrP6); - [Graphs in logarithmic scale](\ref GrP7); - [Highlight mode for graph](\ref GrP8). \anchor GrP0; ### Introduction. Graphs are drawn via the painter `TGraphPainter` class. This class; implements techniques needed to display the various kind of; graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`. To draw a graph `graph` it's enough to do:. graph->Draw(""AL"");. The option `AL` in the `Draw()` method means:. 1. The axis should be drawn (option `A`),; 2. The graph should be drawn as a simple line (option `L`). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; `A` must be specified. `TGraphPainter` offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call `Draw()` again; the; image will be refreshed the next time the pad will be updated. A pad is updated; after one of these three actions:. 1. a carriage return on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. \anchor GrP1; ### Graphs' plotting options; Graphs can be drawn with the following options:. | Option | Description |; |----------|--------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:322,error,error,322,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraphBentErrors; \ingroup Graphs; A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The TGraphBentErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:; Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphBentErrors default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:181,error,error,181,hist/hist/src/TGraphBentErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraphErrors; \ingroup Graphs; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; auto gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphErrors default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:156,error,error,156,hist/hist/src/TGraphErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx,2,['error'],['error']
Availability,////////////////////////////////////////////////////////////////////////////////; /**; * Get the pointer to the template arguments list. Return zero if not available.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/DictSelectionReader.cxx:156,avail,available,156,core/dictgen/src/DictSelectionReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/DictSelectionReader.cxx,1,['avail'],['available']
Availability,"////////////////////////////////////////////////////////////////////////////////; /**; * Second pass through the AST. Two operations are performed:; * 1. Selection rules for classes to be autoselected are created. The; * algorithm works as follows: the members of the classes matching the name of; * the classes which contained autoselected members in the selection namespace; * are inspected. If a field with the same name of the one which was; * autoselected a selection rule based on its typename is built.; * 2. If a class is found which is a @c TemplateSpecialisationDecl its; * name is checked to match one of the patterns identified during the first; * pass. If a match is found, a property is added to the selection rule with; * the number of template arguments to keep in order to percolate this; * information down to the @c AnnotatedRecordDecl creation which happens in the; * @c RScanner .; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/DictSelectionReader.cxx:820,down,down,820,core/dictgen/src/DictSelectionReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/DictSelectionReader.cxx,1,['down'],['down']
Availability,"////////////////////////////////////////////////////////////////////////////////; // //; // TContextMenu //; // //; // This class provides an interface to context sensitive popup menus. //; // These menus pop up when the user hits the right mouse button, and //; // are destroyed when the menu pops downs. //; // //; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/TContextMenu.h:299,down,downs,299,core/gui/inc/TContextMenu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/TContextMenu.h,1,['down'],['downs']
Availability,"////////////////////////////////////////////////////////////////////////////////; // Only newer versions of davix support setting the S3 region and STS tokens.; // But it's only possible to check the davix version through a #define starting from; // 0.6.4.; // I have no way to check if setAwsRegion is available, so let's use SFINAE. :-); // The first overload will always take priority - if ""substitution"" fails, meaning; // setAwsRegion is not there, the compiler will pick the second overload with; // the ellipses. (...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx:303,avail,available,303,net/davix/src/TDavixFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx,1,['avail'],['available']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; /// and create an ArrayF for errors if ""errors"" is true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:205,error,errors,205,hist/hist/src/THnSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx,2,['error'],['errors']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// *** This function is deprecated and will disappear in future versions ***; /// *** It is just a wrapper around TFile::Cp.; /// *** Please use TProofMgr::UploadFiles.; ///; /// Upload a set of files and save the list of files by name dataSetName.; /// The 'files' argument is a list of TFileInfo objects describing the files; /// as first url.; /// The mask 'opt' is a combination of EUploadOpt:; /// kAppend (0x1) if set true files will be appended to; /// the dataset existing by given name; /// kOverwriteDataSet (0x2) if dataset with given name exited it; /// would be overwritten; /// kNoOverwriteDataSet (0x4) do not overwirte if the dataset exists; /// kOverwriteAllFiles (0x8) overwrite all files that may exist; /// kOverwriteNoFiles (0x10) overwrite none; /// kAskUser (0x0) ask user before overwriteng dataset/files; /// The default value is kAskUser.; /// The user will be asked to confirm overwriting dataset or files unless; /// specified opt provides the answer!; /// If kOverwriteNoFiles is set, then a pointer to TList must be passed as; /// skippedFiles argument. The function will add to this list TFileInfo; /// objects describing all files that existed on the cluster and were; /// not uploaded.; ///; /// Communication Summary; /// Client Master; /// |------------>DataSetName----------->|; /// |<-------kMESS_OK/kMESS_NOTOK<-------| (Name OK/file exist); /// (*)|-------> call RegisterDataSet ------->|; /// (*) - optional",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:438,mask,mask,438,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['mask'],['mask']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// *** This function is deprecated and will disappear in future versions ***; /// *** It is just a wrapper around TFile::Cp.; /// *** Please use TProofMgr::UploadFiles.; ///; /// Upload a set of files and save the list of files by name dataSetName.; /// The mask 'opt' is a combination of EUploadOpt:; /// kAppend (0x1) if set true files will be appended to; /// the dataset existing by given name; /// kOverwriteDataSet (0x2) if dataset with given name exited it; /// would be overwritten; /// kNoOverwriteDataSet (0x4) do not overwirte if the dataset exists; /// kOverwriteAllFiles (0x8) overwrite all files that may exist; /// kOverwriteNoFiles (0x10) overwrite none; /// kAskUser (0x0) ask user before overwriteng dataset/files; /// The default value is kAskUser.; /// The user will be asked to confirm overwriting dataset or files unless; /// specified opt provides the answer!; /// If kOverwriteNoFiles is set, then a pointer to TList must be passed as; /// skippedFiles argument. The function will add to this list TFileInfo; /// objects describing all files that existed on the cluster and were; /// not uploaded.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:341,mask,mask,341,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['mask'],['mask']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// - For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.; /// - For axis = 11, 12 or 13 returns the approximate standard error of skewness; /// of the histogram along x, y or z axis; ///; ///Note, that since third and fourth moment are not calculated; ///at the fill time, skewness and its standard error are computed bin by bin; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. See TH1::GetMean and TH1::GetStdDev.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:229,error,error,229,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// - For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; /// Kurtosis(gaussian(0, 1)) = 0.; /// - For axis =11, 12 or 13 returns the approximate standard error of kurtosis; /// of the histogram along x, y or z axis; ////; /// Note, that since third and fourth moment are not calculated; /// at the fill time, kurtosis and its standard error are computed bin by bin; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. See TH1::GetMean and TH1::GetStdDev.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:262,error,error,262,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// - if mode = 0; /// find closest point to target in Y, the object closest to the target which is 3 sigma from the target; /// and has smaller error; /// - if mode = 1; /// find 2 closest point to target in X and between these two take the one closer to the target; /// - if mode = 2 as in mode = 1 but return the lower point not the closest one; /// - if mode = 3 as in mode = 1 but return the upper point not the closest one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterResult.cxx:227,error,error,227,roofit/roostats/src/HypoTestInverterResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterResult.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// @param[in] numthreads Number of threads to use. If not specified or; /// set to zero, the number of threads is automatically; /// decided by the implementation. Any other value is; /// used as a hint.; ///; /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; /// The following objects and methods automatically take advantage of; /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; ///; /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; /// - TTree::GetEntry reads multiple branches in parallel; /// - TTree::FlushBaskets writes multiple baskets to disk in parallel; /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; /// - THx::Fit performs in parallel the evaluation of the objective function over the data; /// - TMVA::DNN trains the deep neural networks in parallel; /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; ///; /// EnableImplicitMT calls in turn EnableThreadSafety.; /// The 'numthreads' parameter allows to control the number of threads to; /// be used by the implicit multi-threading. However, this parameter is just; /// a hint for ROOT: it will try to satisfy the request if the execution; /// scenario allows it. For example, if ROOT is configured to use an external; /// scheduler, setting a value for 'numthreads' might not have any effect.; /// The maximum number of threads can be influenced by the environment; /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; /// the maximum number of active threads to 2, if the scheduling library; /// (such as tbb) ""permits"".; ///; /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:374,avail,available,374,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['avail'],['available']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// A helper function to locate the correct basket - and its first entry.; /// Extracted to a common private function because it is needed by both GetEntry; /// and GetBulkEntries. It should not be called directly.; ///; /// If a new basket must be constructed and the user_buffer is provided, then; /// the user_buffer will back the memory of the newly-constructed basket.; ///; /// Assumes that this branch is enabled.; ///; /// Returns -1 if the entry does not exist; /// Returns -2 in case of error; /// Returns the index of the basket in case of success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:579,error,error,579,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Accept a connection on a parallel server socket. Returns a full-duplex; /// parallel communication TPSocket object. If no pending connections are; /// present on the queue and nonblocking mode has not been enabled; /// with SetOption(kNoBlock,1) the call blocks until a connection is; /// present. The returned socket must be deleted by the user. The socket; /// is also added to the TROOT sockets list which will make sure that; /// any open sockets are properly closed on program termination.; /// In case of error 0 is returned and in case non-blocking I/O is; /// enabled and no connections are available -1 is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPServerSocket.cxx:597,error,error,597,net/net/src/TPServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPServerSocket.cxx,2,"['avail', 'error']","['available', 'error']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Accept a connection on a server socket. Returns a full-duplex; /// communication TSocket object. If no pending connections are; /// present on the queue and nonblocking mode has not been enabled; /// with SetOption(kNoBlock,1) the call blocks until a connection is; /// present. The returned socket must be deleted by the user. The socket; /// is also added to the TROOT sockets list which will make sure that; /// any open sockets are properly closed on program termination.; /// In case of error 0 is returned and in case non-blocking I/O is; /// enabled and no connections are available -1 is returned.; ///; /// The opt can be used to require client authentication; valid options are; ///; /// kSrvAuth = require client authentication; /// kSrvNoAuth = force no client authentication; ///; /// Example: use Opt = kSrvAuth to require client authentication.; ///; /// Default options are taken from fgAcceptOpt and are initially; /// equivalent to kSrvNoAuth; they can be changed with the static; /// method TServerSocket::SetAcceptOptions(Opt).; /// The active defaults can be visualized using the static method; /// TServerSocket::ShowAcceptOptions().; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx:578,error,error,578,net/net/src/TServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx,2,"['avail', 'error']","['available', 'error']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Accept a connection on the server socket.; /// If to > 0, wait max to secs (granularity 1 sec).; /// Return a rpdtcp object describing the open connection (to be destroyed; /// by the caller).; /// On error return a NULL pointer and the errno in *err, if defined;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx:287,error,error,287,net/rpdutils/src/rpdconn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Accept a connection on the server socket.; /// If to > 0, wait max to secs (granularity 1 sec).; /// Return a rpdunix object describing the open connection (to be destroyed; /// by the caller).; /// On error return a NULL pointer and the errno in *err, if defined;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx:288,error,error,288,net/rpdutils/src/rpdconn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Access a named state. If a state with this name doesn't exist yet, the state is; /// assigned the next available positive integer.; /// \param[in] stateName Name of the state to be accessed.; /// \return Reference to the category index. If no state exists, it will be created on the fly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCategory.cxx:189,avail,available,189,roofit/roofitcore/src/RooCategory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCategory.cxx,1,['avail'],['available']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Access to target class pointer (if available)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfoReference.cxx:121,avail,available,121,tree/treeplayer/src/TFormLeafInfoReference.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfoReference.cxx,1,['avail'],['available']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Acquire semaphore. Returns 0 if OK, -1 on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:128,error,error,128,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Acts like snprintf with some printout in case of error if required; /// Returns number of characters printed (excluding the trailing `\0').; /// Returns 0 is buf or size are not defined or inconsistent.; /// Returns -1 if the buffer is truncated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:135,error,error,135,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add ""e"" to error of bin with index ""bin"", enable errors if needed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:97,error,error,97,hist/hist/src/THnSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx,2,['error'],"['error', 'errors']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a 3D point with asymmetric errorbars to an existing graph",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:117,error,errorbars,117,hist/hist/src/TGraph2DAsymmErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx,1,['error'],['errorbars']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a bin to this histogram with the specified bin contents; /// and error. The bin width is used to set the relative scale of; /// bins with different widths.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHist.cxx:155,error,error,155,roofit/roofitcore/src/RooHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHist.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a bin to this histogram with the specified integer bin contents; /// and using an error bar calculated with Poisson statistics. The bin width; /// is used to set the relative scale of bins with different widths.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHist.cxx:172,error,error,172,roofit/roofitcore/src/RooHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHist.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a bin to this histogram with the value (n1-n2)/(n1+n2); /// using an error bar calculated with Binomial statistics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHist.cxx:159,error,error,159,roofit/roofitcore/src/RooHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHist.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a bin to this histogram with the value n1/(n1+n2); /// using an error bar calculated with Binomial statistics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHist.cxx:154,error,error,154,roofit/roofitcore/src/RooHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHist.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a box with statistics information to the specified frame. By default a box with the; /// event count, mean and rms of the plotted variable is added.; ///; /// The following optional named arguments are accepted; /// <table>; /// <tr><td> `What(const char* whatstr)` <td> Controls what is printed: ""N"" = count, ""M"" is mean, ""R"" is RMS.; /// <tr><td> `Format(const char* optStr)` <td> \deprecated Classing parameter formatting options, provided for backward compatibility; ///; /// <tr><td> `Format(const char* what,...)` <td> Parameter formatting options.; /// <table>; /// <tr><td> const char* what <td> Controls what is shown:; /// - ""N"" adds name; /// - ""E"" adds error; /// - ""A"" shows asymmetric error; /// - ""U"" shows unit; /// - ""H"" hides the value; /// <tr><td> `FixedPrecision(int n)` <td> Controls precision, set fixed number of digits; /// <tr><td> `AutoPrecision(int n)` <td> Controls precision. Number of shown digits is calculated from error + n specified additional digits (1 is sensible default); /// <tr><td> `VerbatimName(bool flag)` <td> Put variable name in a \\verb+ + clause.; /// </table>; /// <tr><td> `Label(const chat* label)` <td> Add header label to parameter box; /// <tr><td> `Layout(double xmin, double xmax, double ymax)` <td> Specify relative position of left,right side of box and top of box. Position of; /// bottom of box is calculated automatically from number lines in box; /// <tr><td> `Cut(const char* expression)` <td> Apply given cut expression to data when calculating statistics; /// <tr><td> `CutRange(const char* rangeName)` <td> Only consider events within given range when calculating statistics. Multiple; /// CutRange() argument may be specified to combine ranges.; ///; /// </table>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:755,error,error,755,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,3,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a branch discovered by actual usage to the list of branches to be stored; /// in the cache this function is called by TBranch::GetBasket; /// If we are not longer in the training phase this is an error.; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:286,error,error,286,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a branch to the list of branches to be stored in the cache; /// this function is called by TBranch::GetBasket; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:269,error,error,269,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a branch to the list of branches to be stored in the cache; /// this function is called by the user via TTree::AddBranchToCache.; /// The branch is added even if we are outside of the training phase.; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:359,error,error,359,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a branch to the list of branches to be stored in the cache; /// this is to be used by user (thats why we pass the name of the branch).; /// It works in exactly the same way as TTree::SetBranchStatus so you; /// probably want to look over there for details about the use of bname; /// with regular expressions.; /// The branches are taken with respect to the Owner of this TTreeCache; /// (i.e. the original Tree); /// NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:659,error,error,659,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a data point and update the covariance matrix. The input; /// array must be <TT>fNumberOfVariables</TT> long.; ///; ///; /// The Covariance matrix and mean values of the input data is calculated; /// on the fly by the following equations:; ///; /// \f[; /// \left<x_i\right>^{(0)} = x_{i0}; /// \f]; ///; ///; /// \f[; /// \left<x_i\right>^{(n)} = \left<x_i\right>^{(n-1)}; /// + \frac1n \left(x_{in} - \left<x_i\right>^{(n-1)}\right); /// \f]; ///; /// \f[; /// C_{ij}^{(0)} = 0; /// \f]; ///; ///; ///; /// \f[; /// C_{ij}^{(n)} = C_{ij}^{(n-1)}; /// + \frac1{n-1}\left[\left(x_{in} - \left<x_i\right>^{(n)}\right); /// \left(x_{jn} - \left<x_j\right>^{(n)}\right)\right]; /// - \frac1n C_{ij}^{(n-1)}; /// \f]; ///; /// since this is a really fast method, with no rounding errors (please; /// refer to CERN 72-21 pp. 54-106).; ///; ///; /// The data is stored internally in a <TT>TVectorD</TT>, in the following; /// way:; ///; /// \f[; /// \mathbf{x} = \left[\left(x_{0_0},\ldots,x_{{P-1}_0}\right),\ldots,; /// \left(x_{0_i},\ldots,x_{{P-1}_i}\right), \ldots\right]; /// \f]; ///; /// With \f$P\f$ as defined in the class description.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:866,error,errors,866,hist/hist/src/TPrincipal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx,1,['error'],['errors']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a data point, with its coordinates specified in the 'data' argset, to the data set.; /// Any variables present in 'data' but not in the dataset will be silently ignored.; /// \param[in] data Data point.; /// \param[in] wgt Event weight. Defaults to 1. The current value of the weight variable is; /// ignored.; /// \note To obtain weighted events, a variable must be designated `WeightVar` in the constructor.; /// \param[in] wgtError Optional weight error.; /// \note This requires including the weight variable in the set of `StoreError` variables when constructing; /// the dataset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx:541,error,error,541,roofit/roofitcore/src/RooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a data point, with its coordinates specified in the 'data' argset, to the data set.; /// Any variables present in 'data' but not in the dataset will be silently ignored.; /// \param[in] indata Data point.; /// \param[in] inweight Event weight. The current value of the weight variable is ignored.; /// \note To obtain weighted events, a variable must be designated `WeightVar` in the constructor.; /// \param[in] weightErrorLo Asymmetric weight error.; /// \param[in] weightErrorHi Asymmetric weight error.; /// \note This requires including the weight variable in the set of `StoreAsymError` variables when constructing; /// the dataset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx:535,error,error,535,roofit/roofitcore/src/RooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a data point, with its coordinates specified in the 'data' argset, to the data set.; /// \attention The order and type of the input variables are **assumed** to be the same as; /// for the RooArgSet returned by RooDataSet::get(). Input values will just be written; /// into the internal data columns by ordinal position.; /// \param[in] data Data point.; /// \param[in] wgt Event weight. Defaults to 1. The current value of the weight variable is; /// ignored.; /// \note To obtain weighted events, a variable must be designated `WeightVar` in the constructor.; /// \param[in] wgtError Optional weight error.; /// \note This requires including the weight variable in the set of `StoreError` variables when constructing; /// the dataset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx:692,error,error,692,roofit/roofitcore/src/RooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a new entry to this legend. ""name"" is the name of an object in the pad to; /// be represented label is the text you wish to associate with obj in the legend; /// if label is null or empty, the title of the object will be used.; ///; /// Options are:; ///; /// - L: draw line associated with TAttLine if obj inherits from TAttLine; /// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; /// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; /// - E: draw vertical error bar if option ""L"" is also specified",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLegend.cxx:609,error,error,609,graf2d/graf/src/TLegend.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLegend.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a new entry to this legend. ""obj"" is the object to be represented.; /// ""label"" is the text you wish to associate with obj in the legend.; /// If ""label"" is null or empty, the title of the object will be used.; ///; /// Options are:; ///; /// - L: draw line associated with TAttLine if obj inherits from TAttLine; /// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; /// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; /// - E: draw vertical error bar if option ""L"" is also specified",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLegend.cxx:592,error,error,592,graf2d/graf/src/TLegend.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLegend.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a new y error to the graph and fill it with the values from `eyL` and `eyH`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:98,error,error,98,hist/hist/src/TGraphMultiErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a point with asymmetric errorbars to the graph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:114,error,errorbars,114,hist/hist/src/TGraphAsymmErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx,1,['error'],['errorbars']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a point with bent errors to the graph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:108,error,errors,108,hist/hist/src/TGraphBentErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx,1,['error'],['errors']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a point with errorbars to the graph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:103,error,errorbars,103,hist/hist/src/TGraph2DErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx,2,['error'],['errorbars']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the test sample to be used for the; /// test of the parameterization.; /// This sample needn't be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:208,error,error,208,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,3,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the training sample to be used for the; /// parameterization.; /// The mean of the variables and quantity is calculated on the fly,; /// as outlined in TPrincipal::AddRow.; /// This sample should be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:208,error,error,208,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,3,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add a text box with the current parameter values and their errors to the frame.; /// Observables of this PDF appearing in the 'data' dataset will be omitted.; ///; /// An optional label will be inserted if passed. Multi-line labels can be generated; /// by adding `\n` to the label string. Use 'sigDigits'; /// to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; /// values specify the initial relative position of the text box in the plot frame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:145,error,errors,145,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['error'],['errors']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add all histograms in the collection to this histogram.; /// This function computes the min/max for the x axis,; /// compute a new number of bins, if necessary,; /// add bin contents, errors and statistics.; /// If all histograms have bin labels, bins with identical labels; /// will be merged, no matter what their order is.; /// If overflows are present and limits are different the function will fail.; /// The function returns the total number of entries in the result histogram; /// if the merge is successful, -1 otherwise.; ///; /// Possible option:; /// -NOL : the merger will ignore the labels and merge the histograms bin by bin using bin center values to match bins; /// -NOCHECK: the histogram will not perform a check for duplicate labels in case of axes with labels. The check; /// (enabled by default) slows down the merging; ///; /// IMPORTANT remark. The axis x may have different number; /// of bins and different limits, BUT the largest bin width must be; /// a multiple of the smallest bin width and the upper limit must also; /// be a multiple of the bin width.; /// Example:; ///; /// ~~~ {.cpp}; /// void atest() {; /// TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; /// TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; /// TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; /// TRandom r;; /// for (Int_t i=0;i<10000;i++) {; /// h1->Fill(r.Gaus(-55,10));; /// h2->Fill(r.Gaus(55,10));; /// h3->Fill(r.Gaus(0,10));; /// }; ///; /// TList *list = new TList;; /// list->Add(h1);; /// list->Add(h2);; /// list->Add(h3);; /// TH1F *h = (TH1F*)h1->Clone(""h"");; /// h->Reset();; /// h->Merge(list);; /// h->Draw();; /// }; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:270,error,errors,270,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,2,"['down', 'error']","['down', 'errors']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add an error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TStatus.cxx:93,error,error,93,proof/proofplayer/src/TStatus.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TStatus.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add branch b to the Tree cache.; /// if subbranches is true all the branches of the subbranches are; /// also put to the cache.; ///; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:288,error,error,288,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add branch with name bname to the Tree cache.; /// If bname=""*"" all branches are added to the cache.; /// if subbranches is true all the branches of the subbranches are; /// also put to the cache.; ///; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:357,error,error,357,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add files passed as list of TFileInfo, TUrl or TObjString objects .; /// If TFileInfo, the first entry and the number of entries are also filled.; /// The argument 'meta' can be used to specify one of the subsets in the; /// file as described in the metadata of TFileInfo. By default the first one; /// is taken.; /// If 'availableOnly' is true only files available ('staged' and non corrupted); /// are taken: those not satisfying this requirement are added to 'badlist', if; /// the latter is defined. By default availableOnly is false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx:408,avail,availableOnly,408,proof/proof/src/TDSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx,3,['avail'],"['available', 'availableOnly']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add nWorkersToAdd workers to current list of workers. This function is; /// works on the master only, and only when an analysis is ongoing. A message; /// is sent back to the client when we go ""more"" parallel.; /// Returns -1 on error, number of total (not added!) workers on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:315,error,error,315,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add object at position ids. Give an error when idx is out of bounds; /// (i.e. the array is not expanded).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TObjArray.cxx:122,error,error,122,core/cont/src/TObjArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TObjArray.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add objects to a 2D plot that represent the fit results for the; /// two named parameters. The input frame with the objects added is; /// returned, or zero in case of an error. Which objects are added; /// are determined by the options string which should be a concatenation; /// of the following (not case sensitive):; ///; /// * M - a marker at the best fit result; /// * E - an error ellipse calculated at 1-sigma using the error matrix at the minimum; /// * 1 - the 1-sigma error bar for parameter 1; /// * 2 - the 1-sigma error bar for parameter 2; /// * B - the bounding box for the error ellipse; /// * H - a line and horizontal axis for reading off the correlation coefficient; /// * V - a line and vertical axis for reading off the correlation coefficient; /// * A - draw axes for reading off the correlation coefficients with the H or V options; ///; /// You can change the attributes of objects in the returned RooPlot using the; /// various `RooPlot::getAttXxx(name)` member functions, e.g.; /// ```; /// plot->getAttLine(""contour"")->SetLineStyle(kDashed);; /// ```; /// Use `plot->Print()` for a list of all objects and their names (unfortunately most; /// of the ROOT builtin graphics objects like TLine are unnamed). Drag the left mouse; /// button along the labels of either axis button to interactively zoom in a plot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitResult.cxx:256,error,error,256,roofit/roofitcore/src/RooFitResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitResult.cxx,6,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add points calculated with the specified function, over the range (xlo,xhi).; /// Add at least minPoints equally spaced points, and add sufficient points so that; /// the maximum deviation from the final straight-line segments is prec*(ymax-ymin),; /// down to a minimum horizontal spacing of resolution*(xhi-xlo).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCurve.cxx:339,down,down,339,roofit/roofitcore/src/RooCurve.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCurve.cxx,1,['down'],['down']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add the 'Errors' group frame to the 'Histos - Graphs' tab.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:95,Error,Errors,95,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['Error'],['Errors']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Add the basket to this branch.; ///; /// Warning: if the basket are not 'flushed/copied' in the same; /// order as they were created, this will induce a slow down in; /// the insert (since we'll need to move all the record that are; /// entere 'too early').; /// Warning we also assume that the __current__ write basket is; /// not present (aka has been removed) or is empty (no entries).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:244,down,down,244,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['down'],['down']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Adds a channel with signal, background and data given as input.; /// In addition, error sources are defined.; /// TH1 are here used for convenience: each bin has to be seen as; /// an error source (relative).; /// names is an array of strings containing the names of the sources.; /// Sources with the same name are correlated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimitDataSource.cxx:168,error,error,168,hist/hist/src/TLimitDataSource.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimitDataSource.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Adds all graphs from the collection to this graph.; /// Returns the total number of points in the result or -1 in case of an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:211,error,error,211,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Adds all graphs with asymmetric errors from the collection to this graph.; /// Returns the total number of points in the result or -1 in case of an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:118,error,errors,118,hist/hist/src/TGraphAsymmErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx,2,['error'],"['error', 'errors']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Adds all graphs with errors from the collection to this graph.; /// Returns the total number of points in the result or -1 in case of an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:107,error,errors,107,hist/hist/src/TGraphErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx,2,['error'],"['error', 'errors']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Adds new workers. Must be implemented by each real packetizer properly.; /// Returns the number of workers added, or -1 on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx:209,failure,failure,209,proof/proof/src/TVirtualPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx,1,['failure'],['failure']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Adds new workers. Returns the number of workers added, or -1 on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx:150,failure,failure,150,proof/proofplayer/src/TPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx,2,['failure'],['failure']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Adds the dataset in the folder of group, user to the list in target.; /// If dsName is defined, only the information about the specified dataset; /// is processed.; ///; /// The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; /// Available options (to be .or.ed):; /// kPrint print the dataset content; /// kQuotaUpdate update quotas; /// kExport use export naming; /// kList get a list of dataset names; ///; /// NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; /// NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx:337,Avail,Available,337,proof/proof/src/TDataSetManagerFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx,1,['Avail'],['Available']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Adopt a file already open.; /// Return 0 if OK, -1 in case of failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofOutputFile.cxx:148,failure,failure,148,proof/proof/src/TProofOutputFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofOutputFile.cxx,1,['failure'],['failure']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Analyse and paint the TLatex formula; ///; /// It is called twice : first for calculating the size of; /// each portion of the formula, then to paint the formula.; /// When analyse finds an operator or separator, it calls; /// itself recursively to analyse the arguments of the operator.; /// when the argument is an atom (normal text), it calculates; /// the size of it and return it as the result.; /// for example : if the operator #%frac{arg1}{arg2} is found :; /// Analyse(arg1) return the size of arg1 (width, up, down); /// Analyse(arg2) return the size of arg2; /// now, we know the size of #%frac{arg1}{arg2}:; ///; /// ~~~ {.cpp}; /// width = max(width_arg1, width_arg2); /// up = up_arg1 + down_arg1; /// down = up_arg2 + down_arg2; /// ~~~; ///; /// so, when the user wants to paint a fraction at position (x,y),; /// the rect used for the formula is : (x,y-up,x+width,y+down); ///; /// return size of zone occupied by the text/formula; /// - `t` : chain to be analyzed; /// - `length` : number of chars in t.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLatex.cxx:606,down,down,606,graf2d/graf/src/TLatex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLatex.cxx,3,['down'],['down']
Availability,////////////////////////////////////////////////////////////////////////////////; /// Analyze a sub-expression in one formula.; ///; /// Expressions in one formula are recursively analyzed.; /// Result of analysis is stored in the object tables.; ///; /// ### Table of function codes and errors; ///; /// ~~~ {.cpp}; /// * functions :; ///; /// + 1 pow 20; /// - 2 sq 21; /// * 3 sqrt 22; /// / 4 strstr 23; /// % 5 min 24; /// max 25; /// log 30; /// cos 10 exp 31; /// sin 11 log10 32; /// tan 12; /// acos 13 abs 41; /// asin 14 sign 42; /// atan 15 int 43; /// atan2 16; /// fmod 17 rndm 50; ///; /// cosh 70 acosh 73; /// sinh 71 asinh 74; /// tanh 72 atanh 75; ///; /// expo 100 gaus 110 gausn (see note below); /// expo(0) 100 0 gaus(0) 110 0 gausn(0); /// expo(1) 100 1 gaus(1) 110 1 gausn(1); /// xexpo 100 x xgaus 110 x xgausn; /// yexpo 101 x ygaus 111 x ygausn; /// zexpo 102 x zgaus 112 x zgausn; /// xyexpo 105 x xygaus 115 x xygausn; /// yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); /// xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2); ///; /// landau 120 x landaun (see note below); /// landau(0) 120 0 landaun(0); /// landau(1) 120 1 landaun(1); /// xlandau 120 x xlandaun; /// ylandau 121 x ylandaun; /// zlandau 122 x zlandaun; /// xylandau 125 x xylandaun; /// ylandau(5) 121 5 ylandaun(5); /// xylandau(2) 125 2 xylandaun(2); ///; /// pol0 130 x pol1 130 1xx; /// pol0(0) 130 0 pol1(0) 130 100; /// pol0(1) 130 1 pol1(1) 130 101; /// xpol0 130 x xpol1 130 101; /// ypol0 131 x ypol1 131 101; /// zpol0 132 x zpol1 132 1xx; /// ypol0(5) 131 5 ypol1(5) 131 105; ///; /// pi 40; ///; /// && 60 < 64; /// || 61 > 65; /// == 62 <= 66; /// != 63 => 67; /// ! 68; /// ==(string) 76 & 78; /// !=(string) 77 | 79; /// <<(shift) 80 >>(shift) 81; /// ? : 82; ///; /// * constants (kConstants) :; ///; /// c0 141 1 c1 141 2 etc..; ///; /// * strings (kStringConst):; ///; /// sX 143 x; ///; /// * variables (kFormulaVar) :; ///; /// x 144 0 y 144 1 z 144 2 t 144 3; ///; /// * parameters :; ///; /// [,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:288,error,errors,288,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['error'],['errors']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Analyze the received message.; /// Returns 0 on success (1 if this the last message from this socket), -1 if; /// any failure occurs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:204,failure,failure,204,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['failure'],['failure']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Appends (or insert at the specified position) the given HTML text to the; /// end of any HTML text that may have been inserted by prior calls to this; /// command. Then it runs the tokenizer, parser and layout engine as far as; /// possible with the text that is available. The display is updated; /// appropriately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:349,avail,available,349,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,1,['avail'],['available']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Apply a function to all data points \f$ y = f(x,y) \f$.; ///; /// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; /// \f$ eyl = f(x,y)-f(x,y-eyl) \f$.; ///; /// Special treatment has to be applied for the functions where the; /// role of ""up"" and ""down"" is reversed.; ///; /// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:152,Error,Errors,152,hist/hist/src/TGraphBentErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx,2,"['Error', 'down']","['Errors', 'down']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Apply a function to all data points \f$ y = f(x,y) \f$.; ///; /// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; /// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; ///; /// Only the first error dimension is affected.; ///; /// Special treatment has to be applied for the functions where the; /// role of ""up"" and ""down"" is reversed.; ///; /// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:152,Error,Errors,152,hist/hist/src/TGraphMultiErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx,3,"['Error', 'down', 'error']","['Errors', 'down', 'error']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Apply a function to all data points \f$ y = f(x,y) \f$; ///; /// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; /// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; ///; /// Special treatment has to be applied for the functions where the; /// role of ""up"" and ""down"" is reversed.; ///; /// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:151,Error,Errors,151,hist/hist/src/TGraphAsymmErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx,2,"['Error', 'down']","['Errors', 'down']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Apply correction to errors and covariance matrix. This uses two covariance; /// matrices, one with the weights, the other with squared weights, to obtain; /// the correct errors for weighted likelihood fits.; /// Applies the calculated covaraince matrix to the RooMinimizer and returns; /// the quality of the covariance matrix.; /// See also the documentation of RooAbsPdf::fitTo(), where this function is used.; /// \param[in] minimizer The RooMinimizer to get the fit result from. The state; /// of the minimizer will be altered by this function: the covariance; /// matrix caltulated here will be applied to it via; /// RooMinimizer::applyCovarianceMatrix().; /// \param[in] nll The NLL object that was used for the fit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx:106,error,errors,106,roofit/roofitcore/src/FitHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx,2,['error'],['errors']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Apply function to all the data points \f$ x = f(x,y) \f$.; ///; /// The error is calculated as \f$ ex=(f(x+ex,y)-f(x-ex,y))/2 \f$.; /// This is the same as \f$ error(fx) = df/dx * ex \f$ for small errors.; ///; /// For generic functions the symmetric errors might become non-symmetric; /// and are averaged here. Use TGraphAsymmErrors if desired.; ///; /// Error on \f$ y \f$ doesn't change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:158,error,error,158,hist/hist/src/TGraphErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx,5,"['Error', 'error']","['Error', 'error', 'errors']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Apply function to all the data points \f$ y = f(x,y) \f$.; ///; /// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; /// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; ///; /// For generic functions the symmetric errors might become non-symmetric; /// and are averaged here. Use TGraphAsymmErrors if desired.; ///; /// Error on \f$ x \f$ doesn't change.; ///; /// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:158,error,error,158,hist/hist/src/TGraphErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx,5,"['Error', 'error']","['Error', 'error', 'errors']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Apply results of given external covariance matrix. i.e. propagate its errors; /// to all RRV parameter representations and give this matrix instead of the; /// HESSE matrix at the next save() call",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx:156,error,errors,156,roofit/roofitcore/src/RooMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx,1,['error'],['errors']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Approximation of the log of the complex error function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooGExpModel.cxx:126,error,error,126,roofit/roofit/src/RooGExpModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooGExpModel.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Argument iClass specifies the class to generate the ROC curve in a; /// multiclass setting. It is ignored for binary classification.; ///; /// Returns a ROC graph for a given method, or nullptr on error.; ///; /// Note: Evaluation of the given method must have been run prior to ROC; /// generation through Factory::EvaluateAllMetods.; ///; /// NOTE: The ROC curve is 1 vs. all where the given class is considered signal; /// and the others considered background. This is ok in binary classification; /// but in in multi class classification, the ROC surface is an N dimensional; /// shape, where N is number of classes - 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx:283,error,error,283,tmva/tmva/src/Factory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Ask the master for the list of queries.; /// Options:; /// ""A"" show information about all the queries known to the; /// server, i.e. even those processed by other sessions; /// ""L"" show only information about queries locally available; /// i.e. already retrieved. If ""L"" is specified, ""A"" is; /// ignored.; /// ""F"" show all details available about queries; /// ""H"" print help menu; /// Default """"",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:311,avail,available,311,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['avail'],['available']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Ask the system fo the list of available printers and populate the combo; /// box. If there is a default printer, select it in the list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEditDialogs.cxx:116,avail,available,116,gui/gui/src/TGTextEditDialogs.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEditDialogs.cxx,1,['avail'],['available']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Askes all registered generators to fill their browsables into; /// the list. The browsables are generated for a given parent,; /// or (if 0), for a given branch. The branch is passed down to; /// leaves of TVirtualBranchBrowsable, too, as we need to access; /// the branch's TTree to be able to traw.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:269,down,down,269,tree/tree/src/TBranchBrowsable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx,1,['down'],['down']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Asks the PROOF Serv for new workers in Dynamic Startup mode and activates; /// them. Returns the number of new workers found, or <0 on errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:221,error,errors,221,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['error'],['errors']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Assert directory path 'dirpath', with the ownership of the last already; /// existing subpath.; /// Return 0 on success, -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofOutputFile.cxx:213,error,error,213,proof/proof/src/TProofOutputFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofOutputFile.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Assign given value to linear transformation: sets input variable to (value-offset)/slope; /// If slope is zerom an error message is printed and no assignment is made",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinearVar.cxx:201,error,error,201,roofit/roofitcore/src/RooLinearVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinearVar.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Associate given PDF with index category state label 'catLabel'.; /// The name state must be already defined in the index category.; ///; /// RooSimultaneous can function without having a PDF associated; /// with every single state. The normalization in such cases is taken; /// from the number of registered PDFs, but getVal() will fail if; /// called for an unregistered index state.; ///; /// PDFs may not overlap (i.e. share any variables) with the index category (function).; /// \param[in] pdf PDF to be added.; /// \param[in] catLabel Name of the category state to be associated to the PDF.; /// \return `true` in case of failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx:714,failure,failure,714,roofit/roofitcore/src/RooSimultaneous.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx,1,['failure'],['failure']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Attempt to recover file if not correctly closed; ///; /// The function returns the number of keys that have been recovered.; /// If no keys can be recovered, the file will be declared Zombie by; /// the calling function. This function is automatically called when; /// opening a file.; /// If the file is open in read only mode, the file is not modified.; /// If open in update mode and the function finds something to recover,; /// a new directory header is written to the file. When opening the file gain; /// no message from Recover will be reported.; /// If keys have been recovered, the file is usable and you can safely; /// read the corresponding objects.; /// If the file is not usable (a zombie), you can test for this case; /// with code like:; ///; /// ~~~{.cpp}; /// TFile f(""myfile.root"");; /// if (f.IsZombie()) {<actions to take if file is unusable>}; /// ~~~; ///; /// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; /// You can test if the file has been recovered with; ///; /// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; ///; /// When writing TTrees to a file, it is important to save the Tree header; /// at regular intervals (see TTree::AutoSave). If a file containing a Tree; /// is recovered, the last Tree header written to the file will be used.; /// In this case all the entries in all the branches written before writing; /// the header are valid entries.; /// One can disable the automatic recovery procedure by setting; ///; /// TFile.Recover 0; ///; /// in the <em>system.rootrc</em> file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:97,recover,recover,97,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,12,"['Recover', 'recover']","['Recover', 'recover', 'recovered', 'recovery']"
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Authentication related setup in TProofServ run after successful; /// startup. Provided for backward compatibility.; /// Return 0 on success, -1 on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:233,failure,failure,233,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['failure'],['failure']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Authentication related stuff setup in TProofServ.; /// This is the place where the buffer send by the client / master is; /// decoded. It contains also password information, if the case requires.; /// Return 0 on success, -1 on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:314,failure,failure,314,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['failure'],['failure']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Broadcast a character string buffer to all slaves in the specified; /// list (either all slaves or only the active slaves). Use kind to; /// set the TMessage what field. Returns the number of slaves the message; /// was sent to. Returns -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:337,error,error,337,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Broadcast a character string buffer to all slaves in the specified; /// list. Use kind to set the TMessage what field. Returns the number of; /// slaves the message was sent to. Returns -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:286,error,error,286,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Broadcast a character string buffer to the remote session.; /// Use kind to set the TMessage what field.; /// Returns 0 on success, -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:232,error,error,232,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Broadcast a message to all slaves in the specified list (either; /// all slaves or only the active slaves). Returns the number of slaves; /// the message was successfully sent to. Returns -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:288,error,error,288,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Broadcast a message to all slaves in the specified list. Returns; /// the number of slaves the message was successfully sent to.; /// Returns -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:242,error,error,242,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Broadcast a message to the remote session.; /// Returns 0 on success, -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:170,error,error,170,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Broadcast a raw buffer of specified length to all slaves in the; /// specified list. Returns the number of slaves the buffer was sent to.; /// Returns -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:251,error,error,251,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Broadcast a raw buffer of specified length to the remote session.; /// Returns 0 on success, -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:193,error,error,193,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Broadcast an object to all slaves in the specified list. Use kind to; /// set the TMEssage what field. Returns the number of slaves the message; /// was sent to. Returns -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:270,error,error,270,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Broadcast an object to the remote session.; /// Use kind to set the TMessage what field.; /// Returns 0 on success, -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:216,error,error,216,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Broadcast file to all workers in the specified list. Returns the number of workers; /// the buffer was sent to.; /// Returns -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:225,error,error,225,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Broadcast the group priority to all workers in the specified list. Returns; /// the number of workers the message was successfully sent to.; /// Returns -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:253,error,error,253,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Browse the tree of nodes starting from top node according to pathname.; /// Changes the path accordingly. The path is changed to point to the top node; /// in case of failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:253,failure,failure,253,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['failure'],['failure']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Build a Tree Index (default is TTreeIndex).; /// See a description of the parameters and functionality in; /// TTreeIndex::TTreeIndex().; ///; /// The return value is the number of entries in the Index (< 0 indicates failure).; ///; /// A TTreeIndex object pointed by fTreeIndex is created.; /// This object will be automatically deleted by the TTree destructor.; /// If an index is already existing, this is replaced by the new one without being; /// deleted. This behaviour prevents the deletion of a previously external index; /// assigned to the TTree via the TTree::SetTreeIndex() method.; /// \see also comments in TTree::SetTreeIndex().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:303,failure,failure,303,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['failure'],['failure']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Build specified package. Executes the PROOF-INF/BUILD.sh; /// script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; /// then submit build command to slaves, but don't wait; /// for results. If opt is kCollectBuildResults then collect result; /// from slaves. To be used on the master.; /// If opt = kBuildAll (default) then submit and wait for results; /// (to be used on the client).; /// Returns 0 in case of success and -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:542,error,error,542,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; /// Build the list of styles which will appear in the available styles; /// combo box. The new style to select is mentioned. If no style has; /// been specified, the last entry of the list is selected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:136,avail,available,136,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['avail'],['available']
