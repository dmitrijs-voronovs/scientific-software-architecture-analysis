quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Modifiability,"ian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val)¶; Sets scalar or array QCVariable key to val on self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float]) – Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError – If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:23923,variab,variable,23923,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"ian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val)¶; Sets scalar or array QCVariable key to val on self.; :rtype: None. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float]) – Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError – If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:24103,variab,variable,24103,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"ian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val)¶; Sets scalar or array QCVariable key to; val on self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float]) – Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError – If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:23770,variab,variable,23770,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,4,['variab'],['variable']
Modifiability,"ian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dlpno(arg0); Runs the DLPNO codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B[, transA, transB]); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. dummy_einsums(ref_wfn); Runs the einsums placeholder code. dummy_integratorxx(ref_wfn); Runs the integratorxx placeholder code. fcidump_tei_helper(nirrep, restricted, ...); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). get_array_variables(). get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:4314,config,configuration,4314,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,1,['config'],['configuration']
Modifiability,"ian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dlpno(arg0); Runs the DLPNO codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B[, transA, transB]); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. dummy_einsums(ref_wfn); Runs the einsums placeholder code. fcidump_tei_helper(nirrep, restricted, ...); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). Deprecated since version 1.4. get_array_variables(). Deprecated since version 1.4. get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-modul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:4307,config,configuration,4307,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,1,['config'],['configuration']
Modifiability,"ian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dlpno(arg0); Runs the DLPNO codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B[, transA, transB]); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, ...); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). Deprecated since version 1.4. get_array_variables(). Deprecated since version 1.4. get_atomic_point_charges(). Deprecated since version 1.4. get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-module",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:4369,config,configuration,4369,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['config'],['configuration']
Modifiability,"ian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dlpno(arg0); Runs the DLPNO codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B[, transA, transB]); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, ...); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). Deprecated since version 1.4. get_array_variables(). Deprecated since version 1.4. get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-module) scope. get_global_option_list(); Returns a list of all g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:4305,config,configuration,4305,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,2,['config'],['configuration']
Modifiability,"ian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been set in global memory. close_outfile(); Closes the output file. dct(ref_wfn); Runs the density cumulant (functional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B, transA, transB); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). Deprecated since version 1.4. get_array_variables(). Deprecated since version 1.4. get_atomic_point_charges(). Deprecated since version 1.4. get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-module) scope. get_global_option_list(); Retu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:4321,config,configuration,4321,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['config'],['configuration']
Modifiability,"ianShellE {lvalue},i); | ; | is_cartesian(...); | is_cartesian( (GaussianShell)arg1) -> bool :; | docstring; | ; | C++ signature :; | b is_cartesian(N3psi13GaussianShellE {lvalue}); | ; | is_pure(...); | is_pure( (GaussianShell)arg1) -> bool :; | docstring; | ; | C++ signature :; | b is_pure(N3psi13GaussianShellE {lvalue}); | ; | original_coef(...); | original_coef( (GaussianShell)arg1, (int)arg2) -> float :; | docstring; | ; | C++ signature :; | d original_coef(N3psi13GaussianShellE {lvalue},i); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | AMCHAR; | docstring; | ; | am; | docstring; | ; | amchar; | docstring; | ; | function_index; | Basis function index where this shell starts.; | ; | ncartesian; | docstring; | ; | ncenter; | docstring; | ; | nfunction; | docstring; | ; | nprimitive; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GeometryUnits(Boost.Python.enum); | docstring; | ; | Method resolution order:; | GeometryUnits; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Angstrom = psi4.GeometryUnits.Angstrom; | ; | Bohr = psi4.GeometryUnits.Bohr; | ; | names = {'Angstrom': psi4.GeometryUnits.Angstrom, 'Bohr': psi4.Geometr...; | ; | values = {0: psi4.GeometryUnits.Angstrom,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:473131,inherit,inherited,473131,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ibMints library to generate and print SO basis (with symmetry) integrals. Creating a New Plugin Using a Conda Pre-compiled Binary¶; Psi4 plugins can also be created using Conda for both Psi4 binary and; development environment.; To compile a plugin with the default Makefile, it is necessary to have the; gcc compiler installed in the Conda distribution or environment (below,; $PSI4CONDA) used to run Psi4.; # prepare; >>> bash; >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; >>> conda install gcc # install compilers into expected place. # check (yes, next line gives empty result. yes, LD_LIBRARY_PATH irrelevant); >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 gcc; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc. # create and compile plugin; >>> psi4 --new-plugin testplugin # generate new plugin; >>> cd testplugin # move into plugin directory; >>> make # compile the plugin to product testplugin.so; >>> psi4 # run sample input.dat; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; Psi4 code is not necessary.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:4862,plugin,plugin,4862,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,10,['plugin'],['plugin']
Modifiability,"ic License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .constants import constants; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]; class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):; """"""Initialize Molecule object from LibmintsMolecule""""""; super(Molecule, self).__init__(). if molinit is not None or geom is not None:; if isinstance(molinit, dict):; molrec = molinit. elif isinstance(molinit, str):; compound_molrec = qcel.molparse.from_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html:1844,extend,extends,1844,psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,4,['extend'],['extends']
Modifiability,"ic locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed. Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. Alternately, the scratch directory can be set through the environment; variable PSI_SCRATCH (overrides ~/.psi4rc settings).; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and Boost; Threads for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled PSI4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:3690,variab,variable,3690,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,2,['variab'],['variable']
Modifiability,"ical derivatives of the static polarizability tensor, while DYN (=2) requests a calculation of Raman intensities based on the derivatives of the dynamical polarizability tensor. Type: string; Possible Values: ON, DYN, OFF; Default: OFF. CFOUR_RAMAN_ORB (CFOUR); CFOUR — Specifies whether Raman intensities are calculated with orbital relaxation with respect to the electric field perturbation (RELAXED, = 1) or without orbital relaxation (UNRELAXED, = 0). Type: string; Possible Values: RELAXED, UNRELAXED; Default: UNRELAXED. CFOUR_RDO (CFOUR); CFOUR — Specifies whether or not relaxed density natural orbitals are to be computed. This option only has meaning for a correlated calculation. For =0, Do not compute. For =1, compute. Type: boolean; Default: true. CFOUR_REFERENCE (CFOUR); CFOUR — Specifies the type of SCF calculation to be performed. RHF (= 0) requests a restricted Hartree-Fock reference; UHF (= 1) an unrestricted Hartree-Fock reference; ROHF (= 2) a restricted open-shell Hartree-Fock calculation; TCSCF (=3) a two-configurational SCF calculation, and CASSCF (=4) a complete-active space SCF calculations (currently not implemented). Psi4 Interface: Keyword subject to translation from value of REFERENCE unless set explicitly. Type: string; Possible Values: RHF, UHF, ROHF, TCSCF, CASSCF; Default: RHF. CFOUR_RELATIVISTIC (CFOUR); CFOUR — Specifies the treatment of relativistic effects. The default is a non-relativistic treatment (OFF), while perturbational treatments are invoked via MVD1 (mass-velocity and 1-electron Darwin conribution), MVD2 (mass-velocity and 1- and 2-electron Darwin contribution), DPT2 (second-order direct perturbation theory approach), SF-DPT4 (scalar-relativistic part of fourth-order direct perturbation theory, DPT4 (full fourth-order DPT including spin-orbit corrections), SF-DPT6 (scalar-relativistic part of sixth-order direct perturbation theory), SFREE (spin-free treatment), X2C1E (spin-free X2C-1e treatment), or DPT (synonym with DPT2). Type:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:70114,config,configurational,70114,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['config'],['configurational']
Modifiability,"ical derivatives of the static polarizability tensor, while DYN (=2) requests a calculation of Raman intensities based on the derivatives of the dynamical polarizability tensor. Type: string; Possible Values: ON, DYN, OFF; Default: OFF. CFOUR_RAMAN_ORB (CFOUR); CFOUR — Specifies whether Raman intensities are calculated with orbital relaxation with respect to the electric field perturbation (RELAXED, = 1) or without orbital relaxation (UNRELAXED, = 0). Type: string; Possible Values: RELAXED, UNRELAXED; Default: UNRELAXED. CFOUR_RDO (CFOUR); CFOUR — Specifies whether or not relaxed density natural orbitals are to be computed. This option only has meaning for a correlated calculation. For =0, Do not compute. For =1, compute. Type: boolean; Default: true. CFOUR_REFERENCE (CFOUR); CFOUR — Specifies the type of SCF calculation to be performed. RHF (= 0) requests a restricted Hartree-Fock reference; UHF (= 1) an unrestricted Hartree-Fock reference; ROHF (= 2) a restricted open-shell Hartree-Fock calculation; TCSCF (=3) a two-configurational SCF calculation, and CASSCF (=4) a complete-active space SCF calculations (currently not implemented). Psi4 Interface: Keyword subject to translation from value of REFERENCE unless set explicitly. Type: string; Possible Values: RHF, UHF, ROHF, TCSCF, CASSCF; Default: RHF. CFOUR_RELATIVISTIC (CFOUR); CFOUR — Specifies the treatment of relativistic effects. The default is a non-relativistic treatment (OFF), while perturbational treatments are invoked via MVD1 (mass-velocity and 1-electron Darwin contribution), MVD2 (mass-velocity and 1- and 2-electron Darwin contribution), DPT2 (second-order direct perturbation theory approach), SF-DPT4 (scalar-relativistic part of fourth-order direct perturbation theory, DPT4 (full fourth-order DPT including spin-orbit corrections), SF-DPT6 (scalar-relativistic part of sixth-order direct perturbation theory), SFREE (spin-free treatment), X2C1E (spin-free X2C-1e treatment), or DPT (synonym with DPT2). Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:70535,config,configurational,70535,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['config'],['configurational']
Modifiability,"icense for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import re; import os; import math; import warnings; import pickle; import copy; import collections; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments('');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:1716,variab,variable,1716,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['variab'],['variable']
Modifiability,"icient for MP2 correlation, by default none; ""ss"": 0.0, coefficient for same spin correlation in SCS methods, forces alpha = 1.0; ""os"": 0.0, coefficient for opposite spin correlation in SCS methods, forces alpha = 1.0; },. ""dispersion"": { definition of dispersion corrections; ""type"": """", dispersion type - ""d2"", ""d3zero"", ""d3bj"" etc., see empirical_dispersion.py; ""params"": {}, parameters for the dispersion correction; ""nlc"": False (optional) logical switch to turn off nlc (e.g. VV10) correction defined by LibXC; ""citation"": """", special reference for the dispersion correction parameters, appended to output. One can also use the dft_functional keyword argument to use the; orbitals generated by DFT for correlated wavefunction methods:; # MP2 with a PBE0 reference computation. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis 6-31G; dft_spherical_points 302; dft_radial_points 99; reference rks; }. mp2_dft = energy(""MP2"", dft_functional=""PBE0""). Note that this would only update the generic Psi variables (e.g., “CURRENT ENERGY”) and not the MP2 or DFT variables.; Psi4 also supports easy customization and manipulation of DFT functionals. The values of alpha and omega can be adjusted with the DFT_ALPHA; and DFT_OMEGA keywords. For example, for LRC functionals, one can control the fraction of long-range Hartree-Fock and short-range DFA by changing DFT_OMEGA:; molecule ch2 {; 0 3; C; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set reference uhf; set guess gwh; set basis cc-pvdz; set e_convergence 8. # Override the default value of omega; set dft_omega 2.0. E = energy('wb97x'). # Revoke the change for later computations if needed; revoke_global_option_changed('DFT_OMEGA'). This feature would be useful after finishing the IP fitting procedure, for example. table of contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Correct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:33042,variab,variables,33042,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['variab'],['variables']
Modifiability,"icipated with INTEGRAL_PACKAGE erd, PSI4 will; throw an error if you try to execute that class of computation. But; there may be more, so use with caution. Warning; erd seems to be having some problems with Intel 2018 compilers. presently disabled in conda package. Installation¶; Binary. ERD is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; erd can be obtained through conda install erd -c psi4.; Then enable it as a feature with ENABLE_erd,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect erd and activate dependent code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/erd-1.html:1872,config,configure,1872,psi4manual/1.4.0/erd-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/erd-1.html,8,['config'],['configure']
Modifiability,"icity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:4554,variab,variable,4554,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,15,['variab'],['variable']
Modifiability,"iconda has; already been installed (instructions at Quick Installation),; erd can be obtained through conda install erd -c psi4.; Then enable it as a feature with ENABLE_erd,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect erd and activate dependent code.; Previous bullet had details. To build PSI4 from source and use; erd from conda without thinking, consult sec:condapsi4dev.; To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/erd-1.html:2230,variab,variable,2230,psi4manual/1.2.1/erd-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/erd-1.html,8,['variab'],['variable']
Modifiability,"ict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GaussianShell(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GaussianShell; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | coef(...); | coef( (GaussianShell)arg1, (int)arg2) -> float :; | docstring; | ; | exp(...); | exp( (GaussianShell)arg1, (int)arg2) -> float :; | Returns the exponent of the given primitive; | ; | is_cartesian(...); | is_cartesian( (GaussianShell)arg1) -> bool :; | docstring; | ; | is_pure(...); | is_pure( (GaussianShell)arg1) -> bool :; | docstring; | ; | normalize_shell(...); | normalize_shell( (GaussianShell)arg1) -> None :; | docstring; | ; | --------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:50171,inherit,inherited,50171,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_basis_fun(...); | add_basis_fun( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | add_beta_mo(...); | add_beta_mo( (GridProp)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | build_grid_overages(...); | build_grid_overages( (GridProp)arg1, (float)arg2) -> No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:24618,inherit,inherited,24618,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"ides libefp with QM fragment information; | ; | C++ signature :; | void set_qm_atoms(N3psi3efp3EFPE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ERI(TwoElectronInt); | docstring; | ; | Method resolution order:; | ERI; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | -----------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:442156,inherit,inherited,442156,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ids happens in the; intrinsic atomic orbital space (as opposed to the SAO1 method where the standard atomic orbital space is used), with; one iteration of fragment orbital optimization and link orbital orthogonalization, a process that very quickly; achieves self-consistency. Altogether, the allowed values for FISAPT_LINK_ASSIGNMENT are c (default),; ab (the opposite of c where the entire linking pair is assigned to A/B), sao0, sao1, sao2,; siao0, siao1 (recommended for all I-SAPT applications), and siao2 (essentially identical to siao1 but; slightly more expensive). Advanced I-SAPT Keywords for SAOn/SIAOn Partitionings¶. FISAPT_LINK_ORTHO¶. Orthogonalization of link orbitals for FISAPT_LINK_ASSIGNMENT=SAOx/SIAOx Link A orthogonalized to A in whole (interacting) molecule or in the (noninteracting) fragment?. Type: string; Possible Values: FRAGMENT, WHOLE, NONE; Default: FRAGMENT. FISAPT_EXCH_PARPERP¶. Calculate separate exchange corrections for parallel and perpendicular spin coupling of link orbitals? When false, only the averaged out exchange corrections are computed. Type: boolean; Default: false. FISAPT_CUBE_LINKIBOS¶. Generate cube files for unsplit link orbitals (IBOs)?. Type: boolean; Default: false. FISAPT_CUBE_LINKIHOS¶. Generate cube files for split link orbitals (IHOs)?. Type: boolean; Default: false. FISAPT_CUBE_DENSMAT¶. Generate cube files for fragment density matrices?. Type: boolean; Default: false. Other F/I-SAPT Keywords¶; The input files described above cover roughly 90% of all F/I-SAPT analyses. For; more delicate or involved problems, there are a large number of user options; that permit the customization of the I-SAPT subsystem partition, the convergence; of the IBO localization procedure, numerical thresholds, etc. We have an entire; video tutorial devoted to F/I-SAPT Options .; Direct source-code documentation on these options is available here. Additional Notes¶. Caution; In constrast to Ed Hohenstein’s SAPT0 code, FISAPT uses the -JKFIT; au",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/fisapt.html:15720,coupling,coupling,15720,psi4manual/1.8.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/fisapt.html,3,['coupling'],['coupling']
Modifiability,"ied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. tpdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool) → None¶; docstring. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:29341,variab,variables,29341,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,5,['variab'],['variables']
Modifiability,"ield strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefunction) – Wavefunction instance.; filenumber (int) – Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key)¶; Whether scalar or array QCVariable key; has been set on self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction) → psi4.core.MintsHelper¶; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. module(self: psi4.core.Wavefunction) → str¶; Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunction’s molecule. nalpha(self: psi4.core.Wavefunction) → int¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:18424,variab,variable,18424,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,4,['variab'],['variable']
Modifiability,"ientHessianWfnReturn"",; ]. import abc; import copy; import logging; from typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import qcelemental as qcel; from qcelemental.models import AtomicInput, AtomicResult, DriverEnum; from qcelemental.models.results import AtomicResultProtocols; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core. from . import p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html:2158,Config,Config,2158,psi4manual/1.9.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html,2,['Config'],['Config']
Modifiability,"ier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; How to get high angular momentum integrals from conda. Configuring, Building, and Installing PSI4 via Source¶. Planning: how to configure Psi4 and invoke CMake; How to build and install Psi4, the compact version; How to build, test, and install Psi4, in detail; How to see what build configuration options are available; How to choose the compilation directory, {objdir}; How to install elsewhere than /usr/local/psi4; How to use conda to get a Psi4 development environment; How to configure code to use high angular momentum basis sets; How to see the actual compiling commands (or errors) with cmake; How to save configuration settings for a future compilation; How to configure a Psi4 build on Cray. Non-QC Dependencies¶. What are the tools and dependencies strictly required for building Psi4; How to configure Python for building Psi4; How to handle “runtime library may be hidden” when building with Anaconda Python; How to configure BLAS/LAPACK for building Psi4; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew. QC Dependencies and Extensions¶. What are the add-on capabilities for Psi4 and what are their dependencies; How to use a local Add-On repository in the Psi4 build; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_faq-1.html:1657,config,configure,1657,psi4manual/1.4.0/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_faq-1.html,24,['config'],['configure']
Modifiability,"ier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; How to get high angular momentum integrals from conda. Configuring, Building, and Installing PSI4 via Source¶. Planning: how to configure Psi4 and invoke CMake; How to build and install Psi4, the compact version; How to build, test, and install Psi4, in detail; How to see what build configuration options are available; How to choose the compilation directory, {objdir}; How to install elsewhere than /usr/local/psi4; How to use conda to get a Psi4 development environment; How to configure code to use high angular momentum basis sets; How to see the actual compiling commands (or errors) with cmake; How to save configuration settings for a future compilation; How to configure a Psi4 build on Cray. Non-QC Dependencies¶. What are the tools and dependencies strictly required for building Psi4; How to configure Python for building Psi4; How to handle “runtime library may be hidden” when building with Anaconda Python; How to configure BLAS/LAPACK for building Psi4; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew. QC Dependencies and Extensions¶. What are the add-on capabilities for Psi4 and what are their dependencies; How to use a local Add-On repository in the Psi4 build; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_faq.html:1950,config,configure,1950,psi4manual/master/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/master/build_faq.html,3,['config'],['configure']
Modifiability,"ies of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Implementation inside adcc,; the ADC backend used for most ADC methods available in PSI4. “adcc: A versatile toolkit for rapid development of; algebraic-diagrammatic construction methods,”; M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.; WIREs Comput. Mol. Sci., (2020).; (DOI: 10.1002/wcms.1462, Preprint https://adc-connect.org/q/publications. “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and the implementation for ADC(2) excitation energies within PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-source spin-adapted implementation of the density; matrix renormalization group for ab initio quantum chemistry,”; S. Wouters, W. Poelmans, P. W. Ayers and D. Van Neck,; Comput. Phys. Commun. 185 (6), 1501-1514 (2014).; (doi: 10.1016/j.cpc.2014.01.019).; “The density matrix renormalization group for ab initio quantum chemistry,”; S. Wouters and D. Van Neck, Eur. Phys. J. D 68 (9), 272 (2014).; (doi: 10.1140/epjd/e2014-50500-1). Scalar Relativistic Corrections¶; General theory for the exact two-component approach (X2C). “Analytic energy gradients for the spin-free exact two-component theory; using an exact block diagonalization for the one-electron Dirac; Hamiltonian,”; L. Cheng and J. Gauss, J. Chem. Phys. 135, 084114 (2011).; (doi: 10.1063/1.3624397). Implementation within Psi4. “Predicting Near Edge X-ray Absorption Spectra with the Spin-Free; Exact-Two-Component Hamiltonian and Orthogonality Constrained Density; Functional Theory,”; P. Verma, W. D. Derricotte and F. A. Evangelista,; J. Chem. Theory Comput. (2015).; (doi: 10.1021",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/introduction-1.html:20824,adapt,adapted,20824,psi4manual/1.4.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/introduction-1.html,5,['adapt'],['adapted']
Modifiability,"ies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn, hess=None, irrep=None, molecule=None, project_trans=True, project_rot=True):; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn : :py:class:`~psi4.core.Wavefunction`; The wavefunction which had its Hessian computed.; hess : ndarray of float, optional; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep : int or string; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:73466,variab,variable,73466,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['variab'],['variable']
Modifiability,"ies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self); Get dict of converged T amplitudes. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:4421,variab,variable,4421,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variable']
Modifiability,"ies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:69818,variab,variables,69818,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}; /psi/install/directory/bin/psi4 -i input.in -o input.out -n 4. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. The top section features PBS-specific commands. These depend on the; specific characteristics of your PBS queuing system but they may include:; #!/bin/tcsh; #PBS -j oe; #PBS -l pmem=2120mb; #PBS -N jobname; #PBS -V. The PBS -j oe option instructs PBS to write any output or error message; from the queuing system in dedicated files. PBS -l pmem=2120mb requests; 2120 MB of memory for each thread on the node. The total memory requested for; the job by PBS should generally be slightly greater than what indicated; in the input file (see memory setting).; Then, we move to the working directory using PBS variable $PBS_O_WORKDIR and; we create scratch directories on every node, using the $PBS_NODEFILE which; points to a file containing a list of the nodes attributed to the job.; cd $PBS_O_WORKDIR; setenv myscratch /scratch/user/psi4.$PBS_JOBID. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Creating scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ssh $i mkdir -p $myscratch; end. The next section is very important as it sets the environment variables needed; by PSI4:; unsetenv PSIDATADIR; setenv PSI_SCRATCH $myscratch; if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}. PSIDATADIR does not need to be set.; In the present example we unset it to make sure it does not interfere with the internal location-finding.; PSIPATH is needed only if you are using external modules or; plugins in PSI4 and should point to the directories where they can be found. In the; present example, we make sure the variable is set with if ! ( $?PSIPATH ) setenv PSIPAT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:15870,variab,variable,15870,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['variab'],['variable']
Modifiability,"if Fortran active ...; -DCMAKE_Fortran_COMPILER=icpc \; -DCMAKE_Fortran_FLAGS=""-gcc-name=${GCC5}/bin/gcc -gxx-name=${GCC5}/bin/g++"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC5}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables CRAYPE_LINK_TYPE; and CRAY_ADD_RPATH before running cmake.; 1CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies; PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubuntu gfortran; conda gcc or gcc-5 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gcc conda package. This provides gcc, g++, and; gfortran compilers for Mac. The two former are 4.8.5 and so are too; old to compile PSI4, but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and effici",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:29238,variab,variable,29238,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['variab'],['variable']
Modifiability,"if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:132326,variab,variables,132326,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,12,['variab'],['variables']
Modifiability,"if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name == 'mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'fno-mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:124596,variab,variable,124596,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"if db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""core.print_variables()\n""""""); freagent.write(""""""core.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""core.set_variable('NATOM', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""core.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (core.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:22708,variab,variable,22708,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,2,['variab'],['variable']
Modifiability,"if db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""core.print_variables()\n""""""); freagent.write(""""""core.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""core.set_variable('NATOM', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""core.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (core.variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] !=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:22619,variab,variable,22619,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['variab'],['variable']
Modifiability,"if db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:22582,variab,variable,22582,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['variab'],['variable']
Modifiability,"if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:76705,variab,variables,76705,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variables']
Modifiability,"if not np_out:; validated_molrec = unnp(validated_molrec). return validated_molrec. @classmethod; def from_dict(cls, molrec, verbose=1):. mol = cls(); mol._internal_from_dict(molrec=molrec, verbose=verbose); return mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat],; Z, label, molrec['elea'][iat]); for var in molrec['variables']:; self.set_geometry_variable(var[0], var[1]). else:; geom = np.array(molrec['geom']).reshape((-1, 3)); nat = geom.shape[0]; unsettled = False. for iat in range(nat):; x, y, z = geom[iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_atom(Z, x, y, z, molrec['elem'][iat], molrec['mass'][iat],; Z, label, molrec['elea'][iat]); # TODO charge and 2nd elez site; # TODO real back to type Ghost?. # apparently py- and c- sides settled on a diff convention of 2nd of pair in fragments_; fragment_separators = np.array(molrec['fragment_separators'], dtype=np.int); fragment_separators = np.insert(fragment_separators, 0, 0); fragment_separators = np.append(fragment_separators, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments,; ['Real'] * len(fragments),; [int(f) for f in molrec['fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:51690,variab,variables,51690,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['variab'],['variables']
Modifiability,"ifference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:81242,variab,variables,81242,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['variab'],['variables']
Modifiability,"ifference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""CURRENT HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:81939,variab,variables,81939,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,2,['variab'],['variables']
Modifiability,"ific notes; VI. Common Problems with PSI Compilation. Scratch Files and the ~/.psi4rc File¶; One very important part of user configuration at the end of the; installation process (details here); is to tell PSI4 where to write its temporary; (“scratch”) files. Electronic structure packages like PSI4 can; create rather large temporary disk files. It is very important to; ensure that PSI4 is writing its temporary files to a disk drive; phsyically attached to the computer running the computation. If it; is not, it will significantly slow down the program and the network.; By default, PSI4 will write temporary files to /tmp, but this; directory is often not large enough for typical computations. Therefore,; you need to (a) make sure there is a sufficiently large directory on a; locally attached disk drive (100GB–1TB or more, depending on the size of; the molecules to be studied) and (b) tell PSI4 the path to this; directory. Scratch file location can be specified through the; PSI_SCRATCH environment variable or, more flexibly, through; a resource file, ~/.psi4rc (example psi4/samples/example_psi4rc_file).; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. The primary use of the ~/.psi4rc file is to control the; handling of scratch files. PSI4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are sequentially; numbered and are written to /tmp, then deleted at the end of the computation,; unless otherwise instructed by the user.; A Python callable handle to the PSI4 I/O management routines is available,; an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:1936,variab,variable,1936,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['variab'],['variable']
Modifiability,"ific notes; VI. Common Problems with PSI Compilation. Scratch Files and the ~/.psi4rc File¶; One very important part of user configuration at the end of the; installation process (details here); is to tell PSI4 where to write its temporary; (“scratch”) files. Electronic structure packages like PSI4 can; create rather large temporary disk files. It is very important to; ensure that PSI4 is writing its temporary files to a disk drive; phsyically attached to the computer running the computation. If it; is not, it will significantly slow down the program and the network.; By default, PSI4 will write temporary files to /tmp, but this; directory is often not large enough for typical computations. Therefore,; you need to (a) make sure there is a sufficiently large directory on a; locally attached disk drive (100GB–1TB or more, depending on the size of; the molecules to be studied) and (b) tell PSI4 the path to this; directory. Scratch file location can be specified through the; PSI_SCRATCH environment variable or, more flexibly, through; a resource file, ~/.psi4rc (example psi4/samples/example_psi4rc_file).; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. The primary use of the ~/.psi4rc file is to control the; handling of scratch files. PSI4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are written to the; designated scratch numbered by content and labeled; with the process id, then are deleted at the end of the computation,; unless otherwise instructed by the user.; A Python callable handle to the P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/external-1.html:1875,variab,variable,1875,psi4manual/4.0b4/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/external-1.html,4,['variab'],['variable']
Modifiability,"ified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the modul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:247224,plugin,plugins,247224,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['plugin'],['plugins']
Modifiability,"ified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:104245,variab,variables,104245,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,14,['variab'],['variables']
Modifiability,"ifort compilers backed by conda's psi4-dev-provided gcc/g++ PLUS compile for multiple architectures (useful for cluster deployments).; --gcc Engage conda's psi4-dev-provided gcc/g++/gfortran compilers. # execute or adapt `cmake` commands above; DepsCache handles python & addons;; # DepsMKLCache handles math; further psi4-path-advisor options handle compilers.; >>> `psi4-path-advisor [your args]` -Dany_addl_cmake_vals=ON; >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`; >>> make install. Same for Linux/Mac/WSL. Substitute desired python version: 3.6, 3.7, 3.8, 3.9. Fine; to choose your own env name. Include -c psi4/label/dev to get dependencies to; build current master, as opposed to latest release.; Activate environment, conda activate; p4dev. Go to where you’ve cloned psi4. Execute psi4-path-advisor.; It gives you a basic cmake command covering python, sphinx, link-time qc; addons, and run-time qc addons. There’s a help menu -h that gives more; info. There’s other options that will also pre-configure compilers. For; example, at GaTech psi4-path-advisor --intel works. On Macs with; XCode, psi4-path-advisor --clang works. Just read the help. For users; who want a minimal build, there’s a --disable-addons, but it is generally not; encouraged. It gives you a fully; functional cmake command, but those are just setting up CMake cache; — like the plugins you can always add your own CMake variables to; the command.; For run-time, you may also wish to install the optional runtime add-ons (e.g., adcc); >>> conda install psi4-rt. What do the conda packages psi4 & psi4-dev and the installer psi4conda contain¶; psi4 - has full-featured psi4 itself and necessarily all the link-time qc; addons (e.g., chemps2). It has python, pytest, numpy, and a few more python; modules for specialized functions. Of gcc-ness, it has minimal, run-time; libraries (e.g., libgcc-ng) not compilers.; It doesn’t have the run-time qc addons psi4-rt (e.g., snsmp2) or build tools (e.g., g++, sphinx, cm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/conda-1.html:10103,config,configure,10103,psi4manual/1.4.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/conda-1.html,9,['config'],['configure']
Modifiability,"ighly correlated CI wavefunctions that can be helpful in more; challenging cases such as highly strained molecules or bond breaking reactions. The CI; code is based on the fast, determinant-based string formalism; of Handy [Handy:1980]. It can solve for restricted active space; configuration interaction (RAS CI) wavefunctions as described by Olsen,; Roos, Jorgensen, and Aa. Jensen [Olsen:1988]. Excitation-class; selected multi-reference CI wavefunctions, such as second-order CI,; can be formulated as RAS CI’s. A RAS CI selects determinants for the; model space as those which have no more than \(n\) holes in the lowest set; of orbitals (called RAS I) and no more than \(m\) electrons in the highest; set of orbitals (called RAS III). An intermediate set of orbitals, if; present (RAS II), has no restrictions placed upon it. All determinants; satisfying these rules are included in the RAS CI.; The DETCI module is also very efficient at computing full configuration; interaction; wavefunctions, and it is used in this capacity in the complete-active-space; self-consistent-field (CASSCF) code. It can also perform approximate; CASSCF computations in which one uses RAS restrictions on the CI excitations,; rather than doing a full CI in the active space. This is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in MCSCF: Multi-Configurational Self-Consistent-Field.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:3360,config,configuration,3360,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,9,['config'],['configuration']
Modifiability,"iginally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:5507,plugin,plugin,5507,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,8,['plugin'],['plugin']
Modifiability,"ignature :; | N3psi17SymmetryOperationE transform(N3psi17SymmetryOperationE {lvalue},N3psi17SymmetryOperationE); | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | Performs transposition of matrix operation; | ; | C++ signature :; | void transpose(N3psi17SymmetryOperationE {lvalue}); | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | Set equal to a unit matrix; | ; | C++ signature :; | void unit(N3psi17SymmetryOperationE {lvalue}); | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | Zero out the symmetry operation; | ; | C++ signature :; | void zero(N3psi17SymmetryOperationE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ThreeCenterOverlapInt(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ThreeCenterOverlapInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | compute_shell(...); | compute_shell( (ThreeCenterOverlapInt)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi21ThreeCenterOverlapIntE {lvalue},i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (ThreeCenterOverlapInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi21ThreeCenterOverlapIntE {lvalue},b); | ; | ---------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:631475,inherit,inherited,631475,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ignature :; | i dim(N3psi9IntVectorE {lvalue},i); | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | C++ signature :; | i get(N3psi9IntVectorE {lvalue},i,i); | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | C++ signature :; | i nirrep(N3psi9IntVectorE {lvalue}); | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi9IntVectorE {lvalue}); | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | C++ signature :; | void set(N3psi9IntVectorE {lvalue},i,i,i); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntegralFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntegralFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (BasisSet)arg2, (BasisSet)arg3, (BasisSet)arg4, (BasisSet)arg5) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi8BasisSetEEE); | ; | __init__( (object)arg1, (BasisSet)arg2 [, (BasisSet)arg3]) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi8BasisSetEEE [,N5boost10shared_ptrIN3psi8BasisSetEEE]); | ; | __reduce__ = <unnamed Boost.Python",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:496624,inherit,inherited,496624,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ilable from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/libefp.html:8466,config,configdir,8466,psi4manual/1.6.x/libefp.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html,2,['config'],"['configdir', 'configure']"
Modifiability,"ild PSI4 to detect simint and activate dependent code. Previous bullet had details. To build PSI4 from source and use; simint from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove simint. Source. If using PSI4 built from source and you want simint built from; from source also,; enable it as a feature with ENABLE_simint,; and let the build system fetch and build it and activate dependent code. How to configure simint for building Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_simint — CMake variable to force detecting pre-built simint and not falling back on internal build; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Examples. Build bundled. >>> cmake -DENABLE_simint=ON. Build without simint. >>> cmake. Link against pre-built. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dep",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/simint-1.html:2333,variab,variable,2333,psi4manual/1.2.1/simint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/simint-1.html,4,['variab'],['variable']
Modifiability,"ile H$_2$O and LaTeX tables; are not translated correctly. Python docstrings are absorbed as-is, so; please use reST math formatting (essentially $latex math$ \(\Rightarrow\); :math:`latex math`).; Starting around PSI4 1.1, MathJax is used for in-browser LaTeX; rendering in place of offline PNG generation of math images. Check the; online rendering, as occasionally there will be errors even when the LaTeX; looked sound. The Map of the Sphinx¶. Adding a new Appendix or First-TOC-Level page; Create your reST file and fill it with information. Add the name of your; file to psi4/doc/sphinxman/source/appendices.rst for an appendix or; to psi4/doc/sphinxman/source/index.rst for a first-TOC-level.; Finally, add your file to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your; new page. Adding a new module to “Theoretical Methods”; Copy the file of a well-established module, like; psi4/doc/sphinxman/source/sapt.rst. Change the title, author, sec; label, ref, and source labels at the top of the file to point instead to; your code. Edit psi4/doc/sphinxman/source/methods.rst to add the; name of your file so that it will appear in the TOC tree. Add your file; to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your new; file. Follow the models in existing methods pages to write your; documentation. If you don’t get all the keyword links, bibliography; links, sample inputs, math, tables, etc. working in Sphinx, don’t worry; about it. A genie will probably come through and tidy up all your; source. table of contents. Documentation; Installing Sphinx; Documentation Structure; reStructuredText; Math in the Codebase; The Map of the Sphinx. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/documentation-1.html:6192,variab,variable,6192,psi4manual/1.2.1/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/documentation-1.html,2,['variab'],['variable']
Modifiability,"ile itself, input.dat. The input file should be just a simple input file to run the test, with small additions.; #! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxiliary basis.; #! Also a bit more to force a second line. nucenergy = 8.801466202085710 #TEST; refenergy = -76.05098402733282 #TEST. molecule h2o {; symmetry c1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pVTZ; scf_type df; df_basis_scf cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy(""hf""). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, get_variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be descriptive since it is inlined into the manual (unless !nosample in the comment) as a sample input.; The reference values are assigned to variables for later use. The compare_values function (along with several relatives in psi4/psi4/driver/p4util/testing.py for comparing strings, matrices, etc.) checks that the computed values match these reference values to suitable precision. This function prints an error message and signals that the test failed to the make system, if the values don’t match. Any lines of the input associated with the validation process should be flagged with #TEST at the end of each line, so that they can be removed when copying from the tests to the samples directory.; Finally, add the directory name to the list of tests in psi4/tests/CMakeLists.txt.; In preparing the test case, turn energy, density, amplitude, and; geometry convergence criteria to very tight levels, and use these; results for reference energies, reference geometries, reference cube; files, etc.. Then, either remove or relax the convergence settings,; if these are not a vital part of the test. In choosing the number of; digits",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/add_tests-1.html:2172,variab,variables,2172,psi4manual/1.4.0/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/add_tests-1.html,4,['variab'],['variables']
Modifiability,"ile makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for sam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:5688,plugin,plugin,5688,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"ile makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import psi4; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; psi4.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/plugins-1.html:5688,plugin,plugin,5688,psi4manual/4.0b5/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"ile replacing myplugin with the name of your great code.; If the name you provide is not valid, Psi4 will complain.; >>> psi4 --new-plugin myplugin. Psi4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; Psi4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf; >>> psi4 --new-plugin myplugin +ambit. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/plugins/backtrans/backtrans.cc; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mollerplesset2/mp2.cc; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Creating a New Plugin Using a Conda Pre-compiled Binary¶; Psi4 plugins can also be created using Conda for both Psi4 binary and; development environment.; To compile a plugin with the default Makefile, it is necessary to have the; gcc compiler installed in the Con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:3238,plugin,plugin,3238,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"ile. Compile the code (optional -j triggers parallel compilation).; 1; 2>>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. 1>>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++11 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (2.7, 3.5, or 3.6) https://www.python.org/; CMake (3.3+) http://www.cmake.org/download/; NumPy (needed at runtime and buildtime) http://www.numpy.org/; mpmath (only needed if you build gau2grid to angular momentum >16) http://mpmath.org/; System utilities: GNU make, GNU install, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download and build. gau2grid <cmake:gau2grid — [what is this?] [min version]; Libint — [what is this?] [min version]; Libxc — [what is this?] [min version]; pybind11 — [what is this?] [min version]. Additionally, there are runtime-only dependencies:. NumPy http://www.numpy.org/; networkx https://github.com/networkx/networkx; deepdiff https://github.com/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:3808,config,configure,3808,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['config'],['configure']
Modifiability,"ilers into expected place. # check (yes, next line gives empty result. yes, LD_LIBRARY_PATH irrelevant); >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 gcc; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc. # create and compile plugin; >>> psi4 --new-plugin testplugin # generate new plugin; >>> cd testplugin # move into plugin directory; >>> make # compile the plugin to product testplugin.so; >>> psi4 # run sample input.dat; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; Psi4 code is not necessary.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of Psi4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:5551,plugin,plugin,5551,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"iliary; basis exists for the atom in question). If it does not, use the; DF_BASIS_MP2 keyword to manually specify the basis.; DFMP2 likes memory. At a minimum, \(2Q^2\) doubles are required,; where \(Q\) is the size of the auxiliary basis set. However, there is; one disk transpose of the \((Q|ov)\) tensor in the RHF-MP2 algorithm; [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.; If you notice DFMP2 using more memory than allowed, it is possible that; the threaded three-index ERI computers are using too much overhead memory.; Set the DF_INTS_NUM_THREADS to a smaller number to prevent this; in this section (does not affect threaded efficiency in the rest of the; code).; DFMP2 likes disk. At a minimum, \(2Qov\) doubles are required for; RHF-MP2, and \(4Qov\) doubles are required for UHF-MP2.; DFMP2 likes threads. Some of the formation of the \((Q|ov)\) tensor; relies on threaded BLAS (such as MKL) for efficiency. The main; \({\cal O}(N^5)\) step is done via small/medium-sized DGEMMs inside of; OpenMP, so make sure to set the OMP_NESTED environment variable; to FALSE to prevent thread thrash (or just as well, do not define; OMP_NESTED at all).; Freezing core is good for both efficiency and correctness purposes.; Freezing virtuals is not recommended. The DFMP2 module will remind you how; many frozen/active orbitals it is using in a section just below the title.; ROHF-MBPT(2) may be preferred to UHF-MP2, as the latter can suffer from; severe spin contamination in some cases.; MP2 is not suitable for systems with multireference character. The; orbital energies will come together and an explosion will occur. table of contents. DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; Introduction; Theory; Recommendations. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dfmp2-1.html:8517,variab,variable,8517,psi4manual/1.1.0/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dfmp2-1.html,2,['variab'],['variable']
Modifiability,"ill stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def _core_wavefunction_set_frequencies(cls, val):; warnings.warn(; ""Using `psi4.core.Wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:23848,variab,variables,23848,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variables']
Modifiability,"imary basis set. Type: string; Possible Values: basis string; Default: No Default. BASIS_GUESS (SCF); SCF — Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. BASIS_RELATIVISTIC (GLOBALS); GLOBALS — Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. BCCD_MAXITER (CCENERGY); CCENERGY — Convert ROHF MOs to semicanonical MOs. Type: integer; Default: 50. BENCH (GLOBALS); GLOBALS — Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC); FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:6377,extend,extended,6377,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['extend'],['extended']
Modifiability,"imary use of the ~/.psi4rc file is to control the; handling of scratch files. PSI4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are sequentially; numbered and are written to /tmp, then deleted at the end of the computation,; unless otherwise instructed by the user.; A Python callable handle to the PSI4 I/O management routines is available,; and is called psi4_io. To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to the ~/.psi4rc; file.:; psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:3222,variab,variable,3222,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['variab'],['variable']
Modifiability,"imization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the source code.; ; psimrcc(...); psimrcc() -> float :; Runs the multireference coupled cluster code.; ; reference_wavefunction(...); reference_wavefunction() -> Wavefunction :; Returns the current wavefunction object, from the most recent computation.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:111897,variab,variables,111897,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['variab'],['variables']
Modifiability,"imization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the source code.; ; psimrcc(...); psimrcc() -> float :; Runs the multireference coupled cluster code.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an optio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:112481,variab,variables,112481,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,4,['variab'],['variables']
Modifiability,"import logging; from typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import qcelemental as qcel; from qcelemental.models import AtomicInput, AtomicResult, DriverEnum; from qcelemental.models.results import AtomicResultProtocols; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core. from . import p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, descrip",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html:2188,Config,Config,2188,psi4manual/1.9.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html,2,['Config'],['Config']
Modifiability,"in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:5863,plugin,plugin,5863,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,15,['plugin'],['plugin']
Modifiability,"in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of Psi4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); The and terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree-Fock supermolecular interaction energy; and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis; computations). They are defined by:. (6). (7); Additionally, high-order coupling between induction and dispersion can be; extracted from the supermolecular MP2 interaction energy:. where is the correlation part of the supermolecular MP2; interaction energy. and also improve the; description of electrostatically dominated complexes. ; can be applied to SAPT2+ or SAPT2+(3) energies whereas ; should be applied to SAPT2+3 energies.; A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs],; and a systematic study of the accuracy of these truncations (with and; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in Psi4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:3071,coupling,coupling,3071,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['coupling'],['coupling']
Modifiability,"in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints all PSI variables that have been set internally.; ; psi_top_srcdir(...); psi_top_srcdir() -> str :; Returns the location of the so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:111601,plugin,plugin,111601,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,4,['plugin'],['plugin']
Modifiability,"in directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; Psi4 code is not necessary.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of Psi4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main Psi4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructure",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:6366,plugin,plugin,6366,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"in of spheres exchange” (COSX); approach described in [Neese:2009:98]. The coulomb term is computed with a; direct density-fitting algorithm. The COSX algorithm uses no I/O, scales; well with system size, and requires minimal memory, making it ideal for; large systems and multi-core CPUs. See the COSX section below for more information. LINKAn implementation of the linear-scaling “Linear Exchange” (LinK); algorithm described in [Ochsenfeld:1998:1663]. As with the COSX option,; the Coulomb term is computed with an integral-direct density-fitting; algorithm. The LINK algorithm provides many of the benefits of integral-direct; SCF algorithms, including no disk I/O, low memory usage, and effective; parallelization. Additionally, the; LINK implementation scales well with system size; while simultaneously providing a formally-exact computation of the; Exchange term. See Linear Exchange for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert user",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:27874,config,configurations,27874,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,1,['config'],['configurations']
Modifiability,"in the Psi4 build¶; For each Add-On, PSI4 pulls source from a specific online Git; repository and a specific tag/branch/commit in it. This ensures success; of the PSI4 build, reproducibility of the runtime results, and; freedom for continued upstream development. Sometimes, you’re the one; doing that development, and you need the CMake superbuild to pull source; from a local path rather than the approved codeset.; Find the CMakeLists.txt governing the target Add-On in; psi4/external and make changes analogous to the below:; 1; 2; 3; 4#GIT_REPOSITORY https://github.com/jturney/ambit; #GIT_TAG 1.0; DOWNLOAD_COMMAND """"; SOURCE_DIR ""/path/to/ambit-directclone"". If you’re changing the PSI4 repo codebase between compiles, there’s; nothing more to do as CMake will handle the code rebuild deps for you.; If you’re changing the local Add-On repo codebase between compiles,; CMake does not know when libaddon.[a|so|dylib] needs rebuilding. It; is recommended that the PSI4 build be initially configured with; -DBUILD_SHARED_LIBS=ON (easier to notice changes). And to trigger; Add-On library rebuild, rm -rf {objdir}/external/upstream/addon/; and rm -rf {objdir}/stage/share/cmake/AddOn. This should; re-clone the Add-On, rebuild and install it, rebuild any parts of; PSI4 that interface to it, and relink the main core.so.; If you’re modifying the Add-On’s file or directory structure, be; smart and rm all traces of it within {objdir}/stage/,; especially any *.pyc files.; Alternatively to the above, you can instead build and install the; Add-On library yourself, external to the PSI4 repository. This; is especially useful if you want to avoid full recompiles of the; Add-On at each change to the Add-On’s source. Build the Add-On; library dynamically (-DBUILD_SHARED_LIBS=ON) and mind any; “Psi4 wants” in the Add-On’s top-level CMakeLists.txt. Install the; Add-On and note the full path to AddOnConfig.cmake. Pass; the path containing that file to PSI4’s CMake as; -DAddon_DIR=/path/to/config/u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:53630,config,configured,53630,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['config'],['configured']
Modifiability,"in the Psi4 build¶; For each Add-On, PSI4 pulls source from a specific online Git; repository and a specific tag/branch/commit in it. This ensures success; of the PSI4 build, reproducibility of the runtime results, and; freedom for continued upstream development. Sometimes, you’re the one; doing that development, and you need the CMake superbuild to pull source; from a local path rather than the approved codeset.; Find the CMakeLists.txt governing the target Add-On in; psi4/external and make changes analogous to the below:; 1; 2; 3; 4#GIT_REPOSITORY https://github.com/jturney/ambit; #GIT_TAG 1.0; DOWNLOAD_COMMAND """"; SOURCE_DIR ""/path/to/ambit-directclone"". If you’re changing the PSI4 repo codebase between compiles, there’s; nothing more to do as CMake will handle the code rebuild deps for you.; If you’re changing the local Add-On repo codebase between compiles,; CMake does not know when libaddon.[a|so|dylib] needs rebuilding. It; is recommended that the PSI4 build be initially configured with; -DBUILD_SHARED_LIBS=ON (easier to notice changes). And to trigger; Add-On library rebuild, rm -rf {objdir}/external/upstream/addon/; and rm -rf {objdir}/stage/{prefix}/share/cmake/AddOn. This should; re-clone the Add-On, rebuild and install it, rebuild any parts of; PSI4 that interface to it, and relink the main core.so.; If you’re modifying the Add-On’s file or directory structure, be; smart and rm all traces of it within {objdir}/stage/{prefix},; especially any *.pyc files.; Alternatively to the above, you can instead build and install the; Add-On library yourself, external to the PSI4 repository. This; is especially useful if you want to avoid full recompiles of the; Add-On at each change to the Add-On’s source. Build the Add-On; library dynamically (-DBUILD_SHARED_LIBS=ON) and mind any; “Psi4 wants” in the Add-On’s top-level CMakeLists.txt. Install the; Add-On and note the full path to AddOnConfig.cmake. Pass; the path containing that file to PSI4’s CMake as; -DAddon_DIR=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:50371,config,configured,50371,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['config'],['configured']
Modifiability,"in the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | MultipoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:94099,inherit,inherited,94099,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"in the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (object)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:62506,inherit,inherited,62506,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"in/gcc -gxx-name=${GCC5}/bin/g++"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC5}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables CRAYPE_LINK_TYPE; and CRAY_ADD_RPATH before running cmake.; 1CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies; PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubuntu gfortran; conda gcc or gcc-5 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gcc conda package. This provides gcc, g++, and; gfortran compilers for Mac. The two former are 4.8.5 and so are too; old to compile PSI4, but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular systems",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:29326,variab,variable,29326,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['variab'],['variable']
Modifiability,"ination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_NUM_DOUBLET_ROOTS (MRCC)¶MRCC — Number of root in case of open shell system. This becomes ndoub (option #13) int fort.56. Type: integer; Default: 0. MRCC_NUM_SINGLET_ROOTS (MRCC)¶MRCC — Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS (MRCC)¶MRCC — Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS. This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. MRCC_OMP_NUM_THREADS (MRCC)¶MRCC (Expert) — Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART (MRCC)¶MRCC (Expert) — The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. MS0 (DETCI)¶DETCI — Do use the \(M_s = 0\) component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NAT_ORBS (DETCI)¶DETCI — Do compute natural orbitals?. Type: boolean; Default: false. NAT_ORBS (DFOCC)¶DFOCC — D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:173378,variab,variable,173378,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['variab'],['variable']
Modifiability,"inciple; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in PSI4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to PSI4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the PSI4; output file and is available from input as get_gradient().; sandwich mode := molecule and cfour list within; Naturally, additional jobs can follow in the input file.; Depending on the nature of preceding or following jobs, it is prudent to; separate them with the following:; 1; 2; 3clean() # removes Psi4 scratch files; clean_variables() # empties the PSI variables list; cfour {} # empties. In this scheme, the contents of the cfour {...} block are tacked onto; the end of the ZMAT file that is otherwise written from psi style; format. It is by this route that, for example %excite* sections can at; present be specified.; The execution of xcfour can be modified by a few parameters. Setting; the option CFOUR_OMP_NUM_THREADS sets the environment variable; OMP_NUM_THREADS for only the duration of the Cfour computation.; That is, portions of an input file that run PSI4 modules are; unaffected. Additionally, there are a few arguments to the function; run_cfour() that control the Cfour scratch; directory. table of contents. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:34261,variab,variable,34261,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,2,['variab'],['variable']
Modifiability,"include(psi4OptionsTools); option_with_print(BUILD_SHARED_LIBS ""Build internally built Psi4 add-on libraries as shared, not static"" OFF); option_with_print(ENABLE_OPENMP ""Enables OpenMP parallelization"" ON); option_with_print(ENABLE_AUTO_BLAS ""Enables CMake to auto-detect BLAS"" ON); option_with_print(ENABLE_AUTO_LAPACK ""Enables CMake to auto-detect LAPACK"" ON); option_with_print(ENABLE_PLUGIN_TESTING ""Test the plugin templates build and run"" OFF); option_with_print(ENABLE_CYTHONIZE ""Compile each python file rather than plaintext (requires cython) !experimental!"" OFF). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recursively delete all the “.pyc” files. It; may just run. How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:21652,variab,variable,21652,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,4,['variab'],['variable']
Modifiability,"ind a good starting guess for the SEM method if GUESS_VECTOR is H0_BLOCK. Defaults to 400. Note that the program may change the given size for Ms=0 cases MS0 is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 400. H0_BLOCK_COUPLING¶. Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE¶. Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0. H0_GUESS_SIZE¶. size of H0 block for initial guess. Type: integer; Default: 400. HD_AVG¶. How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possible Values: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE; Default: EVANGELISTI. Expert Density Matrices¶. OPDM_KE¶. Do compute the kinetic energy contribution from the correlated part of the one-particle density matrix?. Type: boolean; Default: false. Expert Root Following¶. FOLLOW_VECTOR¶. In following a particular root (see FOLLOW_ROOT , sometimes the root number",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html:14757,coupling,coupling,14757,psi4manual/4.0b2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html,16,['coupling'],['coupling']
Modifiability,"ine -decontract option for basis sets. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc52; CCSD Response for H2O2. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dft-reference; MP2 with a PBE0 reference computation. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. linK-1; RHF Linear Exchange Algorithm test for water. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:27213,variab,variables,27213,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['variab'],['variables']
Modifiability,"inear CCD [manual] [details]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. ccsd(at); CCSD with asymmetric perturbative triples (CCSD(AT)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/energy.html:4751,config,configuration,4751,psi4manual/1.1.0/energy.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/energy.html,11,['config'],['configuration']
Modifiability,"inear CCD [manual] [details]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. ccsd(at); CCSD with asymmetric perturbative triples (CCSD(AT)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. sapt2; 2nd-order SAPT, traditional definition ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/energy-1.html:4626,config,configuration,4626,psi4manual/1.0.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/energy-1.html,2,['config'],['configuration']
Modifiability,"ined as 2Ms + 1); | ; | set_name(...); | set_name( (Molecule)arg1, (str)arg2) -> None :; | Sets molecule name; | ; | set_point_group(...); | set_point_group( (Molecule)arg1, (PointGroup)arg2) -> None :; | Sets the molecular point group to the point group object arg2; | ; | set_variable(...); | set_variable( (Molecule)arg1, (str)arg2, (float)arg3) -> None :; | Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(); | ; | symbol(...); | symbol( (Molecule)arg1, (int)arg2) -> str :; | Gets the cleaned up label of atom arg2 (C2 => C, H4 = H); | ; | symmetrize(...); | symmetrize( (Molecule)arg1, (float)arg2) -> None :; | Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry.; | ; | translate(...); | translate( (Molecule)arg1, (Vector3)arg2) -> None :; | Translates molecule by arg2; | ; | update_geometry(...); | update_geometry( (Molecule)arg1) -> None :; | Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string.; | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:61616,variab,variable,61616,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,4,['variab'],['variable']
Modifiability,"ing PSI4; How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}; Find-the-code Quiz; Binary Installer; Conda Binary Package; Clone from GitHub Repository; Fork from GitHub Repository; Tarball from GitHub Repository; Psi3 from SourceForge; What is the suggested GitHub workflow. Compiling and Installing from Source; Planning: how to configure Psi4 and invoke CMake; How to build and install Psi4, the compact version; How to build, test, and install Psi4, in detail; What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies; How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda; How to see what build configuration options are available; How to install elsewhere than /usr/local/psi4; How to compile for debugging; How to fix error “RuntimeError: value for ERI”; How to choose the compilation directory, {objdir}; How to save configuration settings for a future compilation; What is the directory layout of the installed or staged Psi4; How to run Psi4 as executable after compilation; How to solve ModuleNotFoundError: No module named 'psi4'; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/external-1.html:802,config,configure,802,psi4manual/1.3.2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/external-1.html,12,['config'],"['configuration', 'configure']"
Modifiability,"ing Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html:2892,plugin,plugins,2892,psi4manual/1.4.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html,9,['plugin'],['plugins']
Modifiability,"ing times for all methods are the same as for regular dictionaries. # The internal self.__map dictionary maps keys to links in a doubly linked list.; # The circular doubly linked list starts and ends with a sentinel element.; # The sentinel element never gets deleted (this simplifies the algorithm).; # Each link is stored as a list of length three: [PREV, NEXT, KEY]. def __init__(self, *args, **kwds):; '''Initialize an ordered dictionary. Signature is the same as for; regular dictionaries, but keyword arguments are not recommended; because their insertion order is arbitrary. '''; if len(args) > 1:; raise TypeError('expected at most 1 arguments, got %d' % len(args)); try:; self.__root; except AttributeError:; self.__root = root = [] # sentinel node; root[:] = [root, root, None]; self.__map = {}; self.__update(*args, **kwds). def __setitem__(self, key, value, dict_setitem=dict.__setitem__):; 'od.__setitem__(i, y) <==> od[i]=y'; # Setting a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated with the new key/value pair.; if key not in self:; root = self.__root; last = root[0]; last[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self, key, dict_delitem=dict.__delitem__):; 'od.__delitem__(y) <==> del od[y]'; # Deleting an existing item uses self.__map to find the link which is; # then removed by updating the links in the predecessor and successor nodes.; dict_delitem(self, key); link_prev, link_next, key = self.__map.pop(key); link_prev[1] = link_next; link_next[0] = link_prev. def __iter__(self):; 'od.__iter__() <==> iter(od)'; root = self.__root; curr = root[1]; while curr is not root:; yield curr[2]; curr = curr[1]. def __reversed__(self):; 'od.__reversed__() <==> reversed(od)'; root = self.__root; curr = root[0]; while curr is not root:; yield curr[2]; curr = curr[0]. [docs] def clear(self):; 'od.clear() -> None. Remove all items from od.'; try:; for node",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:1967,inherit,inherited,1967,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,1,['inherit'],['inherited']
Modifiability,"ing with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to use a local Add-On repository in the Psi4 build. Installing from Binary; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of PSI4; Useful Commands; Troubleshooting. Scratch Files and Elementary Restart¶; One very important part of user configuration at the end of the; installation process; is to tell PSI4 where to write its temporary; (“scratch”) files. Electronic structure packages like PSI4 can; create rather large temporary disk files. It is very important to; ensure that PSI4 is writing its temporary files to a disk drive; physically attached to the computer running the computation. If it; is not, it will significantly slow down the program and the network.; By default, PSI4 will write temporary files to /tmp, but this; directory is often not large enough for typical computations. Therefore,; you need to (a) make sure there is a sufficiently large directory on a; locally attached disk drive (100GB–1TB or more, depending on the size of; the molecules to be studied) and (b) tell PSI4 the path to this; directory. Scratch file location can be specified through the; PSI_SCRATCH environment variable or through the ~/.psi4rc file; (see section ~/.psi4rc File). Most of the time, PSI_SCRATCH; is preferred, and it overrides any existing ~/.psi4rc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/external-1.html:3685,config,configuration,3685,psi4manual/1.2.1/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/external-1.html,2,['config'],['configuration']
Modifiability,"ing, and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, LIBEFP; Psi4 contains code to interface to the LIBEFP library developed; in L. Slipchenko’s group by I. Kaliman. LIBEFP at version 1.2.1; is distributed with Psi4 and requires no additional licence,; downloads, or configuration. Conversely, Psi4 cannot build; without LIBEFP. More information about the LIBEFP project; is available at http://www.libefp.org/; and source is hosted at https://github.com/libefp/libefp. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source psi4/lib/efpfrag. Any of these may be used directly in; a Psi4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it assessible to Psi4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are searched; for first in the current directory, next in the paths of PSIPATH, and; finally in built-in library. If Psi4 is unable to find the; fragment, an error will be reported. Note; When constructing new fragment files, the name of the name of the; file should be lowercase and have extension .efp. The molecule name; within the file, e.g., $NH3 must correspond to the name of the; fragment file. Molecule Specification¶; EFP fragment geometries are specified alongside the quantum mechanical; (QM) molecule and make use of the -- fragment separation scheme; described here. Each EFP fragment has its own; fragment section that includes the label efp, the name of the file; fragname from which EFP parameters are to be read, and the position; specification for the fragment in one of two ways, XYZABC or POINTS. For; XYZABC, the fragment specification is all on one line: efp and; fragname are followed by two sets of three numbers: the coordinate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/libefp-1.html:1324,variab,variable,1324,psi4manual/1.0.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/libefp-1.html,2,['variab'],['variable']
Modifiability,"ing.; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | Returns cross product of arg1 and arg2; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns distance between two points represented by arg1 and arg2; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns dot product of arg1 and arg2; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | Returns Euclidean norm of arg1; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | Returns vector of unit length and arg1 direction; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:92029,inherit,inherited,92029,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"ing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:42593,variab,variable,42593,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"ing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variable"", ""psi4.core.variable"", 1.9, f"" Replace `get_variable` with `variable` (or `scalar_variable` for scalar variables only).""). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_variables` with `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only).""). def _core_get_array_variable(key):; """"""; .. deprecate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:44662,variab,variable,44662,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"ing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whethe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/extras.html:7297,extend,extend,7297,psi4manual/1.8.x/_modules/psi4/extras.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/extras.html,2,['extend'],['extend']
Modifiability,"ing; def test(extent: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]def set_output_file(ofile: str, append: bool = False, *, loglevel: int = 20, execute: bool = True) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file`",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/extras.html:6777,extend,extend,6777,psi4manual/1.7.x/_modules/psi4/extras.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/extras.html,2,['extend'],['extend']
Modifiability,"ingle point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (whitespace-tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OPEN-SHELL¶. Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) inclusion of the so called “pseudo-triples” beyond the first-order interacting space is also possible. The two-determinant CC method for open-shell singlet states can be activated by TD-CC (=8). Type: string; Possible Values: SPIN-ORBITAL, SR-CC, PSA-CC_FULL, SR-CC_FULL, TD-CC; Default: SPIN-ORBITAL. CFOUR_OPT_MAXCYC¶. Identical to CFOUR_GEO_MAXCYC. Type: integer; Default: 50. CFOUR_ORBITALS¶. Specifies the type of molecular orbitals used in post-HF calculations. STANDARD (=0) requests usage of the orbitals (from a corresponding HF-SCF calculation) without any modification. These are in the case of RHF/UHF the usual canonical HF orbitals and in the case of ROHF calcu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:42676,adapt,adapted,42676,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['adapt'],['adapted']
Modifiability,"ingles doubles (QCISD) [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. qcisd(t); QCISD with perturbative triples [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. fno-df-ccsd(t); CCSD(T) with density fitting and frozen natural orbitals [manual]. bccd(t); BCCD with perturbative triples [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. gaussian-2 (g2); gaussian-2 composite method [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. name; calls method (aliases to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/energy-1.html:2780,adapt,adapted,2780,psi4manual/4.0b4/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/energy-1.html,4,['adapt'],['adapted']
Modifiability,"inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class F12Squared(TwoElectronInt); | docstring; | ; | Method resolution order:; | F12Squared; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> None :; | docstring; | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:42449,inherit,inherited,42449,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class F12Squared(TwoElectronInt); | docstring; | ; | Method resolution order:; | F12Squared; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | -----------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:459223,inherit,inherited,459223,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"iniconda2-latest-MacOSX-x86_64.sh""; >>> curl -o Miniconda-latest.sh ""https://repo.continuum.io/miniconda/Miniconda3-latest-MacOSX-x86_64.sh"". >>> bash; >>> bash Miniconda-latest.sh -b -p $HOME/miniconda # agrees to conda's license terms; >>> echo ""export PATH=$HOME/miniconda/bin:\$PATH"" >> ~/.bashrc # Mac: use ~/.bash_profile; # log out, log back in so conda in path; >>> conda update --yes --all; >>> conda config --add channels http://conda.anaconda.org/psi4; >>> conda install --yes psi4; >>> psi4 ""$(dirname $(which psi4))""/../share/psi4/samples/sapt1/test.in # test installation. works b/c PSI_SCRATCH defaults to /tmp. That last command tested that psi4 is in your path, and it’s finding; all the libraries it needs. Now you need only specify a scratch directory; (see Scratch Files and Elementary Restart) by replacing the placeholder in the following:; >>> echo ""export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files"" >> ~/.bashrc; # log out, log back in so variable takes effect. All done!. Note; Above commands use bash for installation and set up your environment for bash at runtime. To use csh at runtime, follow the on-screen directions at the end of the installation or consult step 7 below. Detailed Installation of Miniconda¶. Sanity check. If you already have Miniconda or Anaconda, skip to step 5. The whole installation takes ~5 min; reading this page takes far longer.; Get bzip2. You’ll need this slightly exotic command so run which to test for availability, and install from yum, source, etc. if unavailable. You’ll also need an internet connection for downloading; computers behind a firewall or with restricted login domains are eligible. So long as you can ssh into the computer to an account with write permissions and can connect to the internet from the computer, all is well. # check; >>> which bzip2; /usr/bin/bzip2; >>> curl -O ""http://psicode.org/psi4manual/master/introduction.html""; >>> ls -1; introduction.html. Get Minicon",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/conda-1.html:13278,variab,variable,13278,psi4manual/1.2.1/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/conda-1.html,6,['variab'],['variable']
Modifiability,"init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class QuadrupoleInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | QuadrupoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:592504,inherit,inherited,592504,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"init__( (object)arg1, (float)arg2) -> None; | ; | __init__( (object)arg1, (float)arg2, (float)arg3, (float)arg4) -> None; | ; | __init__( (object)arg1, (Vector3)arg2) -> None; | ; | __isub__(...); | __isub__( (object)arg1, (Vector3)arg2) -> object; | ; | __neg__(...); | __neg__( (Vector3)arg1) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __str__(...); | __str__( (Vector3)arg1) -> str :; | docstring; | ; | __sub__(...); | __sub__( (Vector3)arg1, (Vector3)arg2) -> object; | ; | cross(...); | cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :; | docstring; | ; | distance(...); | distance( (Vector3)arg1, (Vector3)arg2) -> float :; | docstring; | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | docstring; | ; | norm(...); | norm( (Vector3)arg1) -> float :; | docstring; | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None; | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); |",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:80698,inherit,inherited,80698,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"inning of a finite difference computation. set_psi_file_prefix(arg0). set_scalar_variable(arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val). timer_off(arg0); Stop timer of label argument. timer_on(arg0); Start timer with argument as label. triplet(A, B, C, transA, transB, transC); Returns the multiplication of three matrics A, B, and C, with options to transpose each beforehand. tstart(); docstring. tstop(); docstring. variable(key). variables(). version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; docstring. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. DIISManager; docstring. Deriv; Computes gradients of wavefunctions. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron reuplsion integrals. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ErfComplementERI; Computes ERF complement electron repulsion integr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:301378,adapt,adapted,301378,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['adapt'],['adapted']
Modifiability,"input file. An example input for this feature is:; # A bit small-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1, 5):; set_num_threads(nthread); energy(""scf/cc-pvdz""). In PsiAPI mode of operation, this syntax, psi4.set_num_threads(nthread), is; the primary way to control threading.; (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; set MODULE_NAME df_ints_num_threads n. to explicitly control the number of threads used for integral formation. Setting; this variable to 0 (the default) uses the number of threads specified by the; set_num_threads() Psithon method or the default environmental variables. PBS job file¶; To run a PSI4 job on a PBS queueing system, you need to properly set up; all necessary variables in the PBS job file. Below is a minimal example of; a PBS job file for a threaded job, and a short explanation for each section.; #!/bin/tcsh; #PBS -j oe; #PBS -l pmem=2120mb; #PBS -N jobname; #PBS -V. cd $PBS_O_WORKDIR; setenv myscratch /scratch/user/psi4.$PBS_JOBID. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Creating scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ssh $i mkdir -p $myscratch; end. unsetenv PSIDATADIR; setenv PSI_SCRATCH $myscratch; if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}; /psi/install/directory/bin/psi4 -i input.in -o input.out -n 4. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:14196,variab,variable,14196,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,18,['variab'],"['variable', 'variables']"
Modifiability,"ins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:4844,plugin,plugin,4844,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"installing,; and FAQ; are maintained on the GitHub Wiki.; If uncertain, start here. Scratch Files and Elementary Restart¶; One very important part of user configuration at the end of the; installation process; is to tell Psi4 where to write its temporary; (“scratch”) files. Electronic structure packages like Psi4 can; create rather large temporary disk files. It is very important to; ensure that Psi4 is writing its temporary files to a disk drive; physically attached to the computer running the computation. If it; is not, it will significantly slow down the program and the network.; By default, Psi4 will write temporary files to /tmp, but this; directory is often not large enough for typical computations. Therefore,; you need to (a) make sure there is a sufficiently large directory on a; locally attached disk drive (100GB–1TB or more, depending on the size of; the molecules to be studied) and (b) tell Psi4 the path to this; directory. Scratch file location can be specified through the; PSI_SCRATCH environment variable or through the ~/.psi4rc file; (see section ~/.psi4rc File). Most of the time, PSI_SCRATCH; is preferred, and it overrides any existing ~/.psi4rc setting. You can set up; PSI_SCRATCH by issuing the following commands in a terminal,; or including them in the appropriate rc file. For C shell (~/.tcshrc file):; setenv PSI_SCRATCH /scratch/user. For Bash (~/.bashrc file):; export PSI_SCRATCH=/scratch/user. Psi4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are written to the; designated scratch numbered by content and labeled; with the process id, then are deleted at the end of the computation,; unless otherwise ins",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:1798,variab,variable,1798,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['variab'],['variable']
Modifiability,"int ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:8654,variab,variables,8654,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,10,['variab'],['variables']
Modifiability,"int level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val)¶; Sets scalar or array QCVariable key to val on self.; :rtype: None. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float]) – Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError – If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction) – Wavefunction or inherited class instance.; filename (Optional[str]) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:24871,variab,variable,24871,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"int(df.tail(5)); return df. [docs] def table_reactions(self, modelchem, benchmark='default', sset='default',; failoninc=True,; columnplan=['indx', 'tagl', 'bm', 'mc', 'e', 'pe'],; title=""""""Reaction energies [kcal/mol] for {sset} $\subset$ {dbse} with {mc}"""""",; indextitle=""""""Detailed results for {sset} $\subset$ {dbse} with {mc}"""""",; plotpath='analysis/mols/',; standalone=True, theme='rxns', filename=None):; r""""""Prepare single LaTeX table to *filename* or return lines if None showing; the per-reaction results for reactions in *sset* for single or array; or 'all' *modelchem*, where the last uses self.mcs(), model chemistries; versus *benchmark*. Use *failoninc* to toggle between command failing; or blank lines in table. Use *standalone* to toggle between full; compilable document and suitable for inclusion in another LaTeX document.; Use *columnplan* to customize column (from among columnreservoir, below); layout. Use *title* and *indextitle* to customize table caption and; table-of-contents caption, respectively; variables in curly braces will; be substituted. Use *theme* to customize the \ref{tbl:} code. """"""; # define eligible columns for inclusion; columnreservoir = {; 'dbrxn': ['l', r""""""\textbf{Reaction}"""""", """"""{0:25s}""""""],; 'indx': ['r', '', """"""{0:14s}""""""],; 'tagl': ['l', r""""""\textbf{Reaction}"""""", """"""{0:50s}""""""],; 'bm': ['d', r""""""\multicolumn{1}{c}{\textbf{Benchmark}}"""""", """"""{0:8.2f}""""""],; 'mc': ['d', r""""""\multicolumn{1}{c}{\textbf{ModelChem}}"""""", """"""{0:8.2f}""""""],; 'e': ['d', r""""""\multicolumn{1}{c}{\textbf{Error}}"""""", """"""{0:8.2f}""""""],; 'pe': ['d', r""""""\multicolumn{1}{c}{\textbf{\% Err.}}"""""", """"""{0:8.1f}""""""],; 'imag': ['l', '', r""""""\includegraphics[width=1.0cm,height=3.5mm]{%s%%ss.png}"""""" % (plotpath)], # untested; }; for col in columnplan:; if col not in columnreservoir.keys():; raise ValidationError('Column {0} not recognized. Register with columnreservoir.'.format(col)). if isinstance(modelchem, basestring):; if modelchem.lower() == 'all':; mcs = sorted(self.mc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:87704,variab,variables,87704,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['variab'],['variables']
Modifiability,"int)arg2) -> float :; | Returns the exponent of the given primitive; | ; | is_cartesian(...); | is_cartesian( (GaussianShell)arg1) -> bool :; | docstring; | ; | is_pure(...); | is_pure( (GaussianShell)arg1) -> bool :; | docstring; | ; | normalize_shell(...); | normalize_shell( (GaussianShell)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | AMCHAR; | docstring; | ; | am; | docstring; | ; | amchar; | docstring; | ; | center; | A Vector3 representing the center of the GaussianShell.; | ; | coefs; | The coefficients of all the primitives; | ; | exps; | The exponents of all the primitives; | ; | function_index; | Basis function index where this shell starts.; | ; | ncartesian; | docstring; | ; | ncenter; | docstring; | ; | nfunction; | docstring; | ; | nprimitive; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GridProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | GridProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | add_alpha_mo(...); | add_alpha_mo( (GridProp)arg1, (int)ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:51934,inherit,inherited,51934,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"int_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59584,variab,variables,59584,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,['variab'],['variables']
Modifiability,"inted to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:21083,variab,variables,21083,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['variab'],['variables']
Modifiability,"integer; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TRIPLES_ALGORITHM¶. The type of algorithm to use for (T) computations. Type: string; Possible Values: SPIN_ADAPTED, RESTRICTED, UNRESTRICTED; Default: RESTRICTED. TRIPLES_DIIS¶. Do use DIIS extrapolation to accelerate convergence for iterative triples excitations?. Type: boolean; Default: false. USE_SPIN_SYM¶. Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. WFN_SYM¶. The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering). Type: string; Default: 1. ZERO_INTERNAL_AMPS¶. Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?. Type: boolean; Default: true. Expert¶. TIKHONOW_TRIPLES¶. Do use Tikhonow regularization in (T) computations?. Type: boolean; Default: false. USE_SPIN_SYMMETRY¶. Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. table of contents. PSIMRCC; General; CC_NUM_THREADS; CORR_ANSATZ; CORR_CCSD_T; CORR_CHARGE; CORR_MULTP; CORR_WFN; COUPLING; COUPLING_TERMS; DAMPING_PERCENTAGE; DIAGONALIZE_HEFF; DIAGONAL_CCSD_T; DIIS_MAX_VECS; DIIS_START; E_CONVERGENCE; FAVG_CCSD_T; FOLLOW_ROOT; HEFF4; HEFF_PRINT; LOCK_SINGLET; MAXITER; MP2_CCSD_METHOD; MP2_GUESS; NO_SINGLES; OFFDIAGONAL_CCSD_T; PERTURB_CBS; PERTURB_CBS_COUPLING; PT_ENERGY; R_CONVERGENCE; SMALL_CUTOFF; TIKHONOW_MAX; TIKHONOW_OMEGA; TRIPLES_ALGORITHM; TRIPLES_DIIS; USE_SPIN_SYM; WFN_SYM; ZERO_INTERNAL_AMPS. Expert; TIKHONOW_TRIPLES; USE_SPIN_SYMMETRY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__psimrcc.html:4818,config,configurations,4818,psi4manual/1.7.x/autodir_options_c/module__psimrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__psimrcc.html,3,"['COUPLING', 'config']","['COUPLING', 'configurations']"
Modifiability,"interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/share/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script, probably as $PSIDATADIR/scripts/ixyz2database.py. (If you; run it in place, there won’t be any path problems. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/share/databases.; Alternately, append the directory containing your new database into; PSIPATH. Previous topic; Defining a Method Alias; Next topic; Appendices. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Customization: Adding Simple Extensions ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/quickadddatabase-1.html:3607,variab,variable,3607,psi4manual/1.0.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/quickadddatabase-1.html,2,['variab'],['variable']
Modifiability,"inting.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everythin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:3023,Variab,Variable,3023,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,3,['Variab'],['Variable']
Modifiability,"into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:3704,plugin,plugin,3704,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns; Whether some form of DIIS is enabled during SCF. Return type; bool. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefuncti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:35262,variab,variables,35262,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,10,['variab'],['variables']
Modifiability,"int¶; Number of molecule orbitals. nmopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of molecular orbitals per irrep. no_occupations(self: psi4.core.Wavefunction) → List[List[Tuple[float, int, int]]]¶; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction) → int¶; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of symmetry orbitals per irrep. occupation_a(self: psi4.core.HF) → psi4.core.Vector¶; Returns the Alpha occupation numbers. occupation_b(self: psi4.core.HF) → psi4.core.Vector¶; Returns the Beta occupation numbers. onel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; One-electron Hessian-vector products. options(self: psi4.core.Wavefunction) → psi::Options¶; Returns the Wavefunction’s options object. potential_variable(self: psi4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). print_energies()¶. print_header(self: psi4.core.HF) → None¶; docstring. print_orbitals(self: psi4.core.HF) → None¶; docstring. print_preiterations(small=False)¶. push_back_external_potential(self: psi4.core.HF, V: psi4.core.Matrix) → None¶; Add an external potential to the private external_potentials list. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. reset_occupation(self: psi4.core.HF) → None¶; docstring. rotate_orbitals(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:28819,variab,variable,28819,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,20,['variab'],['variable']
Modifiability,"inux-gnu-"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC7}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables before running cmake.; CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... CRAYPE_LINK_TYPE¶; Set to allow PSI4 to build as shared library on Cray supercomputers. CRAY_ADD_RPATH¶; Set to true to allow PSI4 to build on Cray supercomputers. How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies. PSI4 (\(\Leftarrow\) optional) Fortran Compiler; dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:. Ubuntu gfortran; conda gfortran_linux-64 or gfortran_osx-64 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gfortran_osx-64 conda package. This provides; gfortran compilers for Mac. The version is 4.8.5, which is quite old,; but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and eff",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:41160,variab,variable,41160,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,1,['variab'],['variable']
Modifiability,"ion follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/pcm-scf,; pcmsolver/pcm-dft, and; pcmsolver/pcm-dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, ???. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/pcmsolver-1.html:3530,config,configure,3530,psi4manual/1.1.0/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/pcmsolver-1.html,4,['config'],['configure']
Modifiability,"ion is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_opdm(self: psi4.core.CIWavefunction) → None¶; docstring. form_tpdm(self: psi4.core.CIWavefunction) → None¶; docstring. frequencies()¶. static from_file(wfn_data)¶; Build Wavefunction from data. Parameters; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to numpy.load(); to read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dimension(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Dimension¶; Returns the dimension of requested orbital subspace. Parameters; orbital_name (str) – {‘FZC’, ‘DRC’, ‘DOCC’, ‘ACT’, ‘RAS1’, ‘RAS2’, ‘RAS3’, ‘RAS4’, ‘POP’, ‘VIR’, ‘FZV’, ‘DRV’, ‘ALL’}; Which subspace of orbitals should be returned?. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_opdm(self: psi4.core.CIWavefunction, Iroot: int, Jroot: int, spin: str, full_space: bool) → psi4.core.Matrix¶; Returns the one-particle density or transition matrix. Parameters. Iroot (int) – The index of the root in the bra. If Iroot and Jroot are -1, return the density matrix of root 0.; Always use -1 for sin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html:18822,variab,variable,18822,psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,2,['variab'],['variable']
Modifiability,"ion is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_opdm(self: psi4.core.CIWavefunction) → None¶; docstring. form_tpdm(self: psi4.core.CIWavefunction) → None¶; docstring. frequencies()¶. static from_file(wfn_data)¶; Build Wavefunction from data. Parameters; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to numpy.load(); to read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dimension(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Dimension¶; Returns the dimension of requested orbital subspace. Parameters; orbital_name (str) – {‘FZC’, ‘DRC’, ‘DOCC’, ‘ACT’, ‘RAS1’, ‘RAS2’, ‘RAS3’, ‘RAS4’, ‘POP’, ‘VIR’, ‘FZV’, ‘DRV’, ‘ALL’}; Which subspace of orbitals should be returned?. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_opdm(self: psi4.core.CIWavefunction, Iroot: int, Jroot: int, spin: str, full_space: bool) → psi4.core.Matrix¶; Returns the one-particle density or transition matrix. Parameters. Iroot (int) – The index of the root in the bra. If Iroot and Jroot are -1, return the density matrix of root 0.; Always use -1 for single-state calculations.; Jroot (int) – The index of the root in the ket. Select -1 for th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:17687,variab,variable,17687,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,3,['variab'],['variable']
Modifiability,ion method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. ERD. erd_coef() psi4.core.GaussianShell method. erf_complement_eri() psi4.core.IntegralFactory method. erf_eri() psi4.core.IntegralFactory method. ERI class in psi4.core. eri() psi4.core.IntegralFactory method. ERISieve class in psi4.core. ESP AT CENTER n. esp_at_nuclei() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. ESPPropCalc class in psi4.core. evals() psi4.core.OrbitalSpace method. EX_ALLOW (DETCI). EX_LEVEL (DETCI). exch() psi4.core.FISAPT method. EXCH_SCALE_ALPHA (SAPT). EXCITATION_RANGE (CCEOM). exists() psi4.core.IO method. exp() psi4.core.GaussianShell method. EXPLICIT_HAMILTONIAN (CPHF). exponent() psi4.core.FittedSlaterCorrelationFactor method. extend() psi4.core.BSVec method. EXTERN (SCF). external_pot() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS). ExternalPotential class in psi4.core. extract_subsets() psi4.core.Molecule method. extrapolation schemes. Exvals() psi4.core.OEProp method. Eyvals() psi4.core.OEProp method. Ezvals() psi4.core.OEProp method. F. f12() psi4.core.IntegralFactory method. f12_cgtg() psi4.core.MintsHelper method. f12_double_commutator() psi4.core.IntegralFactory method. f12_squared() psi4.core.IntegralFactory method. f12g12() psi4.core.IntegralFactory method. F_CUT (DLPNO). Fa() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:57596,extend,extend,57596,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['extend'],['extend']
Modifiability,ion method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. ERD. erd_coef() psi4.core.GaussianShell method. erf_complement_eri() psi4.core.IntegralFactory method. erf_eri() psi4.core.IntegralFactory method. ERI class in psi4.core. eri() psi4.core.IntegralFactory method. ERISieve class in psi4.core. ESP AT CENTER n. esp_at_nuclei() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. ESPPropCalc class in psi4.core. evals() psi4.core.OrbitalSpace method. EX_ALLOW (DETCI). EX_LEVEL (DETCI). exch() psi4.core.FISAPT method. EXCH_SCALE_ALPHA (SAPT). EXCITATION_RANGE (CCEOM). exists() psi4.core.IO method. exp() psi4.core.GaussianShell method. EXPLICIT_HAMILTONIAN (CPHF). exponent() psi4.core.FittedSlaterCorrelationFactor method. extend() psi4.core.BSVec method. EXTERN (SCF). external_pot() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS). ExternalPotential class in psi4.core. extract_subsets() psi4.core.Molecule method. extrapolation schemes. Exvals() psi4.core.OEProp method. Eyvals() psi4.core.OEProp method. Ezvals() psi4.core.OEProp method. F. f12() psi4.core.IntegralFactory method. f12_double_commutator() psi4.core.IntegralFactory method. f12_squared() psi4.core.IntegralFactory method. f12g12() psi4.core.IntegralFactory method. F_CUT (DLPNO). Fa() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:55435,extend,extend,55435,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['extend'],['extend']
Modifiability,ion method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. ERD. erd_coef() psi4.core.GaussianShell method. erf_complement_eri() psi4.core.IntegralFactory method. erf_eri() psi4.core.IntegralFactory method. ERI class in psi4.core. eri() psi4.core.IntegralFactory method. ERISieve class in psi4.core. ESP AT CENTER n. esp_at_nuclei() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. ESPPropCalc class in psi4.core. evals() psi4.core.OrbitalSpace method. EX_ALLOW (DETCI). EX_LEVEL (DETCI). exch() psi4.core.FISAPT method. EXCH_SCALE_ALPHA (SAPT). EXCITATION_RANGE (CCEOM). exists() psi4.core.IO method. exp() psi4.core.GaussianShell method. EXPLICIT_HAMILTONIAN (CPHF). exponent() psi4.core.FittedSlaterCorrelationFactor method. extend() psi4.core.BSVec method. EXTERN (SCF). external_pot() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS). ExternalPotential class in psi4.core. extract_subsets() psi4.core.Molecule method. extrapolation schemes. Exvals() psi4.core.OEProp method. Eyvals() psi4.core.OEProp method. Ezvals() psi4.core.OEProp method. F. f12() psi4.core.IntegralFactory method. f12_double_commutator() psi4.core.IntegralFactory method. f12_squared() psi4.core.IntegralFactory method. f12g12() psi4.core.IntegralFactory method. Fa() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. Fa_subset() p,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:54875,extend,extend,54875,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['extend'],['extend']
Modifiability,"ion of Raman intensities based on the geometrical derivatives of the static polarizability tensor, while DYN (=2) requests a calculation of Raman intensities based on the derivatives of the dynamical polarizability tensor. Type: string; Possible Values: ON, DYN, OFF; Default: OFF. CFOUR_RAMAN_ORB¶. Specifies whether Raman intensities are calculated with orbital relaxation with respect to the electric field perturbation (RELAXED, = 1) or without orbital relaxation (UNRELAXED, = 0). Type: string; Possible Values: RELAXED, UNRELAXED; Default: UNRELAXED. CFOUR_RDO¶. Specifies whether or not relaxed density natural orbitals are to be computed. This option only has meaning for a correlated calculation. For =0, Do not compute. For =1, compute. Type: boolean; Default: true. CFOUR_REFERENCE¶. Specifies the type of SCF calculation to be performed. RHF (= 0) requests a restricted Hartree-Fock reference; UHF (= 1) an unrestricted Hartree-Fock reference; ROHF (= 2) a restricted open-shell Hartree-Fock calculation; TCSCF (=3) a two-configurational SCF calculation, and CASSCF (=4) a complete-active space SCF calculations (currently not implemented). Psi4 Interface: Keyword subject to translation from value of REFERENCE unless set explicitly. Type: string; Possible Values: RHF, UHF, ROHF, TCSCF, CASSCF; Default: RHF. CFOUR_RELATIVISTIC¶. Specifies the treatment of relativistic effects. The default is a non-relativistic treatment (OFF), while perturbational treatments are invoked via MVD1 (mass-velocity and 1-electron Darwin conribution), MVD2 (mass-velocity and 1- and 2-electron Darwin contribution), DPT2 (second-order direct perturbation theory approach), SF-DPT4 (scalar-relativistic part of fourth-order direct perturbation theory, DPT4 (full fourth-order DPT including spin-orbit corrections), SF-DPT6 (scalar-relativistic part of sixth-order direct perturbation theory), SFREE (spin-free treatment), X2C1E (spin-free X2C-1e treatment), or DPT (synonym with DPT2). Type: string; Possib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:51250,config,configurational,51250,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['config'],['configurational']
Modifiability,"ion of Raman intensities based on the geometrical derivatives of the static polarizability tensor, while DYN (=2) requests a calculation of Raman intensities based on the derivatives of the dynamical polarizability tensor. Type: string; Possible Values: ON, DYN, OFF; Default: OFF. CFOUR_RAMAN_ORB¶. Specifies whether Raman intensities are calculated with orbital relaxation with respect to the electric field perturbation (RELAXED, = 1) or without orbital relaxation (UNRELAXED, = 0). Type: string; Possible Values: RELAXED, UNRELAXED; Default: UNRELAXED. CFOUR_RDO¶. Specifies whether or not relaxed density natural orbitals are to be computed. This option only has meaning for a correlated calculation. For =0, Do not compute. For =1, compute. Type: boolean; Default: true. CFOUR_REFERENCE¶. Specifies the type of SCF calculation to be performed. RHF (= 0) requests a restricted Hartree-Fock reference; UHF (= 1) an unrestricted Hartree-Fock reference; ROHF (= 2) a restricted open-shell Hartree-Fock calculation; TCSCF (=3) a two-configurational SCF calculation, and CASSCF (=4) a complete-active space SCF calculations (currently not implemented). Psi4 Interface: Keyword subject to translation from value of REFERENCE unless set explicitly. Type: string; Possible Values: RHF, UHF, ROHF, TCSCF, CASSCF; Default: RHF. CFOUR_RELATIVISTIC¶. Specifies the treatment of relativistic effects. The default is a non-relativistic treatment (OFF), while perturbational treatments are invoked via MVD1 (mass-velocity and 1-electron Darwin contribution), MVD2 (mass-velocity and 1- and 2-electron Darwin contribution), DPT2 (second-order direct perturbation theory approach), SF-DPT4 (scalar-relativistic part of fourth-order direct perturbation theory, DPT4 (full fourth-order DPT including spin-orbit corrections), SF-DPT6 (scalar-relativistic part of sixth-order direct perturbation theory), SFREE (spin-free treatment), X2C1E (spin-free X2C-1e treatment), or DPT (synonym with DPT2). Type: string; Possi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:51239,config,configurational,51239,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,24,['config'],['configurational']
Modifiability,"ion of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_NUM_DOUBLET_ROOTS (MRCC); MRCC — Number of root in case of open shell system. This becomes ndoub (option #13) int fort.56. Type: integer; Default: 0. MRCC_NUM_SINGLET_ROOTS (MRCC); MRCC — Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS (MRCC); MRCC — Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS. This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. MRCC_OMP_NUM_THREADS (MRCC); MRCC (Expert) — Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART (MRCC); MRCC (Expert) — The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. MS0 (DETCI); DETCI — Do use the \(M_s = 0\) component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NAT_ORBS (DETCI); DETCI — Do compute natural orbitals?. Type: boolean; Default: false. NAT_ORBS (DFOCC); DFOCC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:170276,variab,variable,170276,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['variab'],['variable']
Modifiability,"ion options are available; How to install elsewhere than /usr/local/psi4; How to compile for debugging; How to fix error “RuntimeError: value for ERI“; How to choose the compilation directory, {objdir}; How to save configuration settings for a future compilation; What is the directory layout of the installed or staged Psi4; How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set PSIDATADIR and why; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct“; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Installation and Runtime Configuration. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:43101,config,configure,43101,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,8,['config'],['configure']
Modifiability,"ion order:; | NablaInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:565178,inherit,inherited,565178,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ion — optimize() and gradient(). Geometry Optimization — optimize() and gradient()¶. Psi4 Native Gradient Methods; Psi4 Native DFT Gradient Methods (excepting double-hybrids); CFOUR Interfaced Gradient Methods. For further discussion of geometry optimization, see; Sec. Geometry Optimization.; optimize() is the only command most users will ever; need to access directly to perform geometry optimizations. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float – Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Extra options passed to the GeomeTRIC or optking optimizers",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/opt.html:1180,variab,variables,1180,psi4manual/1.7.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/opt.html,4,['variab'],['variables']
Modifiability,"ion('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:163530,variab,variables,163530,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variables']
Modifiability,"ion('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). returnvalue = procedures['property'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). optstash.restore(); return returnvalue. ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory :ref:`[manual] <sec:dcft>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-Plesset perturbation theory (MP2) :ref:`[manual] <",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:45410,variab,variables,45410,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['variab'],['variables']
Modifiability,"ion('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:160088,variab,variable,160088,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variable']
Modifiability,"ion() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:32118,variab,variable,32118,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,6,['variab'],['variable']
Modifiability,"ion) → Annotated[list[float], FixedSize(3)]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefunction) – Wavefunction instance.; filenumber (int) – Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key)¶; Whether scalar or array QCVariable key has been set on self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction) → psi4.core.MintsHelper¶; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction) → list[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. module(self: psi4.core.Wavefunction) → str¶; Name of the last/highest level of theory module (internal or external) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:18329,variab,variable,18329,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"ion, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; from typing import Any, Dict, Optional, Tuple, Union, TYPE_CHECKING. from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs] @abc.abstractmethod; def compute(self):; pass. [docs] @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicRes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_base.html:1999,Config,Config,1999,psi4manual/1.7.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_base.html,1,['Config'],['Config']
Modifiability,"ion, arg0: str) → None; docstring. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix) → None; docstring. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sigma(*args, **kwargs); Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) → List[psi4.core.Matrix]; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None; docstring. transform_mcscf_integrals(self: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.ciwavefunction.html:14837,variab,variable,14837,psi4manual/1.2.1/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"ion. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[, tolerance]); Finds highest possible computational molecular point group. find_point_group(self[, tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self, arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self, arg0); Fix the orientation at its current frame. flabel(self, atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self, atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self, arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom, elea, elez, elem, mass, ...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[, return_dict, ...]); Construct Molecule from non-Psi4 schema. from_string(molstr[, dtype, name, fix_com, ...]). fsymbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self, arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:2898,variab,variables,2898,psi4manual/1.8.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html,6,['variab'],['variables']
Modifiability,"ion. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self, atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[, tolerance]); Finds highest possible computational molecular point group. find_point_group(self[, tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self, arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self, arg0); Fix the orientation at its current frame. flabel(self, atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self, atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self, arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom, elea, elez, elem, mass, ...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[, return_dict, ...]); Construct Molecule from non-Psi4 schema. from_string(molstr[, dtype, name, fix_com, ...]). fsymbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. fx(self, arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:2914,variab,variables,2914,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,6,['variab'],['variables']
Modifiability,"ion. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:1064,variab,variables,1064,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,2,['variab'],['variables']
Modifiability,"ion. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:1064,variab,variables,1064,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,2,['variab'],['variables']
Modifiability,"ion. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psithoninput-1.html:1064,variab,variables,1064,psi4manual/4.0b5/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psithoninput-1.html,2,['variab'],['variables']
Modifiability,"ion. reference_wavefunction(...); docstring. same_a_b_dens(...); Returns true if the alpha and beta densities are the same. same_a_b_orbs(...); Returns true if the alpha and beta orbitals are the same. set_array((self: psi4.core.Wavefunction, ...); Returns the requested internal array. set_basisset((self: psi4.core.Wavefunction, ...); Sets the requested auxiliary basis. set_frequencies(...); Sets the frequencies of the Hessian. set_gradient((self: psi4.core.Wavefunction, ...); Sets the Wavefunctions gradient. set_hessian((self: psi4.core.Wavefunction, ...); Sets the Wavefunctions Hessian. set_name((self: psi4.core.Wavefunction, ...); Sets the level of theory this wavefunction corresponds to. set_oeprop((self: psi4.core.Wavefunction, ...); Associate an OEProp object with this wavefunction. set_print((self: psi4.core.Wavefunction, ...); Sets the print level of the Wavefunction. set_reference_wavefunction(...); docstring. set_variable((self: psi4.core.Wavefunction, ...); Sets the requested internal variable. shallow_copy((self: psi4.core.Wavefunction, ...); Copies the pointers to the internal data. sobasisset(...); Returns the symmetry orbitals basis. soccpi(...); Returns the number of singly occupied orbitals per irrep. variables(...); Returns the map of all internal variables. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:4559,variab,variable,4559,psi4manual/1.1.0/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"ion.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:34683,variab,variables,34683,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"ion; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98500,variab,variable,98500,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"ion>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class F12(TwoElectronInt); | docstring; | ; | Method resolution order:; | F12; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> None :; | docstring; | ; | set_enable_pybuf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:37160,inherit,inherited,37160,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ion>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Dat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:20521,inherit,inherited,20521,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,4,['inherit'],['inherited']
Modifiability,"ion>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:18768,inherit,inherited,18768,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ionError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dct_wfn = core.dct(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dct_wfn = core.dct(ref_wfn). for k, v in dct_wfn.variables().items():; core.set_variable(k, v). return dct_wfn. def run_dct_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). core.set_global_option('DERTYPE', 'FIRST'); dct_wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:54670,variab,variables,54670,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,10,['variab'],['variables']
Modifiability,"ionError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dct_wfn = core.dct(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dct_wfn = core.dct(ref_wfn). for k, v in dct_wfn.variables().items():; core.set_variable(k, v). return dct_wfn. def run_dct_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). core.set_global_option('DERTYPE', 'FIRST'); dct_wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true');; dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:52558,variab,variables,52558,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variables']
Modifiability,"ional energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI); DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI); DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CCD_E_CONVERGENCE (SAPT); SAPT — E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER (SAPT); SAPT — Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE (SAPT); SAPT — Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CCL_ENERGY (OCC); OCC — Do compute CC Lambda energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE = COMPUTE” option. Type: boolean; Default: false. CEPA_LEVEL (FNOCC); FNOCC (Expert) — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). CEPA_NO_SINGLES (FNOCC); FNOCC — Flag to exclude singly excited configurations from a coupled-pair computation. Type: boolean; Default: false. CEPA_OS_SCALE (OCC); OCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE (OCC); OCC — CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC); OCC — CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE (OCC); OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CFOUR_ABCDTYPE (CFOUR); CFOUR — Specifies the way the \(\langle ab||cd \rangle\) molecular orbital integrals are handled in post-MP2 calculations. STANDARD (= 0) uses directly the corresponding MO integrals and thus results in an algorithm which in particular for large-scale calculations results in excessive use of disk space (storage of all \(\langle ab||cd\rangle\) integrals. AOBASIS (=2) uses an AO-based algorithm to evaluate all terms involving the \(\langle ab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:16399,config,configurations,16399,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['config'],['configurations']
Modifiability,"ional energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI); DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI); DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CCD_E_CONVERGENCE (SAPT); SAPT — E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER (SAPT); SAPT — Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE (SAPT); SAPT — Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CCL_ENERGY (OCC); OCC — Do compute CC Lambda energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE = COMPUTE” option. Type: boolean; Default: false. CEPA_LEVEL (FNOCC); FNOCC (Expert) — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). CEPA_NO_SINGLES (FNOCC); FNOCC — Flag to exclude singly excited configurations from a coupled-pair computation. Type: boolean; Default: false. CEPA_OS_SCALE (OCC); OCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE (OCC); OCC — CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC); OCC — CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE (OCC); OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CFOUR_ABCDTYPE (CFOUR); CFOUR — Specifies the way the molecular orbital integrals are handled in post-MP2 calculations. STANDARD (= 0) uses directly the corresponding MO integrals and thus results in an algorithm which in particular for large-scale calculations results in excessive use of disk space (storage of all integrals. AOBASIS (=2) uses an AO-based algorithm to evaluate all terms involving the integrals and significantly reduces the amount of disk storage. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:16803,config,configurations,16803,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['config'],['configurations']
Modifiability,"ional energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI); DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI); DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CCD_E_CONVERGENCE (SAPT); SAPT — E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER (SAPT); SAPT — Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE (SAPT); SAPT — Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CCL_ENERGY (OCC); OCC — Do compute CC Lambda energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE = COMPUTE” option. Type: boolean; Default: false. CEPA_LEVEL (FNOCC); FNOCC (Expert) — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). CEPA_NO_SINGLES (FNOCC); FNOCC — Flag to exclude singly excited configurations from a coupled-pair computation. Type: boolean; Default: false. CEPA_OS_SCALE (OCC); OCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE (OCC); OCC — CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC); OCC — CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE (OCC); OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CHECK_C_ORTHONORM (TRANSQT); TRANSQT — Do check MO orthogonality condition?. Type: boolean; Default: false. CHOLESKY_TOLERANCE (FNOCC); FNOCC — tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1.0e-4. CHOLESKY_TOLERANCE (SCF); SCF — Tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1e-4. CI_DIIS (MCSCF); MCSCF — Do use DIIS extrapolation to accelerate convergence of the CI coefficients?. Type: boo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:16257,config,configurations,16257,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['config'],['configurations']
Modifiability,"ional energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI); DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI); DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CCD_E_CONVERGENCE (SAPT); SAPT — E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER (SAPT); SAPT — Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE (SAPT); SAPT — Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CCL_ENERGY (OCC); OCC — Do compute CC Lambda energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE = COMPUTE” option. Type: boolean; Default: false. CEPA_LEVEL (FNOCC); FNOCC (Expert) — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). CEPA_NO_SINGLES (FNOCC); FNOCC — Flag to exclude singly excited configurations from a coupled-pair computation. Type: boolean; Default: false. CEPA_OS_SCALE (OCC); OCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE (OCC); OCC — CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC); OCC — CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE (OCC); OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CHECK_C_ORTHONORM (TRANSQT); TRANSQT — Do check MO orthogonality condition?. Type: boolean; Default: false. CHOLESKY_TOLERANCE (FNOCC); FNOCC — tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1.0e-4. CI_DIIS (MCSCF); MCSCF — Do use DIIS extrapolation to accelerate convergence of the CI coefficients?. Type: boolean; Default: false. CI_NUM_THREADS (DETCI); DETCI — Number of threads for DETCI. Type: integer; Default: 1. CIBLKS_PRINT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:16218,config,configurations,16218,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['config'],['configurations']
Modifiability,"ioned ###############. # <<< CMake build overview >>>; #; # >>> ls; # external/ COPYING psi4/ tests/ ...; # >>> cmake -H. -Bobjdir -DCMAKE_INSTALL_PREFIX=/path/to/install-psi4 ...; # ...; # -- Generating done; # -- Build files have been written to: /current/dir/objdir; # >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`; # >>> make install. # <<< Required build dependencies that Psi4 can't build itself >>>; #; # - CMake (e.g., `conda install cmake`); # - C++ and C compilers (C++11 compliant); # - BLAS/LAPACK (also runtime; e.g., `conda install mkl-devel`); # - Python (also runtime; interpreter and headers; e.g., `conda install python`); # - NumPy (also runtime; avoidable at buildtime if gau2grid pre-built; e.g., `conda install numpy`); # - deepdiff (runtime only; e.g., `conda install deepdiff -c conda-forge`); # - networkx (runtime only; e.g., `conda install networkx`); # - pint (runtime only; e.g., `conda install pint -c conda-forge`). # These three ""### Options ###"" sections contain useful CMake variables for build configuration. # <<< Compilers and flags >>>; #; # - CMAKE_C_COMPILER ""C compiler""; # - CMAKE_C_FLAGS ""Additional C flags""; # - CMAKE_CXX_COMPILER ""C++ compiler""; # - CMAKE_CXX_FLAGS ""Additional C++ flags""; # - CMAKE_Fortran_COMPILER ""Fortran compiler (required for some add-ons)""; # - CMAKE_Fortran_FLAGS ""Additional Fortran flags"". # <<< Detecting dependencies and add-ons >>>; #; # - PYTHON_EXECUTABLE ""Python interpreter to use (e.g., /path/to/bin/python2.7)""; # - PYTHON_LIBRARY ""Python library that goes with the interpreter (e.g., /path/to/lib/python2.7.so)""; # - PYTHON_INCLUDE_DIR ""Path to the python include files (e.g., /path/to/include/python2.7)""; # - SPHINX_ROOT ""Root directory for Sphinx: 'bin/sphinx-build' (or similar) should be in this dir.""; #; # For any ${AddOn} of: ambit, CheMPS2, dkh, libefp, erd, gau2grid, gdma, Libint, PCMSolver, pybind11, pylibefp,; # qcelemental, simint, Libxc; # - CMAKE_PREFIX_PATH ""Set to list of root directories to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:10829,variab,variables,10829,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,4,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"ions of the same class together. For example, in C3v; there are two distinct C3 rotations and 3 distinct reflections, each; with a separate character. Thus symop has 6 elements rather than the 3; you'll find in most published character tables. """""". def __init__(self, *args):; """"""Constructor"""""". # order of the principal rot axis; self.nt = 0; # the class of the point group; self.pg = PointGroups['C1']; # the number of irreps in this pg; self.PYnirrep = 0; # an array of irreps; self.PYgamma = 0; # the matrices describing sym ops; self.symop = 0; # index of the inverse symop; self.inv = 0; # the Schoenflies symbol for the pg; self.symb = 0; # Bitwise representation of the symmetry operations; self.PYbits = 0. # Divert to constructor functions; if len(args) == 0:; pass; elif len(args) == 1 and \; isinstance(args[0], basestring):; self.constructor_schoenflies(*args); elif len(args) == 1 and \; isinstance(args[0], int):; self.constructor_bits(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_schoenflies(self, cpg):; """"""This constructor takes the Schoenflies symbol of a point group; as input. """"""; self.symb = cpg; # Check the symbol coming in; self.PYbits = PointGroup.full_name_to_bits(cpg); if self.PYbits is None:; raise ValidationError('CharacterTable: Invalid point group name: %s\n' % (cpg)); self.common_init(). [docs] def constructor_bits(self, bits):; """"""This constructor takes the bitswise representation of a point; group as input. """"""; self.PYbits = bits; self.symb = PointGroup.bits_to_basic_name(bits); self.common_init(). [docs] def common_init(self):; """"""First parse the point group symbol, this will give us the; order of the point group(g), the type of point group (pg), the; order of the principle rotation axis (nt), and the number of; irreps (nirrep). """"""; if len(self.symb) == 0:; raise ValidationError('CharacterTable::CharacterTable: null p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:21242,config,configuration,21242,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['config'],['configuration']
Modifiability,"ipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together. Obligations of the External Project owners are to:. allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_addon-1.html:6048,sandbox,sandbox,6048,psi4manual/1.4.0/manage_addon-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_addon-1.html,18,"['plugin', 'sandbox']","['plugins', 'sandbox']"
Modifiability,"ipes in https://github.com/psi4/psi4meta/tree/master/conda-recipes. PSI4 and Add-On Projects Working Together; Obligations of the External Project owners are to:; allow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:; leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/manage_addon-1.html:6041,sandbox,sandbox,6041,psi4manual/1.2.1/manage_addon-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/manage_addon-1.html,8,"['plugin', 'sandbox']","['plugins', 'sandbox']"
Modifiability,"iplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; psi4.core.set_global_option_python('EXTERN', None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Arguments:; mdi_arguments: MDI configuration options; """"""; MDI_Init(mdi_arguments). [docs]def mdi_run(scf_method, **kwargs):; """""" Begin functioning as an MDI engine. Arguments:; scf_method: Method used when calculating energies or gradients; """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.mdi_engine. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:13099,config,configuration,13099,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,2,['config'],['configuration']
Modifiability,"iplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; psi4.core.set_global_option_python('EXTERN', None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Arguments:; mdi_arguments: MDI configuration options; """"""; MDI_Init(mdi_arguments). [docs]def mdi_run(scf_method, **kwargs):; """""" Begin functioning as an MDI engine. Arguments:; scf_method: Method used when calculating energies or gradients; """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; psi4.driver.mdi_engine. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/mdi_engine.html:13099,config,configuration,13099,psi4manual/1.5.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/mdi_engine.html,2,['config'],['configuration']
Modifiability,"iplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.flabel(at)); else:; text += "" %-8s"" % (""Gh("" + self.flabel(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:33155,variab,variable,33155,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['variab'],['variable']
Modifiability,"irectory on the default input file.; Psi4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf; >>> psi4 --new-plugin myplugin +ambit. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/plugins/backtrans/backtrans.cc; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mollerplesset2/mp2.cc; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Creating a New Plugin Using a Conda Pre-compiled Binary¶; Psi4 plugins can also be created using Conda for both Psi4 binary and; development environment.; To compile a plugin with the default Makefile, it is necessary to have the; gcc compiler installed in the Conda distribution or environment (below,; $PSI4CONDA) used to run Psi4.; # prepare; >>> bash; >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; >>> conda install gcc # install compilers into expected place. # check (yes, next line gives empty r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:3631,plugin,plugins,3631,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugins']
Modifiability,"irects output to /dev/null. benchmark_blas1(arg0, arg1); docstring. benchmark_blas2(arg0, arg1); docstring. benchmark_blas3(arg0, arg1, arg2); docstring. benchmark_disk(arg0, arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Get",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:242109,variab,variables,242109,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"irs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to GDMA Distributed Multipole Analysis by A.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/gdma.html:5967,variab,variable,5967,psi4manual/master/gdma.html,https://psicode.org,https://psicode.org/psi4manual/master/gdma.html,2,['variab'],['variable']
Modifiability,"irs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/gdma-1.html:5996,variab,variable,5996,psi4manual/1.2.1/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/gdma-1.html,4,['variab'],['variable']
Modifiability,"irs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/gdma-1.html:5989,variab,variable,5989,psi4manual/1.3.2/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/gdma-1.html,4,['variab'],['variable']
Modifiability,"irs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to GDMA Distributed Multipole Analysis by A. J. Stone",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gdma-1.html:5926,variab,variable,5926,psi4manual/1.4.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gdma-1.html,4,['variab'],['variable']
Modifiability,"irs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to GDMA Distributed Multipole Analysis by A. J. Stone",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/gdma-1.html:5926,variab,variable,5926,psi4manual/1.5.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/gdma-1.html,4,['variab'],['variable']
Modifiability,"irs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to GDMA Distributed Multipole Analysis by A. J. Stone",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/gdma.html:5926,variab,variable,5926,psi4manual/1.6.x/gdma.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/gdma.html,2,['variab'],['variable']
Modifiability,"irs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to GDMA Distributed Multipole Analysis by A. J. Stone",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gdma.html:5929,variab,variable,5929,psi4manual/1.7.x/gdma.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gdma.html,2,['variab'],['variable']
Modifiability,"irs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to GDMA Distributed Multipole Analysis by A. J. Sto",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/gdma.html:5931,variab,variable,5931,psi4manual/1.8.x/gdma.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/gdma.html,2,['variab'],['variable']
Modifiability,"irs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to GDMA Distributed Multipole Analysis by A. J. Sto",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/gdma.html:5958,variab,variable,5958,psi4manual/1.9.x/gdma.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/gdma.html,2,['variab'],['variable']
Modifiability,"ir}/stage/{prefix}/lib/psi4/core.so ../psi4/core.so; >>> python ../psi4/run_psi4.py --inplace input.dat. Why not to set PSIDATADIR¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is for developer use only. In PSI4 1.1; and beyond, the program always knows where its resources are, and the; only reason to set this variable is to point to another location.; Previously in PSI4 1.0 and previous, only installed executables knew; the location, so it always needed to be explicitly set when run from the; compilation directory.; At runtime; >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4. Or in the shell; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIDATADIR {top-level-psi4-dir}/psi4/share/psi4. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIDATADIR={top-level-psi4-dir}/psi4/share/psi4. How to configure C++ and C compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a C++ compiler is vital for building the code.; Downstream Dependencies — PSI4 \(\Leftarrow\) C++ Compiler. CMake Variables. CMAKE_CXX_COMPILER — CMake variable to specify name or full path to C++ compiler.; CMAKE_C_COMPILER — CMake variable to specify name or full path to C compiler.; CMAKE_CXX_FLAGS — CMake variable to specify any additional custom compiler flags for C++ source.; CMAKE_C_FLAGS — CMake variable to specify any additional custom compiler flags for C source. Examples. Build with detected compilers from PATH. >>> cmake. Build with specific (Intel) compilers from PATH. >>> cmake -DCMAKE_CXX_COMPILER=icpc -DCMAKE_C_COMPILER=icc. Build with specific (GNU) compilers not in PATH. >>> cmake -DCMAKE_CXX_COMPILER=/path/to/gcc6.2/bin/g++ -DCMAKE_C_COMPILER=/path/to/gcc6.2/bin/gcc. Build with specific (Intel) compilers from PATH based on GCC not in PATH. >>> cmake -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:27992,config,configure,27992,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['config'],['configure']
Modifiability,"is Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation fun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10198,variab,variables,10198,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,8,['variab'],['variables']
Modifiability,"is covers:. Physical Constants: psi4/psi4/include/psi4/physconst.h; Python Driver: docstrings from *.py files in psi4/psi4/driver; Databases: docstrings from *.py files in psi4/psi4/share/psi4/databases; Basis Sets: *.gbs files in psi4/psi4/share/psi4/basis; C++ Keywords: psi4/psi4/src/read_options.cc; Sample Inputs: input.dat files in psi4/samples; PSI Variables: variables and associated modules extracted from code and comments in the Python and C++ source; * Modules scraped are the sections of psi4/psi4/src/read_options.cc; * Variables should be all-caps, except where representing substitutions, e.g., ROOT n -> ROOT m and double-quote "" delimited, even in Python; * Scraper looks for Process::environment.globals, set_array_variable, variables_, etc. lines and comments in the C++ code; * C-side, the module for the variable is determined by the directory where it’s found.; * Scraper looks for set_variable together with # P::e MODULE lines and comments in the Python code; * Py-side, the module for the variable is specified by MODULE in the comment; * When a variable is set by code in either language, e.g., variables_[varname.str()] rather than plain string, variables_[""FCI TOTAL ENERGY""], add a plain string line as a single-line comment, so the scraper can find it.; * Add new places to scrape for variables to psi4/doc/sphinxman/document_psivariables.pl; * For now, we’re scraping both global and Wfn variables; * All of these show up in referenceable appendices like apdx:detci_psivar; Plugins: doc.rst text, *.py modules, and C++ keywords in psi4/tests/plugin_* plugin directories (disabled at the moment); PSI Files: scratch file names and numbers in psi4/psi4/include/psi4/psifiles.h. Some documentation is even extracted from PSI4 objects at runtime. psi4: docstrings for the C++ submodule psi4.core and the Python submodule psi4.driver that comprise PSI4. C++ docstrings from “core” and “export” files in psi4/psi4/src/, and Py docstrings from psi4/psi4/driver/.; DFT: functio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/documentation-1.html:3209,variab,variable,3209,psi4manual/1.4.0/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/documentation-1.html,18,['variab'],['variable']
Modifiability,"is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:36436,variab,variable,36436,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,6,['variab'],['variable']
Modifiability,"is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name == 'mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'fno-mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4); elif name == 'mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:124768,variab,variable,124768,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"is is typically the; first layer encountered, Libmints handles the transform from AO to SO; automatically. If Cartesian functions are used, the number of functions; per shell remains (L + 1)(L + 2)/2, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a PSI4 Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, …. USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:10511,adapt,adapted,10511,psi4manual/1.2.1/prog_blas-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html,4,['adapt'],['adapted']
Modifiability,"is problem. Caution; In early versions (notably PSI4 alpha circa 2011; and before), frozen core was implemented incompletely and for; only selected terms. Comparisons with papers published using early; PSI4 SAPT code may show discrepancies of 0.01-0.10 kcal/mol in; individual terms, particularly \(E_{exch}^{(11)}\) and \(E_{exch}^{(12)}\). Caution; January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total SAPT energy psivars were renamed. Caution; February 7, 2020, a missing term in \(E^{(30)}_{ind}\) was added, causing; possible discrepancies with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in \(V\). For; a complete description of SAPT, the reader",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:1556,adapt,adapted,1556,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,2,['adapt'],['adapted']
Modifiability,"ises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_to_shell(...); | ao_to_shell( (BasisSet)arg1, (int)arg2) -> int :; | docstring; | ; | C++ signature :; | i ao_to_shell(N3psi8BasisSetE {lvalue},i); | ; | decontract(...); | decontract( (BasisSet)arg1) -> BasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi8BasisSetEEE decontract(N3psi8BasisSetE {lvalue}); | ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:374849,inherit,inherited,374849,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | a1(...); | a1( (Dispersion)arg1) -> float :; | docstring; | ; | C++ signature :; | d a1(N3psi10DispersionE {lvalue}); | ; | a2(...); | a2( (Dispersion)arg1) -> float :; | docstring; | ; | C++ signature :; | d a2(N3psi10DispersionE {lvalue}); | ; | bibtex(...); | bibtex( (Dispersion)arg1) -> str :; | Get the BibTeX key for the lit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:433762,inherit,inherited,433762,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ElectrostaticInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | ElectrostaticInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:444738,inherit,inherited,444738,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | C++ signature :; | Ss __getitem__(N3psi7Process11EnvironmentE {lvalue},Ss); | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ---------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:446593,inherit,inherited,446593,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class LaplaceDenominator(Boost.Python.instance); | docstring; | ; | Method resolution order:; | LaplaceDenominator; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Vector)arg2, (Vector)arg3, (float)arg4) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE,d); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | denominator_occ(...); | denominator_occ( (LaplaceDenominator)arg1) -> Matrix :; | docstring",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:507367,inherit,inherited,507367,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (IntegralFactory)arg4, (MatrixFactory)arg5) -> None :; | ; | C++ signature :; | void __init__(P7_object,i,N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost10shared_ptrIN3psi15IntegralFactoryEEE,N5boost10shared_ptrIN3psi13MatrixFactoryEEE); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:561479,inherit,inherited,561479,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void add(N3psi6OEPropE {lvalue},Ss); | ; | clear(...); | clear( (OEProp)arg1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:565584,inherit,inherited,565584,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PMLocalizer(Localizer); | docstring; | ; | Method resolution order:; | PMLocalizer; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inheri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:575218,inherit,inherited,575218,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:581550,inherit,inherited,581550,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = psi4.PsiReturnType.Balk; | ; | EndLoop = psi4.PsiReturnType.EndLoop; | ; | Failure = psi4.PsiReturnType.Failure; | ; | Success = psi4.PsiReturnType.Success; | ; | names = {'Balk': psi4.PsiReturnType.Balk, 'EndLoop': psi4.PsiReturnTyp...; | ; | values = {0: psi4.PsiReturnType.Success, 1: psi4.PsiReturnType.Failure...; | ; | ---------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:586254,inherit,inherited,586254,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inheri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:593421,inherit,inherited,593421,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class TwoBodyAOInt(Boost.Python.instance); | docstring; | ; | Method resolution order:; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:634694,inherit,inherited,634694,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"isites¶. C++ Compiler. F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. A version of MPI is required to compile distributed-parallel PSI;; MPICH2 is recommended.; (Note: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g+",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:1452,config,config,1452,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['config']
Modifiability,"isites¶. C++ Compiler. F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:1452,config,config,1452,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['config']
Modifiability,"isites¶. C++ Compiler. F77 Compiler (the F95 compiler, gfortran, with gcc-4.X will work). Note; The F77 compiler is only used to determine the symbol-naming; convention of and some system routines for the BLAS and LAPACK libraries; on a few architectures. It is optional in a few cases (e.g. Mac OS X; systems). Optimized BLAS library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). Optimized LAPACK library (preferably NOT one supplied by a standard; Linux distribution; see recommendations at Section IV below). POSIX threads (Pthreads) library (optional). Python interpreter (2.6 or higher; psi4 is Python3 compatible). Python developer libraries corresponding to your interpreter. Note; To check to see if you have the Python developer libraries; installed look for the Python config program. If your Python interpreter; is named python look for the config program python-config,; likewise if your interpreter is python2.6, the config program is; python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. Mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:1452,config,config,1452,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['config'],['config']
Modifiability,"ispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/interfacing.html:2717,config,configure,2717,psi4manual/1.7.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/interfacing.html,1,['config'],['configure']
Modifiability,"ispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/interfacing.html:2719,config,configure,2719,psi4manual/1.8.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/interfacing.html,1,['config'],['configure']
Modifiability,"ispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/interfacing.html:2719,config,configure,2719,psi4manual/1.9.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/interfacing.html,1,['config'],['configure']
Modifiability,"isplayed.; More detailed documentation about adcc and its features can be found; at https://adc-connect.org,; especially the theory section.; If you are using adcc from PSI4 for your calculations,; please cite both PSI4 as well as adcc [Herbst2020]; in your published work.; The ADC wavefunction object.; After running the ADC calculation in adcc, the interface code sets; a number of variables in the returned Wavefunction; in case they are computed.; In the following the <method> prefix refers to the ADC method (such as adc(1),; adc(3), cvs-adc(2)-x). Ground state energy terms like MP2 correlation energy, MP3 correlation energy,; MP2 total energy, MP3 total energy, current correlation energy and current energy.; MP2 dipole X and the other components: Ground state dipole moments at MP(2) level.; number of iterations: The number of iterations the iterative solver required to converge.; number of excited states: The number of excited states, which were computed.; More variables are summarized in PSI Variables by Alpha. The following attribute is set on returned wavefunctions:. adcc_state: The adcc.ExcitedStates; object used by adcc to store the ADC(n) excitation energies and all precomputed data; in the format used by adcc.; Provides direct access to analysis and plotting capabilities from adcc.; For example adcc_state.plot_spectrum() plots a broadened excited states spectrum; in matplotlib. See the adcc calculations documentation; for details. Tips for convergence issues.; If you encounter convergence issues inside adcc, the following parameters; are worth tweaking:. MAX_NUM_VECS: Specifies the maximal number of subspace vectors; in the Jacobi-Davidson scheme before a restart occurs. The defaults are usually; good, but do not be shy to increase this value if you encounter convergence problems.; NUM_GUESSES: By default adcc uses twice as many guess vectors as; states to be computed. Sometimes increasing this value by a few vectors can be helpful.; If you encounter a conv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/adc.html:10989,variab,variables,10989,psi4manual/1.6.x/adc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/adc.html,5,['variab'],['variables']
Modifiability,"isset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:33042,variab,variables,33042,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,18,['variab'],['variables']
Modifiability,"ist[List[Tuple[float, int, int]]]¶; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction) → int¶; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of symmetry orbitals per irrep. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. set_array(key, val)¶. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html:9480,variab,variable,9480,psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,9,['variab'],['variable']
Modifiability,istic Hamiltonians; SAPT: Symmetry-Adapted Perturbation Theory; SAPT: Symmetry-Adapted Perturbation Theory; HF: Hartree–Fock Theory; HF: Hartree–Fock Theory; Search; Search; Interface to SIMINT by B. Pritchard; Interface to SIMINT by B. Pritchard; Embarrassing Parallelism; Embarrassing Parallelism; Test Suite and Sample Inputs; Test Suite and Sample Inputs; Vibrational and Thermochemical Analysis; Vibrational and Thermochemical Analysis; Psithon Tutorial: Using PSI4 as an Executable; Psithon Tutorial: Using PSI4 as an Executable. /_downloads; . /6b06aea2f974f887d435bebc240ce203; ; gdma-2.2.06.pdf. /_modules; . /psi4; . /driver; ; psi4.driver.aliases; psi4.driver.diatomic; psi4.driver.driver; psi4.driver.driver_cbs; psi4.driver.driver_nbody; psi4.driver.inputparser; psi4.driver.molutil. /p4util; ; psi4.driver.p4util.exceptions; psi4.driver.p4util.fcidump; psi4.driver.p4util.numpy_helper; psi4.driver.p4util.python_helpers; psi4.driver.p4util.text; psi4.driver.p4util.util. psi4.driver.plugin. /procrouting; ; psi4.driver.procrouting.empirical_dispersion. /libcubeprop; ; psi4.driver.procrouting.libcubeprop.cubeprop. psi4.driver.procrouting.proc; psi4.driver.procrouting.proc_util. /scf_proc; ; psi4.driver.procrouting.scf_proc.scf_iterator. /qcdb; ; psi4.driver.qcdb.molecule; psi4.driver.qcdb.parker. psi4.driver.qmmm. /util; ; psi4.driver.util.filesystem. psi4.driver.wrapper_database. /qcdb; ; qcdb.interface_gcp. Overview: module code. /_static; ; basic.css; cloud.base.js; cloud.css; cloud.js; doctools.js; documentation_options.js; favicon-psi4.ico; graphviz.css; jquery.cookie.js; jquery.js; language_data.js; psi4.css; pygments.css; searchtools.js; underscore.js. ADC: Ab Initio Polarization Propagator; ADC: Ab Initio Polarization Propagator; Adding Test Cases; Adding Test Cases. /api; ; adc; adc; AngularMomentumInt; AOShellCombinationsIterator; array_variable; array_variable; array_variables; array_variables; BasisExtents; BasisFunctions; BasisSet; be_quiet; be_quiet; bench,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:501764,plugin,plugin,501764,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['plugin']
Modifiability,"isting_exp > candidate_exp: # candidate has more digits; places = Decimal(10) ** (existing_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILING)); if (self[key].quantize(places, rounding=ROUND_CEILING).compare(value.quantize(places, rounding=ROUND_CEILING)) != 0) and \; (self[key].quantize(places, rounding=ROUND_FLOOR).compare(value.quantize(places, rounding=ROUND_FLOOR)) != 0):; raise ParsingValidationError(; """"""Output file yielded both %s and %s as values for quantity %s."""""" %; (self[key].to_eng_string(), value.to_eng_string(), key)); #print 'Resetting variable %s to %s' % (key, best_value.to_eng_string()); else:; best_value = value; #print 'Setting variable %s to %s' % (key, best_value.to_eng_string()); super(PreservingDict, self).__setitem__(key, best_value). [docs] def update(self, *args, **kwargs):; if args:; if len(args) > 1:; raise TypeError(""update expected at most 1 arguments, ""; ""got %d"" % len(args)); other = dict(args[0]); for key in other:; self[key] = other[key]; for key in kwargs:; self[key] = kwargs[key]. [docs] def setdefault(self, key, value=None):; if key not in self:; self[key] = value; return self[key]. if __name__ == '__main__':; c4info = PreservingDict(); c4info['scf 4.5e0 total energy'] = '-1.e-4'; c4info['1.3'] = '.4'; c4info['curl'] = '-437.12345678'; c4info['curl'] = '-437.12345677'; c4info['curl'] = '-437.123456'; c4info['curl'] = '-437.123457'; c4info['curl'] = '-437.1234444' # fails; c4info['curl'] = '-437.123456789'; #c4info['curl'] = '-437.1234567779' # fails; print(c4info). Quick search. Enter search ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:3048,variab,variable,3048,psi4manual/1.0.0/_modules/qcdb/pdict.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html,1,['variab'],['variable']
Modifiability,"istribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes."""""". [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html:1785,variab,variables,1785,psi4manual/4.0b5/_modules/qcdb/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/exceptions.html,2,['variab'],['variables']
Modifiability,"it in place,; rather than running make after each change. Easiest is from; <objdir>, run pytest ../tests/pytests. Add any filters (-k; test_name_fragment) or parallelism (-n <N> if pytest-xdist; installed) or print test names (-v) or print warnings (-rws). To; see stdout output from an otherwise passing test, easiest to add assert; 0 at its end to trigger failure. An important point is that because; they’re PsiAPI, import psi4 is happening, so the <objdir> PSI4; module must be in PYTHONPATH. Also, any call to QCEngine is; using which psi4, so the <objdir> PSI4 executable must be in; PATH. The easiest way to prepare your local environment is to; execute the printout of <objdir>/stage/bin/psi4 --psiapi. Test must be in the psi4/tests/pytests/ directory.; Test file name must start with test_. This is how pytest knows to collect it.; Test file may contain many tests. To be recognized as a test, the Python function must start with test_.; No registration required to bring a test to pytest’s attention. There are individual “marks” that can be added to whole tests or parts; of parameterized tests so that they can be run by category (pytest -m; <mark> vs. ctest -L <mark>) rather than just by name (pytest -k; <name_fragment> vs. ctest -R <name_fragment>). Most important are; “quick” and “long” that opt tests into the quick CI suite or out of; the normal full suite. Mark with a decorator for the full test or the; marks argument in a parameterized test. Search “mark” in the test suite; for examples. Use “quick” freely for tests that cover functionality and; are under 15s. Use “long” sparingly to winnow out the longest examples,; particularly those over a minute. table of contents. Adding PSIthon Test Cases; Adding PsiAPI Test Cases. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Adding PSIthon Test Cases. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/add_tests-1.html:5350,parameteriz,parameterized,5350,psi4manual/1.4.0/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/add_tests-1.html,4,['parameteriz'],['parameterized']
Modifiability,"it in place,; rather than running make after each change. Easiest is from; <objdir>, run pytest ../tests/pytests. Add any filters (-k; test_name_fragment) or parallelism (-n <N> if pytest-xdist; installed) or print test names (-v) or print warnings (-rws). To; see stdout output from an otherwise passing test, easiest to add assert; 0 at its end to trigger failure. An important point is that because; they’re PsiAPI, import psi4 is happening, so the <objdir> PSI4; module must be in PYTHONPATH. Also, any call to QCEngine is; using which psi4, so the <objdir> PSI4 executable must be in; PATH. The easiest way to prepare your local environment is to; execute the printout of <objdir>/stage/bin/psi4 --psiapi. Test must be in the psi4/tests/pytests/ directory.; Test file name must start with test_. This is how pytest knows to collect it.; Test file may contain many tests. To be recognized as a test, the Python function must start with test_.; No registration required to bring a test to pytest’s attention. There are individual “marks” that can be added to whole tests or parts; of parameterized tests so that they can be run by category (pytest -m; <mark> vs. ctest -L <mark>) rather than just by name (pytest -k; <name_fragment> vs. ctest -R <name_fragment>). Most important are; “quick” and “long” that opt tests into the quick CI suite or out of; the normal full suite. Mark with a decorator for the full test or the; marks argument in a parameterized test. Search “mark” in the test suite; for examples. Use “quick” freely for tests that cover functionality and; are under 15s. Use “long” sparingly to winnow out the longest examples,; particularly those over a minute. table of contents. Adding PSIthon Test Cases; Adding PsiAPI Test Cases. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Adding PSIthon Test Cases. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/add_tests-1.html:5350,parameteriz,parameterized,5350,psi4manual/1.5.0/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/add_tests-1.html,4,['parameteriz'],['parameterized']
Modifiability,"it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56 | begin{tabular}{ccc} | Value & Method & Description \ | hline | 1 & CC & \ | 2 & CC(n-1)[n] & \ | 3 & CC(n-1)(n) & (CC(n-1)[n] energy is also calculated) \ | 4 & CC(n-1)(n)_L & (CC(n-1)[n] and CC(n-1)(n) energies are also calculated) \ | 5 & CC(n)-1a & \ | 6 & CC(n)-1b & \ | 7 & CCn & \ | 8 & CC(n)-3 & \ | end{tabular}. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. Table Of Contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. Previous topic; WFN; Next topic; E_CONVERGENCE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__mrcc-1.html:1882,variab,variable,1882,psi4manual/4.0b2/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__mrcc-1.html,8,['variab'],['variable']
Modifiability,"it__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class TwoElectronInt(TwoBodyAOInt); | docstring; | ; | Method resolution order:; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> None :; | docstring; | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:135656,inherit,inherited,135656,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"it__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class TwoElectronInt(TwoBodyAOInt); | docstring; | ; | Method resolution order:; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | -----------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:637145,inherit,inherited,637145,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ith PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compila",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:3664,config,configuration,3664,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configuration']
Modifiability,"ith an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples.; The equivalent Python PsiAPI syntax is shown alongside the Psithon code snippets.; When using the Python API, one must import the PSI4 module with:; import psi4. No such directive is neccesary when using Psithon, which is run using the psi4; executable. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:1578,variab,variable,1578,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['variab'],['variable']
Modifiability,"ith conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility; I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4.; In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub; I want to develop using PSI4 infrastructure and libraries, not; on them; I think a plugin might do.; I’ve got a PSI4 compilation. Use it, then consult plugins; I’d rather not compile PSI4 or I don’t have compilers —; Goto Binary-Package then consult; plugins through conda. I really like parentheses and/or DBOC, so I want Psi3. —; Goto Psi3-from-SourceForge. Binary Installer¶. Get Initially; Just go to http://www.psicode.org/downloads.html and follow the; instructions there. Build; Not applicable as binary is pre-built. Get Updates directions; >>> conda update psi4. Contribute Back; Not applicable as not under git control. Conda Binary Package¶. Get Initially; The pre-compiled conda packages at https://anaconda.org/psi4/psi4; can be installed into an existing Anaconda or Miniconda distribution; according to directions. Locally, install into; a conda environment as below.; >>> conda create -n p4env psi4 -c psi4; >>> conda activate p4env. Build; Not applicable as binary is pre-built. Get Updates directions; >>> conda update psi4 -c psi4. Contribute Back; Not applicable as not under git control. Clone from GitHub Repository¶. Get Initially; The PSI4 repository at https://github.com/psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_obtaining-1.html:2193,plugin,plugins,2193,psi4manual/1.3.2/build_obtaining-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_obtaining-1.html,4,['plugin'],['plugins']
Modifiability,"ith standard DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(). © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gdma.html:6351,config,configdir,6351,psi4manual/1.7.x/gdma.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gdma.html,2,['config'],"['configdir', 'configure']"
Modifiability,"ith this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import print_function. [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. [docs]class ParsingValidationError(QcdbException):; """"""Error called for problems with syntax from a QC output file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class FragmentCountError(QcdbException):; """"""Error called molecule has wrong number of fragments for method.; Prints error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; #print('\nQcdbException: %s\n\n' % (msg)). [docs]class BasisSetFileNotFound(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbExce",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html:1831,variab,variables,1831,psi4manual/1.0.0/_modules/qcdb/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html,1,['variab'],['variables']
Modifiability,"ithin irrep (h) to its energy-sorted index among all roots. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:26596,variab,variables,26596,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variables']
Modifiability,"ithon input, not PsiAPI.; It does nothing that can’t be done in other more transparent ways.; It should be avoided.; It is very easy to forget about the ~/.psi4rc file you once; created, leading to great confusion over why all your jobs are using; the wrong memory or are suddenly not density-fit. Also be aware that; ~/.psi4rc contents count as part of your input file (invoked after; e.g. from psi4 import * and before your Psithon–>Python parsed; input commands), so these settings take priority over command-line; arguments to the psi4 executable.; Please use the ~/.psi4rc file sparingly. If using the environment variable PSI_SCRATCH is inconvenient,; or if some psi4_io commands must be present in all input files,; the ~/.psi4rc resource file can be used (example psi4/samples/example_psi4rc_file).; All the commands mentioned in section Scratch Files can be used in this file.; To set up the scratch path:; psi4_io.set_default_path('/scratch/user'). To set up the scratch path from a variable $MYSCRATCH:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). To set up a specific path for the internal coordinate file and instruct PSI4 not to delete it:; psi4_io.set_specific_path(12, './'); psi4_io.set_specific_retention(12, True). # equivalent to above; psi4_io.set_specific_path(PSIF_INTCO, './'); psi4_io.set_specific_retention(PSIF_INTCO, True). The Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. As a consequence, the commands in the input files supersede; any instructions in the ~/.psi4rc file. During; execution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed.; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threadi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:10321,variab,variable,10321,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['variab'],['variable']
Modifiability,"ithout CheMPS2. >>> cmake. Build bundled with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5. Link against pre-built. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root. >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir. Link against pre-built with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=""/path/to/chemps2/root;/path/to/hdf5/root"". Build bundled despite pre-built being detectable. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/chemps2/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_CheMPS2=ON. How to fix “plugin needed to handle lto object” when building CheMPS2¶; For building with GCC, errors involving unresolved symbols or a message; “plugin needed to handle lto object” may indicate a failure of the; interprocedural optimization. This can be resolved by passing full; locations to gcc toolchain utilities to setup or cmake:; -DCMAKE_RANLIB=/path/to/gcc-ranlib -DCMAKE_AR=/path/to/gcc-ar .; Details at https://github.com/psi4/psi4/issues/414. table of contents. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/chemps2-1.html:7848,config,configure,7848,psi4manual/1.1.0/chemps2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/chemps2-1.html,4,"['config', 'plugin']","['configure', 'plugin']"
Modifiability,"itive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). print_vector(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: int) → None¶; docstring. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. rotate_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector, arg2: psi4.core.Vector) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPot",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:24822,variab,variable,24822,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"itterE {lvalue}); | ; | setAuxiliary(...); | setAuxiliary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | C++ signature :; | void setAuxiliary(N3psi14DFChargeFitterE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE); | ; | setD(...); | setD( (DFChargeFitter)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void setD(N3psi14DFChargeFitterE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE); | ; | setPrimary(...); | setPrimary( (DFChargeFitter)arg1, (BasisSet)arg2) -> None :; | docstring; | ; | C++ signature :; | void setPrimary(N3psi14DFChargeFitterE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DFTensor(Boost.Python.instance); | docstring; | ; | Method resolution order:; | DFTensor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Idfmo(...); | Idfmo( (DFTensor)arg1) -> Matrix :; | doctsring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Idfmo(N3psi8DFTensorE {lvalue}); | ; | Imo(...); | Imo( (DFTensor)arg1) -> Matrix :; | doctsring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Imo(N3psi8DFTensorE {lvalue}); | ; | Qmo(...); | Qmo( (DFTensor)arg1) -> Matrix :; | doctsring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Qmo(N3psi8DFTensorE {lvalue}); | ; | Qoo(...); | Qoo( (DFTensor)arg1) -> Matrix :; | doctsring; | ; | C++ signature :; | N5boost10shared_pt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:421342,inherit,inherited,421342,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ive Gaussian; basis functions. This is set to f-type functions (AM=3) by default. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.53.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir=PATH configure flags. If a; default or user-specified boost installation is found to be incomplete,; incompatible, or nonexistent, boost 1.53.0 will be unpacked automatically; and built as part of the PSI4 build process.; Required Compiled Boost Modules (all Boost 1.46.0 or later):. Filesystem; Python; Regex; Serialization; System; Thread. Relevant Configure Options:. --with-boost[=value] — Use Boost library from a standard location; if yes (default), from the specified location if <path>, or disable; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:14388,variab,variable,14388,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,3,"['config', 'variab']","['configure', 'variable']"
Modifiability,"iven, the option; value and has_changed value is stored for global, local to module, and used by; module scopes; otherwise (used for BASIS keywords), only global scope is stored.; Class can store, print, and restore option values.; >>> OptionState('SCF_TYPE', 'SCF'). >>> print(OptionState('DF_BASIS_MP2')). restore()[source]¶. class OptionsState(*largs)[source]¶; Class to contain multiple OptionsState() objects.; Used in python driver functions to collect several options before altering; them, then restoring before function return.; >>> optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). restore()[source]¶. Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. class Table(rows=(), row_label_width=10, row_label_precision=4, cols=(), width=16, precision=10)[source]¶; Class defining a flexible Table object for storing data. absolute_to_relative(Factor=627.5095)[source]¶; Function to shift the data of each column of the Table object; such that the lowest value is zero. A scaling factor of Factor is applied. copy()[source]¶; Function to return a copy of the Table object. format_label()[source]¶; Function to pad the width of Table object labels. format_values(values)[source]¶; Function to pad the width of Table object data cells. save(file)[source]¶; Function to save string of the Table object to file. scale(Factor=627.5095)[source]¶; Function to apply a scaling factor Factor to the; data of the Table object. banner(text, type=1, width=35)[source]¶; Function to print text to output file in a banner of; minimum width width and minimum three-line height for; type = 1 or one-line height for type = 2. print_stderr(stuff)[source]¶; Function to print stuff to standard error stream. print_stdout(stuff)[source]¶; Function to print stu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:33433,flexible,flexible,33433,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['flexible'],['flexible']
Modifiability,iver.p4util. PCM_SCF_TYPE (PCM). PCMSolver. PCMSOLVER_PARSED_FNAME (PCM). PE. Using PE. PE (GLOBALS). PE ENERGY. PE_ECP (PE). PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). perturb_grad() psi4.core.MintsHelper method. PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() psi4.core.MintsHelper method. psi4.core.SOBasisSet method. petite_list1() psi4.core.MintsHelper method. PetiteList class in psi4.core. PHI_POINTS (SCF). physconst. physical constants. pitzer_to_ci_order_onel() psi4.core.CIWavefunction method. pitzer_to_ci_order_twoel() psi4.core.CIWavefunction method. PK_ALL_NONSYM (SCF). PK_MAX_BUCKETS (SCF). plan() psi4.driver.AtomicComputer method. psi4.driver.driver_cbs.CompositeComputer method. psi4.driver.driver_findif.FiniteDifferenceComputer method. psi4.driver.driver_nbody.ManyBodyComputer method. psi4.driver.task_base.BaseComputer method. play() psi4.core.MintsHelper method. plot() psi4.core.FISAPT method. plugin. ; v2rdm_casscf. plugin() in module psi4.core. plugin_close() in module psi4.core. plugin_close_all() in module psi4.core. plugin_load() in module psi4.core. plump_qcvar() in module psi4.driver.p4util. PMLocalizer class in psi4.core. PNO_CONVERGENCE (DLPNO). point_group() psi4.core.Molecule method. point_values() psi4.core.PointFunctions method. PointFunctions class in psi4.core. PointGroup class in psi4.core. POINTS (FINDIF). pop() psi4.core.BSVec method. populateExtern() psi4.driver.QMMMbohr method. position_camera() psi4.driver.p4util.InPsight method. potential_grad() psi4.core.MintsHelper method. potential_integral() psi4.core.NumIntHelper method. potential_variable() psi4.core.Wavefunction method. potential_variables() psi4.core.Wavefunction method. PotentialInt class in psi4.core. POTFILE (PE). power() psi4.core.Matrix method. PPL_TYPE (DFOCC). precondition() psi4.driver.p4util.SolverEngine method. PRECONDITIONER (DETCI). prefactor_ecd() in module psi4.driver.p4util. prefacto,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/genindex.html:87599,plugin,plugin,87599,psi4manual/1.8.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/genindex.html,1,['plugin'],['plugin']
Modifiability,"iver_cbs._cbs_gufunc(properties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:50871,variab,variables,50871,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['variab'],['variables']
Modifiability,"ivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:9113,config,configure,9113,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['configure']
Modifiability,"iwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135596,variab,variable,135596,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"ixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libefp-1.html:8041,variab,variable,8041,psi4manual/1.2.1/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libefp-1.html,13,['variab'],['variable']
Modifiability,"ization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs.; MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal.; LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_blas-1.html:11740,adapt,adapted,11740,psi4manual/1.4.0/prog_blas-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_blas-1.html,9,['adapt'],['adapted']
Modifiability,"ization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to fix error “RuntimeError: value for ERI”¶; You will need to rebuild Libint. Reissue cmake or edit; CMakeCache.txt with larger MAX_AM_ERI and rebuild. How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir; cd {top-level-psi4-dir} && cmake -H. -Bobjdir; cd {top-level-psi4-dir} && cmake -H. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-level-psi4-dir are permitted. How to save configuration settings for a future compilation¶; Create a file like do-configure with the cmake command and options; on one line.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> cd {top-level-psi4-dir}; >>> cat do-configure; cmake -H. -B{objdir} \; -DCMAKE_INSTALL_PATH=""/Users/me/psi4"" \; -DCMAKE_PREFIX_PATH=""/Users/me/externals/install-libint"" \; -DMAX_AM_ERI=6 \; -DENABLE_gdma=ON \; -DBUILD_SHARED_LIBS=ON; >>> chmod u+x do-configure; >>> ./do-configure. What is the directory layout of the installed or staged Psi4¶; After compilation (cd objdir && make), a directory structure like the; below will exist at objdir/stage. This may be tested and used; just like a full installation.; After installation (cd objdir && make && make install), a directory; structure like the below will exist at /prefix. This is a full; installation.; /; bin/ (executables for psi4 + any external proj); bin/psi4 (psi4 executable, actually just a py script); include/ (installed headers for psi4 + any external proj); include/psi4/ (header files for #include-ing); include/psi4/psi4-dec.h (primary psi4 header); include/psi4/masses.h (a project-wide psi4 header); include/psi4/libmints/ (psi4 library hea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:20294,config,configure,20294,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['config'],['configure']
Modifiability,"ization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to fix error “RuntimeError: value for ERI”¶; You will need to rebuild Libint. Reissue cmake or edit; CMakeCache.txt with larger MAX_AM_ERI and rebuild. How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir; cd {top-level-psi4-dir} && cmake -H. -Bobjdir; cd {top-level-psi4-dir} && cmake -H. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-level-psi4-dir are permitted. How to save configuration settings for a future compilation¶; Create a file like do-configure with the cmake command and options; on one line.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> cd {top-level-psi4-dir}; >>> cat do-configure; cmake -H. -B{objdir} \; -DCMAKE_INSTALL_PATH=""/Users/me/psi4"" \; -DCMAKE_PREFIX_PATH=""/Users/me/externals/install-libint"" \; -DMAX_AM_ERI=6 \; -DENABLE_gdma=ON \; -DBUILD_SHARED_LIBS=ON; >>> chmod u+x do-configure; >>> ./do-configure. What is the directory layout of the installed or staged Psi4¶; After compilation (cd objdir && make), a directory structure like the; below will exist at objdir/stage/prefix. This may be tested and used; just like a full installation.; After installation (cd objdir && make && make install), a directory; structure like the below will exist at /prefix. This is a full; installation.; /; bin/ (executables for psi4 + any external proj); bin/psi4 (psi4 executable, actually just a py script); include/ (installed headers for psi4 + any external proj); include/psi4/ (header files for #include-ing); include/psi4/psi4-dec.h (primary psi4 header); include/psi4/masses.h (a project-wide psi4 header); include/psi4/libmints/ (psi4 libr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:19343,config,configure,19343,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['config'],['configure']
Modifiability,"izationally, this module isolates qcdb code from psi4 code. """"""; import inspect; import os; import re; import shutil; import subprocess; import sys; import uuid. import qcelemental as qcel. from psi4 import core. from .. import p4util, qcdb; from ..p4util.exceptions import *. # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]; def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT within will be used. :type genbas: str; :param genbas:. Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/interface_cfour.html:2277,Variab,Variables,2277,psi4manual/1.9.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/interface_cfour.html,2,['Variab'],['Variables']
Modifiability,"ize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn, hess=None, irrep=None, molecule=None, project_trans=True, project_rot=True):; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn : :py:class:`~psi4.core.Wavefunction`; The wavefunction which had its Hessian computed.; hess : ndarray of float, optional; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep : int or string; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:73413,variab,variable,73413,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['variab'],['variable']
Modifiability,izer; PointFunctions; PointGroup; PotentialInt; prepare_options_for_module; PrimitiveType; print_global_options; print_options; print_out; print_variables; Prop; ProtoIntVector; ProtoVector; psi_top_srcdir; psimrcc; psio_entry; PsiReturnType; QuadrupoleInt; reopen_outfile; revoke_global_option_changed; revoke_local_option_changed; RHF; RKSFunctions; ROHF; run_gdma; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; AtomicComputer; banner; basis_helper; cbs; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicates; energies_from_fcidump; expand_psivars; fcidump; f,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:792433,variab,variables,792433,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['variab'],['variables']
Modifiability,izer; PointFunctions; PointGroup; PotentialInt; prepare_options_for_module; PrimitiveType; print_global_options; print_options; print_out; print_variables; Prop; ProtoIntVector; ProtoVector; psi_top_srcdir; psimrcc; psio_entry; PsiReturnType; QuadrupoleInt; reopen_outfile; revoke_global_option_changed; revoke_local_option_changed; RHF; RKSFunctions; ROHF; run_gdma; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; AtomicComputer; banner; basis_helper; cbs; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; libint2_configuration; libint2_print_out; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicates; energie,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:822782,variab,variables,822782,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['variab'],['variables']
Modifiability,"ject at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:35084,variab,variables,35084,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variables']
Modifiability,"ject,N3psi7OptionsE {lvalue}); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | compute(...); | compute( (EFP)arg1) -> None :; | Computes libefp energies and, if active, torque; | ; | C++ signature :; | void compute(N3psi3efp3EFPE {lvalue}); | ; | nfragments(...); | nfragments( (EFP)arg1) -> int :; | Returns the number of EFP fragments in the molecule; | ; | C++ signature :; | i nfragments(N3psi3efp3EFPE {lvalue}); | ; | print_out(...); | print_out( (EFP)arg1) -> None :; | Prints options settings and EFP and QM geometries; | ; | C++ signature :; | void print_out(N3psi3efp3EFPE {lvalue}); | ; | set_qm_atoms(...); | set_qm_atoms( (EFP)arg1) -> None :; | Provides libefp with QM fragment information; | ; | C++ signature :; | void set_qm_atoms(N3psi3efp3EFPE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ERI(TwoElectronInt); | docstring; | ; | Method resolution order:; | ERI; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:441404,inherit,inherited,441404,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Dispersion"", saptd_en['DISP'] * units[0], saptd_en['DISP'] * units[1], saptd_en['DISP'] * units[2])); core.print_out("" %-27s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Total "" + saptd_name + ""-D"", total * units[0], total * units[1], total * units[2])); core.print_out("" "" + ""-"" * 104 + ""\n""). if saptd_name == ""FISAPT0"":; pw_disp = dimer_wfn.variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS""); pw_disp.name = 'Empirical_Disp'; filepath = core.get_option(""FISAPT"", ""FISAPT_FSAPT_FILEPATH""); fisapt_proc._drop(pw_disp, filepath). return dimer_wfn. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.procrouting.proc_util. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:11191,variab,variable,11191,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,2,['variab'],['variable']
Modifiability,"join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Dispersion"", saptd_en['DISP'] * units[0], saptd_en['DISP'] * units[1], saptd_en['DISP'] * units[2])); core.print_out("" %-27s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Total "" + saptd_name + ""-D"", total * units[0], total * units[1], total * units[2])); core.print_out("" "" + ""-"" * 104 + ""\n""). if saptd_name == ""FISAPT0"":; pw_disp = dimer_wfn.variable(""PAIRWISE DISPERSION CORRECTION ANALYSIS""); pw_disp.name = 'Empirical_Disp'; filepath = core.get_option(""FISAPT"", ""FISAPT_FSAPT_FILEPATH""); fisapt_proc._drop(pw_disp, filepath). return dimer_wfn. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; psi4.driver.procrouting.proc_util. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc_util.html:11191,variab,variable,11191,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc_util.html,2,['variab'],['variable']
Modifiability,"k( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | tocclean( (IO)arg1, (int)arg2, (str)arg3) -> None :; | docstring; | ; | tocprint(...); | tocprint( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | tocwrite(...); | tocwrite( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | change_file_namespace(...); | change_file_namespace( (int)arg1, (str)arg2, (str)arg3) -> None :; | docstring; | ; | get_default_namespace(...); | get_default_namespace() -> str :; | docstring; | ; | set_default_namespace(...); | set_default_namespace( (str)arg1) -> None :; | docstring; | ; | shared_object(...); | shared_object() -> IO; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IOManager(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IOManager; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | crashclean(...); | crashclean( (IOManager)arg1) -> None :; | docstring; | ; | get_default_path(...); | get_default_path( (IOManager)arg1) -> str :; | docstring; | ; | get_file_path(...); | get_file_path( (IOManager)arg1, (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:31498,inherit,inherited,31498,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"k=""-L/opt/acml5.2.0/gfortran64_mp/lib -lacml_mp"". g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:8429,config,configure,8429,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configure']
Modifiability,"k=""-L/opt/acml5.2.0/gfortran64_mp/lib -lacml_mp"". g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install Xcode.; However, Xcode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with Xcode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:9229,config,configure,9229,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['config'],['configure']
Modifiability,"ke a full installation.; After installation (cd objdir && make && make install), a directory; structure like the below will exist at /prefix. This is a full; installation.; /; bin/ (executables for psi4 + any external proj); bin/psi4 (psi4 executable, actually just a py script); include/ (installed headers for psi4 + any external proj); include/psi4/ (header files for #include-ing); include/psi4/psi4-dec.h (primary psi4 header); include/psi4/masses.h (a project-wide psi4 header); include/psi4/libmints/ (psi4 library headers); include/psi4/libfock/ (ditto); share/ (read-only arch-indep files for psi4 + any external proj); share/cmake/psi4/ (files for detecting installed targets); share/cmake/psi4/psi4Config.cmake (psi4 build/install info); share/cmake/psi4/psi4ConfigVersion.cmake (psi4 version info); share/doc/psi4/html/ (sphinx html documentation); share/psi4/ (text files needed by psi4); share/psi4/basis (basis sets); share/psi4/plugins (plugin template files); share/psi4/fsapt (fsapt scripts); share/psi4/samples/ (sample input files); lib/ (shared libraries and py modules for psi4 + any external proj); # ordinary; lib/psi4/ (object files); lib/psi4/driver/ (py-side, uncompiled); lib/psi4/header.py (prints file header); lib/psi4/__init__.py (module marker/loader for psi4.core); lib/psi4/core.so (c-side, compiled and bound by pybind11); # conda; lib/pythonX.X/site-packages/psi4/. The following environment variables point to certain places in the above; directory structure. None to few need to be set; see for details:; running compiled executable,; running compiled Python module,; running conda binary. PATH pointing to bin; PYTHONPATH pointing to lib (ordinary) or lib/pythonX.X/site-packages (conda); PSIDATADIR pointing to share/psi4. How to run Psi4 as executable after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:17857,plugin,plugins,17857,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,4,['plugin'],"['plugin', 'plugins']"
Modifiability,"kers.; >>> cat ~/.vimrc; set hlsearch; map <F7> :/\(<<<<<<<\\|=======\\|>>>>>>>\)<CR>. How to handle “runtime library may be hidden” when building with Anaconda Python¶; When building against Ana/Miniconda python (e.g., cmake; -DPYTHON_EXECUTABLE=/path/to/conda/bin/python), the warning below often; appears. It is harmless, proceed.; CMake Warning at src/bin/psi4/CMakeLists.txt:58 (add_executable):; Cannot generate a safe runtime search path for target psi4 because files in; some directories may conflict with libraries in implicit directories:. runtime library [libm.so.6] in /usr/lib64 may be hidden by files in:; /theoryfs2/common/software/anaconda/lib. Some of these libraries may not be found correctly. How to set up the scratch directory¶; The scratch directory is where Psi4 stores potentially large files during; computation. It should thus be on a local, fast disk to minimize any; computational inefficiencies caused by I/O. The scratch directory is; commonly set up through the PSI_SCRATCH environment variable:; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. See also the more general scratch documentation. How do I retain specific Psi4 scratch files¶; You can set up a specific path for PSI4 scratch file and keep them; for later use through the psi4_io handler. How to use Psi4 within a PBS queue¶; You will usually need to set up a PBS job script that is setting all; necessary environment variables, making sure the scratch directories are; set up, and invokes the executable. An example PBS script; is provided in the manual, but make sure to also consult your own PBS; documentation for appropriate setup. How to update and rebuild Psi4¶; Obtain code updates as appropriate from Binary Installer,; Clone fro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:44157,variab,variable,44157,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,6,['variab'],['variable']
Modifiability,"kers.; >>> cat ~/.vimrc; set hlsearch; map <F7> :/\(<<<<<<<\\|=======\\|>>>>>>>\)<CR>. How to handle “runtime library may be hidden” when building with Anaconda Python¶; When building against Ana/Miniconda python (e.g., cmake; -DPython_EXECUTABLE=/path/to/conda/bin/python), the warning below often; appears. It is harmless, proceed.; CMake Warning at src/bin/psi4/CMakeLists.txt:58 (add_executable):; Cannot generate a safe runtime search path for target psi4 because files in; some directories may conflict with libraries in implicit directories:. runtime library [libm.so.6] in /usr/lib64 may be hidden by files in:; /theoryfs2/common/software/anaconda/lib. Some of these libraries may not be found correctly. How to set up the scratch directory¶; The scratch directory is where Psi4 stores potentially large files during; computation. It should thus be on a local, fast disk to minimize any; computational inefficiencies caused by I/O. The scratch directory is; commonly set up through the PSI_SCRATCH environment variable:; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. See also the more general scratch documentation. How do I retain specific Psi4 scratch files¶; You can set up a specific path for PSI4 scratch file and keep them; for later use through the psi4_io handler. How to use Psi4 within a PBS queue¶; You will usually need to set up a PBS job script that is setting all; necessary environment variables, making sure the scratch directories are; set up, and invoking the executable. An example PBS script; is provided in the manual, but make sure to also consult your own PBS; documentation for appropriate setup. How to update and rebuild Psi4¶; Obtain code updates as appropriate from Binary Installer,; Clone fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:50561,variab,variable,50561,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['variab'],['variable']
Modifiability,"key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(val)); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). def _core_del_variable(key):; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls, key):; if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables():; return {**core.scalar_variables(), **core.array_variables()}. def _core_wavefunction_variables(cls):; return {**cls.scalar_variables(), **cls.array_variables()}. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; warnings.w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:20835,variab,variables,20835,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variables']
Modifiability,"key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Ta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:27534,variab,variable,27534,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; return self.has_scalar_variable(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; flo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:33949,variab,variable,33949,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"keywords; text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += "" no_com\n""; if self.PYfix_orientation:; text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.flabel(at)); else:; text += "" %-8s"" % (""Gh("" + self.flabel(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:32833,variab,variables,32833,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['variab'],['variables']
Modifiability,"kinetic (\(T=\hat{p}^2/2\)) energy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/relativistic-1.html:4812,extend,extended,4812,psi4manual/1.1.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/relativistic-1.html,2,['extend'],['extended']
Modifiability,"kner orbitals are to be determined for the specified CC method. OFF(=0) Brueckner orbitals are not to be determined, ON (=1) they are to be determined. Type: boolean; Default: false. CFOUR_CACHE_RECS¶. The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL¶. Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Default: SCF. CFOUR_CC_CONV¶. Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than \(10^N\), where \(N\) is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER¶. Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in the solution of the CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION¶. Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Purvis and Bartlett, DIIS (=1) uses the DIIS approach by Pulay, NOJACOBI (=2) uses RLE with continuous extrapolation, OFF (=3) uses no convergence acceleration. In general, DIIS provides the best results and is recommended, while OFF often results in poor convergence and thus cannot be recommended. Type: string; Possible Values: RLE, DIIS, NOJACOBI, OFF; Default: DIIS. CFOUR_CC_MAXCYC¶. Specifies the maximum number of iterations in solving the CC amplitude equations. Type: integer; Default: 50. CFOUR_CC_PROGRAM¶. Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC sho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:8402,enhance,enhance,8402,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,20,['enhance'],['enhance']
Modifiability,"l array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Alpha Density Matrix. Da_subse",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html:13000,variab,variable,13000,psi4manual/1.2.1/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"l array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.DFHelper¶; Bases: pybind11_builtins.pybind11_object; docstring. add_space(self: psi4.core.DFHelper, arg0: str, arg1: psi4.core.Matrix) → None¶. add_transformation(self: psi4.core.DFHelper, name: str, key1: str, key2: str, order: str='Qpq') → None¶. clear_all(self: psi4.core.DFHelper) → None¶. clear_spaces(self: psi4.core.DFHelper) → None¶. get_AO_core(self: psi4.core.DFHelper) → bool¶. get_AO_size(self: psi4.core.DFHelper) → int¶. get_MO_core(self: psi4.core.DFHelper) → bool¶. get_memor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:43313,variab,variable,43313,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variable']
Modifiability,"l array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.atomic_displacements(arg0: psi::Molecule) → List[psi::Matrix]¶; Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:223321,variab,variable,223321,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variable']
Modifiability,"l symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST (SCF); SCF — If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. GUESS_R_CONVERGENCE (DCFT); DCFT — Convergence criterion for the density cumulant and orbital guess for the variationally orbital-optimized DCFT methods. Currently only available for ALGORITHM = SIMULTANEOUS. Type: conv double; Default: 1e-3. GUESS_VECTOR (DETCI); DETCI (Expert) — Guess vector type. Accepted values are UNIT for a unit vector guess (NUM_ROOTS and NUM_INIT_VECS must both be 1); H0_BLOCK to use eigenvectors from the H0 BLOCK submatrix (default); DFILE to use NUM_ROOTS previously converged vectors in the D file;. Type: string; Possible Values: UNIT, H0_BLOCK, DFILE; Default: H0_BLOCK. H0_BLOCK_COUPLING (DETCI); DETCI (Expert) — Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE (DETCI); DETCI (Expert) — Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0. H0_BLOCKSIZE (DETCI); DETCI (Expert) — This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The n determinants with the lowest SCF energy are selected, and a submatrix of the Hamiltonian is formed using these determinants. This submatrix is used to accelerate convergence of the CI iterations in the OLSEN and MITRUSHENKOV iteration schemes, and also to find a good starting guess for the SEM method if GUESS_VECTOR is H0_BLOCK. Defaults to 1000. Note that the program may change the given size for Ms=0 cases (MS0 is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably elimin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:134742,coupling,coupling,134742,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['coupling'],['coupling']
Modifiability,"l yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: LENGTH. GEOM_MAXITER (OPTKING); OPTKING — Maximum number of geometry optimization steps. Type: integer; Default: 20. GUESS (SCF); SCF — The type of guess orbitals. Type: string; Possible Values: CORE, GWH, SAD, READ; Default: CORE. GUESS_VECTOR (DETCI); DETCI (Expert) — Guess vector type. Accepted values are UNIT for a unit vector guess (NUM_ROOTS and NUM_INIT_VECS must both be 1); H0_BLOCK to use eigenvectors from the H0 BLOCK submatrix (default); DFILE to use NUM_ROOTS previously converged vectors in the D file; IMPORT to import a guess previously exported from a CI computation (possibly using a different CI space). Type: string; Possible Values: UNIT, H0_BLOCK, DFILE, IMPORT; Default: H0_BLOCK. H0_BLOCK_COUPLING (DETCI); DETCI (Expert) — Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE (DETCI); DETCI (Expert) — Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0. H0_BLOCKSIZE (DETCI); DETCI (Expert) — This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The n determinants with the lowest SCF energy are selected, and a submatrix of the Hamiltonian is formed using these determinants. This submatrix is used to accelerate convergence of the CI iterations in the OLSEN and MITRUSHENKOV iteration schemes, and also to find a good starting guess for the SEM method if GUESS_VECTOR is H0_BLOCK. Defaults to 400. Note that the program may change the given size for Ms=0 cases (MS0 is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 400. H0_GUESS_SIZE (DETCI); DETCI (Expert) — size of H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:40447,coupling,coupling,40447,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['coupling'],['coupling']
Modifiability,"l yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: LENGTH. GEOM_MAXITER (OPTKING); OPTKING — Maximum number of geometry optimization steps. Type: integer; Default: 50. GUESS (SCF); SCF — The type of guess orbitals. Type: string; Possible Values: CORE, GWH, SAD, READ; Default: CORE. GUESS_VECTOR (DETCI); DETCI (Expert) — Guess vector type. Accepted values are UNIT for a unit vector guess (NUM_ROOTS and NUM_INIT_VECS must both be 1); H0_BLOCK to use eigenvectors from the H0 BLOCK submatrix (default); DFILE to use NUM_ROOTS previously converged vectors in the D file; IMPORT to import a guess previously exported from a CI computation (possibly using a different CI space). Type: string; Possible Values: UNIT, H0_BLOCK, DFILE, IMPORT; Default: H0_BLOCK. H0_BLOCK_COUPLING (DETCI); DETCI (Expert) — Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE (DETCI); DETCI (Expert) — Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0. H0_BLOCKSIZE (DETCI); DETCI (Expert) — This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The n determinants with the lowest SCF energy are selected, and a submatrix of the Hamiltonian is formed using these determinants. This submatrix is used to accelerate convergence of the CI iterations in the OLSEN and MITRUSHENKOV iteration schemes, and also to find a good starting guess for the SEM method if GUESS_VECTOR is H0_BLOCK. Defaults to 400. Note that the program may change the given size for Ms=0 cases (MS0 is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 400. H0_GUESS_SIZE (DETCI); DETCI (Expert) — size of H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:49421,coupling,coupling,49421,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['coupling'],['coupling']
Modifiability,"l(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS/UKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:87095,variab,variables,87095,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variables']
Modifiability,"l); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CompositeJK; docstring. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:10900,adapt,adapted,10900,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,2,['adapt'],['adapted']
Modifiability,"l); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFJCOSK; docstring. DFJLinK; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrost",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:10892,adapt,adapted,10892,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['adapt'],['adapted']
Modifiability,"l); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFJCOSK; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. Exte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psi4api.html:11762,adapt,adapted,11762,psi4manual/1.6.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html,1,['adapt'],['adapted']
Modifiability,"l); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. DIISEntry; docstring. DIISManager; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes ele",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:11762,adapt,adapted,11762,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,2,['adapt'],['adapted']
Modifiability,"l)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE getI(N3psi11PseudoTrialE {lvalue}); | ; | getIPS(...); | getIPS( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE getIPS(N3psi11PseudoTrialE {lvalue}); | ; | getQ(...); | getQ( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE getQ(N3psi11PseudoTrialE {lvalue}); | ; | getR(...); | getR( (PseudoTrial)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE getR(N3psi11PseudoTrialE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PseudospectralInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | PseudospectralInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void comput",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:584577,inherit,inherited,584577,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"l-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. set scf {; basis cc-pvdz; scf_type df; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1,5):; set_num_threads(nthread); energy('scf'). (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; set MODULE_NAME df_ints_num_threads n. to explicitly control the number of threads used for integral formation. Setting; this variable to 0 (the default) uses the number of threads specified by the; set_num_threads() Psithon method or the default environmental variables. PBS job file¶; To run a Psi4 job on a PBS queueing system, you need to properly set up; all necessary variables in the PBS job file. Below is a minimal example of; a PBS job file for a threaded job, and a short explanation for each section.; #!/bin/tcsh; #PBS -j oe; #PBS -l pmem=2120mb; #PBS -N jobname; #PBS -V. setenv OMP_NUM_THREADS 4; setenv MKL_NUM_THREADS 4; cd $PBS_O_WORKDIR; setenv myscratch /scratch/user/psi4.$PBS_JOBID. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Creating scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ssh $i mkdir -p $myscratch; end. unsetenv PSI4DATADIR; unsetenv PSIDATADIR; setenv PSI_SCRATCH $myscratch; if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}; /psi/install/directory/bin/psi4 -i input.in -o input.out. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. The top section features PBS-specific commands. These depend on the; spec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:9809,variab,variables,9809,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['variab'],['variables']
Modifiability,"l.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name == 'mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'fno-mp3':; emp3 = core.variable(""MP3 TOTAL ENERGY""); cemp3 = core.variable(""MP3 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp3); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = core.variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4); elif name == 'mp4':; emp4 = core.variable(""MP4 TOTAL ENERGY""); cemp4 = core.variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:124987,variab,variable,124987,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"l; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, (int)arg3, (int)arg4, (int)arg5, (int)arg6, (float)arg7, (Matrix)arg8, (int)arg9, (Vector)arg10, (int)arg11, (float)arg12, (Vector)arg13, (int)arg14) -> None :; docstring; ; DGEEV(...); DGEEV( (int)arg1, (str)arg2, (str)arg3, (int)arg4, (Matrix)arg5, (int)arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:86058,inherit,inherited,86058,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"l; | ; | __delitem__(...); | __delitem__( (matrix_vector)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (matrix_vector)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (matrix_vector)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (matrix_vector)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (matrix_vector)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class vector_of_doubles(Boost.Python.instance); | docstring; | ; | Method resolution order:; | vector_of_doubles; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (vector_of_doubles)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (vector_of_doubles)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (vector_of_doubles)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (vector_of_doubles)arg1, (object)arg2, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:146610,inherit,inherited,146610,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"l[str]) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False)¶; Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:26160,variab,variable,26160,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['variab'],['variable']
Modifiability,"l_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(name.upper()); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; # retire components at v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE"", core.variable(""CC DIPOLE"")); # core.set_variable(""CC ROOT n DIPOLE"", core.variable(""CC DIPOLE"")) # P::e CCENERGY; if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")); # core.set_variable(""CC ROOT n QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")) # P::e CCENERGY. n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1));",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:100841,variab,variable,100841,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"l_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:131751,variab,variable,131751,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"l_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(""CC""); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")). n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:79914,variab,variable,79914,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"l_option_python = _core_set_global_option_python. ## QCvar helps. def _core_has_variable(key):; return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls, key):; return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key):; if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return core.array_variable(key); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls, key):; if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return cls.array_variable(key); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key, val):; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(val)); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). def _core_wavefunction_set_variable(cls, key, val):; if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:18896,variab,variable,18896,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variable']
Modifiability,"l_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | add(...); | add( (BasisSet)arg1, (BasisSet)arg2) -> BasisSet :; | Adds two basis sets together.; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:3626,inherit,inherited,3626,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"l_variable(self: psi4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:21011,variab,variables,21011,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,16,['variab'],['variables']
Modifiability,"l_x_functional(name):. # Call this first; fun = psi4.Functional.build_base('PBE_X'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('PBEsol_X'); # Tab in, trailing newlines; fun.set_description(' PBEsol GGA Exchange Hole (Parameter Free)\n'); # Tab in, trailing newlines; fun.set_citation(' J.P. Perdew et. al., Phys. Rev. Lett., 77(18), 3865-3868, 1996\n'). # These should be set by build_base, but prove that you know what's up; fun.set_gga(True); fun.set_meta(False); fun.set_alpha(1.0); fun.set_omega(0.0). # Custom parameters; fun.set_parameter('PBE_kp', 0.804); fun.set_parameter('PBE_mu', 10.0 / 81.0). # => End User-Customization <= #. return fun. [docs]def build_pw91_x_functional(name):. # Call this first; fun = psi4.Functional.build_base('PW91_X'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('PW91_X'); # Tab in, trailing newlines; fun.set_description(' PW91 Parameterized GGA Exchange\n'); # Tab in, trailing newlines; fun.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # These should be set by build_base, but prove that you know what's up; fun.set_gga(True); fun.set_meta(False); fun.set_alpha(1.0); fun.set_omega(0.0). # Custom parameters; k01 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); k02 = k01 * k01; k04 = k02 * k02; fun.set_parameter('PW91_a1', 0.19645 / (2.0 * k01)); fun.set_parameter('PW91_a2', 7.79560 / (2.0 * k01)); fun.set_parameter('PW91_a3', 0.27430 / (4.0 * k02)); fun.set_parameter('PW91_a4', 0.15080 / (4.0 * k02)); fun.set_parameter('PW91_a5', 100.000 / (4.0 * k02)); fun.set_parameter('PW91_a6', 0.00400 / (16.0 * k04)). # => End User-Customization <= #. return fun. [docs]def build_b97_x_functional(name):. # Call this first; fun = psi4.Functional.build_base('B97_X'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('B97_X'); # Tab in, trailing newlines; fun.set_des",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:7120,Parameteriz,Parameterized,7120,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,1,['Parameteriz'],['Parameterized']
Modifiability,"lacml_mp"". g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:8472,config,configure,8472,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,2,"['config', 'plugin']","['configure', 'plugins']"
Modifiability,"lacml_mp"". g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install Xcode.; However, Xcode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with Xcode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:9272,config,configure,9272,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,2,"['config', 'plugin']","['configure', 'plugins']"
Modifiability,"lar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:39290,variab,variable,39290,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"lar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:40760,variab,variable,40760,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"larizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/interfacing-1.html:2354,config,configure,2354,psi4manual/1.5.0/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/interfacing-1.html,8,['config'],['configure']
Modifiability,"lass AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description=""AtomicResult return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs] @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs] @validator(""method""); def set_method(cls, method):; return method.lower(). [docs] @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs] def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": {; ""stdout"": True,; },; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs] def compute(self, client: Optional[""FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True; from qcportal.models import KeywordSet, Molecule. # Build the keywords; keyword_id = client.add_keywords([KeywordS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/task_base.html:2941,Config,Config,2941,psi4manual/1.6.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/task_base.html,1,['Config'],['Config']
Modifiability,"lass cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GeometryUnits(Boost.Python.enum); | docstring; | ; | Method resolution order:; | GeometryUnits; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Angstrom = psi4.GeometryUnits.Angstrom; | ; | Bohr = psi4.GeometryUnits.Bohr; | ; | names = {'Angstrom': psi4.GeometryUnits.Angstrom, 'Bohr': psi4.Geometr...; | ; | values = {0: psi4.GeometryUnits.Angstrom, 1: psi4.GeometryUnits.Bohr}; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __get",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:474030,inherit,inherited,474030,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"lation and licensing of the BrianQC module)"" OFF); option(ENABLE_Libint1t ""Enables Libint1 in special _t variety"" OFF); # These options are relevant to pasture, expert only; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF); option(psi4_SKIP_ENABLE_Fortran ""Suppress enabling Fortran language even when Fortran addons enabled. Use when only linking pre-built, not compiling addon code."" OFF). # Append modules added to pasture as needed; if(ENABLE_ccsort OR ENABLE_transqt2); set(ENABLE_pasture ON); message(STATUS ""Enabling pasture plugins""); endif(). if(ENABLE_gdma OR ENABLE_dkh OR ENABLE_erd OR ENABLE_PCMSolver); if(psi4_SKIP_ENABLE_Fortran); message(STATUS ""NOT Enabling Fortran""); else(); enable_language(Fortran); set(Fortran_ENABLED ON) # communicate required languages with psi4-core; message(STATUS ""Enabling Fortran""); endif(); endif(). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recurs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:22470,config,configuration,22470,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,1,['config'],['configuration']
Modifiability,"lation directory, substitute; objdir/stage for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4.; 1; 2; 3; 4; 5; 6; 7; 8>>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. todo how to check if current py is compatible with compilation. How to solve ModuleNotFoundError: No module named 'psi4'¶; You’re using PSI4 in PsiAPI mode (python input.py where; input.py contains import psi4) but the Python interpreter; can’t find the PSI4 Python module. Follow the directions at; How to configure paths for PsiAPI. How to configure paths for PsiAPI¶; If you know the location of the PSI4 executable (bin/psi4); for Psithon mode and want to know the corresponding location to add to; PYTHONPATH for PsiAPI mode, execute psi4 --psiapi-path. It; will return bash commands to set PATH (for correct python; interpreter) and PYTHONPATH (to find psi4 module) correctly,; after which import psi4 will work.; >>> psi4 --psiapi-path; export PATH=/path/to/dir/of/python/interpreter/against/which/psi4/compiled:$PATH; export PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPATH. >>> export PATH=/path/to/dir/of/python/interpreter/against/which/psi4/compiled:$PATH; >>> export PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPATH. >>> python -c ""import psi4"". How to run Psi4 as Python module after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:23846,config,configure,23846,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['config'],['configure']
Modifiability,"lation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:3201,config,configuration,3201,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configuration']
Modifiability,"lation; How to configure a Psi4 build on Cray. Non-QC Dependencies¶. What are the tools and dependencies strictly required for building Psi4; How to configure Python for building Psi4; How to handle “runtime library may be hidden” when building with Anaconda Python; How to configure BLAS/LAPACK for building Psi4; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew. QC Dependencies and Extensions¶. What are the add-on capabilities for Psi4 and what are their dependencies; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; How to set PSIDATADIR and why. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_faq-1.html:2320,config,configure,2320,psi4manual/1.1.0/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_faq-1.html,16,"['config', 'plugin']","['configure', 'plugin']"
Modifiability,"layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/prog_ways_to_add.html:6344,maintainab,maintainability,6344,psi4manual/1.8.x/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/prog_ways_to_add.html,2,"['maintainab', 'plugin']","['maintainability', 'plugins']"
Modifiability,"layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/prog_ways_to_add.html:6344,maintainab,maintainability,6344,psi4manual/1.9.x/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/prog_ways_to_add.html,2,"['maintainab', 'plugin']","['maintainability', 'plugins']"
Modifiability,"lculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into PSI4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the PSI4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in PSI4 allows Cartesians, Z-matrices, mixed; Cartesian/Z-matrix, negation of variables, delayed specification of; variables, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a PSI4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; appropriately in the *CFOUR(...) directive. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Whenever the molecule is supplied in PSI4 format, the job control; keywords must be too. All Cfour keywords are the usual; ones, prepended by cfour_ to avoid any possible name conflicts. As; detailed in Job Control Keywords, setting keywords i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:4131,variab,variables,4131,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,12,['variab'],['variables']
Modifiability,"lculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into Psi4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the Psi4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in Psi4 allows Cartesians, Z-matrices, mixed; Cartesian/Z-matrix, negation of variables, delayed specification of; variables, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a Psi4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; appropriately in the *CFOUR(...) directive. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Whenever the molecule is supplied in Psi4 format, the job control; keywords must be too. All Cfour keywords are the usual; ones, prepended by cfour_ to avoid any possible name conflicts. As; detailed in Job Control Keywords, setting keywords i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:4128,variab,variables,4128,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,4,['variab'],['variables']
Modifiability,"ld without Libxc. Installation¶; Binary. Libxc is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the PSI4 binary, Libxc has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. Previous bullet had details. To build PSI4 from source and use; Libxc from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libxc-1.html:1410,config,configure,1410,psi4manual/1.2.1/libxc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libxc-1.html,4,['config'],['configure']
Modifiability,"ld_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self: psi4.core.HF, arg0: str) → float¶; docstring. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. guess(self: psi4.core.HF) → None¶; Forms the guess (guarantees C, D, and E). guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶; Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. Return type; bool. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. initialize()¶; Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self: psi4.core.HF) → None¶; Sets up a GTFock JK object. initialize_jk(memory, jk=None)¶. iterations(e_conv=None, d_conv=None)¶. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. lagrangian(self: psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:24075,variab,variable,24075,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,28,['variab'],['variable']
Modifiability,"lding Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_simint — CMake variable to force detecting pre-built simint and not falling back on internal build; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Examples. Build bundled. >>> cmake -DENABLE_simint=ON. Build without simint. >>> cmake. Link against pre-built. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. table of contents. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to SIMINT by B. Pritchard. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/simint.html:3102,config,configdir,3102,psi4manual/1.7.x/simint.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/simint.html,2,['config'],"['configdir', 'configure']"
Modifiability,"le (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables ( and ), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. memory 250 mb. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; RO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:3136,variab,variables,3136,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,4,['variab'],['variables']
Modifiability,"le (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables ( and ), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. memory 250 mb. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92534160932308. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; RO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:2958,variab,variables,2958,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,4,['variab'],['variables']
Modifiability,"le (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, Psi4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables ( and ), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. memory 250 mb. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; RO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:3786,variab,variables,3786,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['variab'],['variables']
Modifiability,"le (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.copy(geom); # This for loop and tuple unpacking is why the function can handle; # an arbitrary number of SALCs.; for salc_index, disp_steps in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:5202,variab,variable,5202,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,2,['variab'],['variable']
Modifiability,"le (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. set_variable(key, val)¶; Sets scalar or array QCVariable key to val on cls. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. soFeff(self: psi4.core.ROHF) → psi4.core.Matrix¶; Returns the effective Fock matrix in the orthogonalized SO basis. See libscf_solver/rohf.cc::form_Cfor technical definition. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html:33886,variab,variable,33886,psi4manual/1.5.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html,4,['variab'],['variable']
Modifiability,"le (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. set_variable(key, val)¶; Sets scalar or array QCVariable key to val on cls. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:31650,variab,variable,31650,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,24,['variab'],['variable']
Modifiability,"le QC variables. Prefer variables(). set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:22930,variab,variable,22930,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,4,['variab'],['variable']
Modifiability,"le Values: basis string; Default: No Default. BASIS_GUESS (SCF)¶SCF — Accelerate convergence by performing a preliminary SCF with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the Defaults small basis set 3-21G, pcseg-0, or def2-SV(P). Type: string; Default: FALSE. BASIS_RELATIVISTIC (GLOBALS)¶GLOBALS — Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. BCCD_MAXITER (CCENERGY)¶CCENERGY — Maximum number of iterations for Brueckner CCD. Type: integer; Default: 50. BENCH (GLOBALS)¶GLOBALS — Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI)¶DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BORDER (PE)¶PE — Activate border options for sites in proximity to the QM/MM border. Type: boolean; Default: false. BORDER_N_REDIST (PE)¶PE — number of neighbor sites to redistribute to. The default (-1) redistributes to all sites which are not in the border region. Type: integer; Default: -1. BORDER_REDIST_ORDER (PE)¶PE — order from which moments are removed, e.g., if set to 1 (default), only charges are redistributed and all higher order moments are removed. Type: integer; Default: 1. BORDER_REDIST_POL (PE)¶PE — redistribute polarizabilities? If false, polarizabilities are removed (default). Type: boolean; Default: false. BORDER_RMIN (PE)¶PE — minimum radius from QM atoms to MM sites to be taken into account for removal/redistribution. Type: double; Default: 2.2. BORDER_RMIN_UNIT (PE)¶PE — unit of BORDER_RMIN, default is atomic units (AU). Type: string; Possible Values: AU, AA; Default: AU. BO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:6399,extend,extended,6399,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['extend'],['extended']
Modifiability,"le compilers.; >>> `psi4-path-advisor [your args]` -Dany_addl_cmake_vals=ON; >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`; >>> make install. Same for Linux/Mac/Windows. Substitute desired python version: 2.7, 3.5, 3.6. Fine; to choose your own env name. Include -c psi4/label/dev to get dependencies to; build current master, as opposed to latest release.; Activate environment, conda activate; p4dev. Go to where you’ve cloned psi4. Execute psi4-path-advisor.; It gives you a basic cmake command covering python, sphinx, link-time qc; addons, and run-time qc addons. There’s a help menu -h that gives more; info. There’s other options that will also pre-configure compilers. For; example, at GaTech psi4-path-advisor --intel works. On Macs with; XCode, psi4-path-advisor --clang works. Just read the help. For users; who want a minimal build, there’s a --disable-addons, but it is generally not; encouraged. It gives you a fully; functional cmake command, but those are just setting up CMake cache; — like the plugins you can always add your own CMake variables to; the command.; For run-time, you may also wish to install the executable add-ons (e.g., dftd3); >>> conda install numpy psi4-rt. What do the conda packages psi4 & psi4-dev and the installer psi4conda contain¶; psi4 - has full-featured psi4 itself and necessarily all the link-time qc; addons (e.g., chemps2). It has python, pytest, numpy, and a few more python; modules for specialized functions. Of gcc-ness, it has minimal, run-time; libraries (e.g., libgcc-ng) not compilers.; It doesn’t have the run-time qc addons psi4-rt (e.g., dftd3) or build tools (e.g., g++, sphinx, cmake).; psi4-dev - does not have psi4 itself or the run-time addons psi4-rt or numpy (though fine to install them; alongside). Does have all the link-time addons. Does have; cmake and sphinx (and python). Of gcc-ness, has full packages, that is,; compilers as well as runtime packages.; Psi4conda installer - has full-featured psi4 itself, all link-ti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/conda-1.html:9660,plugin,plugins,9660,psi4manual/1.2.1/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/conda-1.html,4,"['plugin', 'variab']","['plugins', 'variables']"
Modifiability,"le compilers.; >>> `psi4-path-advisor [your args]` -Dany_addl_cmake_vals=ON; >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`; >>> make install. Same for Linux/Mac/Windows. Substitute desired python version: 3.5, 3.6, 3.7. Fine; to choose your own env name. Include -c psi4/label/dev to get dependencies to; build current master, as opposed to latest release.; Activate environment, conda activate; p4dev. Go to where you’ve cloned psi4. Execute psi4-path-advisor.; It gives you a basic cmake command covering python, sphinx, link-time qc; addons, and run-time qc addons. There’s a help menu -h that gives more; info. There’s other options that will also pre-configure compilers. For; example, at GaTech psi4-path-advisor --intel works. On Macs with; XCode, psi4-path-advisor --clang works. Just read the help. For users; who want a minimal build, there’s a --disable-addons, but it is generally not; encouraged. It gives you a fully; functional cmake command, but those are just setting up CMake cache; — like the plugins you can always add your own CMake variables to; the command.; For run-time, you may also wish to install the executable add-ons (e.g., dftd3); >>> conda install numpy psi4-rt. What do the conda packages psi4 & psi4-dev and the installer psi4conda contain¶; psi4 - has full-featured psi4 itself and necessarily all the link-time qc; addons (e.g., chemps2). It has python, pytest, numpy, and a few more python; modules for specialized functions. Of gcc-ness, it has minimal, run-time; libraries (e.g., libgcc-ng) not compilers.; It doesn’t have the run-time qc addons psi4-rt (e.g., dftd3) or build tools (e.g., g++, sphinx, cmake).; psi4-dev - does not have psi4 itself or the run-time addons psi4-rt or numpy (though fine to install them; alongside). Does have all the link-time addons. Does have; cmake and sphinx (and python). Of gcc-ness, has full packages, that is,; compilers as well as runtime packages.; Psi4conda installer - has full-featured psi4 itself, all link-ti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/conda-1.html:9660,plugin,plugins,9660,psi4manual/1.3.2/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/conda-1.html,4,"['plugin', 'variab']","['plugins', 'variables']"
Modifiability,"le initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no sy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:2643,plugin,plugin,2643,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"le initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans lib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:2643,plugin,plugin,2643,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"le initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-parti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:2628,plugin,plugin,2628,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"le lines- should be handled in energy. run_bccd(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. run_bccd_t(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. run_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. run_cc_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; all CC property calculations. run_ccenergy(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. run_dcft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. run_dcft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; DCFT gradient calculation. run_detci(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. run_dfmp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. Caution; Get rid of madness-era restart file. run_dft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory calculation. run_dft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. run_eom_cc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. run_eom_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. run_libfock(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. run_mcscf(name, **kwargs)[so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:4302,config,configuration,4302,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['config'],['configuration']
Modifiability,"le point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H2O Test FCI Energy Point. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. omp3-2; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:12314,variab,variables,12314,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['variab'],['variables']
Modifiability,"le stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field in the ```cbs_metadata``` list, and is only; allowed if all preceding stages are active. .. include:: /cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:34349,variab,variables,34349,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,8,['variab'],['variables']
Modifiability,"le values as if member data.; #; # """"""; ## #if not name in self.__dict__:; ## if not name in self.__dict__['__dict__']:; ## if object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; ## else:; ## #return self.__dict__[name]; ## return self.__dict__['__dict__'][name]; #; ## if name in self.__dict__:; ## return self.__dict__[name]; ## elif '__dict__' in self.__dict__ and name in self.__dict__['__dict__']:; ## return self.__dict__['__dict__'][name]; ## elif object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; #; # if not name in self.__dict__:; # if object.__getattribute__(self, 'is_variable')(name):; # return object.__getattribute__(self, 'get_variable')(name); # else:; # raise AttributeError; # else:; # return self.__dict__[name]. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:37935,variab,variable,37935,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['variab'],['variable']
Modifiability,"le(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_EP2"", aux_basis). dfep2_wfn = core.DFEP2Wavefunction(ref_wfn). # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add IP info; ip_info = np.unique(irrep_map[ip_map], return_counts=True); for irrep, cnt in zip(*ip_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep] - cnt, nalphapi[irrep])). # Add EA info; ea_info = np.unique(irrep_map[ea_map], return_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:95242,extend,extend,95242,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,16,['extend'],['extend']
Modifiability,le(Ss). psi4.print_global_options()¶; Python Library Documentation: built-in function print_global_options in module psi4; print_global_options(...). print_global_options() -> None :. Prints the currently set global (all modules) options to the output file.; C++ signature :. void print_global_options(). psi4.print_options()¶; Python Library Documentation: built-in function print_options in module psi4; print_options(...). print_options() -> None :. Prints the currently set options (to the output file) for the current module.; C++ signature :. void print_options(). psi4.print_out()¶; Python Library Documentation: built-in function print_out in module psi4; print_out(...). print_out( (str)arg1) -> None :. Prints a string (using sprintf-like notation) to the output file.; C++ signature :. void print_out(Ss). psi4.print_variables()¶; Python Library Documentation: built-in function print_variables in module psi4; print_variables(...). print_variables() -> None :. Prints all PSI variables that have been set internally.; C++ signature :. void print_variables(). psi4.psi_top_srcdir()¶; Python Library Documentation: built-in function psi_top_srcdir in module psi4; psi_top_srcdir(...). psi_top_srcdir() -> str :. Returns the location of the source code.; C++ signature :. Ss psi_top_srcdir(). psi4.psimrcc()¶; Python Library Documentation: built-in function psimrcc in module psi4; psimrcc(...). psimrcc( (Wavefunction)arg1) -> float :. Runs the multireference coupled cluster code.; C++ signature :. d psimrcc(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.reopen_outfile()¶; Python Library Documentation: built-in function reopen_outfile in module psi4; reopen_outfile(...). reopen_outfile() -> None :. Reopens the output file.; C++ signature :. void reopen_outfile(). psi4.revoke_global_option_changed()¶; Python Library Documentation: built-in function revoke_global_option_changed in module psi4; revoke_global_option_changed(...). revoke_global_option_changed( (str)arg1) -> None :.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:37754,variab,variables,37754,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['variab'],['variables']
Modifiability,"le(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:29784,variab,variable,29784,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variable']
Modifiability,"le.; ; C++ signature :; void flush_outfile(); ; fnocc(...); fnocc( (Wavefunction)arg1) -> Wavefunction :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE fnocc(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; get_active_efp(...); get_active_efp() -> EFP :; Returns the currently active EFP object.; ; C++ signature :; N5boost10shared_ptrIN3psi3efp3EFPEEE get_active_efp(); ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; C++ signature :; N5boost10shared_ptrIN3psi8MoleculeEEE get_active_molecule(); ; get_array_variable(...); get_array_variable( (str)arg1) -> Matrix :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE get_array_variable(Ss); ; get_array_variables(...); get_array_variables() -> dict :; Returns dictionary of the PSI variables set internally by the modules or python driver.; ; C++ signature :; N5boost6python4dictE get_array_variables(); ; get_atomic_point_charges(...); get_atomic_point_charges() -> Vector :; Returns the most recently computed atomic point charges, as a double * object.; ; C++ signature :; N5boost10shared_ptrIN3psi6VectorEEE get_atomic_point_charges(); ; get_efp_torque(...); get_efp_torque() -> Matrix :; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object.; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE get_efp_torque(); ; get_frequencies(...); get_frequencies() -> Vector :; Returns the most recently computed frequencies, as a 3N-6 Vector object.; ; C++ signature :; N5boost10shared_ptrIN3psi6VectorEEE get_frequencies(); ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name *arg1*, returns the value associated with the keyword from the global options. Returns error if keyword is not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:682918,variab,variables,682918,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['variab'],['variables']
Modifiability,le; get_writer_file_prefix; get_writer_file_prefix; git_version; git_version; has_array_variable; has_array_variable; has_global_option_changed; has_global_option_changed; has_local_option_changed; has_local_option_changed; has_option_changed; has_option_changed; has_scalar_variable; has_scalar_variable; HF; IDAMAX; initialize; initialize; IntegralFactory; IntegralTransform; IntVector; IO; IOManager; IrreducibleRepresentation; JK; KineticInt; LaplaceDenominator; legacy_wavefunction; legacy_wavefunction; LibXCFunctional; Localizer; Matrix; MatrixFactory; mcscf; mcscf; MemDFJK; MintsHelper; MoldenWriter; MolecularGrid; Molecule; MOSpace; MOWriter; mrcc_generate_input; mrcc_generate_input; mrcc_load_densities; mrcc_load_densities; MultipoleInt; MultipoleSymmetry; NablaInt; NBOWriter; occ; occ; OEProp; OneBodyAOInt; opt_clean; opt_clean; option_exists_in_module; option_exists_in_module; Options; optking; optking; OrbitalSpace; outfile_name; outfile_name; OverlapInt; PetiteList; plugin; plugin; plugin_close; plugin_close; plugin_close_all; plugin_close_all; plugin_load; plugin_load; PMLocalizer; PointFunctions; PointGroup; PotentialInt; prepare_options_for_module; prepare_options_for_module; PrimitiveType; print_global_options; print_global_options; print_options; print_options; print_out; print_out; print_variables; print_variables; Prop; PseudospectralInt; psi_top_srcdir; psi_top_srcdir; psimrcc; psimrcc; PsiReturnType; QuadrupoleInt; reopen_outfile; reopen_outfile; revoke_global_option_changed; revoke_global_option_changed; revoke_local_option_changed; revoke_local_option_changed; RHF; RKSFunctions; ROHF; run_gdma; run_gdma; SADGuess; SalcComponent; sapt; sapt; SaveType; scalar_variable; scalar_variable; scalar_variables; scalar_variables; scatter; scatter; scfgrad; scfgrad; scfhess; scfhess; set_active_molecule; set_active_molecule; set_array_variable; set_array_variable; set_datadir; set_datadir; set_global_option; set_global_option; set_legacy_gradient; set_legacy_g,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:462802,plugin,plugin,462802,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['plugin'],['plugin']
Modifiability,"le` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to addi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:5157,plugin,plugin,5157,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,15,['plugin'],['plugin']
Modifiability,"lean; Default: true. COMPLEX_TOLERANCE (CCEOM); CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. CONSECUTIVE_BACKSTEPS (OPTKING); OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC); PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC); PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC); PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC); PSIMRCC — The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_WFN (PSIMRCC); PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING (PSIMRCC); PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC); PSIMRCC — Do include the terms that couple the reference determinants?. Type: boolean; Default: true. COVALENT_CONNECT (OPTKING); OPTKING — When determining connectivity, a bond is assigned if interatomic distance is less than (this number) * sum of covalent radii. Type: double; Default: 1.3. CPHF_MEM_SAFETY_FACTOR (CPHF); CPHF — Memory safety factor for allocating JK. Type: double; Default: 0.75. CPHF_TASKS (CPHF); CPHF — Which tasks to run CPHF For * Valid choices: * -Polarizability *. Type: array; Default: No Default. CUTOFF (OMP2); OMP2 — Cutoff value for numerical procedures. Type: integer; Default: 14. CUTOFF (OMP3); OMP3 — Cutoff value for numerical procedures. Type: integer; Default: 14. D_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for density. Type: conv double; Default: 1e-6. D_CONVERGENCE (SAPT); SAPT — Convergence c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:18925,coupling,coupling,18925,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['coupling'],['coupling']
Modifiability,"lecular orbitals. Type: string; Possible Values: basis string; Default: No Default. BASIS (SCF); SCF — Primary basis set. Type: string; Possible Values: basis string; Default: No Default. BASIS_GUESS (SCF); SCF — Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. BB_M_FILE (TRANSQT); TRANSQT — MO basis (pq|rs) type two-electron integrals file. Type: integer; Default: PSIF_MO_BB_TEI. BENCH (DFTSAPT); DFTSAPT — Bench level. Type: integer; Default: 0. BENCH (GLOBALS); GLOBALS — Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC); FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:6400,extend,extended,6400,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['extend'],['extended']
Modifiability,"lecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:24061,variab,variables,24061,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['variab'],['variables']
Modifiability,"lecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]def ipi_broker(; LOT: str,; molecule: Optional[psi4.core.Molecule] = None,; serverdata: Union[str, bool] = False,; options: Optional[Dict] = None; ) -> IPIBroker:; """"""Runs :class:`~psi4.driver.ipi_broker.IPIBroker` to connect to i-PI (https://ipi-code.org/). Parameters; ----------; LOT; level of theory; molecule; Initial molecule; serverdata; Configuration where to connect to ipi; options; any additional Psi4 options. """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call-to-delete]; sys.exit(1). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.ipi_broker. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/ipi_broker.html:4609,Config,Configuration,4609,psi4manual/1.7.x/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/ipi_broker.html,1,['Config'],['Configuration']
Modifiability,"lecule object.; # A useful optional argument is nmax, the total number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac_nuke(h2o, nmax = 2). Note: this feature is new/powerful enough that we have several papers pending on; it, and are interested in expanding this work. If you would like to publish; results using this code, please contact Rob Parrish to make arrangements for; collaboration. Dispersion Corrections¶; Dispersion corrections are discussed at this link. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Table Of Contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Tre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dft-1.html:22287,extend,extending,22287,psi4manual/4.0b3/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dft-1.html,6,['extend'],['extending']
Modifiability,"lecule object.; # A useful optional argument is nmax, the total number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac_nuke(h2o, nmax = 2). Note: this feature is new/powerful enough that we have several papers pending on; it, and are interested in expanding this work. If you would like to publish; results using this code, please contact Rob Parrish to make arrangements for; collaboration. Dispersion Corrections¶; Dispersion corrections are discussed at this link. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; Psi4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Table Of Contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Tre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:22655,extend,extending,22655,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['extend'],['extending']
Modifiability,"lecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. opdm(self, arg0, arg1, arg2, arg3); docstring. pitzer_to_ci_order_onel(self, arg0, arg1); docstring. pitzer_to_ci_order_twoel(self, arg0, arg1); docstring. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. print_vector(self, arg0, arg1); docstring. reference_wavefunction(self); Returns the reference wavefunction. rotate_mcscf_integrals(self, arg0, arg1, arg2); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. semicanonical_orbs(self); docstring. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_ci_guess(self, arg0); docstring. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:7129,variab,variable,7129,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"led cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scalar_variable(arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(); Returns dictionary of all double QC variables. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(val). set_legacy_gradient(arg0); Assigns the global gradient to the values in the (nat, 3) Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(arg0, arg1); Sets an option to a Python object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_pa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:299308,variab,variable,299308,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"led with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5. Link against pre-built. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root. >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir. Link against pre-built with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=""/path/to/chemps2/root;/path/to/hdf5/root"". Build bundled despite pre-built being detectable. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/chemps2/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_CheMPS2=ON. How to fix “plugin needed to handle lto object” when building CheMPS2¶; For building with GCC, errors involving unresolved symbols or a message; “plugin needed to handle lto object” may indicate a failure of the; interprocedural optimization. This can be resolved by passing full; locations to gcc toolchain utilities to setup or cmake:; -DCMAKE_RANLIB=/path/to/gcc-ranlib -DCMAKE_AR=/path/to/gcc-ar .; Details at https://github.com/psi4/psi4/issues/414. table of contents. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS; DMRG_DIIS; DMRG_DIIS_WRITE; DMRG_EXCITATION; DMRG_IRREP; DMRG_LOCAL_INIT; DMRG_MOLDEN_WRITE; DMRG_MPS_WRITE; DMRG_MULTIPLICITY; DMRG_OPDM_AO_PRINT; DMRG_PRINT_CORR; DMRG_SCF_ACTIVE_SPACE; DMRG_SCF_DIIS_THR; DMRG_SCF_GRAD_THR; DMRG_SCF_MAX_ITER; DMRG_SCF_STATE_AVG; DMRG_SWEEP_DVDSON_RTOL; DMRG_SWEEP_ENERGY_CONV; DMRG_SWEEP_MAX_SWEEPS; DMRG_SWEEP_NOISE_PREFAC; DMRG_SWEEP_STATES; DMRG_UNITARY_WRITE. How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/chemps2-1.html:8117,config,configure,8117,psi4manual/1.2.1/chemps2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/chemps2-1.html,4,"['config', 'plugin']","['configure', 'plugin']"
Modifiability,"lem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/plugins-1.html:1525,plugin,plugin-compile,1525,psi4manual/1.3.2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/plugins-1.html,2,['plugin'],['plugin-compile']
Modifiability,"len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]def ipi_broker(LOT, molecule=None, serverdata=False, options=None):; """""" Run IPIBroker to connect to i-pi. Arguments:; molecule: Initial molecule; serverdata: Configuration where to connect to ipi; options: any additional Psi4 options; """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call-to-delete]; sys.exit(1). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.ipi_broker. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html:4249,Config,Configuration,4249,psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/ipi_broker.html,1,['Config'],['Configuration']
Modifiability,"len(atoms)). def calculate_force(self, pos=None, **kwargs):; """"""Fetch force, energy of PSI. Arguments:; - pos: positions of the atoms as array. If None, the positions of the current active; molecule is used.; """"""; if pos is None:; molecule = psi4.core.get_active_molecule(); pos = np.array(molecule.geometry()). self._force, self._potential = self.callback(pos, **kwargs); return self._force, self._potential. def callback(self, pos, **kwargs):; """"""Initialize psi with new positions and calculate force. Arguments:; - pos: positions of the atoms as array.; """""". self.initial_molecule.set_geometry(psi4.core.Matrix.from_array(pos)). self.calculate_gradient(self.LOT, pos=pos, **kwargs). self._potential = psi4.variable('CURRENT ENERGY'); self._force = -np.array(self.grd); self._vir = np.array([[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]). return self._force, np.float64(self._potential). def calculate_gradient(self, LOT, bypass_scf=False, **kwargs):; """"""Calculate the gradient with @LOT. When bypass_scf=True a hf energy calculation has been done before.; """"""; start = time.time(); self.grd = psi4.gradient(LOT, bypass_scf=bypass_scf, **kwargs); time_needed = time.time() - start; self.timing[LOT] = self.timing.get(LOT, []) + [time_needed]. [docs]def ipi_broker(LOT, molecule=None, serverdata=False, options=None):; """""" Run IPIBroker to connect to i-pi. Arguments:; molecule: Initial molecule; serverdata: Configuration where to connect to ipi; options: any additional Psi4 options; """"""; b = IPIBroker(LOT, molecule=molecule, serverdata=serverdata, options=options). try:; if b.serverdata:; b.run(); else:; return b. except KeyboardInterrupt:; psi4.core.print_out(""Killing IPIBroker\n""); b.__del__() # lgtm [py/explicit-call-to-delete]; sys.exit(1). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; psi4.driver.ipi_broker. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/ipi_broker.html:4249,Config,Configuration,4249,psi4manual/1.5.0/_modules/psi4/driver/ipi_broker.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/ipi_broker.html,1,['Config'],['Configuration']
Modifiability,"ler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubuntu gfortran; conda gfortran_linux-64 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gcc conda package. This provides gcc, g++, and; gfortran compilers for Mac. The two former are 4.8.5 and so are too; old to compile PSI4, but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular systems.; Downstream Dependencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; MKL_ROOT — Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location.; MATH_ROOT — Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so).; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be semicolon-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL. Examples. Build with any LAPACK in standard location. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL not also present).; If NumPy not using native Accelerate LAPACK, then directing Psi4; to use ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:35318,variab,variable,35318,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['variab'],['variable']
Modifiability,"ler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples.; The equivalent Python PsiAPI syntax is shown alongside the Psithon code snippets.; When using the Python API, one must import the PSI4 module with:; import psi4. No such directive is neccesary when using Psithon, which is run using the psi4; executable. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:1320,variab,variables,1320,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['variab'],['variables']
Modifiability,"lerate convergence of the CI coefficients?. Type: boolean; Default: false. DIIS¶. Do use DIIS extrapolation to accelerate convergence of the SCF energy (MO coefficients only)?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DOCC¶. The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. D_CONVERGENCE¶. Convergence criterion for density, as measured by the orbital gradient. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-6. FAVG¶. Do use the average Fock matrix during the SCF optimization?. Type: boolean; Default: false. FAVG_START¶. Iteration at which to begin using the averaged Fock matrix. Type: integer; Default: 5. FOLLOW_ROOT¶. Which solution of the SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FORCE_TWOCON¶. Do attempt to force a two configuration solution by starting with CI coefficents of \(\pm \sqrt{\frac{1}{2}}\) ?. Type: boolean; Default: false. INTERNAL_ROTATIONS¶. Do consider internal rotations?. Type: boolean; Default: true. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.0. MAXITER¶. Maximum number of iterations. Type: integer; Default: 100. MO_READ¶. Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF, TWOCON, MCSCF, GENERAL; Default: RHF. SOCC¶. The number of singly occupied orbitals, per irrep. Type: array; Default: No Default. TURN_ON_ACTV¶. Type: integer; Default: 0. WFN_SYM¶. The symmetry of the SCF wavefunction. Type: string; Default: 1. Expert¶. ROTATE_MO_ANGLE¶. For orbital rotations after convergence, the angle (in degrees) by which to rotate. Type: double; Default: 0.0. ROTATE_MO_IRREP¶. For orbital rotations after convergence, irrep (1-based, Cotton order) of the orbitals to rota",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__mcscf-1.html:1593,config,configuration,1593,psi4manual/1.3.2/autodir_options_c/module__mcscf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__mcscf-1.html,20,['config'],['configuration']
Modifiability,"lers for Mac. The version is 4.8.5, which is quite old,; but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular systems.; Downstream Dependencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be “;”-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL.; OpenMP_LIBRARY_DIRS — CMake variable to specify OpenMP library (iomp5/gomp/omp) directories explicitly. Should be “;”-separated list of full directory paths. Usually the solution to error Could NOT find MathOpenMP. MKL_ROOT¶; Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location. MATH_ROOT¶; Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so). Examples. Build with any LAPACK in standard location. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL not also present).; If NumPy not using native Accelerate LAPACK, then directing Psi4; to use it is Bad Idea!. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL also present); If NumPy not using native Accelerate LAPACK, then directing Psi4; to use it is Bad Idea!. >>> cmake -DBLAS_TYPE=SYSTEM_NATIVE -DLAPACK_TYPE=SYSTEM_NATIVE. Build with Intel MKL. >>> source /path/to/intel/vers/linux/mkl/bin/mklv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:41490,variab,variable,41490,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['variab'],['variable']
Modifiability,"ler–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/plugin_snsmp2.html:1687,adapt,adapted,1687,psi4manual/1.7.x/plugin_snsmp2.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/plugin_snsmp2.html,1,['adapt'],['adapted']
Modifiability,"les :ref:`[manual] <sec:cc>` :ref:`[details] <dd_bccd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-ccsd(t) | CCSD(T) with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cc3 | approximate CC singles, doubles, and triples (CC3) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_cc3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | ccenergy | **expert** full control over ccenergy module |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisd | configuration interaction (CI) singles and doubles (CISD) :ref:`[manual] <sec:ci>` :ref:`[details] <dd_cisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-cisd | CISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdt | CI singles, doubles, and triples (CISDT) :ref:`[manual] <sec:ci>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cisdtq | CI singles, doubles, triples, and quadruples (CISDTQ) :ref:`[manual] <sec:ci>` |; +-------------------------+--------------------------------------------------------------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:21218,config,configuration,21218,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['config'],['configuration']
Modifiability,"les only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:44083,variab,variables,44083,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"les    . toc    . next    . previous    ; PSI4 [beta3] » . Installation and Runtime Configuration¶. Obtaining PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to; Compiling and Installing (same information as; the file psi4/INSTALL distributed with the package). Additional compilation; hints may be found at Psi Compiling. Compiling and Installing¶. I. Compilation Prerequisites; II. Brief Summary of Configuration, Compilation, and Installation; III. Detailed Installation Instructions; IV. Recommendations for BLAS and LAPACK libraries; V. Miscellaneous architecture-specific notes; VI. Common Problems with PSI Compilation. Scratch Files and the ~/.psi4rc File¶; One very important part of user configuration at the end of the; installation process (details here); is to tell PSI4 where to write its temporary; (“scratch”) files. Electronic structure packages like PSI4 can; create rather large temporary disk files. It is very important to; ensure that PSI4 is writing its temporary files to a disk drive; phsyically attached to the computer running the computation. If it; is not, it will significantly slow down the program and the network.; By default, PSI4 will write temporary files to /tmp, but this; directory is often not large enough for typical computations. Therefore,; you need to (a) make sure there is a sufficiently large directory on a; locally attached disk drive (100GB–1TB or more, depending on the size of; the molecules to be studied) and (b) tell PSI4 the path to this; directory. Scratch file location can be specified through the; PSI_SCRATCH environment variable or, more flexibly, through; a resource file, ~/.psi4rc (example psi4/samples/example_psi4rc_file).; For convenience, the Python interpreter will execu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:1051,config,configuration,1051,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['config'],['configuration']
Modifiability,"les(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by name. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_efp_torque(arg0); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_frequencies(arg0); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(arg0, arg1); Sets an option to a Python object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:248701,variab,variable,248701,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variable']
Modifiability,"les(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis, quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[, assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self, arg0, arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:2446,variab,variable,2446,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['variab'],['variable']
Modifiability,"let the build system fetch and build it and activate dependent code. Input¶; For all electron calculations one can use the Douglas-Kroll-Hess (DKH); Hamiltonian to take into account scalar relativistic effects.; Minimal input for DKH single-point computation looks like this:; molecule {; Mg; }. set basis aug-cc-pvdz-dk; set relativistic dkh. energy('scf'). By default a 2nd-order DKH calculation is performed. To change the default; order use the DKH_ORDER option. The version of the code found in; PSI4 is capable of up to 4th-order DKH calculations. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. DKH_ORDER¶. Order of Douglas-Kroll-Hess. Type: integer; Default: 2. Reference¶; When using this code please make reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dkh-1.html:2053,config,configure,2053,psi4manual/1.4.0/dkh-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dkh-1.html,9,['config'],['configure']
Modifiability,"lete Basis Set¶. Code author: Lori A. Burns; Section author: Lori A. Burns. complete_basis_set(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, delta3_wfn, delta3_wfn_lesser, delta3_basis, delta3_scheme, delta4_wfn, delta4_wfn_lesser, delta4_basis, delta4_scheme, delta5_wfn, delta5_wfn_lesser, delta5_basis, delta5_scheme])[source]¶; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases :cbs(). Returns:(float) – Total electronic energy in Hartrees. Psi variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular.; No scheme defaults for given basis zeta number, so scheme must be specified explicitly.; No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Here, is an energy or energy extrapolation scheme, and the following also hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; app",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:1166,variab,variables,1166,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,4,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"lf); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:2355,variab,variable,2355,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,4,['variab'],['variable']
Modifiability,"lf); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:2355,variab,variable,2355,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,3,['variab'],['variable']
Modifiability,"lf); Returns the Wavefunctions energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(self); Returns the frequencies of the Hessian. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(self, arg0); Sets the requested internal array. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_variable(self, arg0); Returns the requested internal variable. gradient(self); Returns the Wavefunctions gradient. hessian(self); Returns the Wavefunctions Hessian. mo_extents(self); returns the wavefunction’s electronic orbital extents. molecule(self); Returns the Wavefunctions molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(sel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html:2891,variab,variable,2891,psi4manual/1.2.1/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"lf, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. total_index(self, i, h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha orbital subset. Parameters. basis (str) – {‘SO’, AO’}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str) – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbitals should be returned?. Returns; A Pitzer-ordered matrix of the orbitals, (# basis functions, # orbitals in the subset).; Pitzer-ordering is with respect to c1 symmetry if basis is AO. Return type; Matrix. Cb(self: psi4.core.Wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:8095,variab,variable,8095,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variable']
Modifiability,"lf.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += ""\t%s %5d %s\n"" % (self.symbol(), now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); text += ""\t%s %5d %s %5d %s\n"" % (self.symbol(), now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += ""\t%s %5d %s %5d %s %5d %s\n"" % \; (self.symbol(), now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:11673,variab,variables,11673,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,4,['variab'],['variables']
Modifiability,"lf: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X()¶. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:12986,variab,variables,12986,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,3,['variab'],['variables']
Modifiability,"lf: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X()¶. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:11619,variab,variables,11619,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,3,['variab'],['variables']
Modifiability,"lf: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X()¶. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:11597,variab,variables,11597,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,7,['variab'],['variables']
Modifiability,"lf: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X()¶. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html:13144,variab,variables,13144,psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,2,['variab'],['variables']
Modifiability,"lf: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X()¶. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self: psi4.core.DFEP2Wavefunction, arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html:11740,variab,variables,11740,psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,2,['variab'],['variables']
Modifiability,"lf: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X()¶. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:11821,variab,variables,11821,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,4,['variab'],['variables']
Modifiability,"lfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”). Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself.; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; >>> cd {top-level-psi4-dir}; >>> cmake -S. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. >>> cd {top-level-psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:1224,config,configure,1224,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,4,['config'],['configure']
Modifiability,"lib. CMake Variables. ENABLE_CheMPS2 — CMake variable toggling whether Psi4 builds with CheMPS2; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For CheMPS2, set to an installation directory containing include/chemps2/DMRG.h; CheMPS2_DIR — CMake variable to specify where pre-built CheMPS2 can be found. Set to installation directory containing share/cmake/CheMPS2/CheMPS2Config.cmake; CMAKE_DISABLE_FIND_PACKAGE_CheMPS2 — CMake variable to force internal build of CheMPS2 instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_CheMPS2 — CMake variable to force detecting pre-built CheMPS2 and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_CheMPS2=ON. Build without CheMPS2. >>> cmake. Build bundled with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5. Link against pre-built. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root. >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir. Link against pre-built with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=""/path/to/chemps2/root;/path/to/hdf5/root"". Build bundled despite pre-built being detectable. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/chemps2/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_CheMPS2=ON. How to fix “plugin needed to handle lto object” when building CheMPS2¶; For building with GCC, errors involving unresolved symbols or a message; “plugin needed to handle lto object” may indicate a failure of the; interprocedural optimization. This can be resolved by passing full; locations to gcc toolchain utilities to setup or cmake:; -DCMAKE_RANLIB=/path/to/gcc-ranlib -DCMAKE_AR=/path/to/gcc-ar .; Details at https://github.com/psi4/psi4/issues/414. table of contents. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/chemps2-1.html:6735,config,configdir,6735,psi4manual/1.2.1/chemps2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/chemps2-1.html,13,['config'],['configdir']
Modifiability,"library routines. From this point forward, it is; assumed that you have compiled PSI4 with OpenMP and MKL (Note that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in PSI4 can be accomplished at a variety of levels,; ranging from global environment variables to direct control of thread count in; the input file, to even directives specific to each model. This hierarchy is; explained below. Note that each deeper level trumps all previous levels.; (1) OpenMP/MKL Environment Variables. Deprecated since version 1.1: Environment variables OMP_NUM_THREADS and MKL_NUM_THREADS; do not affect threading in PSI4. (2) The -n Command Line Flag; To change the number of threads at runtime, the psi4 -n flag may be used. An; example is:; psi4 -i input.dat -o output.dat -n 4. which will run on four threads. Note that is is not available for PsiAPI mode of operation.; (3) Setting Thread Numbers in an Input; For more explicit control, the Process::environment class in PSI4 can; override the number of threads set by environment variables. This functionality; is accessed via the psi4.set_num_threads() function, which controls; both MKL and OpenMP thread numbers. The number of threads may be changed; multiple times in a PSI4 input file. An example input for this feature is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17# A bit small-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. set scf {; basis cc-pvdz; scf_type df; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1,5):; set_num_threads(nthread); energy('scf'). In PsiAPI mode of operation, this syntax, psi4.set_num_threads(nthread), is; the primary way to control threading.; (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This require",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:11148,variab,variables,11148,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,6,['variab'],['variables']
Modifiability,"library routines. From this point forward, it is; assumed that you have compiled PSI4 with OpenMP and MKL (Note that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in PSI4 can be accomplished at a variety of levels,; ranging from global environment variables to direct control of thread count in; the input file, to even directives specific to each model. This hierarchy is; explained below. Note that each deeper level trumps all previous levels.; (1) OpenMP/MKL Environment Variables. Deprecated since version 1.1: Environment variables OMP_NUM_THREADS and MKL_NUM_THREADS; do not affect threading in PSI4. (2) The -n Command Line Flag; To change the number of threads at runtime, the psi4 -n flag may be used. An; example is:; psi4 -i input.dat -o output.dat -n 4. which will run on four threads. Note that is is not available for PsiAPI mode of operation.; (3) Setting Thread Numbers in an Input; For more explicit control, the Process::environment class in PSI4 can; override the number of threads set by environment variables. This functionality; is accessed via the set_num_threads() function, which controls; both MKL and OpenMP thread numbers. The number of threads may be changed; multiple times in a PSI4 input file. An example input for this feature is:; # A bit small-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1, 5):; set_num_threads(nthread); energy(""scf/cc-pvdz""). In PsiAPI mode of operation, this syntax, psi4.set_num_threads(nthread), is; the primary way to control threading.; (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the gen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:13067,variab,variables,13067,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['variab'],['variables']
Modifiability,"license terms; >>> echo ""export PATH=$HOME/psi4conda/bin:\$PATH"" >> ~/.bash_profile; # log out, log back in so conda and psi4 in path; >>> psi4 --test. # Windows; # py27|py35|py36 for alternate python versions; >>> curl -O ""http://vergil.chemistry.gatech.edu/download/Psi4conda-latest-py35-Windows-x86_64.sh"" --keepalive-time 2; >>> bash; >>> bash Psi4conda-latest-py35-Windows-x86_64.sh -b -p $HOME/psi4conda # agrees to license terms; >>> echo ""export PATH=$HOME/psi4conda/bin:\$PATH"" >> ~/.bashrc; # log out, log back in so conda and psi4 in path; >>> psi4 --test. That last command tested that psi4 is in your path, and it’s finding; all the libraries it needs. It works because PSI_SCRATCH; defaults to /tmp. Now you need only specify a permanent scratch; directory (see Scratch Files and Elementary Restart) by replacing the placeholder in the; following:; >>> echo ""export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files"" >> ~/.bashrc; # log out, log back in so variable takes effect. All done!; Configuration for this set-up is summarized at How to run Psi4 as executable or Python module from conda installation. Note; PSI4 installs a Python distribution alongside, so you should choose an installer based on the Python version you want, irrespective of any Python version you have. Note; Above commands use bash for installation and set up your environment for bash at runtime. To use csh at runtime, follow the on-screen directions at the end of the installation or consult step 7 below. How to install a Psi4 binary into an Ana/Miniconda distribution¶; Conda command to install the latest nightly build of PSI4 + compiled; add-ons + runtime add-ons into an existing Anaconda or Miniconda; distribution.; # Linux or Mac or Windows; # substitute x.x by 2.7|3.5|3.6 for alternate python versions; # remove `-c psi4/label/dev` to get stable releases instead of nightly builds; >>> conda create -n p4env python=x.x psi4 psi4-rt -c psi4/label/dev -c psi4. A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/conda-1.html:4240,variab,variable,4240,psi4manual/1.2.1/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/conda-1.html,2,['variab'],['variable']
Modifiability,"license terms; >>> echo ""export PATH=$HOME/psi4conda/bin:\$PATH"" >> ~/.bash_profile; # log out, log back in so conda and psi4 in path; >>> psi4 --test. # Windows; # py27|py35|py36 for alternate python versions; >>> curl -O ""http://vergil.chemistry.gatech.edu/download/Psi4conda-latest-py35-Windows-x86_64.sh"" --keepalive-time 2; >>> bash; >>> bash Psi4conda-latest-py35-Windows-x86_64.sh -b -p $HOME/psi4conda # agrees to license terms; >>> echo ""export PATH=$HOME/psi4conda/bin:\$PATH"" >> ~/.bashrc; # log out, log back in so conda and psi4 in path; >>> psi4 --test. That last command tested that psi4 is in your path, and it’s finding; all the libraries it needs. It works because PSI_SCRATCH; defaults to /tmp. Now you need only specify a permanent scratch; directory (see Scratch Files and Elementary Restart) by replacing the placeholder in the; following:; >>> echo ""export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files"" >> ~/.bashrc; # log out, log back in so variable takes effect. All done!; Configuration for this set-up is summarized at How to run Psi4 as executable or Python module from conda installation. Note; PSI4 installs a Python distribution alongside, so you should choose an installer based on the Python version you want, irrespective of any Python version you have. Note; Above commands use bash for installation and set up your environment for bash at runtime. To use csh at runtime, follow the on-screen directions at the end of the installation or consult step 7 below. How to install a Psi4 binary into an Ana/Miniconda distribution¶; Conda command to install the latest nightly build of PSI4 + compiled; add-ons + runtime add-ons into an existing Anaconda or Miniconda; distribution.; # Linux or Mac or Windows; # substitute x.x by 2.7|3.5|3.6 for alternate python versions; >>> conda create -n p4env python=x.x psi4 psi4-rt -c psi4/label/dev -c psi4. Activate environment and make the adjustments to PATH and; PSI_SCRATCH that it s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/conda-1.html:4031,variab,variable,4031,psi4manual/1.1.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/conda-1.html,2,['variab'],['variable']
Modifiability,"license terms; >>> echo ""export PATH=$HOME/psi4conda/bin:\$PATH"" >> ~/.bash_profile; # log out, log back in so conda and psi4 in path; >>> psi4 --test. # Windows; # py27|py35|py36 for alternate python versions; >>> curl -O ""http://vergil.chemistry.gatech.edu/download/Psi4conda-latest-py35-Windows-x86_64.sh"" --keepalive-time 2; >>> bash; >>> bash Psi4conda-latest-py35-Windows-x86_64.sh -b -p $HOME/psi4conda # agrees to license terms; >>> echo ""export PATH=$HOME/psi4conda/bin:\$PATH"" >> ~/.bashrc; # log out, log back in so conda and psi4 in path; >>> psi4 --test. That last command tested that psi4 is in your path, and it’s finding; all the libraries it needs. It works because PSI_SCRATCH; defaults to /tmp. Now you need only specify a permanent scratch; directory (see Scratch Files and Elementary Restart) by replacing the placeholder in the; following:; >>> echo ""export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files"" >> ~/.bashrc; # log out, log back in so variable takes effect. All done!; Configuration for this set-up is summarized at How to run Psi4 as executable or Python module from conda installation. Note; PSI4 installs a Python distribution alongside, so you should choose an installer based on the Python version you want, irrespective of any Python version you have. Note; Above commands use bash for installation and set up your environment for bash at runtime. To use csh at runtime, follow the on-screen directions at the end of the installation or consult step 7 below. How to install a Psi4 binary into an Ana/Miniconda distribution¶; Conda command to install the latest nightly build of PSI4 + compiled; add-ons + runtime add-ons into an existing Anaconda or Miniconda; distribution.; # Linux or Mac or Windows; # substitute x.x by 3.5|3.6|3.7 for alternate python versions; # remove `-c psi4/label/dev` to get stable releases instead of nightly builds; >>> conda create -n p4env python=x.x psi4 psi4-rt -c psi4/label/dev -c psi4. A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/conda-1.html:4240,variab,variable,4240,psi4manual/1.3.2/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/conda-1.html,2,['variab'],['variable']
Modifiability,"licity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s %s%d %d\n"" % (; """" if Pfr == 0 else "" --\n"",; ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent':; text += "" %-8s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += "" %-8s"" % (self.fsymbol(at)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(at) + "")""); text += "" %s"" % (self.full_atoms[at].print_in_input_format()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". return text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:32021,variab,variable,32021,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,2,['variab'],['variable']
Modifiability,"lif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); core.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:24823,variab,variables,24823,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,2,['variab'],['variables']
Modifiability,"lif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from global memory. Parameters; ----------; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:40606,variab,variables,40606,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:93545,variab,variables,93545,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,14,['variab'],['variables']
Modifiability,"literature and external representation of some; aspect of quantum chemistry (basis set, method, etc.) with a; shorthand and indexed representation of same. Module with functions that interface with Grimme’s DFTD3 code. run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. class OrientMols(molPermanent, molChangeable)[source]¶; Class to encode a transformation between two molecular coordinate; systems. After initializing with two qcdb.Molecule objects at the; same geometry in possible different frames and orderings, class; can apply the appropriate transformations to coordinate, gradient,; Hessian, etc. arrays. create_orientation_from_molecules(Pmol, Cmol)[source]¶; Finds the shift, rotation, axis exchange, axis inversion,; and atom remapping necessary to bring the geometry of Cmol; into coincidence with the geometry of Pmol. Pmol and Cmol; must be qcdb.Molecule and represent the same; geometry. Presently catches some errors of orientation that; Cfour as Cmol should properly fulfill. These are unnecessary; restrictions and can be relaxed later. transform_coordinates(coord)[source]¶. transform_coordinates2(coord)[source]¶. transform_elementlist(elem)[source]¶; Applies to elem th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:69537,extend,extended,69537,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['extend'],['extended']
Modifiability,"lity is accessible through Psi4. Psi4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a Psi4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into Psi4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the Psi4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in Psi4 allows Cartesians, Z-matrices, mixed; Cartesian/Z-matrix, negation of variables, delayed specification of; variables, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a Psi4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; appropriately in the *CFOUR(...) directive. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:3800,variab,variables,3800,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['variab'],['variables']
Modifiability,"lization; Initial Guess; Convergence Stabilization; ERI Algorithms; Second-order Convergence; Stability Analysis; External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; Introduction; Theory; Recommendations. CC: Coupled Cluster Theory; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; Advanced OCC Keywords; Basic DFOCC Keywords; Advanced DFOCC Keywords; Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Interpreting SAPT Results. F/I-SAPT: Functional",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/methods-1.html:1613,config,configuration,1613,psi4manual/1.1.0/methods-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/methods-1.html,2,['config'],['configuration']
Modifiability,"lized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dkh.html:3199,config,configdir,3199,psi4manual/master/dkh.html,https://psicode.org,https://psicode.org/psi4manual/master/dkh.html,2,['config'],"['configdir', 'configure']"
Modifiability,"ll -fpstkchk"" ""-fcheck=all"" ""-fbounds-check -fcheck-array-temporaries""); option_with_flags(ENABLE_ASAN ""Enables address sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=address -fno-omit-frame-pointer""); option_with_flags(ENABLE_TSAN ""Enables thread sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=thread -fPIE -pie -fno-omit-frame-pointer""); option_with_flags(ENABLE_UBSAN ""Enables undefined behavior sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=undefined -fno-omit-frame-pointer""); option_with_flags(ENABLE_MSAN ""Enables memory sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=memory -fPIE -pie -fno-omit-frame-pointer""); option_with_default(MAX_AM_ERI ""Maximum angular momentum for integrals"" 5); option_with_default(CMAKE_BUILD_TYPE ""Build type (Release or Debug)"" Release); option_with_default(FC_SYMBOL ""The type of Fortran name mangling"" 2). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recurs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:17934,config,configuration,17934,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['config'],['configuration']
Modifiability,"ll perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradient_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.compute_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:66511,variab,variables,66511,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['variab'],['variables']
Modifiability,"ll_vary}.so ../psi4/core.cpython-{ext_will_vary}.so; >>> python ../psi4/run_psi4.py --inplace input.dat. Why not to set PSIDATADIR¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is for developer use only. In PSI4 1.1; and beyond, the program always knows where its resources are, and the; only reason to set this variable is to point to another location.; Previously in PSI4 1.0 and previous, only installed executables knew; the location, so it always needed to be explicitly set when run from the; compilation directory.; At runtime; >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4. Or in the shell; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIDATADIR {top-level-psi4-dir}/psi4/share/psi4. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIDATADIR={top-level-psi4-dir}/psi4/share/psi4. How to configure C++ and C compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a C++ compiler is vital for building the code.; Downstream Dependencies — PSI4 \(\Leftarrow\) C++ Compiler. CMake Variables. CMAKE_CXX_COMPILER — CMake variable to specify name or full path to C++ compiler.; CMAKE_C_COMPILER — CMake variable to specify name or full path to C compiler.; CMAKE_CXX_FLAGS — CMake variable to specify any additional custom compiler flags for C++ source.; CMAKE_C_FLAGS — CMake variable to specify any additional custom compiler flags for C source. Examples. Build with detected compilers from PATH. >>> cmake. Build with specific (Intel) compilers from PATH. >>> cmake -DCMAKE_CXX_COMPILER=icpc -DCMAKE_C_COMPILER=icc. Build with specific (GNU) compilers not in PATH. >>> cmake -DCMAKE_CXX_COMPILER=/path/to/gcc6.2/bin/g++ -DCMAKE_C_COMPILER=/path/to/gcc6.2/bin/gcc. Build with specific (Intel) compilers from PATH based on GCC not in PATH. >>> cmake -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:29355,config,configure,29355,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,11,['config'],['configure']
Modifiability,"llable) – . Return type:; Dict[float, float]. psi4.set_output_file(ofile, append=False, *, loglevel=20, execute=True, print_header=None, inherit_loglevel=False)[source]¶; Set the name for output and logging files. Parameters:. ofile (str) – Name of ASCII output file including extension. The logging file is set from this string with a .log extension.; append (bool) – Do append to the output and logging files rather than (the default) truncating them?; loglevel (int) – The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute (bool) – Do set ofile via psi4.core.set_output_file() and add the logger, rather than just returning ofile path.; print_header (Optional[bool]) – Whether to write the Psi4 header to the ASCII output file. (Only applicable if execute=True.) By default,; writes if file is truncated (append=False) but not if appended.; inherit_loglevel (bool) – If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns:; Path(ofile). Return type:; Path. Notes; This psi4.set_output_file() command calls psi4.core.set_output_file() and should be used in; preference to it as this additionally sets up logging. pydantic model psi4.driver.task_base.BaseComputer[source]¶; Base class for “computers” that plan, run, and process QC tasks. Show JSON schema{; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }. abstract compute()[source]¶. abstract plan()[source]¶. psi4.driver.task_planner.TaskComputers¶; alias of Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]. psi4.driver.driver_nbody.SubTaskComputers¶; alias of Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. psi4.driver.task_planner.expand_cbs_methods(method, basis, driver, **kwargs)[source]¶; Sort out the user input method string into recognized fields. Handles cases l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/external_apis.html:6396,inherit,inherited,6396,psi4manual/1.9.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/external_apis.html,1,['inherit'],['inherited']
Modifiability,"llation, conda remove simint. Source. If using PSI4 built from source and you want simint built from; from source also,; enable it as a feature with ENABLE_simint,; and let the build system fetch and build it and activate dependent code. How to configure simint for building Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Examples. Build bundled. >>> cmake -DENABLE_simint=ON. Build without simint. >>> cmake. Link against pre-built. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. table of contents. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on W",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/simint-1.html:2193,variab,variable,2193,psi4manual/1.1.0/simint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/simint-1.html,4,['variab'],['variable']
Modifiability,"llelHelperE {lvalue}); | ; | Done(...); | Done( (LibParallelHelper)arg1) -> bool :; | ; | C++ signature :; | b Done(N3psi11LibParallel17LibParallelHelperE {lvalue}); | ; | MakeJob(...); | MakeJob( (LibParallelHelper)arg1) -> None :; | ; | C++ signature :; | void MakeJob(N3psi11LibParallel17LibParallelHelperE {lvalue}); | ; | Next(...); | Next( (LibParallelHelper)arg1) -> str :; | ; | C++ signature :; | N5boost6python3strE Next(N3psi11LibParallel17LibParallelHelperE {lvalue}); | ; | Synch(...); | Synch( (LibParallelHelper)arg1, (list)arg2, (int)arg3) -> list :; | ; | C++ signature :; | N5boost6python4listE Synch(N3psi11LibParallel17LibParallelHelperE {lvalue},N5boost6python4listE {lvalue},i); | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 48; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Localizer(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | C++ signature :; | void localize(N3psi9LocalizerE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:510717,inherit,inherited,510717,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"llowing work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubuntu gfortran; conda gcc or gcc-5 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gcc conda package. This provides gcc, g++, and; gfortran compilers for Mac. The two former are 4.8.5 and so are too; old to compile PSI4, but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular systems.; Downstream Dependencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; MKL_ROOT — Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location.; MATH_ROOT — Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so).; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be semicolon-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL. Examples. Build with any LAPACK in standard location. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL not also present). >>> cmake. Build with native Accelerate LAPACK on Mac (MKL also present). >>> cmake -DBLAS_TYPE=SYSTEM_NATIVE -DLAPACK_TYPE=SYSTEM_NATIVE. Build with Intel MKL. >>> source /path/to/intel/vers/linux",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:30575,variab,variable,30575,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['variab'],['variable']
Modifiability,"lly in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of Psi4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main Psi4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the Psi4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:6964,plugin,plugin,6964,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"loat)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_meta_cutoff(N3psi10FunctionalE {lvalue},d); | ; | set_name(...); | set_name( (Functional)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_name(N3psi10FunctionalE {lvalue},Ss); | ; | set_omega(...); | set_omega( (Functional)arg1, (float)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_omega(N3psi10FunctionalE {lvalue},d); | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | C++ signature :; | void set_parameter(N3psi10FunctionalE {lvalue},Ss,d); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10FunctionalEEE build_base(Ss); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ---------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:469861,inherit,inherited,469861,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"loat]. Parameters:; name (str | Callable) – . psi4.set_output_file(ofile, append=False, *, loglevel=20, execute=True, print_header=None, inherit_loglevel=False)[source]¶; Set the name for output and logging files. Parameters:. ofile (str) – Name of ASCII output file including extension. The logging file is set from this string with a .log extension.; append (bool) – Do append to the output and logging files rather than (the default) truncating them?; loglevel (int) – The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute (bool) – Do set ofile via psi4.core.set_output_file() and add the logger, rather than just returning ofile path.; print_header (Optional[bool]) – Whether to write the Psi4 header to the ASCII output file. (Only applicable if execute=True.) By default,; writes if file is truncated (append=False) but not if appended.; inherit_loglevel (bool) – If true, do not set loglevel even to default value. Instead, allow level to be inherited from existing logger. Returns:; Path(ofile). Return type:; Path. Notes; This psi4.set_output_file() command calls psi4.core.set_output_file() and should be used in; preference to it as this additionally sets up logging. pydantic model psi4.driver.task_base.BaseComputer[source]¶; Base class for “computers” that plan, run, and process QC tasks. Show JSON schema{; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }. abstract compute()[source]¶. abstract plan()[source]¶. psi4.driver.task_planner.TaskComputers¶; alias of Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]. psi4.driver.driver_nbody.SubTaskComputers¶; alias of Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. psi4.driver.task_planner.expand_cbs_methods(method, basis, driver, **kwargs)[source]¶; Sort out the user input method string into recognized fields.; Handles cases ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/external_apis.html:6356,inherit,inherited,6356,psi4manual/1.8.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/external_apis.html,1,['inherit'],['inherited']
Modifiability,"loats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:7831,variab,variable,7831,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,8,['variab'],['variable']
Modifiability,"lobals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Programming: Using the Core Libraries. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optionshandling-1.html:986,plugin,plugins,986,psi4manual/1.1.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optionshandling-1.html,4,['plugin'],"['plugin', 'plugins']"
Modifiability,"lobals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Programming with the Core Libraries. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algorithm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/optionshandling-1.html:986,plugin,plugins,986,psi4manual/1.3.2/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/optionshandling-1.html,4,['plugin'],"['plugin', 'plugins']"
Modifiability,"local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:79776,variab,variables,79776,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"local_option(Ss,Ss). psi4.get_memory()¶; Python Library Documentation: built-in function get_memory in module psi4; get_memory(...). get_memory() -> int :. Returns the amount of memory available to Psi (in bytes).; C++ signature :. m get_memory(). psi4.get_option()¶; Python Library Documentation: built-in function get_option in module psi4; get_option(...). get_option( (str)arg1, (str)arg2) -> object :. Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; C++ signature :. N5boost6python3api6objectE get_option(Ss,Ss). psi4.get_variable()¶; Python Library Documentation: built-in function get_variable in module psi4; get_variable(...). get_variable( (str)arg1) -> float :. Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; C++ signature :. d get_variable(Ss). psi4.get_variables()¶; Python Library Documentation: built-in function get_variables in module psi4; get_variables(...). get_variables() -> dict :. Returns dictionary of the PSI variables set internally by the modules or python driver.; C++ signature :. N5boost6python4dictE get_variables(). psi4.get_writer_file_prefix()¶; Python Library Documentation: built-in function get_writer_file_prefix in module psi4; get_writer_file_prefix(...). get_writer_file_prefix( (str)arg1) -> str :. Returns the prefix to use for writing files for external programs.; C++ signature :. Ss get_writer_file_prefix(Ss). psi4.git_version()¶; Python Library Documentation: built-in function git_version in module psi4; git_version(...). git_version() -> str :. Returns the git version of this copy of Psi.; C++ signature :. PKc git_version(). psi4.has_global_option_changed()¶; Python Library Documentation: built-i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:29491,variab,variables,29491,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['variab'],['variables']
Modifiability,"lopment; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:3396,config,configure,3396,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,3,['config'],"['configuration', 'configure']"
Modifiability,"lose_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(key, value); Sets",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:8401,adapt,adapted,8401,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,2,['adapt'],['adapted']
Modifiability,"lowing two implementations. MEM_DF; A DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used.; DISK_DF; A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4’s internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation.; For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications).; We have added the automatic capability to use the extremely fast DF; code for intermediate convergence of the orbitals, for SCF_TYPE; DIRECT. At the moment, the code defaults to cc-pVDZ-JKFIT as the; auxiliary basis, unless the user specifies DF_BASIS_SCF manually. For; some atoms, cc-pVDZ-JKFIT is not defined, so a very large fitting basis of last; resort will be used.; To avoid this, either set DF_BASIS_SCF to an auxiliary; basis set defined for all atoms in the system, or set DF_SCF_GUESS; to false, which disables this acceleration entirely. Second-order Convergence¶; Second-order convergence takes into account both the gradient and Hessian to; take a full Newton step with respect to the orbital parameters. This results in; quadratic convergence with respect to density for SCF methods. Fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/scf-1.html:23890,extend,extended,23890,psi4manual/1.2.1/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/scf-1.html,4,['extend'],['extended']
Modifiability,"lpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. set_array(self, arg0, arg1); Returns the requested internal array. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(self, arg0); Sets the frequencies of the Hessian. set_gradient(self, arg0); Sets the Wavefunctions gradient. set_hessian(self, arg0); Sets the Wavefunctions Hessian. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_variable(self, arg0, arg1); Sets the requested internal variable. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. variables(self); Returns the map of all internal variables. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction) → psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html:4863,variab,variables,4863,psi4manual/1.2.1/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html,2,['variab'],['variables']
Modifiability,"ls how to cache quantities within the DPD library. Type: integer; Default: 2. DCFT_GUESS¶. Whether to read the orbitals from a previous computation, or to compute an MP2 guess. Type: string; Possible Values: CC, BCC, MP2; Default: MP2. IGNORE_TAU¶. Controls whether to ignore terms containing non-idempotent contribution to OPDM or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. LOCK_OCC¶. Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. MO_RELAX¶. Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. QC_COUPLING¶. Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC only). Type: boolean; Default: true. RELAX_GUESS_ORBITALS¶. Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. RELAX_TAU¶. Controls whether to relax tau during the cumulant updates or not. Type: boolean; Default: true. STABILITY_ADD_VECTORS¶. The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__dcft-1.html:4247,coupling,coupling,4247,psi4manual/4.0b3/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__dcft-1.html,4,['coupling'],['coupling']
Modifiability,"ls per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self: psi4.core.HF, arg0: str) → float¶; docstring. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. guess(self: psi4.core.HF) → None¶; Forms the guess (guarantees C, D, and E). guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶; Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. Return type; bool. Parameters. cls (psi4.core.Wavefunction) – ; key (str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:23598,variab,variable,23598,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,18,['variab'],['variable']
Modifiability,"ls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(val)); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). def _core_del_variable(key):; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls, key):; if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables():; return {**core.scalar_variables(), **core.array_variables()}. def _core_wavefunction_variables(cls):; return {**cls.scalar_variables(), **cls.array_variables()}. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:20723,variab,variable,20723,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variable']
Modifiability,"ls.run_dftd3 = qcdb.Molecule.run_dftd3; cls.format_molecule_for_mol = qcdb.Molecule.format_molecule_for_mol. dynamic_variable_bind(core.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name* from the; geometry in string *geom*. Permitted for user use but deprecated; in driver in favor of explicit molecule-passing. Comments within; the string are filtered. """"""; molrec = qcel.molparse.from_string(; geom, enable_qm=True, missing_enabled_return_qm='minimal', enable_efp=True, missing_enabled_return_efp='none'). molecule = core.Molecule.from_dict(molrec['qm']); molecule.set_name(name). if 'efp' in molrec:; try:; import pylibefp; except ImportError as e: # py36 ModuleNotFoundError; raise ImportError(""""""Install pylibefp to use EFP functionality. `conda install pylibefp -c psi4` Or build with `-DENABLE_libefp=ON`"""""") from e; #print('Using pylibefp: {} (version {})'.format(pylibefp.__file__, pylibefp.__version__)); efpobj = pylibefp.from_dict(molrec['efp']); # pylibefp.core.efp rides along on molecule; molecule.EFP = efpobj. # Attempt to go ahead and construct the molecule; try:; molecule.update_geometry(); except:; core.print_out(""Molecule: geometry: Molecule is not complete, please use 'update_geometry'\n""; "" once all variables are set.\n""). activate(molecule). return molecule. [docs]def activate(mol):; """"""Function to set molecule object *mol* as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. """"""; core.set_active_molecule(mol). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.3.2;  · . PSI4. Module code. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/molutil.html:7365,variab,variables,7365,psi4manual/1.3.2/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/molutil.html,1,['variab'],['variables']
Modifiability,"lse:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:69767,variab,variables,69767,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"lse:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:78289,variab,variable,78289,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,14,['variab'],['variable']
Modifiability,"lsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:20478,variab,variables,20478,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['variab'],['variables']
Modifiability,"lt --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. Gnu compiler with ACML math libra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:6223,config,configuration,6223,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,2,['config'],['configuration']
Modifiability,"lt --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile later (especially if; you’re a developer), it can be convenient (but not necessary) to to put; the configure options in a small executable file, so you can re-do the; configuration later very easily. Let us assume that we will be putting; the configure options in a file named do-configure, in the top-level; psi4 directory (we’ll keep it up there instead of down in the compilation; directory $objdir, so that if we delete the compilation directory later,; we’ll still have the do-configure file). All configure options must be; on one line in the do-configure script. Note; The configure options below are for the most common architectures and; compilers. The developers would appreciate it if you would share any special; configuration options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:7203,config,configuration,7203,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['configuration']
Modifiability,"lt from; from source also,; enable it as a feature with ENABLE_ecpint,; and let the build system fetch and build it and activate dependent code. How to configure LibECPInt for building Psi4¶; Role and Dependencies. Role — In PSI4, LibECPInt is a library that provides additional; quantum chemical capabilities (ECP integrals).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) LibECPInt; Upstream Dependencies — LibECPInt \(\Leftarrow\) None. CMake Variables. ENABLE_ecpint — CMake variable toggling whether Psi4 builds with LibECPInt; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For LibECPInt, set to an installation directory containing include/libecpint.hpp; ecpint_DIR — CMake variable to specify where pre-built LibECPInt can be found. Set to installation directory containing lib/cmake/ecpint/ecpint-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_ecpint — CMake variable to force internal build of ecpint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_ecpint — CMake variable to force detecting pre-built LibECPInt and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_ecpint=ON. Build without LibECPInt. >>> cmake. Link against pre-built. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/ecpint/root. >>> cmake -DENABLE_ecpint=ON -Decpint_DIR=/path/to/ecpint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_ecpint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/ecpint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_ecpint=ON. table of contents. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LibECPInt by R. Shaw. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/ecpint.html:2280,config,configdir,2280,psi4manual/1.7.x/ecpint.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/ecpint.html,2,['config'],"['configdir', 'configure']"
Modifiability,"lt through CMake. Prior to 1.1, PSI4 had a Python; script setup as a frontend to CMake, but this is no more, and; cmake is now invoked directly. An abbreviated build guide can be found; within the source itself.; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -H.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; 1; 2; 3; 4; 5>>> cd {top-level-psi4-dir}; >>> cmake -H. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. 1>>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. What are the tools and dependencies strictly required for building Psi4; What are the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:1277,config,configuring,1277,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,4,['config'],['configuring']
Modifiability,"lt-in function fd_geoms_freq_0 in module psi4; fd_geoms_freq_0(...). fd_geoms_freq_0( (Molecule)arg1, (int)arg2) -> matrix_vector :. Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; C++ signature :. St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE fd_geoms_freq_0(N5boost10shared_ptrIN3psi8MoleculeEEE,i). psi4.fd_geoms_freq_1()¶; Python Library Documentation: built-in function fd_geoms_freq_1 in module psi4; fd_geoms_freq_1(...). fd_geoms_freq_1( (Molecule)arg1, (int)arg2) -> matrix_vector :. Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; C++ signature :. St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE fd_geoms_freq_1(N5boost10shared_ptrIN3psi8MoleculeEEE,i). psi4.fisapt()¶; Python Library Documentation: built-in function fisapt in module psi4; fisapt(...). fisapt( (Wavefunction)arg1) -> float :. Runs the functional-group intramolecular symmetry adapted perturbation theory code.; C++ signature :. d fisapt(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.flush_outfile()¶; Python Library Documentation: built-in function flush_outfile in module psi4; flush_outfile(...). flush_outfile() -> None :. Flushes the output file.; C++ signature :. void flush_outfile(). psi4.fnocc()¶; Python Library Documentation: built-in function fnocc in module psi4; fnocc(...). fnocc( (Wavefunction)arg1) -> Wavefunction :. Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE fnocc(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.get_active_efp()¶; Python Library Documentation: built-in function get_active_efp in module psi4; get_active_efp(...). get_active_efp() -> EFP :. Returns the currently active EFP object.; C++ signature :. N5boost10shared_ptrIN3psi3efp3EFPEEE get_active_efp(). psi4.get_active_molecule()¶; Python Library Documentation: built-in function get_active_molecule in m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:23686,adapt,adapted,23686,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['adapt'],['adapted']
Modifiability,"lue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). user_ref = PsiMod.get_option('DETCI', 'REFERENCE'); if (user_ref != 'RHF') or (user_ref != 'ROHF'):; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if (name.lower() == 'zapt'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); PsiMod.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; PsiMod.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif (name.lower() == 'detci-mp') or (name.lower() == 'mp'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'DETCI'); PsiMod.set_local_option('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:38043,config,configuration,38043,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,2,['config'],['configuration']
Modifiability,"lue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DiagonalizeOrder(Boost.Python.enum); | docstring; | ; | Method resolution order:; | DiagonalizeOrder; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Ascending = psi4.DiagonalizeOrder.Ascending; | ; | Descending = psi4.DiagonalizeOrder.Descending; | ; | names = {'Ascending': psi4.DiagonalizeOrder.Ascending, 'Descending': p...; | ; | values = {1: psi4.DiagonalizeOrder.Ascending, 3: psi4.DiagonalizeOrder...; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.enum:; | ; | name; | ; | ----------------------------------------------------------------------; | Methods inherited from __builtin__.int:; | ; | __abs__(...); | x.__abs__() <==> abs(x); | ; | __add__(...); | x.__add__(y) <==> x+y; | ; | __and__(...); | x.__and__(y) <==> x&y; | ; | __cmp__(...); | x.__cmp__(y) <==> cmp(x,y); | ; | __coerce__(...); | x.__coerce__(y) <==> coerce(x, y); | ; | __div__(...); | x.__div__(y) <==> x/y; | ; | __divmod__(...); | x.__divmod__(y) <==> divmod(x, y); | ; | __float__(...); | x.__float__() <==> float(x); | ; | __floordiv__(...); | x.__floordiv__(y) <==> x//y; | ; | __format__(...); | ; | __getattribute__(...); | x.__getattribute__('name') <==> x.name; | ; | __getnew",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:426133,inherit,inherited,426133,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"lugin (can also be added at runtime)"" OFF); option(ENABLE_cct3 ""Enables cct3 plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_gpu_dfcc ""Enables GPU_DFCC plugin for gpu-accelerated df-cc (requires CUDA; can also be added at runtime)"" OFF); option(ENABLE_mdi ""Enables MolSSI driver interface"" OFF); option(ENABLE_BrianQC ""Enables the BrianQC GPU module (requires CUDA; requires separate installation and licensing of the BrianQC module)"" OFF); option(ENABLE_Libint1t ""Enables Libint1 in special _t variety"" OFF); # These options are relevant to pasture, expert only; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF); option(psi4_SKIP_ENABLE_Fortran ""Suppress enabling Fortran language even when Fortran addons enabled. Use when only linking pre-built, not compiling addon code."" OFF). # Append modules added to pasture as needed; if(ENABLE_ccsort OR ENABLE_transqt2); set(ENABLE_pasture ON); message(STATUS ""Enabling pasture plugins""); endif(). if(ENABLE_gdma OR ENABLE_dkh OR ENABLE_erd OR ENABLE_PCMSolver); if(psi4_SKIP_ENABLE_Fortran); message(STATUS ""NOT Enabling Fortran""); else(). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guarantee",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_planning.html:22509,plugin,plugins,22509,psi4manual/1.9.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_planning.html,1,['plugin'],['plugins']
Modifiability,"lugin (can also be added at runtime)"" OFF); option(ENABLE_cct3 ""Enables cct3 plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_gpu_dfcc ""Enables GPU_DFCC plugin for gpu-accelerated df-cc (requires CUDA; can also be added at runtime)"" OFF); option(ENABLE_mdi ""Enables MolSSI driver interface"" OFF); option(ENABLE_BrianQC ""Enables the BrianQC GPU module (requires CUDA; requires separate installation and licensing of the BrianQC module)"" OFF); option(ENABLE_Libint1t ""Enables Libint1 in special _t variety"" OFF); # These options are relevant to pasture, expert only; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF); option(psi4_SKIP_ENABLE_Fortran ""Suppress enabling Fortran language even when Fortran addons enabled. Use when only linking pre-built, not compiling addon code."" OFF). # Append modules added to pasture as needed; if(ENABLE_ccsort OR ENABLE_transqt2); set(ENABLE_pasture ON); message(STATUS ""Enabling pasture plugins""); endif(). if(ENABLE_gdma OR ENABLE_dkh OR ENABLE_erd OR ENABLE_PCMSolver); if(psi4_SKIP_ENABLE_Fortran); message(STATUS ""NOT Enabling Fortran""); else(); enable_language(Fortran); set(Fortran_ENABLED ON) # communicate required languages with psi4-core; message(STATUS ""Enabling Fortran""); endif(); endif(). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:22091,plugin,plugins,22091,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,1,['plugin'],['plugins']
Modifiability,"lugin +scf; >>> psi4 --new-plugin myplugin +ambit. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/plugins/backtrans/backtrans.cc; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mollerplesset2/mp2.cc; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Creating a New Plugin Using a Conda Pre-compiled Binary¶; Psi4 plugins can also be created using Conda for both Psi4 binary and; development environment.; To compile a plugin with the default Makefile, it is necessary to have the; gcc compiler installed in the Conda distribution or environment (below,; $PSI4CONDA) used to run Psi4.; # prepare; >>> bash; >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; >>> conda install gcc # install compilers into expected place. # check (yes, next line gives empty result. yes, LD_LIBRARY_PATH irrelevant); >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 gcc; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc. # create and compile plugin; >>> psi4 --new-plugin testplugin # generate new plugin; >>> cd testplugin # move into plugin directory; >>> make # compile the plugin to product testplugin.so; >>> psi4 # run sample input.dat; Attention! This SCF ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:4070,plugin,plugins,4070,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugins']
Modifiability,"lugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Installation and Runtime Configuration; Build & Run FAQ. © Copyright 2021, The Psi4 Project.; Last ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_faq-1.html:3425,variab,variables,3425,psi4manual/1.4.0/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_faq-1.html,2,['variab'],['variables']
Modifiability,"lugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Installation and Runtime Configuration; Build & Run FAQ. © Copyright 2021, The Psi4 Project.; Last ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/build_faq-1.html:3425,variab,variables,3425,psi4manual/1.5.0/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/build_faq-1.html,2,['variab'],['variables']
Modifiability,"lugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”; How to fix error “RuntimeError: value for ERI”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Installation and Runtime Configuration. © Copyrig",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_faq-1.html:3377,variab,variables,3377,psi4manual/1.3.2/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_faq-1.html,2,['variab'],['variables']
Modifiability,"lugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:4755,plugin,plugin,4755,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"lution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OMP_NUM_THREADS (CFOUR)¶CFOUR (Expert) — Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect CFOUR. Type: integer; Default: 1. CFOUR_OPEN-SHELL (CFOUR)¶CFOUR — Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) inclusion of the so called “pseudo-triples” beyond the first-order interacting space is also possible. The two-determinant CC method for open-shell singlet states can be activated by TD-CC (=8). Type: string; Possible Values: SPIN-ORBITAL, SR-CC, PSA-CC_FULL, SR-CC_FULL, TD-CC; Default: SPIN-ORBITAL. CFOUR_OPT_MAXCYC (CFOUR)¶CFOUR — Identical to CFOUR_GEO_MAXCYC. Type: integer; Default: 50. CFOUR_ORBITALS (CFOUR)¶CFOUR — Specifies the type of molecular orbitals used in post-HF calculations. STANDARD (=0) requests usage of the orbitals (from a corresponding HF-SCF calculation) without any modification. These are in the case of RHF/UHF the usual canonical HF orbitals a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:62028,adapt,adapted,62028,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['adapt'],['adapted']
Modifiability,"lxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35827,variab,variables,35827,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['variab'],['variables']
Modifiability,"ly (or install just the libint conda package), then have; any/all PSI4 builds detect that installation at compile-time. How to configure Libint for building Psi4. How to get high angular momentum integrals from conda¶; To switch from the default libint package to the really large high AM; package, do the below. The channel/subchannel(s) containing the am8; metapackage and the high-AM libint package must be supplied (or in; .condarc).; 1conda install am8 -c psi4. To go back to the default libint package, do the below. The; channel/subchannel containing the default libint package must be supplied; (or in .condarc); otherwise, it’ll just remove libint and every package; depending on libint.; 1conda remove --features am8 -c psi4. The default package is AM6 because of its manageable file size (on Linux,; 10MB for libint and 40MB for libderiv). The AM7 are 20/100, respectively,; and the AM8 is 50/210. How to see what build configuration options are available¶; CMake doesn’t provide a summary for this (unless you want to try the CMake; GUI, which the developers have never looked at). However, the top half of; the main CMakeLists.txt is a passable summary:. ################ Options: Overview and Not Otherwise Mentioned ###############. # <<< CMake build overview >>>; #; # >>> ls; # external/ LICENSE psi4/ tests/ ...; # >>> cmake -H. -Bobjdir -DCMAKE_INSTALL_PREFIX=/path/to/install-psi4 ...; # ...; # -- Generating done; # -- Build files have been written to: /current/dir/objdir; # >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`; # >>> make install. # These three ""### Options ###"" sections contain useful CMake variables for build configuration. # <<< Compilers and flags >>>; #; # - CMAKE_C_COMPILER ""C compiler""; # - CMAKE_C_FLAGS ""Additional C flags""; # - CMAKE_CXX_COMPILER ""C++ compiler""; # - CMAKE_CXX_FLAGS ""Additional C++ flags""; # - CMAKE_Fortran_COMPILER ""Fortran compiler (required for some add-ons)""; # - CMAKE_Fortran_FLAGS ""Additional Fortran flags"". # <<< Detecting",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:7763,config,configuration,7763,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['config'],['configuration']
Modifiability,"ly once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through keyword tabulate, in this case the total SCF energy and the number; of atoms in each reagent.; ==> Mp2 Total Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00004802 -5.69430495 1 -2.84717649 -2; RGC1-HeHe-1.0 -0.00000064 -5.69435362 1 -2.84717649 -2; ------------------------------------------------------------------------------------------------------. ==> Requested Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Energy Reaction Error Reagent 1 Reagent 2; Ref Calc [kcal/mol] [kJ/mol] [Eh] Wt [Eh] Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.0376 0.0301 -0.0075 -0.0312 -5.69430495 1 -2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:7562,variab,variables,7562,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,9,['variab'],['variables']
Modifiability,"ly to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: str) -> bool. Sets value arg3 to string keyword arg2 scoped only to a specific module arg1. psi4.core.set_local_option_python(arg0: str, arg1: object) → None¶; Sets an option to a Python object, but scoped only to a single module. psi4.core.set_memory_bytes(memory: int, quiet: bool=False) → None¶; Sets the memory available to Psi (in bytes). psi4.core.set_num_threads(nthread: int, quiet: bool=False) → None¶; Sets the number of threads to use in SMP parallel computations. psi4.core.set_output_file(*args, **kwargs)¶; Overloaded function. set_output_file(arg0: str) -> None; set_output_file(arg0: str, arg1: bool) -> None. psi4.core.set_parent_symmetry(arg0: str) → None¶; Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. psi4.core.set_psi_file_prefix(arg0: str) → None¶. psi4.core.set_scalar_variable(arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. psi4.core.timer_off(arg0: str) → None¶; Stop timer of label argument. psi4.core.timer_on(arg0: str) → None¶; Start timer with argument as label. psi4.core.triplet(A: psi4.core.Matrix, B: psi4.core.Matrix, C: psi4.core.Matrix, transA: bool=False, transB: bool=False, transC: bool=False) → psi4.core.Matrix¶; Returns the multiplication of three matrics A, B, and C, with options to transpose each beforehand. psi4.core.tstart() → None¶; docstring. psi4.core.tstop() → None¶; docstring. psi4.core.version() → str¶; Returns the version ID of this copy of Psi. Functions¶. DASUM(arg0, arg1, arg2, arg3); docstring. DAXPY(arg0, arg1, arg2, arg3, arg4, arg5, arg6); docstring. DCOPY(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DDOT(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DGBMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGEEV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGEMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:290066,variab,variable,290066,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"ly. Python docstrings are absorbed as-is, so; please use reST math formatting (essentially $latex math$ \(\Rightarrow\); :math:`latex math`).; Starting around PSI4 1.1, MathJax is used for in-browser LaTeX; rendering in place of offline PNG generation of math images. Check the; online rendering, as occasionally there will be errors even when the LaTeX; looked sound. The Map of the Sphinx¶. Adding a new Appendix or First-TOC-Level page; Create your reST file and fill it with information. Add the name of your; file to psi4/doc/sphinxman/source/appendices.rst for an appendix or; to psi4/doc/sphinxman/source/index.rst for a first-TOC-level.; Finally, add your file to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your; new page. Adding a new module to “Theoretical Methods”; Copy the file of a well-established module, like; psi4/doc/sphinxman/source/sapt.rst. Change the title, author, sec; label, ref, and source labels at the top of the file to point instead to; your code. Edit psi4/doc/sphinxman/source/methods.rst to add the; name of your file so that it will appear in the TOC tree. Add your file; to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your new; file. Follow the models in existing methods pages to write your; documentation. If you don’t get all the keyword links, bibliography; links, sample inputs, math, tables, etc. working in Sphinx, don’t worry; about it. A genie will probably come through and tidy up all your; source. table of contents. Updating the PSI4 Users’ and Programmers’ Manual; Installing Sphinx; Documentation Structure; reStructuredText; Math in the Codebase; The Map of the Sphinx. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Updating the PSI4 Users’ and Programmers’ Manual. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/documentation.html:7578,variab,variable,7578,psi4manual/master/documentation.html,https://psicode.org,https://psicode.org/psi4manual/master/documentation.html,1,['variab'],['variable']
Modifiability,"ly.; The back conversion to a Wavefunction object uses the .from_file() functionality; # read wavefunction from file; wfn_from_file = psi4.core.Wavefunction.from_file('my_wfn'). # make a wavefunction from the dict; wfn_from_dict = psi4.core.Wavefunction.from_file(wfn_dict). ~/.psi4rc File¶. Caution; The ~/.psi4rc file is only read for Psithon input, not PsiAPI.; It does nothing that can’t be done in other more transparent ways.; It should be avoided.; It is very easy to forget about the ~/.psi4rc file you once; created, leading to great confusion over why all your jobs are using; the wrong memory or are suddenly not density-fit. Also be aware that; ~/.psi4rc contents count as part of your input file (invoked after; e.g. from psi4 import * and before your Psithon–>Python parsed; input commands), so these settings take priority over command-line; arguments to the psi4 executable.; Please use the ~/.psi4rc file sparingly. If using the environment variable PSI_SCRATCH is inconvenient,; or if some psi4_io commands must be present in all input files,; the ~/.psi4rc resource file can be used (example psi4/samples/example_psi4rc_file).; All the commands mentioned in section Scratch Files can be used in this file.; To set up the scratch path:; psi4_io.set_default_path('/scratch/user'). To set up the scratch path from a variable $MYSCRATCH:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). To set up a specific path for the internal coordinate file and instruct PSI4 not to delete it:; psi4_io.set_specific_path(12, './'); psi4_io.set_specific_retention(12, True). # equivalent to above; psi4_io.set_specific_path(PSIF_INTCO, './'); psi4_io.set_specific_retention(PSIF_INTCO, True). The Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. As a consequence, the commands in the input files supersede; any instruct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:9947,variab,variable,9947,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['variab'],['variable']
Modifiability,"l{name}}_{rxn}-\text{REF}_{rxn})^2}}\]. DCT LAMBDA ENERGY¶; An energy term in density cumulant theory [E_h]. This term is the; 2-electron cumulant’s contribution contribution to the reduced; density matrix energy expression. Not recommended for interpretative; use except by reduced density matrix specialists. DCT SCF ENERGY¶; An energy term in density cumulant theory [E_h]. This term is the; 1-electron reduced density matrix (1RDM) contribution to the reduced; density matrix energy expression, plus the contribution of the; antisymmetrized product of 1RDMs. Not recommended for interpretative; use except by reduced density matrix specialists. DCT THREE-PARTICLE ENERGY¶; The three-particle correlation energy correction [E_h] in density cumulant; theory, akin to (T) CORRECTION ENERGY in coupled-cluster. DCT TOTAL ENERGY¶; Total energy [E_h] in density cumulant theory. Sum of DCT SCF ENERGY,; DCT LAMBDA ENERGY, and DCT THREE-PARTICLE ENERGY when present. DETCI AVG DVEC NORM¶; A measure of configuration interaction convergence. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [E_h] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; \(E_{\text{FCTL}}\) in Eqs. (4) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [E_h] for the requested DFT method,; \(E_{\text{DFT}}\) in Eq. (1). \begin{align*}; E_{\text{DFT}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{FCTL}} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{SCF}} + E_{\text{DH}}; \end{align*}Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the reques",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:27964,config,configuration,27964,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['config'],['configuration']
Modifiability,"m = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:40760,variab,variable,40760,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,6,['variab'],['variable']
Modifiability,"m = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:40756,variab,variable,40756,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"m = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:33926,variab,variable,33926,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"m = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[label] = core.Matrix.from_array(array, name=label) if array is not None else None. for label in wfn_vector:; array = wfn_vector[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not None else None. for label in wfn_dimension:; tup = wfn_dimension[label]; wfn_dimension[label] = core.Dimension.from_list(tup, name=label) if tup is not None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn, filename=None):; """"""Converts a Wavefunction object to a base class. Parameters; ----------; wfn : Wavefunction; A Wavefunction or inherited class; filename : None, optional; An optional filename to write the data to. Returns; -------; dict; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),; 'matrix': {; 'Ca': wfn.Ca().to_array() if wfn.Ca() else None,; 'Cb': wfn.Cb().to_array() if wfn.Cb() else None,; 'Da': wf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:6481,variab,variables,6481,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variables']
Modifiability,"m = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[label] = core.Matrix.from_array(array, name=label) if array is not None else None. for label in wfn_vector:; array = wfn_vector[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not None else None. for label in wfn_dimension:; tup = wfn_dimension[label]; wfn_dimension[label] = core.Dimension.from_list(tup, name=label) if tup is not None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn: core.Wavefunction, filename: str = None) -> Dict:; """"""Converts a Wavefunction object to a base class. Parameters; ----------; wfn; A Wavefunction or inherited class; filename; An optional filename to write the data to. Returns; -------; dict; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),; 'matrix': {; 'Ca': wfn.Ca().to_array() if wfn.Ca() else None,; 'Cb': wfn.Cb().to_array() if wfn.Cb() else None,; 'Da': ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:6772,variab,variables,6772,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,6,['variab'],['variables']
Modifiability,"m = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[label] = core.Matrix.from_array(array, name=label) if array is not None else None. for label in wfn_vector:; array = wfn_vector[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not None else None. for label in wfn_dimension:; tup = wfn_dimension[label]; wfn_dimension[label] = core.Dimension.from_list(tup, name=label) if tup is not None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn: core.Wavefunction, filename: str = None) -> Dict[str, Dict[str, Any]]:; """"""Serialize a Wavefunction object. Opposite of; :meth:`~psi4.core.Wavefunction.from_file`. Parameters; ----------; wfn; Wavefunction or inherited class instance.; filename; An optional filename to which to write the data. Returns; -------; ~typing.Dict[str, ~typing.Dict[str, ~typing.Any]]; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:10290,variab,variables,10290,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variables']
Modifiability,"m Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/libint.html:3047,config,configdir,3047,psi4manual/1.6.x/libint.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libint.html,3,"['config', 'variab']","['configdir', 'configure', 'variables']"
Modifiability,"m gradients for H2O. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. stability3; Test LDA stability analysis against QChem. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. scf-level-shift-rks; SCF level shift on an RKS computation. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. cc36; CC2(RHF)/cc-pVDZ energy of H2O. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. fnocc3; Test FNO-QCISD(T) computation. frac-sym; Fractional occupation with symmetry. tdscf-7; TD-HF test variable access. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). scf-upcast-custom-basis; test scf castup with custom basis sets. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, compute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:22128,variab,variable,22128,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['variab'],['variable']
Modifiability,"m is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available.; The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but at present, it is only available for UHF \(\rightarrow\) UHF stability; analysis. The capabilities of both algorithms are summarized below:. Stability analysis methods available in PSI4¶. Algorithm; REFERENCE; Stability checked; SCF_TYPE. Direct Inversion; RHF; Internal, External (\(\rightarrow\) UHF); PK only. ROHF; Internal; PK only. Davidson; UHF; Internal; Anything. The best algorithm is automatically selected, i.e. Davidson for UHF \(\rightarrow\) UHF and Direct Inversion otherwise.; In addition to the options available for Direct Inversion, the Davidson algorithm can automatically; adapt FOLLOW_STEP_SCALE to find a new SCF minimum. If MAX_ATTEMPTS > 1, additional attempts; will automatically increment FOLLOW_STEP_SCALE by 0.2 every time the SCF falls back to the previously; found unstable minimum. The increment can be adjusted by setting FOLLOW_STEP_INCREMENT.; The default value is 0.2; adjust if needed to try different values of FOLLOW_STEP_SCALE in a single computation.; The Davidson solver for the eigenvalues is controlled through several keywords. In the following; we only report the most pertinent for stability analysis, see documentation for the CPHF; module for a complete list.; Some default values were modified for the stability analysis code, in that case they are; explicitly indicated here. SOLVER_MAXITER: maximum number of iterations; SOLVER_CONVERGENCE: eigenvector convergence threshold; SOLVER_N_ROOT: Solve for N eigenvectors in each irreducible representation; SOLVER_N_GUESS: Use N guess vectors, this needs to be larger tha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:29237,adapt,adapt,29237,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,2,['adapt'],['adapt']
Modifiability,"m pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) None. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:7663,variab,variable,7663,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,4,['variab'],['variable']
Modifiability,"m; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]], lgeom[il + 1]; ); ). if not all(len(v) == 2 for v in variables):; raise ValidationError(""""""Variables should come in pairs: {}"""""".format(variables)). vvars = [[str(v[0]), float(v[1])] for v in variables]. return {""geom_unsettled"": geom_unsettled, ""variables"": vvars}. «; hide menu. me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:22406,variab,variables,22406,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,6,['variab'],['variables']
Modifiability,"mPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns; Whether some form of DIIS is enabled during SCF. Return type; bool. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:35651,variab,variable,35651,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,10,['variab'],['variable']
Modifiability,"macOS (and Windows, through the Ubuntu shell). If using the PSI4 binary, CheMPS2 has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; CheMPS2 can be obtained through conda install chemps2.; Then enable it as a feature with ENABLE_CheMPS2,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect CheMPS2 and activate dependent code. Previous bullet had details. To build PSI4 from source and use; Libint from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove chemps2. Source. If using PSI4 built from source and you want CheMPS2 built from; from source also,; enable it as a feature with ENABLE_CheMPS2,; and let the build system fetch and build it and activate dependent code. Methods¶. Density matrix renormalization group capabilities of PSI4 through CheMPS2¶. name; calls method; Energy; Gradient. dmrg-ci; DMRG configuration interaction (CI); RHF/ROHF; —. dmrg-scf; DMRG complete active space SCF (CASSCF); RHF/ROHF; —. dmrg-caspt2; DMRG CAS with 2nd-order perturbation theory (CASPT2); RHF/ROHF; —. DMRG Keywords¶. DMRG_CASPT2_CALC¶. Do calculate the DMRG-CASPT2 energy after the DMRGSCF calculations are done?. Type: boolean; Default: false. DMRG_CASPT2_IMAG¶. CASPT2 Imaginary shift. Type: double; Default: 0.0. DMRG_CASPT2_IPEA¶. CASPT2 IPEA shift. Type: double; Default: 0.0. DMRG_CASPT2_ORBS¶. Whether to calculate the DMRG-CASPT2 energy after the DMRGSCF calculations are done. Type: string; Possible Values: PSEUDOCANONICAL, ACTIVE; Default: PSEUDOCANONICAL. DMRG_DIIS¶. Whether or not to use DIIS for DMRG. Type: boolean; Default: false. DMRG_DIIS_WRITE¶. Whether or not to store the DIIS checkpoint on disk (convenient for restarting). Type: boolean; Default: true. DMRG_EXCITATION¶. Which root is targeted: 0 means ground state, 1 first excited state, etc. Type: integer; Default: 0. DMRG_IRREP¶. The DMRG wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/chemps2-1.html:1732,config,configuration,1732,psi4manual/1.2.1/chemps2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/chemps2-1.html,4,['config'],['configuration']
Modifiability,"managers:; Ubuntu gfortran; conda gcc or gcc-5 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gcc conda package. This provides gcc, g++, and; gfortran compilers for Mac. The two former are 4.8.5 and so are too; old to compile PSI4, but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular systems.; Downstream Dependencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; MKL_ROOT — Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location.; MATH_ROOT — Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so).; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be semicolon-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL. Examples. Build with any LAPACK in standard location. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL not also present). >>> cmake. Build with native Accelerate LAPACK on Mac (MKL also present). >>> cmake -DBLAS_TYPE=SYSTEM_NATIVE -DLAPACK_TYPE=SYSTEM_NATIVE. Build with Intel MKL. >>> source /path/to/intel/vers/linux/mkl/bin/mklvars.sh intel64 # adjust sh/csh and arch as needed; >>> cmake. >>> MATH_ROOT=/path/to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:30704,variab,variable,30704,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['variab'],['variable']
Modifiability,"mary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psi4/conda/psi4-path-advisor.py; (extensive help menu at conda/psi4-path-advisor.py -h); or psicode downloads; page for the latest guides. This section fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”).; To see working builds for Linux, Mac, and Windows, see :src:; [this GHA]. Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given he",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_planning.html:1230,config,configure,1230,psi4manual/1.9.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_planning.html,2,['config'],['configure']
Modifiability,"mation for both users; and programmers in separate sections. From the top-level object directory,; build the following target (note that a working version of the Psi4; executable in bin/psi4 is a requirement for building the; documentation).:; >>> make sphinxman. This will build a full set of documentation in the html directory that can be viewed offline through any browser.; doc/sphinxman/html/index.html. Much of the documentation is auto-generated from the source. At present,; this covers:. Physical Constants: psi4/include/physconst.h; Python Driver: docstrings from *.py files in psi4/share/python; Databases: docstrings from *.py files in psi4/share/databases; Basis Sets: *.gbs files in psi4/share/basis; C++ Keywords: psi4/src/bin/psi4/read_options.cc; Sample Inputs: input.dat files in psi4/samples; PSI Variables: Process::environment.globals lines and comments in the C++ code; Plugins: doc.rst text, *.py modules, and C++ keywords in psi4/tests/plugin_* plugin directories (disabled at the moment); PSI Files: scratch file names and numbers in psi4/include/psifiles.h. Some documentation is even extracted from Psi4 objects at runtime. psi4: docstrings for the psi4 built-in module constructed in psi4/src/bin/psi4; DFT: functional availibility and characteristics as encoded in psi4/share/python/functional.py; BasisFamily: fitting basis sets for each orbital basis as encoded in psi4/share/python/basislistdunning.py and psi4/share/python/basislistother.py. Building all the documentation takes ~10 minutes. There is now good; dependency structure built into the psi4/doc/sphinxman/CMakeLists.txt; , so very long builds should be infrequent (unless you’re touching; psi4/src/bin/psi4/read_options.cc. Note that not all dependencies are; encoded (PSI variables, for instance, depend on every .cc file in the; source tree), so for a definitive doc build, remove (in the object; directory) doc/sphinxman and start from scratch.; Even ~10 minutes of build time can be annoying when deve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/documentation-1.html:2419,plugin,plugin,2419,psi4manual/1.0.0/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/documentation-1.html,2,['plugin'],['plugin']
Modifiability,"mation( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | C++ signature :; | void form_symmetry_information(N3psi8MoleculeE {lvalue},d); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | C++ signature :; | N3psi6MatrixE geometry(N3psi8MoleculeE {lvalue}); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | C++ signature :; | Ss get_full_point_group(N3psi8MoleculeE {lvalue}); | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | C++ signature :; | d get_variable(N3psi8MoleculeE {lvalue},Ss); | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | C++ signature :; | b is_variable(N3psi8MoleculeE {lvalue},Ss); | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | C++ signature :; | Ss label(N3psi8MoleculeE {lvalue},i); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | C++ signature :; | d mass(N3psi8MoleculeE {lvalue},i); | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | C++ signature :; | i molecular_charge(N3psi8MoleculeE {lvalue}); | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | C++ signature :; | void move_to_com(N3psi8MoleculeE {lvalue}); | ; | multiplicity(...); | multiplicity( (Molecule)arg1) -> int :; | Gets the multiplicity (defined as 2Ms + 1); | ; | C++ signature :; | i multiplicity(N3psi8MoleculeE {lvalue}); | ; | name(...); | n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:548878,variab,variable,548878,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['variab'],['variable']
Modifiability,"mber of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self); Get dict of converged T amplitudes. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:4525,variab,variable,4525,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,2,['variab'],['variable']
Modifiability,"mber of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self); Get dict of converged T amplitudes. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction’s gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction’s Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction’s electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction’s molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:4509,variab,variable,4509,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,1,['variab'],['variable']
Modifiability,"mber of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(key). get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int; Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key). gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool; Is the Matrix QC variable (case-insensitive) set?. has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool; Is the double QC variable (case-insensitive) set?. has_variable(key). hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Wavefunction’s Hessian. legacy_frequencies(). mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule; Returns the Wavefunction’s molecule. nalpha(self: psi4.core.Wavefunction) → int; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction) → int; Number of frozen core electrons. nirrep(self: psi4.core.Wavefunction) → int; Number of irreps in the syste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:23371,variab,variable,23371,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"mber of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self: psi4.core.HF, arg0: str) → float¶; docstring. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. guess(self: psi4.core.HF) → None¶; Forms the guess (guarantees C, D, and E). guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶; Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. Return type; bool. Parameters. cls (psi4.core.Wavefunction) – ; key (str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:25348,variab,variable,25348,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,10,['variab'],['variable']
Modifiability,"mber of molecule orbitals. nmopi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of molecular orbitals per irrep. no_occupations(self: psi4.core.Wavefunction) → List[List[Tuple[float, int, int]]]; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction) → int; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of symmetry orbitals per irrep. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]; Returns the dictionary of all double QC variables. set_array(key, val). set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None; Sets the requested external potential. set_frequencies(val). set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None; Sets the Wavefunction’s Hessian. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None; Sets the frequencies of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None; Sets the level ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:25441,variab,variables,25441,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variables']
Modifiability,"mber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. guess(self: psi4.core.HF) → None¶; Forms the guess (guarantees C, D, and E). guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶; Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. Return type; bool. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. initialize()¶; Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self: psi4.core.HF) → None¶; Sets up a GTFock JK object. initialize_jk(memory, jk=None)¶. iterations(e_conv=None, d_conv=None)¶. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. legacy_frequencies()¶. Deprecated since version 1.4. mintshelper(self: psi4.core.CUHF) → psi4.core.MintsHelper¶; The MintsHelper object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extent",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:24398,variab,variable,24398,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,5,['variab'],['variable']
Modifiability,"mber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. guess(self: psi4.core.HF) → None¶; Forms the guess (guarantees C, D, and E). guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶; Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. Return type; bool. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. initialize()¶; Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self: psi4.core.HF) → None¶; Sets up a GTFock JK object. initialize_jk(memory, jk=None)¶. iterations(e_conv=None, d_conv=None)¶. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. legacy_frequencies()¶. Deprecated since version 1.4. mintshelper(self: psi4.core.RHF) → psi4.core.MintsHelper¶; The MintsHelper object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rhf.html:24392,variab,variable,24392,psi4manual/1.4.0/api/psi4.core.rhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rhf.html,6,['variab'],['variable']
Modifiability,"mber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. guess(self: psi4.core.HF) → None¶; Forms the guess (guarantees C, D, and E). guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶; Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. Return type; bool. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. initialize()¶; Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self: psi4.core.HF) → None¶; Sets up a GTFock JK object. initialize_jk(memory, jk=None)¶. iterations(e_conv=None, d_conv=None)¶. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. legacy_frequencies()¶. Deprecated since version 1.4. mintshelper(self: psi4.core.ROHF) → psi4.core.MintsHelper¶; The MintsHelper object. moFa(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. moFb(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rohf.html:24469,variab,variable,24469,psi4manual/1.4.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rohf.html,6,['variab'],['variable']
Modifiability,"mber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. guess(self: psi4.core.HF) → None¶; Forms the guess (guarantees C, D, and E). guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶; Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. Return type; bool. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. initialize()¶; Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self: psi4.core.HF) → None¶; Sets up a GTFock JK object. initialize_jk(memory, jk=None)¶. iterations(e_conv=None, d_conv=None)¶. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. legacy_frequencies()¶. Deprecated since version 1.4. mintshelper(self: psi4.core.UHF) → psi4.core.MintsHelper¶; The MintsHelper object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.uhf.html:24392,variab,variable,24392,psi4manual/1.4.0/api/psi4.core.uhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.uhf.html,6,['variab'],['variable']
Modifiability,"mber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. guess(self: psi4.core.HF) → None¶; Forms the guess (guarantees C, D, and E). guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶; Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. Return type; bool. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. initialize()¶; Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self: psi4.core.HF) → None¶; Sets up a GTFock JK object. initialize_jk(memory, jk=None)¶. iterations(e_conv=None, d_conv=None)¶. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. legacy_frequencies()¶. Deprecated since version 1.4. mintshelper(self: psi4.core.Wavefunction) → psi4.core.MintsHelper¶; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.hf.html:24422,variab,variable,24422,psi4manual/1.4.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.hf.html,5,['variab'],['variable']
Modifiability,"me = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. # Always must set SCF dipole (retire components at v1.5); with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for cart in [""X"", ""Y"", ""Z""]:; core.set_variable(""SCF DIPOLE "" + cart, core.variable(name + "" DIPOLE "" + cart)); core.set_variable(""SCF DIPOLE"", core.variable(name + "" DIPOLE"")) # P::e SCF. # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']) # yapf:disable. oneel_properties = core.OEProp.valid_methods; twoel_properties = []; response_properties = ['POLARIZABILITY', 'ROTATION', 'ROA', 'ROA_TENSOR']; excited_properties = ['OSCILLATOR_STRENG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:95877,variab,variable,95877,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"me of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:43835,extend,extending,43835,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,8,['extend'],['extending']
Modifiability,"me with any; any “.in” or “.dat” extension replaced by “.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; 1; 2>>> psi4 --version; 0.4.262. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /scratch/user. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/scratch/user. PSIPATH¶; Path in which PSI4 looks for user extensions to the built-in; libraries. Specifically, directories containing; user basis sets,; EFP fragments,; databases,; plugins, and; interface",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/external-1.html:18458,variab,variable,18458,psi4manual/1.2.1/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/external-1.html,4,['variab'],['variable']
Modifiability,"me with any; any ”.in” or ”.dat” extension replaced by ”.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; 1; 2>>> psi4 --version; 0.4.262. Environment Variables¶; These environment variables will influence PSI4‘s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /scratch/user. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/scratch/user. PSIPATH¶; Path in which PSI4 looks for user extensions to the built-in; libraries. Specifically, directories containing; user basis sets,; EFP fragments,; databases,; plugins, and; interface",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:18347,variab,variable,18347,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,2,['variab'],['variable']
Modifiability,"me,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilena",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:4227,variab,variable,4227,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,15,['variab'],['variable']
Modifiability,"memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:1317,adapt,adapted,1317,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,15,['adapt'],['adapted']
Modifiability,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2007-2024, The Psi4 Project.; Last upda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/libefp.html:8033,variab,variable,8033,psi4manual/master/libefp.html,https://psicode.org,https://psicode.org/psi4manual/master/libefp.html,2,['variab'],['variable']
Modifiability,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Create",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libefp-1.html:8220,variab,variable,8220,psi4manual/1.2.1/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libefp-1.html,4,['variab'],['variable']
Modifiability,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/libefp-1.html:8220,variab,variable,8220,psi4manual/1.3.2/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/libefp-1.html,4,['variab'],['variable']
Modifiability,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2021, The Psi4 Project.; Last updated on Thursda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/libefp-1.html:8024,variab,variable,8024,psi4manual/1.4.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/libefp-1.html,4,['variab'],['variable']
Modifiability,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2021, The Psi4 Project.; Last updated on Sunday,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/libefp-1.html:8024,variab,variable,8024,psi4manual/1.5.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/libefp-1.html,4,['variab'],['variable']
Modifiability,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2022, The Psi4 Project.; Last updated on Thursda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/libefp.html:8024,variab,variable,8024,psi4manual/1.6.x/libefp.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libefp.html,2,['variab'],['variable']
Modifiability,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/libefp.html:8024,variab,variable,8024,psi4manual/1.7.x/libefp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/libefp.html,2,['variab'],['variable']
Modifiability,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2007-2023, The Psi4 Project.; Last updated on ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/libefp.html:8026,variab,variable,8026,psi4manual/1.8.x/libefp.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/libefp.html,2,['variab'],['variable']
Modifiability,"ment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2007-2024, The Psi4 Project.; Last updated on ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/libefp.html:8026,variab,variable,8026,psi4manual/1.9.x/libefp.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/libefp.html,2,['variab'],['variable']
Modifiability,"ment symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]¶; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int) → psi4.core.Vector3¶; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int) → float¶; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int) → float¶; z position [Bohr] of atom arg0 (0-indexed without dummies). table of contents. Molecule; Molecule; Molecule.B787(); Molecule.BFS(); Molecule.Z(); Molecule.activate_all_fragments(); Molecule.add_atom(); Molecule.atom_at_position(); Molecule.basis_on_atom(); Molecule.center_of_mass(); Molecule.charge(); Molecule.clone(); Molecule.com_fixed(); Molecule.comment(); Molecule.connectivity(); Molecule.create_psi4_string_from_molecule(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:39023,variab,variable,39023,psi4manual/1.8.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html,6,['variab'],['variable']
Modifiability,"meter('B97_os_a4', 17.94491). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', 3.77344); C.set_parameter('B97_ss_a2', -26.04463); C.set_parameter('B97_ss_a3', 30.69913); C.set_parameter('B97_ss_a4', -9.22695). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.28) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05_2x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05-2X'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Theory Comput., 2, 364, 2006\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_2X_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; C2 = 4.49267E-3; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2; X.set_parameter('PBE_kp', kp); X.set_parameter('PBE_mu', mu). # Meta Exchange type is insane mess of w power series expansion; X.set_parameter('Meta_a0', 1.0); X.set_parameter('Meta_a1', -0.56833); X.set_parameter('Meta_a2', -1.30057); X.set_parameter('Meta_a3', 5.50070); X.set_parameter('Meta_a4', 9.06402); X.set_parameter('Meta_a5', -32.21075); X.set_parameter('Meta_a6', -23.73298); X.set_parameter('Meta_a7', 70.22996); X.set_parameter('Meta_a8', 29.88614",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:64390,Parameteriz,Parameterized,64390,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,1,['Parameteriz'],['Parameterized']
Modifiability,"method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class DoublePyBuffer(Boost.Python.instance); | Buffer interface to NumPy arrays; | ; | Method resolution order:; | DoublePyBuffer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | __array_interface__; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class EFP(Boost.Python.instance); | Class interfacing with libefp; | ; | Method resolution order:; | EFP; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (object)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,N3psi7OptionsE {lvalue}); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | compute(...); | compute( (EFP)arg1) -> None :; | Computes libefp energies and, if active, torque; | ; | C++ signature :; | void compute(N3psi3efp3EFPE {lvalue}); | ; | nfragments(...); | nfragments( (EFP)arg1) -> int :; | Returns the number of EFP fragments in the molecule; | ; | C++ signature :; | i nfragments(N3psi3efp3EFPE {lvalue}); | ; | print_out(...); | pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:439862,inherit,inherited,439862,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"metry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 144 3 3 3 0; B 142 140 2 2 2 0; -------------------------------------------------------; Total 287 284 5 5 5 0; -------------------------------------------------------. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. The table also shows the initial assignment of electrons to; irreps. Initial Guess/Convergence Stabilization¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:12757,adapt,adapted,12757,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,10,['adapt'],['adapted']
Modifiability,"metry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (IntegralFactory)arg4, (MatrixFactory)arg5) -> None :; | ; | C++ signature :; | void __init__(P7_object,i,N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost10shared_ptrIN3psi15IntegralFactoryEEE,N5boost10shared_ptrIN3psi13MatrixFactoryEEE); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | C++ signature :; | St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE create_matrices(N3psi16OperatorSymmetryE {lvalue},Ss); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class NBOWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | NBOWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (NBOWriter)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void write(N3psi9NBOWriterE {lvalue},Ss); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | -------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:562921,inherit,inherited,562921,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"mies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:35286,variab,variable,35286,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['variab'],['variable']
Modifiability,miltonians; SAPT: Symmetry-Adapted Perturbation Theory; SAPT: Symmetry-Adapted Perturbation Theory; HF: Hartree–Fock Theory; HF: Hartree–Fock Theory; Search; Search; Interface to SIMINT by B. Pritchard; Interface to SIMINT by B. Pritchard; Embarrassing Parallelism; Embarrassing Parallelism; Test Suite and Sample Inputs; Test Suite and Sample Inputs; Vibrational and Thermochemical Analysis; Vibrational and Thermochemical Analysis; Psithon Tutorial: Using PSI4 as an Executable; Psithon Tutorial: Using PSI4 as an Executable. /1.2.1; . PSI4: Open-Source Quantum Chemistry. _downloads; ; gdma-2.2.06.pdf. _modules; . /psi4; . /driver; ; psi4.driver.aliases; psi4.driver.diatomic; psi4.driver.driver; psi4.driver.driver_cbs; psi4.driver.driver_nbody; psi4.driver.inputparser; psi4.driver.molutil. /p4util; ; psi4.driver.p4util.exceptions; psi4.driver.p4util.fcidump; psi4.driver.p4util.numpy_helper; psi4.driver.p4util.python_helpers; psi4.driver.p4util.text; psi4.driver.p4util.util. psi4.driver.plugin. /procrouting; ; psi4.driver.procrouting.empirical_dispersion; psi4.driver.procrouting.proc; psi4.driver.procrouting.proc_util. /qcdb; ; psi4.driver.qcdb.molecule. psi4.driver.qmmm. /util; ; psi4.driver.util.filesystem. psi4.driver.wrapper_database. /qcdb; ; qcdb.interface_dftd3; qcdb.interface_gcp. Overview: module code. _static; ; basic.css; cloud.base.js; cloud.css; cloud.js; doctools.js; documentation_options.js; favicon-psi4.ico; jquery.cookie.js; jquery.js; psi4.css; pygments.css; searchtools.js; underscore.js. PSI4: Open-Source Quantum Chemistry; ADC: Ab Initio Polarization Propagator; ADC: Ab Initio Polarization Propagator; Adding Test Cases; Adding Test Cases. api; ; adc; adc; AngularMomentumInt; AOShellCombinationsIterator; atomic_displacements; atomic_displacements; BasisExtents; BasisFunctions; BasisSet; be_quiet; be_quiet; benchmark_blas1; benchmark_blas1; benchmark_blas2; benchmark_blas2; benchmark_blas3; benchmark_blas3; benchmark_disk; benchmark_disk; benchmark_integ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:373594,plugin,plugin,373594,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['plugin']
Modifiability,"mmendations:; It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat, as it is usually just the completely; unoptimized netlib distribution. The choice of LAPACK is less; critical, and so the unoptimized netlib distribution is acceptable.; Perhaps the best choice, if available, is Intel’s MKL library,; which includes efficient threaded BLAS and LAPACK (as of PSI4; v1.1, earliest known working version is MKL 2013). On Mac, the; native Accelerate libraries are also recommended.; For open-source LAPACK distributions, OpenBLAS (formerly GotoBLAS); is known to work, while ATLAS is known; (https://github.com/psi4/psi4/issues/391) to have stability issues; with the DFOCC module.; ACML libraries are known to work with PSI4 v1.1 at ACML 6. The BLAS/LAPACK detected for PSI4 are also linked into any; Add-Ons (e.g., libefp) that require them, rather than relying on; those packages’ native math detection.; The separation between BLAS and LAPACK seen in detection printing; and CMake variables is purely formal. In practice, they get run; together and linked as ${LAPACK_LIBRARIES} ${BLAS_LIBRARIES}.; Sometimes the CMake’s library search capabilites falter at SONAMEs; (e.g., libblas.so.3 vs. libblas.so), extensions (static; vs. dynamic), or suffixes (e.g., libacml_mp.so vs.; libacml.so). The developers would be interested in hearing; of such problems to expand the math detection capabilities. The; immediate solution, however, is to form symlinks between the; library names that exist and the names expected. Consult file; psi4/cmake/math/MathLibs.cmake for the library patterns being; sought.; The BLAS/LAPACK interface is standardized, so only libraries, not; headers, need to be detected. The exception is MKL, where the mkl.h; header defines additional functionality; it must be located to use; BLAS threading. How to configure Python for building Psi4¶; Role and Dependencies. Role — In PSI4, Python allows the core compiled C++ code to; be flexib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:33420,variab,variables,33420,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['variab'],['variables']
Modifiability,"mme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(""fsapt0-d3mbj""). See FSAPT documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; CPHF_R_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. SAPT(DFT); Basic Keywords for SAPT(DFT); SAPT_DFT_GRAC_SHIFT_A; SAPT_DFT_GRAC_SHIFT_B; SAPT_DFT_DO_DHF; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Advanced Keywords for SAPT(D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:50159,parameteriz,parameterization,50159,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,1,['parameteriz'],['parameterization']
Modifiability,"mme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(""fsapt0-d3mbj""). See FSAPT documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. SAPT(DFT); Basic Keywords for SAPT(DFT); SAPT_DFT_GRAC_SHIFT_A; SAPT_DFT_GRAC_SHIFT_B; SAPT_DFT_DO_DHF; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Advanced Keywords ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/sapt.html:49666,parameteriz,parameterization,49666,psi4manual/1.7.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/sapt.html,3,['parameteriz'],['parameterization']
Modifiability,"mme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(“fsapt0-d3mbj”). See FSAPT <fisapt> documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. SAPT(DFT); Basic Keywords for SAPT(DFT); SAPT_DFT_GRAC_SHIFT_A; SAPT_DFT_GRAC_SHIFT_B; SAPT_DFT_DO_DHF; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Advanced ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:46369,parameteriz,parameterization,46369,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,5,['parameteriz'],['parameterization']
Modifiability,"model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to ddx by A. Mikhalev, A. Jha, M. Nottoli and M. F. Herbst; Installation; Using dd-based continum solvation models; Solvent model and solvent cavity definition; Numerical integration and discretisation parameters; Iterative solver parameters; Further keywords for ddx; How to configure ddx for building Psi4. Interface to DFTD3 by S. Grimme; Empirical Dispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/interfacing.html:2276,config,configure,2276,psi4manual/1.7.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/interfacing.html,3,['config'],['configure']
Modifiability,"module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if input.yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:30797,Config,Configuration,30797,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Config'],['Configuration']
Modifiability,"module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = os.environ.get('PSIDATADIR', None); plugin_path = join_path(psidatadir, ""plugin""); for dir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, dir)):; available_plugins.append(dir). [docs]def create_plugin(name, template):; """"""Generate plugin in directory with sanitized *name* based upon *template*."""""". name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/plugin.html:3249,plugin,plugins,3249,psi4manual/1.1.0/_modules/psi4/driver/plugin.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/plugin.html,1,['plugin'],['plugins']
Modifiability,"modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The algorithm to use for the $\left<VV||VV\right>$ terms -*/; options.ad",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optionshandling.html:1047,plugin,plugins,1047,psi4manual/master/optionshandling.html,https://psicode.org,https://psicode.org/psi4manual/master/optionshandling.html,2,['plugin'],"['plugin', 'plugins']"
Modifiability,"modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Adding New Code to PSI4. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/plugins-1.html:1011,plugin,plugin,1011,psi4manual/1.3.2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"molecular plane defining the mirror plane), the above; array will be automatically interpreted as:; 1SOCC = [0, 1]. Some caution is required, however. The \(^2A_1\) state can be obtained with; the; 1SOCC = [1, 0, 0, 0]. specification, which would become; 1SOCC = [1, 0]. under the above-mentioned reduction in symmetry. The \(^2B_2\) state,; whose singly-occupied orbitals are; 1SOCC = [0, 0, 0, 1]. would be mapped to; 1SOCC = [1, 0]. which is the same occupation as the \(^2A_1\) state. In this case, the; \(^2A_1\) state is lower in energy, and is not problematic. The distorted; geometries for the \(^2B_2\) state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:14571,adapt,adapted,14571,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['adapt'],['adapted']
Modifiability,"molecular systems.; Downstream Dependencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; MKL_ROOT — Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location.; MATH_ROOT — Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so).; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be “;”-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL.; OpenMP_LIBRARY_DIRS — CMake variable to specify OpenMP library (iomp5/gomp/omp) directories explicitly. Should be “;”-separated list of full directory paths. Usually the solution to error Could NOT find MathOpenMP. Examples. Build with any LAPACK in standard location. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL not also present).; If NumPy not using native Accelerate LAPACK, then directing Psi4; to use it is Bad Idea!. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL also present); If NumPy not using native Accelerate LAPACK, then directing Psi4; to use it is Bad Idea!. >>> cmake -DBLAS_TYPE=SYSTEM_NATIVE -DLAPACK_TYPE=SYSTEM_NATIVE. Build with Intel MKL. >>> source /path/to/intel/vers/linux/mkl/bin/mklvars.sh intel64 # adjust sh/csh and arch as needed; >>> cmake. >>> MATH_ROOT=/path/to/intel/vers/linux/mkl/ cmake. Build with Intel MKL from conda (install mkl-devel package from defaults channel). >>> cmake -DLAPACK_LIBRARIES=""${CONDA_PREFIX}/lib/libmkl_rt.so"" -DLAPACK_INCLUDE_DIRS=""${CONDA_PREFIX}/include"". Ope",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:38652,variab,variable,38652,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['variab'],['variable']
Modifiability,"molecule orbitals. nmopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of molecular orbitals per irrep. no_occupations(self: psi4.core.Wavefunction) → List[List[Tuple[float, int, int]]]¶; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction) → int¶; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of symmetry orbitals per irrep. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. set_array(key, val)¶. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html:9306,variab,variables,9306,psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,9,['variab'],['variables']
Modifiability,"molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Parameters; ----------; mdi_arguments; MDI configuration options. """"""; MDI_Init(mdi_arguments). [docs]; def mdi_run(scf_method: str, **kwargs):; """""" Begin functioning as an MDI (MolSSI driver interface) engine. Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.mdi_engine. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:13450,config,configuration,13450,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,2,['config'],['configuration']
Modifiability,"molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Parameters; ----------; mdi_arguments; MDI configuration options. """"""; MDI_Init(mdi_arguments). [docs]; def mdi_run(scf_method: str, **kwargs):; """""" Begin functioning as an MDI (MolSSI driver interface) engine. Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.mdi_engine. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html:13528,config,configuration,13528,psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,2,['config'],['configuration']
Modifiability,"more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import collections; import math; import os; import re; import sys. from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational metho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:1865,variab,variables,1865,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,6,['variab'],['variables']
Modifiability,"move_atom(atom, -1*displacement); return E. for atom in range(natom):; for xyz in range(3):; transvec = core.Vector3(0.0); transvec[xyz] += delta; # +1 displacement; Ep1 = displaced_energy(atom, 1*transvec); # -1 displacement; Em1 = displaced_energy(atom, -1*transvec); # +2 displacement; Ep2 = displaced_energy(atom, 2*transvec); # -2 displacement; Em2 = displaced_energy(atom, -2*transvec); # Evaluate; ecpgrad[atom, xyz] = (Em2 + 8*Ep1 - 8*Em1 - Ep2) / (12*delta); ecpgradmat.symmetrize_gradient(ref_wfn.molecule()); ecpgradmat.print_atom_vector(); grad.add(ecpgradmat); grad.print_atom_vector(); ref_wfn.set_print(old_print). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). # Clearly, add some logic when the reach of this fn expands; ref_wfn.set_variable(""H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:81367,variab,variables,81367,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variables']
Modifiability,"mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # PsiMod.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_omega'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; # PsiMod.plugin_load(""%s"" % (plugfile)); #; # PsiMod.set_global_option('BASIS', 'AUG-CC-PVDZ'); # PsiMod.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); # PsiMod.set_global_option('REFERENCE', 'UHF'); # PsiMod.set_global_option('SCF_TYPE', 'DF'); # energy('scf', **kwargs); #; # PsiMod.set_global_option('dft_functional', 'wB97'); # PsiMod.set_global_option('dft_order_spherical', 25); # PsiMod.set_global_option('dft_num_radial', 35); # PsiMod.set_global_option('omega_procedure', 'ip'); # PsiMod.set_global_option('maxiter', 50); # PsiMod.set_global_option('d_convergence', 5); # PsiMod.set_global_option('e_convergence', 7); # PsiMod.plugin(""plugin_omega.so""); #; # return PsiMod.get_variable('SCF TOTAL ENERGY'). # Integration with driver routines; #procedures['energy']['mp2.5'] = run_mp2_5; procedures['energy']['sherrillgroup_gold_standard'] = sherrillgroup_gold_standard; #procedures['energy']['plugin_omega'] = run_plugin_omega. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:5369,plugin,plugin,5369,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,2,['plugin'],['plugin']
Modifiability,"mp4 energy?. Type: boolean; Default: false. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. DFCC¶. Do use density fitting in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). Table Of Contents. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; BASIS; FREEZE_CORE; R_CONVERGENCE; E_CONVERGENCE; MAXITER; DIIS_MAX_VECS; NAT_ORBS; OCC_TOLERANCE; TRIPLES_LOW_MEMORY; CC_TIMINGS; DF_BASIS_CC; CHOLESKY_TOLERANCE; CEPA_NO_SINGLES; DIPMOM. Advanced FNOCC Keywords; SCS_MP2; MP2_SCALE_OS; MP2_SCALE_SS; SCS_CCSD; CC_SCALE_OS; CC_SCALE_SS; RUN_MP2; RUN_MP3; RUN_MP4; RUN_CCSD; RUN_CEPA; COMPUTE_TRIPLES; COMPUTE_MP4_TRIPLES; DFCC; CEPA_LEVEL. Previous topic; CC: Coupled Cluster Methods; Next topic; PSIMRCC Implementation of Mk-MRCC Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/fnocc-1.html:15562,config,configuration,15562,psi4manual/4.0b4/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/fnocc-1.html,2,['config'],['configuration']
Modifiability,"mpact version; How to build, test, and install Psi4, in detail; How to see what build configuration options are available; How to choose the compilation directory, {objdir}; How to install elsewhere than /usr/local/psi4; How to configure code to use high angular momentum basis sets; How to see the actual compiling commands (or errors) with cmake; How to save configuration settings for a future compilation; How to configure a Psi4 build on Cray. Non-QC Dependencies¶. What are the tools and dependencies strictly required for building Psi4; How to configure Python for building Psi4; How to handle “runtime library may be hidden” when building with Anaconda Python; How to configure BLAS/LAPACK for building Psi4; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew. QC Dependencies and Extensions¶. What are the add-on capabilities for Psi4 and what are their dependencies; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compila",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_faq-1.html:2043,config,configure,2043,psi4manual/1.1.0/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_faq-1.html,2,['config'],['configure']
Modifiability,"mpact version; How to build, test, and install Psi4, in detail; How to see what build configuration options are available; How to choose the compilation directory, {objdir}; How to install elsewhere than /usr/local/psi4; How to configure code to use high angular momentum basis sets; How to see the actual compiling commands (or errors) with cmake; How to save configuration settings for a future compilation; How to configure a Psi4 build on Cray. Non-QC Dependencies¶. What are the tools and dependencies strictly required for building Psi4; How to configure Python for building Psi4; How to handle “runtime library may be hidden” when building with Anaconda Python; How to configure BLAS/LAPACK for building Psi4; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew. QC Dependencies and Extensions¶. What are the add-on capabilities for Psi4 and what are their dependencies; How to use a local Add-On repository in the Psi4 build; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_faq-1.html:2045,config,configure,2045,psi4manual/1.2.1/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_faq-1.html,4,['config'],['configure']
Modifiability,"mpile the code (optional -j triggers parallel compilation).; 1; 2>>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux and Mac) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++14 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (3.6 or 3.7) https://www.python.org/; CMake (3.8+) http://www.cmake.org/download/; NumPy (needed at runtime and buildtime) http://www.numpy.org/; System utilities: GNU make, GNU install, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download and build. gau2grid <cmake:gau2grid — [what is this?] [min version]; Libint — [what is this?] [min version]; Libxc — [what is this?] [min version]; pybind11 — [what is this?] [min version]; QCElemental — [what is this?]. Additionally, there are runtime-only dependencies:. NumPy http://www.numpy.org/; networkx https://github.com/networkx/networkx; deepdiff https://github.com/seperman/deepdiff; pint https://pint.readthedocs.io/en/latest/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:4222,config,configure,4222,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['config'],['configure']
Modifiability,"mpile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:4483,config,configure,4483,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['config'],['configure']
Modifiability,"mplates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparator",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:3785,plugin,plugins,3785,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,2,['plugin'],['plugins']
Modifiability,"mplementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/interfacing.html:2808,config,configure,2808,psi4manual/1.8.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/interfacing.html,4,['config'],['configure']
Modifiability,"mplementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/interfacing.html:2808,config,configure,2808,psi4manual/1.9.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/interfacing.html,4,['config'],['configure']
Modifiability,"mps PSI4 SCF module keyword; set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in PSI4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to PSI4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the PSI4; output file and is available from input as gradient().; sandwich mode := molecule and cfour list within; Naturally, additional jobs can follow in the input file.; Depending on the nature of preceding or following jobs, it is prudent to; separate them with the following:; clean() # removes Psi4 scratch files; clean_variables() # empties the PSI variables list; cfour {} # empties. In this scheme, the contents of the cfour {...} block are tacked onto; the end of the ZMAT file that is otherwise written from psi style; format. It is by this route that, for example %excite* sections can at; present be specified.; The execution of xcfour can be modified by a few parameters. Setting; the option CFOUR_OMP_NUM_THREADS sets the environment variable; OMP_NUM_THREADS for only the duration of the Cfour computation.; That is, portions of an input file that run PSI4 modules are; unaffected. Additionally, there are a few arguments to the function; run_cfour() that control the Cfour scratch; directory. table of contents. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cfour.html:34926,variab,variables,34926,psi4manual/1.7.x/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cfour.html,1,['variab'],['variables']
Modifiability,"mps PSI4 SCF module keyword; set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in PSI4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to PSI4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the PSI4; output file and is available from input as gradient().; sandwich mode := molecule and cfour list within; Naturally, additional jobs can follow in the input file.; Depending on the nature of preceding or following jobs, it is prudent to; separate them with the following:; clean() # removes Psi4 scratch files; clean_variables() # empties the PSI variables list; cfour {} # empties. In this scheme, the contents of the cfour {...} block are tacked onto; the end of the ZMAT file that is otherwise written from psi style; format. It is by this route that, for example %excite* sections can at; present be specified.; The execution of xcfour can be modified by a few parameters. Setting; the option CFOUR_OMP_NUM_THREADS sets the environment variable; OMP_NUM_THREADS for only the duration of the Cfour computation.; That is, portions of an input file that run PSI4 modules are; unaffected. Additionally, there are a few arguments to the function; run_cfour() that control the Cfour scratch; directory. table of contents. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; run_cfour(). Functionality; Specification Details; Misc. Running. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/cfour.html:34928,variab,variables,34928,psi4manual/1.8.x/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/cfour.html,3,['variab'],['variables']
Modifiability,"mpute( (JK)arg1) -> None :; | ; | C++ signature :; | void compute(N3psi2JKE {lvalue}); | ; | finalize(...); | finalize( (JK)arg1) -> None :; | ; | C++ signature :; | void finalize(N3psi2JKE {lvalue}); | ; | initialize(...); | initialize( (JK)arg1) -> None :; | ; | C++ signature :; | void initialize(N3psi2JKE {lvalue}); | ; | print_header(...); | print_header( (JK)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_header(N3psi2JKE {lvalue}); | ; | wK(...); | wK( (JK)arg1) -> matrix_vector :; | ; | C++ signature :; | St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE wK(N3psi2JKE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_JK(...); | build_JK( (BasisSet)arg1) -> JK :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi2JKEEE build_JK(N5boost10shared_ptrIN3psi8BasisSetEEE); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class KineticInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | KineticInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:505524,inherit,inherited,505524,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ms where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; ----------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:13333,adapt,adapted,13333,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['adapt'],['adapted']
Modifiability,"ms where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In PSI4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -----------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:10077,adapt,adapted,10077,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,8,['adapt'],['adapted']
Modifiability,"ms where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetric inverse square root of the; overlap matrix is formed, with numerical stability enhanced by the elimination; of eigenvectors corresponding to very small eigenvalues. As a few combinations; of AO basis functions may be discarded, the number of canonical-orthogonalized; OSOs and MOs may be slightly smaller than the number of AOs. In Psi4,; symmetric orthogonalization is used by default, unless the smallest overlap; eigenvalue falls below the user-supplied double option S_TOLERANCE, which; defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical; orthogonalization is forced, and all eigenvectors corresponding to eigenvalues; below the cutoff are eliminated. Use of canonical orthogonalization can be; forced by setting the S_ORTHOGONALIZATION option to CANONICAL. Note; that in practice, the MOs and OSOs are built separately within each irrep from; the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals; (USOs). For canonical orthogonalization, this implies that the number of MOs; and OSOs per irrep may be slightly smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; }. energy('scf'). Output:; ... Initialization ... ==> Pre-Iterations <==. Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Overall, 3 of 287 possible MOs eliminated. ... Initial Orbital Guess Information ... -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -----------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:11428,adapt,adapted,11428,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['adapt'],['adapted']
Modifiability,"ms,; see psicode.org/installs/latest (select “conda”). Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; >>> cd {top-level-psi4-dir}; >>> cmake -S. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. >>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. What are the tools and dependencies strictly required for building Psi4; What are the add-on capabi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:1730,config,configuring,1730,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,2,['config'],['configuring']
Modifiability,"ms_freq_0((arg0: psi::Molecule, ...); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1((arg0: psi::Molecule, ...); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(() -> None). fisapt((arg0: psi::Wavefunction) -> float); Runs the functional-group intramolecular symmetry adapted perturbation theory code. flush_outfile(() -> None); Flushes the output file. fnocc(...); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(() -> psi4.core.EFP); Returns the currently active EFP object. get_active_molecule(() -> psi::Molecule); Returns the currently active molecule object. get_array_variable((arg0: str) -> psi::Matrix); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(() -> Dict[str, psi::Matrix]); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(() -> psi::Vector); Returns the most recently computed atomic point charges, as a double * object. get_efp_torque(() -> psi::Matrix); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_environment((arg0: str) -> str); Get enviromental vairable. get_frequencies(() -> psi::Vector); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option((arg0: str) -> object); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(() -> List[str]); Returns a list of all global options. get_gradient(() -> psi::Matrix); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(() -> psi::Molecule); Returns the currently active molecule object. get_local_option((arg0: str, ...); Given a string of a keyword name arg2 and a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:165234,variab,variables,165234,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,"multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:4588,variab,variable,4588,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['variab'],['variable']
Modifiability,"n %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); print text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(float(vstr)). # handle variable values, whether defined or not; else:; if vstr == 'TDA':; self.geometry_variables[vstr] = 360.0 * math.atan(math.sqrt(2)) / math.pi. # handle negative variable values (ignore leading '-' and return minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationErr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:29569,variab,variable,29569,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['variab'],['variable']
Modifiability,"n -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute contents to allow; # retrivial geometry variable values as if member data.; #; # """"""; ## #if not name in self.__dict__:; ## if not name in self.__dict__['__dict__']:; ## if object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; ## else:; ## #return self.__dict__[name",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:36226,variab,variable,36226,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['variab'],['variable']
Modifiability,"n EINSTEIN A (LEN); CCname ROOT m -> ROOT n EINSTEIN A (LEN) - h TRANSITION; CCname ROOT m -> ROOT n EINSTEIN B (LEN); CCname ROOT m -> ROOT n EINSTEIN B (LEN) - h TRANSITION; CCname ROOT m -> ROOT n OSCILLATOR STRENGTH (LEN); CCname ROOT m -> ROOT n OSCILLATOR STRENGTH (LEN) - h TRANSITION; CCname ROOT m -> ROOT n ROTATORY STRENGTH (LEN); CCname ROOT m -> ROOT n ROTATORY STRENGTH (LEN) - h TRANSITION; CCname ROOT m -> ROOT n ROTATORY STRENGTH (VEL); CCname ROOT m -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION; CCname ROOT n (IN h) CORRELATION ENERGY; CCname ROOT n (IN h) TOTAL ENERGY; CCname ROOT n (h) CORRELATION ENERGY; CCname ROOT n (h) DIPOLE; CCname ROOT n (h) QUADRUPOLE; CCname ROOT n (h) TOTAL ENERGY; CCname ROOT n CORRELATION ENERGY; CCname ROOT n CORRELATION ENERGY - h TRANSITION; CCname ROOT n DIPOLE; CCname ROOT n DIPOLE - h TRANSITION; CCname ROOT n QUADRUPOLE; CCname ROOT n QUADRUPOLE - h TRANSITION; CCname ROOT n TOTAL ENERGY; CCname ROOT n TOTAL ENERGY - h TRANSITION; CURRENT CORRELATION ENERGY; CURRENT ENERGY; LCC2 (+LMP2) TOTAL ENERGY; LCCSD (+LMP2) TOTAL ENERGY; LEFT-RIGHT CC2 EIGENVECTOR OVERLAP; LEFT-RIGHT CC3 EIGENVECTOR OVERLAP; LEFT-RIGHT CCSD EIGENVECTOR OVERLAP; LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP; MP2 ALPHA-ALPHA PAIR ENERGIES (array); MP2 ALPHA-BETA PAIR ENERGIES (array); MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 SINGLET PAIR ENERGIES (array); MP2 TOTAL ENERGY; MP2 TRIPLET PAIR ENERGIES (array); SCF TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS-CCSD CORRELATION ENERGY; SCS-CCSD TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; PSI Variables by Module; CCENERGY. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__ccenergy.html:4466,Variab,Variables,4466,psi4manual/1.7.x/autodir_psivariables/module__ccenergy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_psivariables/module__ccenergy.html,1,['Variab'],['Variables']
Modifiability,"n Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/interfacing.html:2806,config,configure,2806,psi4manual/1.7.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/interfacing.html,4,['config'],['configure']
Modifiability,"n Library Documentation: property. docstring. psi4.PseudospectralInt.set_enable_pybuffer()¶; Python Library Documentation: method set_enable_pybuffer; set_enable_pybuffer(...) unbound psi4.PseudospectralInt method. set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :. docstring; C++ signature :. void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b). PsiReturnType¶. psi4.PsiReturnType.Balk()¶; Python Library Documentation: PsiReturnType in module psi4 object; class PsiReturnType(Boost.Python.enum). docstring. Method resolution order:. PsiReturnType. Boost.Python.enum. __builtin__.int. __builtin__.object. Data and other attributes defined here:. Balk = psi4.PsiReturnType.Balk. EndLoop = psi4.PsiReturnType.EndLoop. Failure = psi4.PsiReturnType.Failure. Success = psi4.PsiReturnType.Success. names = {‘Balk’: psi4.PsiReturnType.Balk, ‘EndLoop’: psi4.PsiReturnTyp... values = {0: psi4.PsiReturnType.Success, 1: psi4.PsiReturnType.Failure... ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:275983,inherit,inherited,275983,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"n a region where the Hessian index is not equal to unity); MANR (=3) – Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly OPT_TYPE and STEP_TYPE. Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. CFOUR_MRCC¶. Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. CFOUR_MULTIPLICITY¶. Specifies the spin multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING¶. Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL¶. Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:38519,coupling,coupling,38519,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,52,['coupling'],['coupling']
Modifiability,"n be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marq",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/libxc.html:1811,variab,variable,1811,psi4manual/master/libxc.html,https://psicode.org,https://psicode.org/psi4manual/master/libxc.html,1,['variab'],['variable']
Modifiability,"n be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/libxc-1.html:1802,variab,variable,1802,psi4manual/1.4.0/libxc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/libxc-1.html,2,['variab'],['variable']
Modifiability,"n be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/libxc-1.html:1802,variab,variable,1802,psi4manual/1.5.0/libxc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/libxc-1.html,2,['variab'],['variable']
Modifiability,"n be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/libxc.html:1802,variab,variable,1802,psi4manual/1.6.x/libxc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/libxc.html,1,['variab'],['variable']
Modifiability,"n be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/libxc.html:1802,variab,variable,1802,psi4manual/1.7.x/libxc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/libxc.html,1,['variab'],['variable']
Modifiability,"n be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/libxc.html:1804,variab,variable,1804,psi4manual/1.8.x/libxc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/libxc.html,1,['variab'],['variable']
Modifiability,"n be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libxc by M. A. L. Marques. © ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/libxc.html:1804,variab,variable,1804,psi4manual/1.9.x/libxc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/libxc.html,1,['variab'],['variable']
Modifiability,"n core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶. Get dict of converged T amplitudes. amps : dict (spacestr, SharedMatrix); spacestr is a description of the amplitude set using the following conventions.; I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF: “tIA”, “tIjAb”; UHF: tIA, tia, tIjAb, tIJAB, tijab; ROHF: tIA, tia, tIjAb, tIJAB, tijab. Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”“”; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. get_array(key)¶. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_scalar_variable(self: psi4.core.Wavefunction, arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:14368,variab,variable,14368,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"n fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”). Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself.; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -H.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; 1; 2; 3; 4; 5>>> cd {top-level-psi4-dir}; >>> cmake -H. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. 1>>> cd {top-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:1188,config,configure,1188,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['config'],['configure']
Modifiability,"n installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; Libxc can be obtained through conda install libxc -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libxc and activate dependent code. To remove a conda installation, conda remove libxc. Source. Note that PSI4 has forked and slightly modified upstream Libxc from; https://gitlab.com/libxc/libxc to regain functionality. If using PSI4 built from source and you want Libxc built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libxc for building Psi4¶; Role and Dependencies. Role — In PSI4, Libxc is a library that provides essential; density functional definitions and compositions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libxc; Upstream Dependencies — Libxc \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libxc, set to an installation directory containing include/libxc/xc.h; Libxc_DIR — CMake variable to specify where pre-built Libxc can be found. Set to installation directory containing share/cmake/Libxc/LibxcConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libxc — CMake variable to force internal build of Libxc instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libxc — CMake variable to force detecting pre-built Libxc and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libxc/root. >>> cmake -DLibxc_DIR=/path/to/libxc/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libxc/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libxc=ON. table of contents. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/libxc-1.html:1646,variab,variable,1646,psi4manual/1.4.0/libxc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/libxc-1.html,9,['variab'],['variable']
Modifiability,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:8591,config,configuration,8591,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['config'],['configuration']
Modifiability,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:8083,config,configuration,8083,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,8,['config'],['configuration']
Modifiability,"n interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stag",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:3690,config,configuration,3690,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,2,['config'],['configuration']
Modifiability,"n irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:243960,variab,variables,243960,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"n keyword key scoped only to a single module. set_memory_bytes(memory[, quiet]); Sets the memory available to Psi (in bytes); prefer psi4.driver.set_memory(). set_num_threads(nthread[, quiet]); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_psi_file_prefix(). Deprecated since version 1.4. set_scalar_variable(key, value); Sets the double QCVariable key (case-insensitive); prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val in global memory. test_matrix_dpd_interface(). timer_off(label); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CompositeJK; docstring. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:10258,variab,variables,10258,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,2,['variab'],['variables']
Modifiability,"n keyword key scoped only to a single module. set_memory_bytes(memory[, quiet]); Sets the memory available to Psi (in bytes); prefer psi4.driver.set_memory(). set_num_threads(nthread[, quiet]); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_psi_file_prefix(). Deprecated since version 1.4. set_scalar_variable(key, value); Sets the double QCVariable key (case-insensitive); prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val in global memory. test_matrix_dpd_interface(). timer_off(label); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFJCOSK; docstring. DFJLinK; docstring. DFSOMCSCF; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:10250,variab,variables,10250,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['variab'],['variables']
Modifiability,"n method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | Method resolution order:; | FittedSlaterCorrelationFactor; | CorrelationFactor; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (float)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | exponent(...); | exponent( (FittedSlaterCorrelationFactor)arg1) -> float; | ; | ----------------------------------------------------------------------; | Methods inherited from CorrelationFactor:; | ; | set_params(...); | set_params( (CorrelationFactor)arg1, (Vector)arg2, (Vector)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FittingMetric; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | form_QR_inverse(...); | form_QR_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_cholesky_inverse(...); | form_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:21650,inherit,inherited,21650,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"n module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of Psi4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main Psi4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the Psi4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. Please note that pure virtual functions in a plugin may cause u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:6801,plugin,plugin,6801,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"n monomers, e.g., HBC6. symm (boolean) – \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to \(C_1\) symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (str) – \(\Rightarrow\) 'default' \(\Leftarrow\) || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (Union[str, List[str]]) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || 'HB' || etc.For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.Specify a list of database members to run. Consult the; database python files for available",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:4196,variab,variable,4196,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,9,['variab'],['variable']
Modifiability,"n object. Return type:Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. legacy_frequencies()¶. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunction’s molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html:7093,variab,variable,7093,psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,6,['variab'],['variable']
Modifiability,"n of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The Psithon function psi4.driver.p4util.Table has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below:; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2). rows = []; table = []. set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]). import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. Python Wrappers¶; The Python foundations of the PSI4 driver",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:12026,flexible,flexible,12026,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,3,['flexible'],['flexible']
Modifiability,"n options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(key, value); Sets value to Python keyword key scoped only to a single module. set_memory_bytes(memory[, quiet]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:8419,variab,variable,8419,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,1,['variab'],['variable']
Modifiability,"n options that might be needed for less commonly encountered; situations. For g++, if you have BLAS and LAPACK in standard locations (like /usr/lib64),; configuration is very easy. Pick one of the following scenarios, and place the; text given in the psi4/do-configure file (all on one long line). Replace the; text after prefix with whatever directory you want to use for your; installation directory. Intel compiler with MKL math library [highly recommended; if you don’t use; this, then at least make sure you have a threaded BLAS (see BLAS; recommendations at Section IV below)]; ../configure --prefix=/usr/local/psi4 --with-blas='-mkl' --with-cc=icc --with-cxx=icpc --with-fc=ifort --with-opt='-O2 -static -no-prec-div' --with-incdirs=-mkl. Note; It’s -mkl, not -lmkl. Warning; There seems to be a problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If yo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:8198,config,configure,8198,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['configure']
Modifiability,"n order:; | KineticInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class LaplaceDenominator(Boost.Python.instance); | docstring; | ; | Method resolution order:; | LaplaceDenominator; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:506961,inherit,inherited,506961,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"n order:; | OverlapInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PMLocalizer(Localizer); | docstring; | ; | Method resolution order:; | PMLocalizer; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python funct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:574812,inherit,inherited,574812,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"n pair approximation variant 3 [manual]. acpf; averaged coupled-pair functional [manual]. aqcc; averaged quadratic coupled cluster [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. qcisd(t); QCISD with perturbative triples [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. fno-df-ccsd(t); CCSD(T) with density fitting and frozen natural orbitals [manual]. bccd(t); BCCD with perturbative triples [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. gaussian-2 (g2); gaussian-2 composite method [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/energy-1.html:2611,config,configuration,2611,psi4manual/4.0b4/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/energy-1.html,4,['config'],['configuration']
Modifiability,"n properties; if n_excited > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(""CC""); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")). n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:79843,variab,variable,79843,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"n psi4/lib/databases; Basis Sets: *.gbs files in psi4/lib/basis; C++ Keywords: psi4/src/bin/psi4/read_options.cc; Sample Inputs: input.dat files in psi4/samples; PSI Variables: Process::environment.globals lines and comments in the C++ code; Plugins: doc.rst text, *.py modules, and C++ keywords in psi4/tests/plugin_* plugin directories. Some documentation is even extracted from Psi4 objects at runtime. PsiMod: docstrings for the PsiMod built-in module constructed in psi4/src/bin/psi4; DFT: functional availibility and characteristics as encoded in psi4/lib/python/functional.py. Run make help to see choices for cleaning various stages of the build.; Running make realclean clears out the built documentation. Building; all the documentation takes ~10 minutes. There is now good; dependency structure built into the psi4/doc/sphinxman/Makefile.in ,; so very long builds should be infrequent (unless you’re touching psi4/src/bin/psi4/read_options.cc.; Note that not all dependencies; are encoded (PSI variables, for instance, depend on every .cc file in the; source tree), so for a definitive doc build, run make realclean and; start from scratch. reStructuredText¶; Sphinx files are written in reStructuredText (*.rst). In the html; documentation, source code is available from the sidebar. Here’re a; few resources on Sphinx formatting. reStructuredText; rendered test document; vs. source test document; Another reStructuredText; A third reStructuredText and Sphinx; LaTeX that Sphinx can handle; Sphinx Docs. Math in the Codebase¶; It is often useful to have mathematical expressions in docstrings or; comments in the code that are auto-documented into the manual. Such; locations include the #! comment comments at the top of test case; input files, the /*- comment -*/ comments in; psi4/src/bin/psi4/read_options.cc, and the """""" comment """"""; docstrings in python modules. For the two former, math has traditionally; been written in LaTeX (with the special substitution @@ for; subscripting u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/documentation-1.html:3142,variab,variables,3142,psi4manual/4.0b2/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/documentation-1.html,2,['variab'],['variables']
Modifiability,"n psi4/lib/databases; Basis Sets: *.gbs files in psi4/lib/basis; C++ Keywords: psi4/src/bin/psi4/read_options.cc; Sample Inputs: input.dat files in psi4/samples; PSI Variables: Process::environment.globals lines and comments in the C++ code; Plugins: doc.rst text, *.py modules, and C++ keywords in psi4/tests/plugin_* plugin directories. Some documentation is even extracted from Psi4 objects at runtime. PsiMod: docstrings for the PsiMod built-in module constructed in psi4/src/bin/psi4; DFT: functional availibility and characteristics as encoded in psi4/lib/python/functional.py. Run make help to see choices for cleaning various stages of the build.; Running make realclean clears out the built documentation. Building; all the documentation takes ~10 minutes. There is now good; dependency structure built into the psi4/doc/sphinxman/Makefile.in ,; so very long builds should be infrequent (unless you’re touching psi4/src/bin/psi4/read_options.cc.; Note that not all dependencies; are encoded (PSI variables, for instance, depend on every .cc file in the; source tree), so for a definitive doc build, run make realclean and; start from scratch. reStructuredText¶; Sphinx files are written in reStructuredText (*.rst). In the html; documentation, source code is available from the sidebar. Here’re a; few resources on Sphinx formatting. reStructuredText; rendered test document; vs. source test document; Another reStructuredText; A third reStructuredText and Sphinx; LaTeX that Sphinx can handle; Sphinx Docs. Math in the Codebase¶; It is often useful to have mathematical expressions in docstrings or; comments in the code that are auto-documented into the manual. Such; locations include the #! comment comments at the top of test case; input files, the /*- comment -*/ comments in; psi4/src/bin/psi4/read_options.cc, and the r"""""" comment """"""; docstrings in python modules. (That r"""""" makes the string read; literally, so your LaTeX symbols aren’t confused with escape characters.); For the t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/documentation-1.html:3387,variab,variables,3387,psi4manual/4.0b3/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/documentation-1.html,2,['variab'],['variables']
Modifiability,"n range(Nweft - 1):; # posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); #; # # initialize plot; # fht = Nweft * 0.8; # fig, ax = plt.subplots(figsize=(12, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); # plt.xlim([-xlimit, xlimit]); # plt.ylim([-1 * Nweft - 1, 0]); # plt.yticks([]); #; # # label plot and tiers; # ax.text(-0.9 * xlimit, -0.25, title,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=12); # for weft in labels:; # ax.text(-0.9 * xlimit, -(1.2 + labels.index(weft)), weft,; # verticalalignment='bottom', horizontalalignment='left',; # family='Times New Roman', weight='bold', fontsize=18); #; # # plot reaction errors and threads; # for rxn in data:; #; # # preparation; # xvals = rxn['data']; # clr = segment_color(color, rxn['color'] if 'color' in rxn else None); # slat = []; # for weft in range(Nweft):; # slat.extend([xvals[weft], xvals[weft], None]); # thread = []; # for weft in range(Nweft - 1):; # thread.extend([xvals[weft], xvals[weft + 1], None]); #; # # plotting; # ax.plot(slat, posnS, color=clr, linewidth=1.0, solid_capstyle='round'); # ax.plot(thread, posnT, color=clr, linewidth=0.5, solid_capstyle='round',; # alpha=0.3); #; # # labeling; # try:; # toplblposn = next(item for item in xvals if item is not None); # botlblposn = next(item for item in reversed(xvals) if item is not None); # except StopIteration:; # pass; # else:; # ax.text(toplblposn, -0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); # ax.text(botlblposn, -1 * Nweft - 0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); #; # # plot trimmings; # if mae is not None:; # ax.plot([-x for x in mae], positions, 's', color='black'); # if mape is not None: # equivalent to MAE for a 10 kcal/mol IE; # ax.plot([",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:15105,extend,extend,15105,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['extend'],['extend']
Modifiability,"n relying on; those packages’ native math detection.; The separation between BLAS and LAPACK seen in detection printing; and CMake variables is purely formal. In practice, they get run; together and linked as ${LAPACK_LIBRARIES} ${BLAS_LIBRARIES}.; Sometimes the CMake’s library search capabilites falter at SONAMEs; (e.g., libblas.so.3 vs. libblas.so), extensions (static; vs. dynamic), or suffixes (e.g., libacml_mp.so vs.; libacml.so). The developers would be interested in hearing; of such problems to expand the math detection capabilities. The; immediate solution, however, is to form symlinks between the; library names that exist and the names expected. Consult file; psi4/cmake/math/MathLibs.cmake for the library patterns being; sought.; The BLAS/LAPACK interface is standardized, so only libraries, not; headers, need to be detected. The exception is MKL, where the mkl.h; header defines additional functionality; it must be located to use; BLAS threading. How to configure Python for building Psi4¶; Role and Dependencies. Role — In PSI4, Python allows the core compiled C++ code to; be flexibly accessed for manipulation and extension in an interpreted; language.; Downstream Dependencies — PSI4 \(\Leftarrow\) Python Interpreter. CMake Variables. PYTHON_EXECUTABLE — specify name or full path to Python interpreter.; PYTHON_LIBRARY — specify path to Python library.; PYTHON_INCLUDE_DIR — specify directory of Python headers. Contains Python.h. Examples. Build with detected Python from PATH. >>> cmake. Build with specific Python. >>> cmake -DPYTHON_EXECUTABLE=/path/to/interp/python2.7. Build with full Python specification to root directory ${PFXC}. >>> cmake -DPYTHON_EXECUTABLE=""${PFXC}/bin/python"" \; -DPYTHON_LIBRARY=""${PFXC}/lib/libpython3.5m.so"" \; -DPYTHON_INCLUDE_DIR=""${PFXC}/include/python3.5m"". What Python is Psi4 running¶; The Python detected at build-time is embedded into the PSI4; executable. That is, the top line of bin/psi4 is something like; #!/path/to/miniconda/en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:40644,config,configure,40644,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,4,['config'],['configure']
Modifiability,"n relying on; those packages’ native math detection.; The separation between BLAS and LAPACK seen in detection printing; and CMake variables is purely formal. In practice, they get run; together and linked as ${LAPACK_LIBRARIES} ${BLAS_LIBRARIES}.; Sometimes the CMake’s library search capabilites falter at SONAMEs; (e.g., libblas.so.3 vs. libblas.so), extensions (static; vs. dynamic), or suffixes (e.g., libacml_mp.so vs.; libacml.so). The developers would be interested in hearing; of such problems to expand the math detection capabilities. The; immediate solution, however, is to form symlinks between the; library names that exist and the names expected. Consult file; psi4/cmake/math/MathLibs.cmake for the library patterns being; sought.; The BLAS/LAPACK interface is standardized, so only libraries, not; headers, need to be detected. The exception is MKL, where the mkl.h; header defines additional functionality; it must be located to use; BLAS threading. How to configure Python for building Psi4¶; Role and Dependencies. Role — In PSI4, Python allows the core compiled C++ code to; be flexibly accessed for manipulation and extension in an interpreted; language.; Downstream Dependencies — PSI4 \(\Leftarrow\) Python Interpreter. CMake Variables. PYTHON_EXECUTABLE — specify name or full path to Python interpreter.; PYTHON_LIBRARY — specify path to Python library.; PYTHON_INCLUDE_DIR — specify directory of Python headers. Contains Python.h. Examples. Build with detected Python from PATH. >>> cmake. Build with specific Python. >>> cmake -DPYTHON_EXECUTABLE=/path/to/interp/python3.6. Build with full Python specification to root directory ${PFXC}. >>> cmake -DPYTHON_EXECUTABLE=""${PFXC}/bin/python"" \; -DPYTHON_LIBRARY=""${PFXC}/lib/libpython3.5m.so"" \; -DPYTHON_INCLUDE_DIR=""${PFXC}/include/python3.5m"". What Python is Psi4 running¶; The Python detected at build-time is embedded into the PSI4; executable. That is, the top line of bin/psi4 is something like; #!/path/to/miniconda/en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:43611,config,configure,43611,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['config'],['configure']
Modifiability,"n relying on; those packages’ native math detection.; The separation between BLAS and LAPACK seen in detection printing; and CMake variables is purely formal. In practice, they get run; together and linked as ${LAPACK_LIBRARIES} ${BLAS_LIBRARIES}.; Sometimes the CMake’s library search capabilites falter at SONAMEs; (e.g., libblas.so.3 vs. libblas.so), extensions (static; vs. dynamic), or suffixes (e.g., libacml_mp.so vs.; libacml.so). The developers would be interested in hearing; of such problems to expand the math detection capabilities. The; immediate solution, however, is to form symlinks between the; library names that exist and the names expected. Consult file; psi4/cmake/math/MathLibs.cmake for the library patterns being; sought.; The BLAS/LAPACK interface is standardized, so only libraries, not; headers, need to be detected. The exception is MKL, where the mkl.h; header defines additional functionality; it must be located to use; BLAS threading. How to configure Python for building Psi4¶; Role and Dependencies. Role — In PSI4, Python allows the core compiled C++ code to; be flexibly accessed for manipulation and extension in an interpreted; language.; Downstream Dependencies — PSI4 \(\Leftarrow\) Python Interpreter. CMake Variables; Note that in v1.4, PSI4 switched from Numpy-written CMake Python; detection to new CMake-written CMake Python detection. Usually only; Python_EXECUTABLE is now needed to hint Python’s location. See; https://cmake.org/cmake/help/latest/module/FindPython.html for full; guidance. Python_EXECUTABLE — specify name or full path to Python interpreter.; Python_LIBRARY — specify path to Python library.; Python_INCLUDE_DIR — specify directory of Python headers. Contains Python.h. Examples. Build with detected Python from PATH. >>> cmake. Build with specific Python. >>> cmake -DPython_EXECUTABLE=/path/to/interp/python3.9. Build with full Python specification to root directory ${PFXC}. >>> cmake -DPython_EXECUTABLE=""${PFXC}/bin/python"" \; -DP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:46804,config,configure,46804,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['config'],['configure']
Modifiability,"n the desired order. val(kw)[source]¶. p4util¶. array_to_matrix¶; classmethod(function) -> method; Convert a function to be a class method.; A class method receives the class as implicit first argument,; just like an instance method receives the instance.; To declare a class method, use this idiom:. class C:; def f(cls, arg1, arg2, ...): ...; f = classmethod(f). It can be called either on the class (e.g. C.f()) or on an instance; (e.g. C().f()). The instance is ignored except for its class.; If a class method is called for a derived class, the derived class; object is passed as the implied first argument.; Class methods are different than C++ or Java static methods.; If you want those, see the staticmethod builtin. Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. class Table(rows=(), row_label_width=10, row_label_precision=4, cols=(), width=16, precision=10)[source]¶; Class defining a flexible Table object for storing data. absolute_to_relative(Factor=627.5095)[source]¶; Function to shift the data of each column of the Table object; such that the lowest value is zero. A scaling factor of Factor is applied. copy()[source]¶; Function to return a copy of the Table object. format_label()[source]¶; Function to pad the width of Table object labels. format_values(values)[source]¶; Function to pad the width of Table object data cells. save(file)[source]¶; Function to save string of the Table object to file. scale(Factor=627.5095)[source]¶; Function to apply a scaling factor Factor to the; data of the Table object. banner(text, type=1, width=35, strNotOutfile=False)[source]¶; Function to print text to output file in a banner of; minimum width width and minimum three-line height for; type = 1 or one-line height for type = 2. If strNotOutfile; is True, function returns string rather than printing it; to output file. find_approximate_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:124845,flexible,flexible,124845,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['flexible'],['flexible']
Modifiability,"n the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL (CFOUR); CFOUR — Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Possible Values: SCF, HF, MBPT(2), MP2, MBPT(3), MP3, SDQ-MBPT(4), SDQ-MP4, MBPT(4), MP4, CCD, CCSD, CCSD(T), CCSDT-1, CCSDT-1b, CCSDT-2, CCSDT-3, CCSDT-4, CCSDT, CC2, CC3, QCISD, QCISD(T), CID, CISD, UCC(4), B-CCD; Default: SCF. CFOUR_CC_CONV (CFOUR); CFOUR — Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than , where is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER (CFOUR); CFOUR — Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in the solution of the CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION (CFOUR); CFOUR — Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Purvis and Bartlett, DIIS (=1) uses the DIIS approach by Pulay, NOJACOBI (=2) uses RLE with continuous extrapolation, OFF (=3) uses no convergence acceleration. In general, DIIS provides the best results and is recommended, while OFF often results in poor convergence and thus cannot be recommended. Type: string; Possible Values: RLE, DIIS, NOJACOBI, OFF; Default: DIIS. CFOUR_CC_MAXCYC (CFOUR); CFOUR — Specifies the maximum number of iterations in solving the CC amplitude equations. Type: integer; Default: 50. CFOUR_CC_PROGRAM (CFOUR); CFOUR — Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:26176,enhance,enhance,26176,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['enhance'],['enhance']
Modifiability,"n the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename (subtracting; any ”.in” or ”.dat” suffix) plus ”.out”. -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4) or databases.; Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/external-1.html:10030,variab,variables,10030,psi4manual/4.0b4/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/external-1.html,4,['variab'],['variables']
Modifiability,"n the simplest use of the Psi4/Cfour interface, a PSI4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into PSI4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the PSI4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in PSI4 allows Cartesians, Z-matrices, mixed; Cartesian/Z-matrix, negation of variables, delayed specification of; variables, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a PSI4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; appropriately in the *CFOUR(...) directive. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:3803,variab,variables,3803,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['variab'],['variables']
Modifiability,"n the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed. Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. Alternately, the scratch directory can be set through the environment; variable PSI_SCRATCH (overrides ~/.psi4rc settings). (First line; for C shell; second line for bash.); setenv PSI_SCRATCH /scratch/user; export PSI_SCRATCH=/scratch/user. The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and Boost; Threads for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:4579,variab,variable,4579,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['variab'],['variable']
Modifiability,"n the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:3394,plugin,plugins,3394,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,2,['plugin'],['plugins']
Modifiability,"n with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:27043,variab,variables,27043,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [E_h] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [E_h] at 0 [K]. ZPVE¶; Vibrational zero-point energy [E_h] at 0 [K]. 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS¶; The interatomic contributions to the dispersion correction [E_h].; Sums to the dispersion energy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; PSI Variables by Alpha. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:63679,variab,variable,63679,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,1,['variab'],['variable']
Modifiability,"n ». Database¶; Code author: Lori A. Burns; Section author: Lori A. Burns. database(name, db_name[, func, mode, cp, rlxd, symm, zpe, benchmark, tabulate, subset])[source]¶; Function to access the molecule objects and reference energies of; popular chemical databases. Aliases :db(). Returns:(float) Mean absolute deviation of the database in kcal/mol. Psi variables:. db_name DATABASE MEAN SIGNED DEVIATION; db_name DATABASE MEAN ABSOLUTE DEVIATION; db_name DATABASE ROOT-MEAN-SQUARE DEVIATION; Python dictionaries of results accessible as DB_RGT and DB_RXN. Note; It is very easy to make a database from a collection of xyz files; using the script psi4/lib/scripts/ixyz2database.pl.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4 ; distribution, add the path to the directory containing the database ; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; psi4/lib/databases or PYTHONPATH. Consult that ; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/db-1.html:1229,variab,variable,1229,psi4manual/4.0b3/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/db-1.html,4,['variab'],['variable']
Modifiability,"n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:58382,variab,variables,58382,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variables']
Modifiability,"n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_global_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_global_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:31267,Config,Configuration,31267,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,1,['Config'],['Configuration']
Modifiability,"n'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: List[str]; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: Union[str, List[str]]; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See :ref:`sec:availableDatabases` for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:5937,variab,variable,5937,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,14,['variab'],['variable']
Modifiability,"n( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name *arg2* and a particular module *arg1*, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module.; ; C++ signature :; N5boost6python3api6objectE get_local_option(Ss,Ss); ; get_memory(...); get_memory() -> int :; Returns the amount of memory available to Psi (in bytes).; ; C++ signature :; m get_memory(); ; get_option(...); get_option( (str)arg1, (str)arg2) -> object :; Given a string of a keyword name *arg2* and a particular module *arg1*, returns the local value associated with the keyword if it's been set, else the global value if it's been set, else the local default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module.; ; C++ signature :; N5boost6python3api6objectE get_option(Ss,Ss); ; get_variable(...); get_variable( (str)arg1) -> float :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; C++ signature :; d get_variable(Ss); ; get_variables(...); get_variables() -> dict :; Returns dictionary of the PSI variables set internally by the modules or python driver.; ; C++ signature :; N5boost6python4dictE get_variables(); ; get_writer_file_prefix(...); get_writer_file_prefix( (str)arg1) -> str :; Returns the prefix to use for writing files for external programs.; ; C++ signature :; Ss get_writer_file_prefix(Ss); ; git_version(...); git_version() -> str :; Returns the git version of this copy of Psi.; ; C++ signature :; PKc git_version(); ; has_global_option_changed(...); has_global_option_changed( (str)arg1) -> bool :; Returns boolean for whether the keyword *arg1* has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user.; ; C++ signature :; b has_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:685716,variab,variables,685716,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['variab'],['variables']
Modifiability,"n('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(""CC""); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")). n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:80248,variab,variable,80248,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"n('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); mono",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:134645,variab,variables,134645,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variables']
Modifiability,"n('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). if (core.get_option('SCF', 'REFERENCE') != 'RHF') and (name.upper() != ""SAPT0""):; raise ValidationError('Only SAPT0 supports a reference different from \""reference rhf\"".'). do_delta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:132281,variab,variables,132281,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variables']
Modifiability,"n('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:175485,variab,variables,175485,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,10,['variab'],['variables']
Modifiability,"n(). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Results ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].iteritems():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_portion'] == job['f_portion']) and; (lvl[1]['f_basis'] == job['f_basis'])):; lvl[1]['f_energy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in_1st_argument(stage['d_scheme'], needname=stage['d_need'], mode='evaluate'); finalenergy += stage['d_energy'] * stage['d_coef']. # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:71590,Variab,Variable,71590,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Variab'],['Variable']
Modifiability,"n(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:34056,variab,variable,34056,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"n),; erd can be obtained through conda install erd -c psi4.; Then enable it as a feature with ENABLE_erd,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect erd and activate dependent code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/erd-1.html:2386,variab,variable,2386,psi4manual/1.4.0/erd-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/erd-1.html,2,['variab'],['variable']
Modifiability,"n),; erd can be obtained through conda install erd -c psi4.; Then enable it as a feature with ENABLE_erd,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect erd and activate dependent code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/erd-1.html:2386,variab,variable,2386,psi4manual/1.5.0/erd-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/erd-1.html,2,['variab'],['variable']
Modifiability,"n),; erd can be obtained through conda install erd -c psi4.; Then enable it as a feature with ENABLE_erd,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect erd and activate dependent code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/erd.html:2386,variab,variable,2386,psi4manual/1.6.x/erd.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/erd.html,1,['variab'],['variable']
Modifiability,"n),; erd can be obtained through conda install erd -c psi4.; Then enable it as a feature with ENABLE_erd,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect erd and activate dependent code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/erd.html:2386,variab,variable,2386,psi4manual/1.7.x/erd.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/erd.html,1,['variab'],['variable']
Modifiability,"n),; erd can be obtained through conda install erd -c psi4.; Then enable it as a feature with ENABLE_erd,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect erd and activate dependent code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interface",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/erd.html:2388,variab,variable,2388,psi4manual/1.8.x/erd.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/erd.html,1,['variab'],['variable']
Modifiability,"n),; erd can be obtained through conda install erd -c psi4.; Then enable it as a feature with ENABLE_erd,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect erd and activate dependent code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interface",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/erd.html:2388,variab,variable,2388,psi4manual/1.9.x/erd.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/erd.html,1,['variab'],['variable']
Modifiability,"n); matrix_vector; vector_of_doubles; ; class AOShellCombinationsIterator(Boost.Python.instance); | Method resolution order:; | AOShellCombinationsIterator; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | first(...); | first( (AOShellCombinationsIterator)arg1) -> None :; | docstring; | ; | C++ signature :; | void first(N3psi27AOShellCombinationsIteratorE {lvalue}); | ; | is_done(...); | is_done( (AOShellCombinationsIterator)arg1) -> bool :; | docstring; | ; | C++ signature :; | b is_done(N3psi27AOShellCombinationsIteratorE {lvalue}); | ; | next(...); | next( (AOShellCombinationsIterator)arg1) -> None :; | docstring; | ; | C++ signature :; | void next(N3psi27AOShellCombinationsIteratorE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | p; | docstring; | ; | q; | docstring; | ; | r; | docstring; | ; | s; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class AngularMomentumInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | AngularMomentumInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:372990,inherit,inherited,372990,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"n); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import psi4; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; psi4.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/plugins-1.html:7038,plugin,plugin,7038,psi4manual/4.0b5/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/plugins-1.html,6,['plugin'],['plugin']
Modifiability,"n, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import uuid. from psi4 import core; from psi4.driver.p4util.exceptions import *; from psi4.driver.p4util.util import set_memory. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/inputparser.html:2004,variab,variable,2004,psi4manual/1.9.x/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/inputparser.html,4,['variab'],['variable']
Modifiability,"n, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; from typing import Any, Dict, Optional, Tuple, Union, TYPE_CHECKING. from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs] @abc.abstractmethod; def compute(self):; pass. [docs] @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_base.html:2029,Config,Config,2029,psi4manual/1.7.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_base.html,1,['Config'],['Config']
Modifiability,"n, arg0: int) → psi4.core.CIVector¶; docstring. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X()¶. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:12858,variab,variable,12858,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,3,['variab'],['variable']
Modifiability,"n, arg0: int) → psi4.core.CIVector¶; docstring. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X()¶. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str) → psi4.core.OrbitalSpace¶; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters. id – Unique name for the orbital space.; basis – {‘SO’, ‘AO’}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset – {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns; Information on subset alpha orbitals. Return type; OrbitalSpace. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wave",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html:13016,variab,variable,13016,psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,2,['variab'],['variable']
Modifiability,"n, arg0: str) → None¶; docstring. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; docstring. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sigma(*args, **kwargs)¶; Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; docstring. transform_mcscf_integrals(sel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:19837,variab,variable,19837,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variable']
Modifiability,"n. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. occupation_a(self); Returns the Alpha occupation numbers. occupation_b(self); Returns the Beta occupation numbers. onel_Hx(self, arg0); One-electron Hessian-vector products. options(self); Returns the Wavefunction's options object. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. print_energies(). print_header(self); docstring. print_orbitals(self); docstring. print_preiterations([small]). push_back_external_potential(self, V); Add an external potential to the private external_potentials list. reference_wavefunction(self); Returns the reference wavefunction. reset_occupation(self); docstring. rotate_orbitals(self, arg0, arg1); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self); docstring. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:8763,variab,variable,8763,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,20,['variab'],['variable']
Modifiability,"n.; set {; basis cc-pvdz-dk; rel_basis cc-pvtz-dk; relativistic x2c; }. It is recommended that when employing the X2C relativistic Hamiltonian, that you use a fully; decontracted basis set. This can be done simply in the input by adding “-decontract” to the; name of the primary basis you want to use for the calculation as detailed in; Decontracted Basis Sets. Publications resulting from the use; of X2C should cite the following publication: [Verma:2015]. Theory¶; X2C is based on exact decoupling of; positive-energy ( ; ) and negative-energy ( ); blocks of the Dirac Hamiltonian (). The transformation ( ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984] treatment.; In the X2C treatment, the positive-energy block of the Hamiltonian ( ); is given by the sum; of a transformed kinetic () and potential energy ( ) contribution.; Relativistic kinetic energy ( ) and nuclear-electron interaction potential ( ) is given interms of non-relativisitc kinetic () energy and nuclear-electron interaction potential (), coupling matrix ( ) and renormalization matrix ( ). The coupling matrix ( ) is obtained from the large () and small () components of the positive energy solutions of the Dirac equation.; The renormalization matrix; ,; depends on the modified overlap matrix; . The integrals can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators and . It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/relativistic-1.html:3453,coupling,coupling,3453,psi4manual/1.0.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/relativistic-1.html,2,['coupling'],['coupling']
Modifiability,"n.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:81823,variab,variables,81823,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"n.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class AngularMomentumInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | AngularMomentumInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:3604,inherit,inherited,3604,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"n.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE __call__(N3psi4ViewE {lvalue}); | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi6MatrixEEE,N3psi9DimensionE,N3psi9DimensionE); | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi6MatrixEEE,N3psi9DimensionE,N3psi9DimensionE,N3psi9DimensionE,N3psi9DimensionE); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Wavefunction(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Ca(N3psi12WavefunctionE {lvalue}); | ; | Ca_subset(...); | Ca_subset( (Wavefunction)arg1, (str)arg2, (str)arg3) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Ca_subset(N3psi12WavefunctionE {lvalue},Ss,Ss); | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Cb(N3psi12WavefunctionE {lvalue}); | ; | Cb_subset(...); | Cb_subset( (Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:648084,inherit,inherited,648084,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"n/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2427,variab,variable,2427,psi4manual/4.0b2/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html,6,['variab'],['variable']
Modifiability,"n; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of PSI4; Useful Commands. Scratch Files¶; One very important part of user configuration at the end of the; installation process; is to tell PSI4 where to write its temporary; (“scratch”) files. Electronic structure packages like PSI4 can; create rather large temporary disk files. It is very important to; ensure that PSI4 is writing its temporary files to a disk drive; physically attached to the computer running the computation. If it; is not, it will significantly slow down the program and the network.; By default, PSI4 will write temporary files to /tmp, but this; directory is often not large enough for typical computations. Therefore,; you need to (a) make sure there is a sufficiently large directory on a; locally attached disk drive (100GB–1TB or more, depending on the size of; the molecules to be studied) and (b) tell PSI4 the path to this; directory. Scratch file location can be specified through the; PSI_SCRATCH environment variable or through the ~/.psi4rc file; (see section ~/.psi4rc File). Most of the time, PSI_SCRATCH; is preferred, and it overrides any existing ~/.psi4rc setting. You can set up; PSI_SCRATCH by issuing the following commands in a terminal,; or including them in the appropriate rc file.; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/disk/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/disk/for/scratch/files. PSI4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent comput",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:4625,variab,variable,4625,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['variab'],['variable']
Modifiability,"n? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. Type: boolean; Default: false. TURN_ON_ACTV (MCSCF); MCSCF —. Type: integer; Default: 0. UNITS (GLOBALS); GLOBALS — Units used in geometry specification. Type: string; Possible Values: BOHR, AU, A.U., ANGSTROMS, ANG, ANGSTROM; Default: ANGSTROMS. UPDATE (DETCI); DETCI — The update or correction vector formula, either DAVIDSON (default) or OLSEN. Type: string; Possible Values: DAVIDSON, OLSEN; Default: DAVIDSON. USE_DF_INTS (FNOCC); FNOCC (Expert) — Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. USE_SPIN_SYM (PSIMRCC); PSIMRCC — Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. USE_SPIN_SYMMETRY (PSIMRCC); PSIMRCC (Expert) — Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. VAL_EX_LEVEL (DETCI); DETCI — In a RAS CI, this is the additional excitation level for allowing electrons out of RAS I into RAS II. The maximum number of holes in RAS I is therefore EX_LEVEL + VAL_EX_LEVEL. Type: integer; Default: 0. VECS_CC3 (CCEOM); CCEOM — Vectors stored in CC3 computations. Type: integer; Default: 10. VECS_PER_ROOT (CCEOM); CCEOM — Vectors stored per root. Type: integer; Default: 12. VECS_WRITE (DETCI); DETCI — Do store converged vector(s) at the end of the run? The vector(s) is(are) stored in a transparent format such that other programs can use it easily. The format is specified in psi4/src/lib/libqt/slaterdset.h . Type: boolean; Default: false. WABEI_LOWDISK (CCHBAR); CCHBAR — Do use the minimal-disk algorithm for Wabei? It’s VERY slow!. Type: boolean; Default: false. WFN (CCDENSITY); CCDENSITY (Expert) — Wavefunction type. Type: string; Default: SCF. WFN (CCENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:128268,config,configurations,128268,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['config'],['configurations']
Modifiability,"nE soccpi(N3psi12WavefunctionE {lvalue}). matrix_vector¶. psi4.matrix_vector.append()¶; Python Library Documentation: method append; append(...) unbound psi4.matrix_vector method. append( (matrix_vector)arg1, (object)arg2) -> None :. C++ signature :. void append(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue},N5boost6python3api6objectE). psi4.matrix_vector.extend()¶; Python Library Documentation: method extend; extend(...) unbound psi4.matrix_vector method. extend( (matrix_vector)arg1, (object)arg2) -> None :. C++ signature :. void extend(St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue},N5boost6python3api6objectE). vector_of_doubles¶. psi4.vector_of_doubles.append()¶; Python Library Documentation: method append; append(...) unbound psi4.vector_of_doubles method. append( (vector_of_doubles)arg1, (object)arg2) -> None :. C++ signature :. void append(St6vectorIdSaIdEE {lvalue},N5boost6python3api6objectE). psi4.vector_of_doubles.extend()¶; Python Library Documentation: method extend; extend(...) unbound psi4.vector_of_doubles method. extend( (vector_of_doubles)arg1, (object)arg2) -> None :. C++ signature :. void extend(St6vectorIdSaIdEE {lvalue},N5boost6python3api6objectE). Full Docs Output¶; Python Library Documentation: built-in module psi4. NAME; psi4. FILE; (built-in). CLASSES; Boost.Python.enum(__builtin__.int); DiagonalizeOrder; GeometryUnits; PsiReturnType; Boost.Python.instance(__builtin__.object); AOShellCombinationsIterator; BasisSet; BasisSetParser; Gaussian94BasisSetParser; CIVector; CdSalcList; CorrelationFactor; FittedSlaterCorrelationFactor; CubeProperties; DFChargeFitter; DFTensor; Deriv; Dimension; Dispersion; DoublePyBuffer; EFP; Environment; ExternalPotential; FCHKWriter; FittingMetric; Functional; GaussianShell; IO; IOManager; IntVector; IntegralFactory; JK; LaplaceDenominator; LibParallelHelper; Localizer; BoysLocalizer; PMLocalizer; Matrix; MatrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:370030,extend,extend,370030,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,6,['extend'],['extend']
Modifiability,"nError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(val)); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). def _core_wavefunction_set_variable(cls, key, val):; if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(val)); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). def _core_del_variable(key):; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls, key):; if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables():; return {**core.scalar_variables(), **core.array_variables()}. def _core_wavefunction_variables(cls):; return {**cls.scalar_variables(), **cls.array_variables()}. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_vari",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:19836,variab,variable,19836,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variable']
Modifiability,"nMP thread numbers. The number of threads may be changed; multiple times in a PSI4 input file. An example input for this feature is:; # A bit small-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. set scf {; basis cc-pvdz; scf_type df; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1,5):; set_num_threads(nthread); energy('scf'). (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; set MODULE_NAME df_ints_num_threads n. to explicitly control the number of threads used for integral formation. Setting; this variable to 0 (the default) uses the number of threads specified by the; set_num_threads() Psithon method or the default environmental variables. Command Line Options¶; PSI4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “output.dat”.; The set of three commands below are completely equivalent, while the fourth is,; perhaps, the most common usage.; psi4; psi4 -i input.dat -o output.dat; psi4 input.dat output.dat. psi4 descriptive_filename.in descriptive_filename.out. Command-line arguments to PSI4 can be accessed through psi4 --help. -a, --append¶; Append results to output file. Default: Truncate first. -h, --help¶; Display the command-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: output.dat. -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:6950,variab,variable,6950,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,8,['variab'],"['variable', 'variables']"
Modifiability,"nMP thread numbers. The number of threads may be changed; multiple times in a PSI4 input file. An example input for this feature is:; # A bit small-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. set scf {; basis cc-pvdz; scf_type df; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1,5):; set_num_threads(nthread); energy('scf'). (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; set MODULE_NAME df_ints_num_threads n. to explicitly control the number of threads used for integral formation. Setting; this variable to 0 (the default) uses the number of threads specified by the; set_num_threads() Psithon method or the default environmental variables. Command Line Options¶; PSI4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “output.dat”.; The set of three commands below are completely equivalent, while the fourth is,; perhaps, the most common usage.; psi4; psi4 -i input.dat -o output.dat; psi4 input.dat output.dat. psi4 descriptive_filename.in descriptive_filename.out. Command-line arguments to PSI4 can be accessed through psi4 --help. -a, --append¶; Append results to output file. Default: Truncate first. -h, --help¶; Display the command-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/external-1.html:8070,variab,variable,8070,psi4manual/4.0b4/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/external-1.html,8,['variab'],"['variable', 'variables']"
Modifiability,"nMP thread numbers. The number of threads may be changed; multiple times in a Psi4 input file. An example input for this feature is:; # A bit small-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. set scf {; basis cc-pvdz; scf_type df; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1,5):; set_num_threads(nthread); energy('scf'). (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; set MODULE_NAME df_ints_num_threads n. to explicitly control the number of threads used for integral formation. Setting; this variable to 0 (the default) uses the number of threads specified by the; set_num_threads() Psithon method or the default environmental variables. PBS job file¶; To run a Psi4 job on a PBS queueing system, you need to properly set up; all necessary variables in the PBS job file. Below is a minimal example of; a PBS job file for a threaded job, and a short explanation for each section.; #!/bin/tcsh; #PBS -j oe; #PBS -l pmem=2120mb; #PBS -N jobname; #PBS -V. setenv OMP_NUM_THREADS 4; setenv MKL_NUM_THREADS 4; cd $PBS_O_WORKDIR; setenv myscratch /scratch/user/psi4.$PBS_JOBID. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Creating scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ssh $i mkdir -p $myscratch; end. unsetenv PSI4DATADIR; unsetenv PSIDATADIR; setenv PSI_SCRATCH $myscratch; if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}; /psi/install/directory/bin/psi4 -i input.in -o input.out. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:9561,variab,variable,9561,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,4,['variab'],"['variable', 'variables']"
Modifiability,"n] and CC(n-1)(n) energies are also calculated) + +——-+————–+————————————————————-+ + 5 + CC(n)-1a + + +——-+————–+————————————————————-+ + 6 + CC(n)-1b + + +——-+————–+————————————————————-+ + 7 + CCn + + +——-+————–+————————————————————-+ + 8 + CC(n)-3 + + +——-+————–+————————————————————-+. Type: integer; Default: 1. MRCC_NUM_SINGLET_ROOTS (MRCC); MRCC — Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS (MRCC); MRCC — Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS. This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. MRCC_OMP_NUM_THREADS (MRCC); MRCC (Expert) — Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART (MRCC); MRCC (Expert) — The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. MS0 (DETCI); DETCI — Do use the component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NAT_ORBS (FNOCC); FNOCC — Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?. Type: boolean; Default: false.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:84436,variab,variable,84436,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['variab'],['variable']
Modifiability,"n_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplug",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:4359,plugin,plugin,4359,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"n_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:4714,plugin,plugin,4714,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"n_mp2_gradient,; 'eom-ccsd' : run_eom_cc_gradient,; 'dcft' : run_dcft_gradient; # Upon adding a method to this list, add it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; 'eom_cc2' : run_cc_property,; 'eom_ccsd' : run_cc_property; # Upon adding a method to this list, add it to the docstring in property() below; }}. # Integrate DFT with driver routines; for ssuper in superfunctional_list():; procedures['energy'][ssuper.name().lower()] = run_dft. for ssuper in superfunctional_list():; procedures['gradient'][ssuper.name().lower()] = run_dft_gradient. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: (*float*) Total electronic energy in Hartrees. SAPT returns interaction energy. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. comment In this table immediately below, place methods that should only be called by ; .. comment developers at present. This table won't show up in the manual.; .. comment; .. comment .. _`table:energy_devel`:; .. comment ; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | name | calls method |; .. comment +=========================+=======================================================================================+; .. comment | df-cc | coupled cluster with density fitting |; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | mp2c | coupled MP2 (MP2C) |; .. comment +-------------------------+---",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:3266,variab,variables,3266,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['variab'],['variables']
Modifiability,"nal algorithm would exceed the available resources. Type: boolean; Default: false. TURN_ON_ACTV (MCSCF); MCSCF —. Type: integer; Default: 0. UHF_NOONS (SCF); SCF — The number of NOONs to print in a UHF calc. Type: string; Default: 3. UNITS (GLOBALS); GLOBALS — Units used in geometry specification. Type: string; Possible Values: BOHR, AU, A.U., ANGSTROMS, ANG, ANGSTROM; Default: ANGSTROMS. UPDATE (DETCI); DETCI — The update or correction vector formula, either DAVIDSON (default) or OLSEN. Type: string; Possible Values: DAVIDSON, OLSEN; Default: DAVIDSON. USE_DF_INTS (FNOCC); FNOCC (Expert) — Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. USE_SPIN_SYM (PSIMRCC); PSIMRCC — Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. USE_SPIN_SYMMETRY (PSIMRCC); PSIMRCC (Expert) — Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. VAL_EX_LEVEL (DETCI); DETCI — In a RAS CI, this is the additional excitation level for allowing electrons out of RAS I into RAS II. The maximum number of holes in RAS I is therefore EX_LEVEL + VAL_EX_LEVEL. Type: integer; Default: 0. VECS_CC3 (CCEOM); CCEOM — Vectors stored in CC3 computations. Type: integer; Default: 10. VECS_PER_ROOT (CCEOM); CCEOM — Vectors stored per root. Type: integer; Default: 12. WABEI_LOWDISK (CCHBAR); CCHBAR — Do use the minimal-disk algorithm for Wabei? It’s VERY slow!. Type: boolean; Default: false. WFN (CCDENSITY); CCDENSITY (Expert) — Wavefunction type. Type: string; Default: SCF. WFN (CCENERGY); CCENERGY (Expert) — Wavefunction type. Type: string; Possible Values: CCSD, CCSD_T, CCSD_AT, EOM_CCSD, LEOM_CCSD, BCCD, BCCD_T, CC2, CC3, EOM_CC2, EOM_CC3, CCSD_MVD; Default: NONE. WFN (CCEOM); CCEOM (Expert) — Wavefunction type. Type: string; Possible Values: EO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:216605,config,configurations,216605,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['config'],['configurations']
Modifiability,"nal energy expression in CC computation? Experimental. Type: boolean; Default: false. CC_VECS_READ (DETCI); DETCI — Do import a CC vector from disk?. Type: boolean; Default: false. CC_VECS_WRITE (DETCI); DETCI — Do export a CC vector to disk?. Type: boolean; Default: false. CCD_E_CONVERGENCE (SAPT); SAPT — E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER (SAPT); SAPT — Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE (SAPT); SAPT — Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CCL_ENERGY (OCC); OCC — Do compute CC Lambda energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE = COMPUTE” * option. Type: boolean; Default: false. CEPA_LEVEL (FNOCC); FNOCC (Expert) — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). CEPA_NO_SINGLES (FNOCC); FNOCC — Flag to exclude singly excited configurations from a coupled-pair computation. Type: boolean; Default: false. CEPA_OS_SCALE (OCC); OCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE (OCC); OCC — CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE (OCC); OCC — CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE (OCC); OCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CFOUR_ABCDTYPE (CFOUR); CFOUR — Specifies the way the \(\langle ab||cd \rangle\) molecular orbital integrals are handled in post-MP2 calculations. STANDARD (= 0) uses directly the corresponding MO integrals and thus results in an algorithm which in particular for large-scale calculations results in excessive use of disk space (storage of all \(\langle ab||cd\rangle\) integrals. AOBASIS (=2) uses an AO-based algorithm to evaluate all terms involving the \(\langle ab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:16401,config,configurations,16401,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['config'],['configurations']
Modifiability,"nal files (e.g., MOINTS and GAMLAM, default choice INTERNAL, =0) or on external files (EXTERNAL, =1). Type: string; Possible Values: INTERNAL, EXTERNAL; Default: INTERNAL. CFOUR_PROPS (CFOUR); CFOUR — Specifies whether and which molecular property is calculated. OFF (=0) means that no property is calculated, FIRST_ORDER (=1) requests computation of various one-electron first-order properties (e.g., dipole moment, quadrupole moment, electric field gradient, spin densities,etc.), SECOND_ORDER (=2, in the next release replaced by STAT_POL) computes static electric polarizabilities, DYNAMICAL (=7, in the next release replaced by DYN_POL) requests the calculation of frequency-dependent polarizabilities (note that here an additional input of the frequency is required), NMR (=5) requests the calculation of NMR chemical shifts/chemical shielding tensors (by default using GIAOs), J_FC requests the calculation of the Fermi-Contact contribution to indirect spin-spin coupling constants, J_SD the calculation of the corresponding spin-dipole contribution, and J_SO the calculation of the corresponding spin-orbit contribution to J; HYPERPOL (=22) invokes a calculation of static hyperpolarizabilities, DYN_HYP (=23) requests the calculation of frequency-dependent hyperpolarizabilities, SHG (=24) the calculation of hyperpolarizabilities related to the second-harmonic generation, OPT_REC (=25) the computation of hyperpolarizabilities related to optical rectification, VERDET (=26) the calculation of Verdet constants. Type: string; Possible Values: OFF, FIRST_ORDER, SECOND_ORDER, NMR, HYPERPOL, DYN_HYP, SHG, OPT_REC, VERDET; Default: OFF. CFOUR_QRHF_GENERAL (CFOUR); CFOUR — The presence of this keyword specifies that a QRHF based CC calculation, or alternatively, an SCF calculation that uses the CFOUR_QRHFGUES option, is to be performed. Type: array; Default: No Default. CFOUR_QRHF_ORBITAL (CFOUR); CFOUR — By default, in QRHF calculations, electrons are removed from the highest occupied o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:66101,coupling,coupling,66101,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['coupling'],['coupling']
Modifiability,"nal. edf2; EDF2 Hyb-GGA Exchange-Correlation Functional. ft97; FT97 GGA Exchange-Correlation Functional. gam; GAM GGA Minessota Exchange-Correlation Functional. hcth120; HCTH120 GGA Exchange-Correlation Functional. hcth120-d3bj. hcth147; HCTH147 GGA Exchange-Correlation Functional. hcth407; HCTH407 GGA Exchange-Correlation Functional. hcth407-d3bj. hcth407p; HCTH407P GGA Exchange-Correlation Functional. hcth93; HCTH93 GGA Exchange-Correlation Functional. hcthp14; HCTHP14 GGA Exchange-Correlation Functional. hcthp76; HCTHP76 GGA Exchange-Correlation Functional. hf. hf+d. hf-d3bj. hf-d3mbj. hf-nl. hf3c; Hartree Fock based 3C composite method with minimal basis set, gCP and D3(BJ). hpbeint; HPBEINT Hyb-GGA Exchange-Correlation Functional. kmlyp; KMLYP Hyb-GGA Exchange-Correlation Functional. ksdt; KSDT Exchange-Correlation Functional. kt2; KT2 GGA Exchange-Correlation Functional. lda0; LDA0 Exchange-Correlation Functional. m05; M05 Meta-GGA XC Functional. m05-2x; Heavily Parameterized Hybrid M05-2X Meta-GGA XC Functional. m06; M06 Meta-GGA XC Functional. m06-2x; Hybrid M06-2X Meta-GGA XC Functional. m06-hf; Minnesota M06-HF Hybrid XC Functional. m06-l; M06-L Meta-GGA XC Functional. m08-hx; Minnesota M08-HX Hybrid XC Functional. m08-so; Minnesota M08-SO Hybrid XC Functional. m11-l; M11-L Meta-GGA XC Functional. m11-l-d3bj. mb3lyp-rc04; MB3LYP-RC04 Hyb-GGA Exchange-Correlation Functional. mgga_ms0; MGGA_MS0 Meta-GGA XC Functional. mgga_ms1; MGGA_MS1 Meta-GGA XC Functional. mgga_ms2; MGGA_MS2 Meta-GGA XC Functional. mgga_ms2h; MGGA_MS2h Hybrid Meta-GGA XC Functional. mgga_mvs; MGGA_MVS Meta-GGA XC Functional. mgga_mvsh; MGGA_MV2h Hybrid Meta-GGA XC Functional. mn12-l; MN12-L Meta-GGA XC Functional. mn12-l-d3bj. mn15; MN15 Hybrid Meta-GGA Exchange-Correlation Functional. mn15-d3bj. mn15-l; MN15-L Meta-GGA XC Functional. mohlyp; MOHLYP GGA Exchange-Correlation Functional. mohlyp2; MOHLYP2 GGA Exchange-Correlation Functional. mpw1b95; mPW1B95 Hyb-GGA Exchange-Correlation Fun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:6739,Parameteriz,Parameterized,6739,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,10,['Parameteriz'],['Parameterized']
Modifiability,"nal_coef; original_coef(...) unbound psi4.GaussianShell method. original_coef( (GaussianShell)arg1, (int)arg2) -> float :. docstring; C++ signature :. d original_coef(N3psi13GaussianShellE {lvalue},i). GeometryUnits¶. psi4.GeometryUnits.Angstrom()¶; Python Library Documentation: GeometryUnits in module psi4 object; class GeometryUnits(Boost.Python.enum). docstring. Method resolution order:. GeometryUnits. Boost.Python.enum. __builtin__.int. __builtin__.object. Data and other attributes defined here:. Angstrom = psi4.GeometryUnits.Angstrom. Bohr = psi4.GeometryUnits.Bohr. names = {‘Angstrom’: psi4.GeometryUnits.Angstrom, ‘Bohr’: psi4.Geometr... values = {0: psi4.GeometryUnits.Angstrom, 1: psi4.GeometryUnits.Bohr}. ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() <==> long(x). __lshift__(...). x.__lshift__(y) <==> x<<y. __mod__(...). x.__mod__(y) <==> x%y. __mul__(...). x.__mul__(y) <==> x*y. __neg__(...). x.__neg__() <==> -x. __nonzero__(...). x.__nonzero__() <==> x != 0. __oct__(...). x.__oct__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:152741,inherit,inherited,152741,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"nalized SO basis. See libscf_solver/rohf.cc::form_Cfor technical definition. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html:35341,variab,variable,35341,psi4manual/1.5.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html,2,['variab'],['variable']
Modifiability,"nally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, read_data=False):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if return_history:; step_energies = []; step_gradients = []; step_coordinates = []. # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # Do not change orientation or COM; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Get geometric-specific options; optimizer_keywords = {k.lower(): v for k, v in kwargs.get(""optimizer_keywords"", {}).items()}. core.print_out('\n'); core.print_out(""\n ==> GeomeTRIC Optimizer <== ~\n""); ; # Default to Psi4 maxiter unless overridden; if 'maxiter' not in optimizer_keywords:; optimizer_keywords['maxiter'] = core.get_global_option('GEOM_MAXITER'). # Default to Psi4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:55393,variab,variable,55393,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,4,['variab'],['variable']
Modifiability,"nalysis.; Another open-source LAPACK distribution, ATLAS had; stability issues with the DFOCC module at last testing,; https://github.com/psi4/psi4/issues/391.; ACML libraries are known to work with PSI4 v1.1 at ACML 6. Because of how link loaders work, at runtime, the BLAS of PSI4; and the BLAS of NumPy are not independent. There can be unpredictable; but reproducible numerical and thread-scaling errors if PSI4; and NumPy BLAS don’t match down to the library name (that is,; libmkl_rt, libmkl_core.so, libmkl_core.a are not; interchangeable). See https://github.com/psi4/psi4/issues/1007,; https://github.com/psi4/psi4/issues/748,; https://github.com/psi4/psi4/issues/755 for gory discussions.; Choose your NumPy and PSI4 compile conditions to use the same; BLAS distribution.; The BLAS/LAPACK detected for PSI4 are also linked into any; Add-Ons (e.g., libefp) that require them, rather than relying on; those packages’ native math detection.; The separation between BLAS and LAPACK seen in detection printing; and CMake variables is purely formal. In practice, they get run; together and linked as ${LAPACK_LIBRARIES} ${BLAS_LIBRARIES}.; Sometimes the CMake’s library search capabilites falter at SONAMEs; (e.g., libblas.so.3 vs. libblas.so), extensions (static; vs. dynamic), or suffixes (e.g., libacml_mp.so vs.; libacml.so). The developers would be interested in hearing; of such problems to expand the math detection capabilities. The; immediate solution, however, is to form symlinks between the; library names that exist and the names expected. Consult file; psi4/cmake/math/MathLibs.cmake for the library patterns being; sought.; The BLAS/LAPACK interface is standardized, so only libraries, not; headers, need to be detected. The exception is MKL, where the mkl.h; header defines additional functionality; it must be located to use; BLAS threading. How to configure Python for building Psi4¶; Role and Dependencies. Role — In PSI4, Python allows the core compiled C++ code to; be flexib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:39800,variab,variables,39800,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,13,['variab'],['variables']
Modifiability,"name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:5630,config,configuration,5630,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['config'],['configuration']
Modifiability,"name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return core.Molecule.from_dict(molrec['qm']), molrec; else:; return core.Molecule.from_dict(molrec['qm']). @classmethod; def molecule_from_arrays(cls,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`. Returns; -------; :py:class:`psi4.core.Molecule`. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/molutil.html:3350,variab,variables,3350,psi4manual/1.3.2/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/molutil.html,1,['variab'],['variables']
Modifiability,"names, either plain for those to be; set globally or mangled ""module__keyword"" for those to be set locally,; and values are keyword values. """"""; flat_options = {}; has_changed_snapshot = {module: core.options_to_python(module) for module in _modules}. for opt in core.get_global_option_list():; handled_locally = False; ghoc = core.has_global_option_changed(opt); opt_snapshot = {k: v[opt] for k, v in has_changed_snapshot.items() if opt in v}; for module, (lhoc, ohoc) in opt_snapshot.items():; if ohoc:; if lhoc:; key = module + '__' + opt; val = core.get_local_option(module, opt); else:; key = opt; val = core.get_global_option(opt); handled_locally = True; flat_options[key] = val. if ghoc and not handled_locally:; # some options are globals section (not level) so not in any module; flat_options[opt] = core.get_global_option(opt). # The normal machinery to forward plugin options to Psi goes through 'plugin_load'.; # Forte doesn't use this. Pending a larger options rewrite (move to a Python dictionary?),; # we need the following dirty hack. try:; import forte # Needed for Forte options to run.; except ImportError:; pass; else:; # Initialization tasks with Psi options; psi_options = core.get_options(); current_module = psi_options.get_current_module(); # Get the current Forte options from Forte; forte_options = forte.ForteOptions(); forte.register_forte_options(forte_options); psi_options.set_current_module(""FORTE""); try:; forte_options.get_options_from_psi4(psi_options); except RuntimeError:; # If we're in this case, Forte hasn't pushed its options to Psi.; pass; else:; # Load changed Forte options into `flat_options`; for name, metadata in forte_options.dict().items():; if metadata[""value""] != metadata[""default_value""]:; flat_options[f""forte__{name.lower()}""] = metadata[""value""]; finally:; # Restore current module; psi_options.set_current_module(current_module); return flat_options. [docs]; def state_to_atomicinput(; *,; driver: str,; method: str,; basis: Optional[str] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:15027,rewrite,rewrite,15027,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,6,['rewrite'],['rewrite']
Modifiability,"names, either plain for those to be; set globally or mangled ""module__keyword"" for those to be set locally,; and values are keyword values. """"""; flat_options = {}; has_changed_snapshot = {module: core.options_to_python(module) for module in _modules}. for opt in core.get_global_option_list():; handled_locally = False; ghoc = core.has_global_option_changed(opt); opt_snapshot = {k: v[opt] for k, v in has_changed_snapshot.items() if opt in v}; for module, (lhoc, ohoc) in opt_snapshot.items():; if ohoc:; if lhoc:; key = module + '__' + opt; val = core.get_local_option(module, opt); else:; key = opt; val = core.get_global_option(opt); handled_locally = True; flat_options[key] = val. if ghoc and not handled_locally:; # some options are globals section (not level) so not in any module; flat_options[opt] = core.get_global_option(opt). # The normal machinery to forward plugin options to Psi goes through 'plugin_load'.; # Forte doesn't use this. Pending a larger options rewrite (move to a Python dictionary?),; # we need the following dirty hack. try:; import forte # Needed for Forte options to run.; except ImportError:; pass; else:; # Initialization tasks with Psi options; psi_options = core.get_options(); current_module = psi_options.get_current_module(); # Get the current Forte options from Forte; forte_options = forte.ForteOptions(); forte.register_forte_options(forte_options); psi_options.set_current_module(""FORTE""); try:; forte_options.get_options_from_psi4(psi_options); except RuntimeError:; # If we're in this case, Forte hasn't pushed its options to Psi.; pass; else:; # Load changed Forte options into `flat_options`; for name, metadata in forte_options.dict().items():; if metadata[""value""] != metadata[""default_value""]:; flat_options[f""forte__{name.lower()}""] = metadata[""value""]; finally:; # Restore current module; psi_options.set_current_module(current_module); return flat_options. [docs]def state_to_atomicinput(; *,; driver: str,; method: str,; basis: Optional[str] = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html:15019,rewrite,rewrite,15019,psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,2,['rewrite'],['rewrite']
Modifiability,"nary and NumPy representation of the Wavefunction. Return type; dict. tpdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool) → None¶; docstring. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:29615,variab,variable,29615,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,5,['variab'],['variable']
Modifiability,"nates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. fx(self, arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nucle",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:4406,variab,variable,4406,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,4,['variab'],"['variable', 'variables']"
Modifiability,"nates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. fx(self, arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self, dipo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:4406,variab,variable,4406,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,6,['variab'],"['variable', 'variables']"
Modifiability,"nates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. fx(self, arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self[, dip",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:4424,variab,variable,4424,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,8,['variab'],"['variable', 'variables']"
Modifiability,"nce of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; core.set_variable('CURRENT ENERGY', core.variable('SCS-MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; core.set_variable('CURRENT ENERGY', core.variable('MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('MP2 CORRELATION ENERGY')). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not availab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:93114,variab,variable,93114,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"nce the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric weights by which the reagent energies are transfromed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through keyword tabulate, in this case the total SCF energy and the number; of atoms in each reagent.; ==> Mp2 Total Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00004802 -5.69430495 1 -2.84717649 -2; RGC1-HeHe-1.0 -0.00000064 -5.69435362 1 -2.84717649 -2; ------------------------------------------------------------------------------------------------------. ==> Requested Energy <==. ------------------------------------------------------------------------------------------------------; Reaction Reaction Energy Reaction Error Reagent 1 Reagent 2; Ref Calc [kcal/mol] [kJ/mol] [Eh] Wt [Eh] Wt; ------------------------------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.0376 0.0301 -0.0075 -0.0312 -5.69430495 1 -2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/db-1.html:7317,variab,variables,7317,psi4manual/1.0.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/db-1.html,2,['variab'],['variables']
Modifiability,"nce the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric weights by which the reagent energies are transfromed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; through keyword tabulate, in this case the total SCF energy and the number; of atoms in each reagent.; ==> Scf Total Energy <==. -----------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; -----------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00011520 -5.71020576 1 -2.85516048 -2; RGC1-HeHe-1.0 0.00000153 -5.71031943 1 -2.85516048 -2; RGC1-HeHe-1.5 -0.00000000 -5.71032096 1 -2.85516048 -2; -----------------------------------------------------------------------------------. ==> Natom <==. -----------------------------------------------------------------------------------; Reaction Reaction Value Reagent 1 Reagent 2; Value Wt Value Wt; -----------------------------------------------------------------------------------; RGC1-HeHe-0.85 0.00000000 2.00000000 1 1.00000000 -2; RGC1-HeHe-1.0 0.00000000 2.00000000 1 1.00000000 -2; RGC1-HeHe-1.5 0.00000000 2.00000000 1 1.00000000 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/db-1.html:6980,variab,variables,6980,psi4manual/4.0b2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/db-1.html,8,['variab'],['variables']
Modifiability,"ncies (roundoff errors of around 0.1 cm-1 may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1776.2423; A1 4113.7717; B2 4211.8290; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; Frequency: 1776.24; Force constant: 0.1194; X Y Z mass; O 0.000 0.000 -0.270 15.994915; H 0.000 0.418 0.538 1.007825; H 0.000 -0.418 0.538 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for; each atom along the normal mode coordinate. (This information could be used; to animate the vibrational frequency using visualization software.). Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. PSI4; contains code to analyze the nature of intermolecular interactions; between two molecules, via symmetry-adapted perturbation theory; (SAPT) [Jeziorski:1994:1887]. This kind of analysis gives a lot; of insight into the nature of intermolecular interactions, and PSI4; makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:; # Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene),; # test case 16 from the S22 database. molecule dimer {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom. no_reorient; symmetry c1; }. Notice we have a couple of new",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:8396,adapt,adapted,8396,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,2,['adapt'],['adapted']
Modifiability,"ncies (roundoff errors of around 0.1 cm-1 may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1776.2423; A1 4113.7717; B2 4211.8290; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; Frequency: 1776.24; Force constant: 0.1194; X Y Z mass; O 0.000 0.000 -0.270 15.994915; H 0.000 0.418 0.538 1.007825; H 0.000 -0.418 0.538 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for; each atom along the normal mode coordinate. (This information could be used; to animate the vibrational frequency using visualization software.). Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. PSI4; contains code to analyze the nature of intermolecular interactions; between two molecules, via symmetry-adapted perturbation theory; (SAPT) [Jeziorski:1994:1887]. This kind of analysis gives a lot; of insight into the nature of intermolecular interactions, and PSI4; makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:; # Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene),; # test case 16 from the S22 database. molecule dimer {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom. }. Here’s the second half of the input, where we specify th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/tutorial-1.html:8396,adapt,adapted,8396,psi4manual/4.0b5/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/tutorial-1.html,2,['adapt'],['adapted']
Modifiability,"ncies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint2.h; Libint2_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing lib/cmake/libint2/libint2-config.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint2 — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint2 — CMake variable to force detecting pre-built Libint and not falling back on internal build; BUILD_Libint2_GENERATOR — CMake variable to allow internal build to start from generator source, not generated source; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR2=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. Build bundled shared library with up to AM=5. >>> cmake -DBUILD_SHARED_LIBS=ON. Build custom library from generator source. >>> # find the ""new-cmake-harness-lab-rb1"" block at :source:`external/upstream/libint2/CMakeLists.txt`; >>> # edit the ""ENABLE"" and ""AM"" variables; >>> cmake -DBUILD_Libint2_GENERATOR=ON -DCMAKE_DISABLE_FIND_PACKAGE_Libint2=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to Libint by E. Valeev. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/libint.html:3047,config,configdir,3047,psi4manual/1.7.x/libint.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/libint.html,3,"['config', 'variab']","['configdir', 'configure', 'variables']"
Modifiability,"nction's options object. pitzer_to_ci_order_onel(self, arg0, arg1); docstring. pitzer_to_ci_order_twoel(self, arg0, arg1); docstring. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. print_vector(self, arg0, arg1); docstring. reference_wavefunction(self); Returns the reference wavefunction. reset_ci_H0block(self); docstring. rotate_mcscf_integrals(self, arg0, arg1, arg2); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. semicanonical_orbs(self); docstring. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_ci_guess(self, arg0); docstring. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_orbitals(self, arg0, arg1); docstring. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:7499,variab,variable,7499,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,4,['variab'],['variable']
Modifiability,"nction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). def cfour_hessian_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_hessian_list(). def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). def write_zmat(name, dertype, molecule):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * core.get_memory()); if mem == 524:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; core.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.tagline = molecule.name(); molcmd, molkw = qcdbmolecule.format_molecule_for_cfour(). if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; bascmd, baskw = '', {}; else:; user_pg = molecule.schoenflies_sy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:14645,Variab,Variables,14645,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,4,['Variab'],['Variables']
Modifiability,"nction(self, arg0); docstring. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. soFeff(self); Returns the effective Fock matrix in the orthogonalized SO basis. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. to_file([filename]); Converts a Wavefunction object to a base class. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html:12135,variab,variable,12135,psi4manual/1.5.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html,2,['variab'],['variable']
Modifiability,"nction) → psi4.core.Matrix¶; Returns the Beta Fock Matrix. Fb_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. Hd_vector(self: psi4.core.CIWavefunction, arg0: int) → psi::detci::CIvect¶; docstring. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. ci_nat_orbs(self: psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:23347,variab,variable,23347,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"nction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | open_check(...); | open_check( (IO)arg1, (int)arg2) -> int :; | docstring; | ; | rehash(...); | rehash( (IO)arg1, (int)arg2) -> None :; | docstring; | ; | set_pid(...); | set_pid( (IO)arg1, (str)arg2) -> None :; | docstring; | ; | state(...); | state( (IO)arg1) -> int :; | docstring; | ; | tocclean(...); | toccle",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:33371,inherit,inherited,33371,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"nction)arg1) -> int :; | docstring; | ; | nalphapi(...); | nalphapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nbeta(...); | nbeta( (Wavefunction)arg1) -> int :; | docstring; | ; | nbetapi(...); | nbetapi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nmopi(...); | nmopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | nsopi(...); | nsopi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | --------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:79490,inherit,inherited,79490,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"nction)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_hessian(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE {lvalue}); | ; | set_reference_wavefunction(...); | set_reference_wavefunction( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_reference_wavefunction(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | shallow_copy(...); | shallow_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void shallow_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}); | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CUHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | CUHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | -------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:404047,inherit,inherited,404047,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"nction)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_hessian(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE {lvalue}); | ; | set_reference_wavefunction(...); | set_reference_wavefunction( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_reference_wavefunction(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | shallow_copy(...); | shallow_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void shallow_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}); | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE matrix(N3psi10CdSalcListE {lvalue}); | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi10CdSal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:415676,inherit,inherited,415676,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"nction)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_hessian(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE {lvalue}); | ; | set_reference_wavefunction(...); | set_reference_wavefunction( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_reference_wavefunction(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | shallow_copy(...); | shallow_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void shallow_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}); | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IO(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IO; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | close(...); | close( (IO)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void close(N3psi4PSIOE {lvalue},j,i); | ; | open(...); | open( (IO)arg1, (int)arg2, (int)arg3) -> N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:488768,inherit,inherited,488768,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"nction)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_hessian(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE {lvalue}); | ; | set_reference_wavefunction(...); | set_reference_wavefunction( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_reference_wavefunction(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | shallow_copy(...); | shallow_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void shallow_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}); | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ROHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | ROHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | moFa(...); | moFa( (ROHF)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE moFa(N3psi3scf4ROHFE {lvalue}); | ; | moFb(...); | moFb( (ROHF)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE moFb(N3psi3scf4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:605048,inherit,inherited,605048,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"nction)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_hessian(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE {lvalue}); | ; | set_reference_wavefunction(...); | set_reference_wavefunction( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_reference_wavefunction(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | shallow_copy(...); | shallow_copy( (Wavefunction)arg1, (Wavefunction)arg2) -> None :; | docstring; | ; | C++ signature :; | void shallow_copy(N3psi12WavefunctionE {lvalue},N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi12WavefunctionE {lvalue}); | ; | soccpi(...); | soccpi( (Wavefunction)arg1) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE soccpi(N3psi12WavefunctionE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SOBasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SOBasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | petite_list(...); | petite_list( (SOBasisSet)arg1) -> PetiteList :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10PetiteListEEE petite_list(N3psi10SOBasisSetE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:617151,inherit,inherited,617151,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"nction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val)¶; Sets scalar or array QCVariable key to val on self.; :rtype: None. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float]) – Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError – If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction) – Wavefunction or inherited class instance.; filename (Optional[str]) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. Returns:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:24939,variab,variable,24939,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"nction.get_basisset(); Wavefunction.get_density(); Wavefunction.get_dipole_field_strength(); Wavefunction.get_print(); Wavefunction.get_scratch_filename(); Wavefunction.get_variable(); Wavefunction.gradient(); Wavefunction.has_array_variable(); Wavefunction.has_potential_variable(); Wavefunction.has_scalar_variable(); Wavefunction.has_variable(); Wavefunction.hessian(); Wavefunction.lagrangian(); Wavefunction.mintshelper(); Wavefunction.mo_extents(); Wavefunction.module(); Wavefunction.molecule(); Wavefunction.nalpha(); Wavefunction.nalphapi(); Wavefunction.name(); Wavefunction.nbeta(); Wavefunction.nbetapi(); Wavefunction.nfrzc(); Wavefunction.nirrep(); Wavefunction.nmo(); Wavefunction.nmopi(); Wavefunction.no_occupations(); Wavefunction.nso(); Wavefunction.nsopi(); Wavefunction.options(); Wavefunction.potential_variable(); Wavefunction.potential_variables(); Wavefunction.reference_wavefunction(); Wavefunction.same_a_b_dens(); Wavefunction.same_a_b_orbs(); Wavefunction.scalar_variable(); Wavefunction.scalar_variables(); Wavefunction.set_array(); Wavefunction.set_array_variable(); Wavefunction.set_basisset(); Wavefunction.set_energy(); Wavefunction.set_external_potential(); Wavefunction.set_gradient(); Wavefunction.set_hessian(); Wavefunction.set_lagrangian(); Wavefunction.set_module(); Wavefunction.set_name(); Wavefunction.set_potential_variable(); Wavefunction.set_print(); Wavefunction.set_reference_wavefunction(); Wavefunction.set_scalar_variable(); Wavefunction.set_variable(); Wavefunction.shallow_copy(); Wavefunction.sobasisset(); Wavefunction.soccpi(); Wavefunction.to_file(); Wavefunction.variable(); Wavefunction.variables(); Wavefunction.write_molden(); Wavefunction.write_nbo(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; Wavefunction. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:32447,variab,variable,32447,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,4,['variab'],"['variable', 'variables']"
Modifiability,nctional. td-kmlyp; TDDFT KMLYP Hyb-GGA Exchange-Correlation Functional. ksdt; KSDT Exchange-Correlation Functional. td-ksdt; TDDFT KSDT Exchange-Correlation Functional. kt2; KT2 GGA Exchange-Correlation Functional. td-kt2; TDDFT KT2 GGA Exchange-Correlation Functional. lc-bop; LC-BOP GGA Exchange-Correlation Functional. td-lc-bop; TDDFT LC-BOP GGA Exchange-Correlation Functional. lc-vv10; LC-VV10 GGA Exchange-Correlation Functional. td-lc-vv10; TDDFT LC-VV10 GGA Exchange-Correlation Functional. lda0; LDA0 Exchange-Correlation Functional. td-lda0; TDDFT LDA0 Exchange-Correlation Functional. lrc-wpbe; LRC-WPBE GGA Exchange-Correlation Functional. td-lrc-wpbe; TDDFT LRC-WPBE GGA Exchange-Correlation Functional. lrc-wpbeh; LRC-wPBEh Hyb-GGA Exchange-Correlation Functional. td-lrc-wpbeh; TDDFT LRC-wPBEh Hyb-GGA Exchange-Correlation Functional. m05; M05 Meta-GGA XC Functional (10.1063/1.2126975). td-m05; TDDFT M05 Meta-GGA XC Functional (10.1063/1.2126975). m05-2x; Heavily Parameterized Hybrid M05-2X Meta-GGA XC Functional. td-m05-2x; TDDFT Heavily Parameterized Hybrid M05-2X Meta-GGA XC Functional. m05-2x-d3zero2b. m05-2x-d3zeroatm. m05-d3zero2b. m05-d3zeroatm. m06; M06 Meta-GGA XC Functional (10.1007/s00214-007-0310-x). td-m06; TDDFT M06 Meta-GGA XC Functional (10.1007/s00214-007-0310-x). m06-2x; Hybrid M06-2X Meta-GGA XC Functional (10.1007/s00214-007-0310-x). td-m06-2x; TDDFT Hybrid M06-2X Meta-GGA XC Functional (10.1007/s00214-007-0310-x). m06-2x-d3zero2b. m06-2x-d3zeroatm. m06-d3zero2b. m06-d3zeroatm. m06-hf; Minnesota M06-HF Hybrid XC Functional (10.1021/jp066479k). td-m06-hf; TDDFT Minnesota M06-HF Hybrid XC Functional (10.1021/jp066479k). m06-hf-d3zero2b. m06-hf-d3zeroatm. m06-l; M06-L Meta-GGA XC Functional. td-m06-l; TDDFT M06-L Meta-GGA XC Functional. m06-l-d3zero2b. m06-l-d3zeroatm. m08-hx; Minnesota M08-HX Hybrid XC Functional (10.1021/ct800246v). td-m08-hx; TDDFT Minnesota M08-HX Hybrid XC Functional (10.1021/ct800246v). m08-hx-d3zero2b. m08-hx-d3zeroatm. ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.energy.html:19368,Parameteriz,Parameterized,19368,psi4manual/1.9.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.energy.html,2,['Parameteriz'],['Parameterized']
Modifiability,"nd Python code; to avoid hard-to-read diffs and merge conflicts.; clang-format and yapf can be used to format C++ and Python code,; respectively, according to a predefined style file.; PSI4 provides the psi4/.clang-format and psi4/.style.yapf files in the root; folder of the project.; It is recommended that modifications and/or new files checked into the; repository are formatted according to these style files using clang-format; and yapf. It is then helpful if these tools be part of your development toolchain.; Once clang-format and yapf are installed, there are three ways in which; formatting of the code can be accomplished, in decreasing order of automation:. By integrating the formatters into your editor.; By installing Git hooks to run the formatters when committing.; By running the formatters manually on the modified files. How to impose code style through your editor¶; Both clang-format and yapf can be integrated into widely used editors.; The Neoformat plugin can be configured; to format files when saving them to disk. How to impose code style through Git hooks¶; Git hooks are scripts that are run before or after certain Git events.; In this particular case, we want to make sure that all files that have been; added to the staging area with git add are formatted according to the style; before they committing them with git commit.; The hook to be modified is then the pre-commit hook.; PSI4 uses the pre-commit framework, with configuration file psi4/.pre-commit-config.yaml.; To take advantage of pre-commit hooks, you will need to install the pre-commit utility:. ::pip install pre-commit. or using Conda:. ::conda install pre_commit -c conda-forge. Finally, you need to install the actual hooks:. ::pre-commit install. Pre-commit hooks will be run on every git commit, but the --no-verify; option can be used to skip their execution.; Hooks are powerful, but integrating the formatter into your editor will prove; to be better. Hooks need to be installed anew for every ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/code_style-1.html:1179,plugin,plugin,1179,psi4manual/1.4.0/code_style-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/code_style-1.html,18,"['config', 'plugin']","['configured', 'plugin']"
Modifiability,"nd don’t usually work when run “by hand” from the objdir via stage/bin/psi4 ../tests/directory_name/input.dat.; If a test is multiple minutes long, load-balancing a parallel CTest run requires the test to be started early. Use the COST line as shown above to set a weighting to about the number of seconds the test takes. input.dat¶; The other necessary file is the input file itself, input.dat. The input file should be just a simple input file to run the test, with small additions.; #! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxiliary basis.; #! Also a bit more to force a second line. nucenergy = 8.801466202085710 #TEST; refenergy = -76.05098402733282 #TEST. molecule h2o {; symmetry c1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pVTZ; scf_type df; df_basis_scf cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy(""hf""). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be descriptive since it is inlined into the manual (unless !nosample in the comment) as a sample input.; Reference values are often assigned to variables for later use.; The compare_values function (along with several relatives in psi4/psi4/driver/p4util/testing.py for comparing strings, matrices, etc.) checks that the computed values match these reference values to suitable precision. This function prints an error message and signals that the test failed to the make system, if the values don’t match. Any lines of the input associated with the validation process should be flagged with #TEST at the end of each line, so that they can be removed when copying from the tests to the samples directory. output.ref¶; When your test case is in final form, run it loc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/add_tests.html:7462,variab,variable,7462,psi4manual/1.6.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/add_tests.html,5,['variab'],['variable']
Modifiability,"nd generate makefiles with CMake.; You will require Eigen (tested with version 3.1.2); and boost (tested with version 1.62). cmake .. Build the examples and samples. make. Test the installation by starting a small calculation.; Make sure to set the BRIANQC_INSTALL_PATH environment variable to <brianqc_install_path>!. export BRIANQC_INSTALL_PATH=<brianqc_install_path>; bin/sample_hf_and_dft --molecule ../share/qc_molecules/cis-decalin.raw --basis ../share/basis_sets/cc-pvdz. Building PSI4 with BrianQC¶; When CMake-ing PSI4, set the ENABLE_BrianQC CMake variable to 1; and set the BrianQC_DIR CMake variable to the path where BrianQC’s; components have been built (usually <brianqc_install_path>/build), then build PSI4 normally. Using BrianQC from PSI4¶; To use BrianQC, the BRIANQC_INSTALL_PATH environment variable; must be set to the full path of your BrianQC installation.; There are two ways to enable BrianQC for a specific calculation:. setting the BRIANQC_ENABLE input option to True;; setting the BRIANQC_ENABLE environment variable to 1. If both the input option and the environment variable are specified,; then the environment variable takes precedence. When to enable BrianQC¶; The operation of BrianQC is transparent from a user’s point of view; every; internal computation is either performed by PSI4 (if unsupported by BrianQC),; or taken over by BrianQC, yielding the same result to within the required; precision. In particular, BrianQC will respect all of PSI4’s usual precision; parameters, like INTS_TOLERANCE and E_CONVERGENCE.; BrianQC can speed up a number of internal computations, including Fock and; gradient computation. Thus, BrianQC will speed up any calculation involving; those terms, such as. HF and DFT single point energies; HF and DFT geometry optimizations; HF and DFT frequency analysis. Note that not every term of every calculation can be handled by BrianQC, thus,; the actual speedup depends on the specifics of the calculation. Necessary and recommended",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/brianqc-1.html:2372,variab,variable,2372,psi4manual/1.4.0/brianqc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/brianqc-1.html,9,['variab'],['variable']
Modifiability,"nd in qcdb/molecule.py; # itself, the raw, staticmethod fns can use their official names again; # and not need the append line at bottom of file. what I do for you,; # py2 ...; cls.to_arrays = qcdb.Molecule._raw_to_arrays; cls.to_dict = qcdb.Molecule._raw_to_dict; cls.BFS = qcdb.Molecule._raw_BFS; cls.B787 = qcdb.Molecule._raw_B787; cls.scramble = qcdb.Molecule._raw_scramble; cls.from_arrays = molecule_from_arrays; cls.from_string = molecule_from_string; cls.to_string = qcdb.Molecule._raw_to_string; cls.from_schema = molecule_from_schema; cls.to_schema = qcdb.Molecule._raw_to_schema. dynamic_variable_bind(core.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name* from the; geometry in string *geom*. Permitted for user use but deprecated; in driver in favor of explicit molecule-passing. Comments within; the string are filtered. """"""; core.efp_init(); geom = pubchemre.sub(process_pubchem_command, geom); geom = filter_comments(geom); molecule = core.Molecule.create_molecule_from_string(geom); molecule.set_name(name). # Attempt to go ahead and construct the molecule; try:; molecule.update_geometry(); except:; core.print_out(""Molecule: geometry: Molecule is not complete, please use 'update_geometry'\n""; "" once all variables are set.\n""). activate(molecule). return molecule. [docs]def activate(mol):; """"""Function to set molecule object *mol* as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. """"""; core.set_active_molecule(mol). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.2.1;  · . PSI4. Module code. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/molutil.html:8500,variab,variables,8500,psi4manual/1.2.1/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/molutil.html,1,['variab'],['variables']
Modifiability,"nd is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/ccsd-pte,; pcmsolver/scf,; pcmsolver/opt-fd,; pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/pcmsolver-1.html:3894,config,configure,3894,psi4manual/1.3.2/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/pcmsolver-1.html,2,['config'],['configure']
Modifiability,"nd of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. FIRST_TMP_FILE (TRANSQT); TRANSQT — First temporary file. Type: integer; Default: 150. FITTING_ALGORITHM (CPHF); CPHF — Fitting algorithm (0 for old, 1 for new). Type: integer; Default: 0. FITTING_CONDITION (CPHF); CPHF — The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. FIXED_BEND (OPTKING); OPTKING — Specify angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FLEXIBLE_G_CONVERGENCE (OPTKING); OPTKING — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. FOCK_TOLERANCE (CCENERGY); CCENERGY — Minimum absolute value below which parts of the Fock matrix are skipped. Type: conv double; Default: 1e-2. FOLLOW (STABILITY); STABILITY — Do follow the most negative eigenvalue of the Hessian towards a lower energy HF solution? Follow a UHF UHF instability of same symmetry?. Type: boolean; Default: false. FOLLOW_ROOT (CCLAMBDA); CCLAMBDA — Root to get OPDM. Type: integer; Default: 1. FOLLOW_ROOT (DETCI); DETCI — The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 1. FOLLOW_ROOT (MCSCF); MCSCF — Which solution of the SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FOLLOW_ROOT (PSIMRCC); PSIMRCC — Which root of the effective hamiltonian is the target st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:45330,flexible,flexible,45330,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['flexible'],['flexible']
Modifiability,"nd what are their dependencies; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; How to set PSIDATADIR and why. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”; How to fix error “RuntimeError: value for ERI”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Installation and Runtime Configuration. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 201",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_faq-1.html:3230,variab,variables,3230,psi4manual/1.1.0/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_faq-1.html,2,['variab'],['variables']
Modifiability,"nd-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. -l <name>, --psidatadir <name>¶; Mainly for use by developers, this overrides the value of; PSIDATADIR and specifies the path to the Psi data; library (psi4/share). -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename (subtracting; any ”.in” or ”.dat” suffix) plus ”.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to Psi4 for available templates. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; >>> psi4 --version; 0.4.262. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence Psi4‘s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring Psi4 through PSIPATH is prefer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:14803,plugin,plugin,14803,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,4,['plugin'],['plugin']
Modifiability,"nd; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libefp-1.html:7481,config,configure,7481,psi4manual/1.2.1/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libefp-1.html,13,['config'],['configure']
Modifiability,"nd; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) None. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:7345,config,configure,7345,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,2,['config'],['configure']
Modifiability,"nda environment that has a script psi4-path-advisor. Running; psi4-path-advisor --help shows more options. Running the script; without arguments gives a cmake command that supplies paths to dependency; conda packages to CMake’s cache. You can add further cmake options to; this command when you execute it. Once the cmake command has built your; objdir, you can build PSI4. Remember to activate this; conda environment during PSI4 running or development. There are a; few extra options to psi4-path-advisor to set up using conda’s GNU; compilers (on Linux), conda’s Clang compilers (on Mac; less reliably),; or your own Intel compilers backed by conda’s GNU compilers (on Linux).; >>> git clone https://github.com/psi4/psi4.git && cd psi4; >>> conda create -n p4dev psi4-dev python=3.8 -c psi4/label/dev; >>> conda activate p4dev; >>> `psi4-path-advisor --gcc`; >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`. How to configure code to use high angular momentum basis sets¶; The Libint integral code handles; arbitrary order angular momentum (AM), but compiling that is; prohibitive. The build process for Libint2 takes longer than; for Libint1, so it’s recommended to use the conda packages. The AM controlling keyword MAX_AM_ERI; has definition changed a little from Libint1. It is used to ensure; that conventional energies can use at least MAX_AM_ERI zeta. See; psi4//external/upstream/libint2/CMakeLists.txt for a fuller; discussion of AM capabilities. Unless BUILD_Libint2_GENERATOR; is set to ON, an internal build of Libint2 will download a; pregenerated tarball of at least MAX_AM_ERI AM. If you; want to build completely from generator source, turn on the keyword,; but parts can only run in serial and parts benefit from parallel, so; it’s not recommended. All the AM generation settings would need to be; edited in the above CMakeLists.txt rather than passing them into; the PSI4 build directly. Build with Higher Angular Momentum; >>> cmake -DMAX_AM_ERI=6. Relevant CMake Options:; MA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:9650,config,configure,9650,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['config'],['configure']
Modifiability,"nda package for Linux and macOS (and Windows, through the Ubuntu shell). If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; erd can be obtained through conda install erd -c psi4.; Then enable it as a feature with ENABLE_erd,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect erd and activate dependent code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/erd-1.html:2149,variab,variable,2149,psi4manual/1.4.0/erd-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/erd-1.html,16,['variab'],['variable']
Modifiability,"ndent code. How to configure simint for building Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_simint — CMake variable to force detecting pre-built simint and not falling back on internal build; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Examples. Build bundled. >>> cmake -DENABLE_simint=ON. Build without simint. >>> cmake. Link against pre-built. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. table of contents. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/simint-1.html:3190,config,configdir,3190,psi4manual/1.3.2/simint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/simint-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,"ndows, through the Ubuntu shell). If using the Psi4conda installer, gCP has already been installed alongside. If using the PSI4 conda package, the gcp conda package can; be obtained through conda install gcp -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the gcp executable can be obtained through conda install gcp -c psi4. To remove a conda installation, conda remove gcp. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/gcp-1.html:1387,variab,variables,1387,psi4manual/1.2.1/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/gcp-1.html,4,['variab'],['variables']
Modifiability,"ndrew C. Simmonett; Section author: Andrew C. Simmonett. psi4.oeprop(wfn, *args[, title])[source]¶; Evaluate one-electron properties. Returns:None. Parameters:wfn (Wavefunction) – set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. Parameters:title (string) – label prepended to all psivars computed. Examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; 1oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, whic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/oeprop-1.html:1253,variab,variables,1253,psi4manual/1.3.2/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/oeprop-1.html,2,['variab'],['variables']
Modifiability,"ne :; | ; | C++ signature :; | void __init__(P7_object); | ; | __init__( (object)arg1, (int)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,i); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | dim(...); | dim( (IntVector)arg1, (int)arg2) -> int :; | docstring; | ; | C++ signature :; | i dim(N3psi9IntVectorE {lvalue},i); | ; | get(...); | get( (IntVector)arg1, (int)arg2, (int)arg3) -> int :; | docstring; | ; | C++ signature :; | i get(N3psi9IntVectorE {lvalue},i,i); | ; | nirrep(...); | nirrep( (IntVector)arg1) -> int :; | docstring; | ; | C++ signature :; | i nirrep(N3psi9IntVectorE {lvalue}); | ; | print_out(...); | print_out( (IntVector)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi9IntVectorE {lvalue}); | ; | set(...); | set( (IntVector)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | C++ signature :; | void set(N3psi9IntVectorE {lvalue},i,i,i); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class IntegralFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | IntegralFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (BasisSet)arg2, (BasisSet)arg3, (BasisSet)arg4, (BasisSet)arg5) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:496444,inherit,inherited,496444,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ne :; | docstring; | ; | C++ signature :; | void set_omega(N3psi10FunctionalE {lvalue},d); | ; | set_parameter(...); | set_parameter( (Functional)arg1, (str)arg2, (float)arg3) -> None :; | docstring; | ; | C++ signature :; | void set_parameter(N3psi10FunctionalE {lvalue},Ss,d); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_base(...); | build_base( (str)arg1) -> Functional :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10FunctionalEEE build_base(Ss); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Gaussian94BasisSetParser(BasisSetParser); | docstring; | ; | Method resolution order:; | Gaussian94BasisSetParser; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:470041,inherit,inherited,470041,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ne of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf; >>> psi4 --new-plugin myplugin +ambit. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/plugins/backtrans/backtrans.cc; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mollerplesset2/mp2.cc; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Creating a New Plugin Using a Conda Pre-compiled Binary¶; Psi4 plugins can also be created using Conda for both Psi4 binary and; development environment.; To compile a plugin with the default Makefile, it is necessary to have the; gcc compiler installed in the Conda distribution or environment (below,; $PSI4CONDA) used to run Psi4.; # prepare; >>> bash; >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; >>> conda install gcc # install compilers into expected place. # check (yes, next line gives empty result. yes, LD_LIBRARY_PATH irrelevant); >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 gcc; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:3790,plugin,plugin,3790,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"ne]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. class psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion(*, name_hint=None, level_hint=None, param_tweaks=None, engine=None, save_pairwise_disp=False)[source]¶; Lightweight unification of empirical dispersion calculation modes. dashlevel¶; {‘d1’, ‘d2’, ‘d3zero’, ‘d3bj’, ‘d3mzero’, ‘d3mbj’, ‘chg’, ‘das2009’, ‘das2010’, ‘nl’, ‘dmp2’}; Name of dispersion correction to be applied. Resolved; from name_hint and/or level_hint into a key of; empirical_dispersion_resources.dashcoeff. Type; str. dashparams¶; Complete set of parameter values defining the flexible parts; of dashlevel. Number and parameter names vary by; dashlevel. Resolved into a complete set (keys of; dashcoeff[dashlevel][‘default’]) from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type; dict. fctldash¶; If dashparams for dashlevel corresponds to a defined,; named, untweaked “functional-dashlevel” set, then that; functional. Otherwise, empty string. Type; str. description¶; Tagline for dispersion dashlevel. Type; str. dashlevel_citation¶; Literature reference for dispersion dashlevel in general,; not necessarily for dashparams. Type; str. dashparams_citation¶; Literature reference for dispersion parameters, if dashparams; corresponds to a defined, named, untweaked “functional-dashlevel”; set with a citation. Otherwise, empty string. Type; str. dashcoeff_supplement¶; See description in qcengine.programs.empirical_dispersion_resources.from_arrays. Used; here to “bless” the dispersion definitions attached to; the procedures/dft/<rung>_f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dftd3-1.html:11585,flexible,flexible,11585,psi4manual/1.4.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dftd3-1.html,2,['flexible'],['flexible']
Modifiability,"necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very latest Intel compilers; around. Missing symbols like “do_fio” or “e_wsfe”; See Section IV(3) above. Table Of Contents. Installation Instructions for PSI4; I. Compilation Prerequisites; II. Brief Summary of Configuration, Compilation, and Installation; III. Detailed Installation Instructions; IV. Recommendations for BLAS and LAPACK libraries; V. Miscellaneous Architecture",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:26576,config,config,26576,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,3,['config'],['config']
Modifiability,"needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Installation and Runtime Configuration; Buil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_faq.html:3678,variab,variables,3678,psi4manual/master/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/master/build_faq.html,1,['variab'],['variables']
Modifiability,"nerate plugin in directory with sanitized *name* based upon *template*."""""". name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.2.1;  · . PSI4. Module code. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/plugin.html:4776,plugin,plugin,4776,psi4manual/1.2.1/_modules/psi4/driver/plugin.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/plugin.html,2,['plugin'],['plugin']
Modifiability,"nergies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self, arg0, arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. get_variable(key). gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:4055,variab,variable,4055,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"nergy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:20686,variab,variables,20686,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['variab'],['variables']
Modifiability,"nergy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of Psi4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main Psi4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the Psi4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:7087,plugin,plugin,7087,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,6,['plugin'],['plugin']
Modifiability,"nergy, , is simply a partial sum of the correlation energy. In a spin-free formalism,; the pair energy is given by. (5); Methods whose shifts ( and ) do not explicitly depend on orbitals or ; (CISD, CEPA(0), ACPF, and AQCC); have solutions that render the energy stationary with respect variations in the amplitudes. This convenient property allows; density matrices and 1-electron properties to be evaluated without any additional effort.; The coupled-pair methods currently supported in PSI4 are outlined in Table CEPA Methods. name; calls method; energy; derivatives; 1-electron properties. cepa(0); coupled electron pair approximation, variant 0; Y; N; Y. cepa(1); coupled electron pair approximation, variant 1; Y; N; N. cepa(3); coupled electron pair approximation, variant 3; Y; N; N. acpf; averaged coupled-pair functional; Y; N; Y. aqcc; averaged quadratic coupled-cluster; Y; N; Y. sdci; configuration interaction with single and double excitations; Y; N; Y. dci; configuration interaction with double excitations; Y; N; Y. Basic Coupled Pair Keywords¶. BASIS¶. Primary basis set. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For heavier elements, there can be some ambiguity in how many core orbitals to freeze; in such cases, SMALL picks the most conservative standard setting (freezes fewer orbitals), and LARGE picks the least conservative standard setting (freezes more orbitals). More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. R_CONVERGENCE¶. Desired convergence for the t1 and t2 amplitud",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cepa-1.html:2936,config,configuration,2936,psi4manual/4.0b3/cepa-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cepa-1.html,2,['config'],['configuration']
Modifiability,"nergy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. DFCC¶. Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). table of contents. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; BASIS; FREEZE_CORE; R_CONVERGENCE; E_CONVERGENCE; MAXITER; DIIS_MAX_VECS; NAT_ORBS; OCC_TOLERANCE; TRIPLES_LOW_MEMORY; CC_TIMINGS; DF_BASIS_CC; CHOLESKY_TOLERANCE; CEPA_NO_SINGLES; DIPMOM. Advanced FNOCC Keywords; SCS_MP2; MP2_SCALE_OS; MP2_SCALE_SS; SCS_CCSD; CC_SCALE_OS; CC_SCALE_SS; RUN_MP2; RUN_MP3; RUN_MP4; RUN_CCSD; RUN_CEPA; COMPUTE_TRIPLES; COMPUTE_MP4_TRIPLES; DFCC; CEPA_LEVEL. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/fnocc.html:19403,config,configuration,19403,psi4manual/1.6.x/fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/fnocc.html,1,['config'],['configuration']
Modifiability,"nergy_ if CURRENT ENERGY. set_variable(key, val)¶; Sets scalar or array QCVariable key to val on cls. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:24279,variab,variables,24279,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,14,['variab'],['variables']
Modifiability,"ne¶; Add an external potential to the private external_potentials list. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. reset_occupation(self: psi4.core.HF) → None¶; docstring. rotate_orbitals(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; docstring. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self: psi4.core.HF) → None¶; docstring. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonicalize(self: psi4.core.HF) → None¶; Semicanonicalizes the orbitals for ROHF. set_array(key, val)¶. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energies(self: psi4.core.HF, arg0: str, arg1: float) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_jk(self: psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html:13806,variab,variables,13806,psi4manual/1.3.2/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html,14,['variab'],['variables']
Modifiability,"ne¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. moFa(self: psi4.core.ROHF) → psi4.core.Matrix; docstring. moFb(self: psi4.core.ROHF) → psi4.core.Matrix; docstring. moFeff(self: psi4.core.ROHF) → psi4.core.Matrix; docstring. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html:5204,variab,variable,5204,psi4manual/1.1.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.rohf.html,1,['variab'],['variable']
Modifiability,"ne¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. moFa(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. moFb(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. moFeff(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Num",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:110540,variab,variable,110540,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variable']
Modifiability,"ne¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:21357,variab,variable,21357,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,11,['variab'],['variable']
Modifiability,"ne¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. set_variable(key, val)¶; Sets scalar or array QCVariable key to val on cls. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:30945,variab,variable,30945,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,28,['variab'],['variable']
Modifiability,"nfiguration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; 1>>> cmake -H. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation).; 1; 2>>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux and Mac) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++14 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (3.6 or 3.7) https://www.python.org/; CMake (3.8+) http://www.cmake.org/download/; NumPy (needed at runtime and buildtime) http://www.numpy.org/; System utilities: GNU make, GNU install, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:3767,config,configure,3767,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,4,"['config', 'variab']","['configure', 'variables']"
Modifiability,"nflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:65071,variab,variables,65071,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variables']
Modifiability,"nflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:72226,variab,variables,72226,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"ng CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Installation and Runtime Configuration; Build & Run F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_faq.html:3425,variab,variables,3425,psi4manual/1.6.x/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_faq.html,1,['variab'],['variables']
Modifiability,"ng CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Installation and Runtime Configuration; Build & Run F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/build_faq.html:3425,variab,variables,3425,psi4manual/1.7.x/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/build_faq.html,1,['variab'],['variables']
Modifiability,"ng CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Installation and Runtime Configuration; Build & Run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_faq.html:3711,variab,variables,3711,psi4manual/1.8.x/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_faq.html,1,['variab'],['variables']
Modifiability,"ng CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Installation and Runtime Configuration; Build & Run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_faq.html:3711,variab,variables,3711,psi4manual/1.9.x/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_faq.html,1,['variab'],['variables']
Modifiability,"ng Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_simint — CMake variable to force detecting pre-built simint and not falling back on internal build; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Examples. Build bundled. >>> cmake -DENABLE_simint=ON. Build without simint. >>> cmake. Link against pre-built. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. table of contents. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to SIMINT by B. Pritchard. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/simint.html:3104,config,configdir,3104,psi4manual/1.8.x/simint.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/simint.html,2,['config'],"['configdir', 'configure']"
Modifiability,"ng Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_simint — CMake variable to force detecting pre-built simint and not falling back on internal build; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Examples. Build bundled. >>> cmake -DENABLE_simint=ON. Build without simint. >>> cmake. Link against pre-built. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. table of contents. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to SIMINT by B. Pritchard. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/simint.html:3104,config,configdir,3104,psi4manual/1.9.x/simint.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/simint.html,2,['config'],"['configdir', 'configure']"
Modifiability,"ng done; # -- Build files have been written to: /current/dir/objdir; # >>> cmake --build objdir --target install -j`getconf _NPROCESSORS_ONLN`. # <<< Required build dependencies that Psi4 can't build itself >>>; #; # - CMake (e.g., `conda install cmake`); # - C++ and C compilers (C++17 compliant); # - BLAS/LAPACK (also runtime; e.g., `conda install mkl-devel`); # - Python (also runtime; interpreter and headers; e.g., `conda install python`); # - NumPy (also runtime; avoidable at buildtime if gau2grid pre-built; e.g., `conda install numpy`); # - networkx >=2.4 (runtime only; e.g., `conda install networkx`); # - pint >=0.10 (runtime only; e.g., `conda install pint -c conda-forge`); # - pydantic >=1.0 (runtime only; e.g., `conda install pydantic -c conda-forge`); # - msgpack-python (runtime only; e.g., `conda install msgpack-python`); # - Eigen (for Libint2; e.g., `conda install eigen`); # - SciPy (runtime only; e.g., `conda install scipy`). # These three ""### Options ###"" sections contain useful CMake variables for build configuration. # <<< Compilers and flags >>>; #; # - CMAKE_C_COMPILER ""C compiler""; # - CMAKE_C_FLAGS ""Additional C flags""; # - CMAKE_CXX_COMPILER ""C++ compiler""; # - CMAKE_CXX_FLAGS ""Additional C++ flags""; # - CMAKE_Fortran_COMPILER ""Fortran compiler (required for some add-ons)""; # - CMAKE_Fortran_FLAGS ""Additional Fortran flags"". # <<< Detecting dependencies and add-ons >>>; #; # - Python_EXECUTABLE ""Python interpreter to use (e.g., /path/to/bin/python3.7)""; # - Python_LIBRARY ""Python library that goes with the interpreter (e.g., /path/to/lib/python3.7.so)""; # - Python_INCLUDE_DIR ""Path to the python include files (e.g., /path/to/include/python3.7)""; # - SPHINX_ROOT ""Root directory for Sphinx: 'bin/sphinx-build' (or similar) should be in this dir.""; #; # For any ${AddOn} of: ambit, CheMPS2, dkh, ecpint, libefp, erd, gau2grid, gdma, Libint2, PCMSolver, pybind11, pylibefp,; # qcelemental, qcengine, simint, Libxc; # - CMAKE_PREFIX_PATH ""Set to list of r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:15061,variab,variables,15061,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"ng files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import print_function; """"""Module with utility classes and functions related; to data tables and text. """"""; #CUimport psi4; import sys; import re; import p4const; from .exceptions import *. [docs]class Table(object):; """"""Class defining a flexible Table object for storing data."""""". def __init__(self, rows=(),; row_label_width=10,; row_label_precision=4,; cols=(),; width=16, precision=10):; self.row_label_width = row_label_width; self.row_label_precision = row_label_precision; self.width = width; self.precision = precision; self.rows = rows. if isinstance(cols, str):; self.cols = (cols,); else:; self.cols = cols. self.labels = []; self.data = []. [docs] def format_label(self):; """"""Function to pad the width of Table object labels.""""""; #str = lambda x: (('%%%d.%df' % (self.row_label_width, self.row_label_precision)) % x); str = lambda x: (('%%%ds' % (self.row_label_width)) % x); return "" "".join(map(str, self.labels)). [docs] def format_values(self, values):; """"""Function to pad the width of Table object data cells.""""""; str = lambda x: (('%%%d.%df' % (self.width, self.precision)) % x); return "" "".join(map(str, values)). def __getitem__(self, value):; self.labels.append(value); return self. def __setitem__(self, name, va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/text.html:1380,flexible,flexible,1380,psi4manual/1.0.0/_modules/p4util/text.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/text.html,1,['flexible'],['flexible']
Modifiability,"ng libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_ch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:154090,plugin,plugins,154090,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['plugin'],['plugins']
Modifiability,"ng of the BrianQC module)"" OFF); # These options are relevant to pasture, expert only; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF); option(psi4_SKIP_ENABLE_Fortran ""Suppress enabling Fortran language even when Fortran addons enabled. Use when only linking pre-built, not compiling addon code."" OFF). # Append modules added to pasture as needed; if(ENABLE_ccsort OR ENABLE_transqt2); set(ENABLE_pasture ON); message(STATUS ""Enabling pasture plugins""); endif(). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recursively delete all the “.pyc” files. It; may just run. How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:23157,variab,variable,23157,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,1,['variab'],['variable']
Modifiability,"ng on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = constants.hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], constants.hartree2kcalmol * ERXN[db_rxn],; error, error * constants.cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:26046,variab,variable,26046,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,17,['variab'],['variable']
Modifiability,"ng on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < ab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:25987,variab,variable,25987,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['variab'],['variable']
Modifiability,"ng the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/interfacing-1.html:2345,config,configure,2345,psi4manual/1.4.0/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/interfacing-1.html,8,['config'],['configure']
Modifiability,"ng type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST (EFP); EFP — Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING (EFP); EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP); EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. EFP_POL_DAMPING (EFP); EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. Type: string; Possible Values: TT, OFF; Default: TT. EKT_EA (OCC); OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC); DFOCC — Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC); OCC — Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. ENERGY_LEVEL_SHIFT (DCFT); DCFT (Expert) — Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the DCFT energy. Type: double; Default: 0.0. ENSURE_BT_CONVERGENCE (OPTKING); OPTKING — Reduce step size as necessary to ensure back-transformation of internal coordinate step to cartesian coordinates. Type: boolean; Default: false. EOM_GUESS (CCEOM); CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, gues",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:116659,extend,extended,116659,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['extend'],['extended']
Modifiability,"ng with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to get a Psi4 logo file; How to use a local Add-On repository in the Psi4 build. Installing from Binary; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of PSI4; Useful Commands. Scratch Files¶; One very important part of user configuration at the end of the; installation process; is to tell PSI4 where to write its temporary; (“scratch”) files. Electronic structure packages like PSI4 can; create rather large temporary disk files. It is very important to; ensure that PSI4 is writing its temporary files to a disk drive; physically attached to the computer running the computation. If it; is not, it will significantly slow down the program and the network.; By default, PSI4 will write temporary files to /tmp, but this; directory is often not large enough for typical computations. Therefore,; you need to (a) make sure there is a sufficiently large directory on a; locally attached disk drive (100GB–1TB or more, depending on the size of; the molecules to be studied) and (b) tell PSI4 the path to this; directory. Scratch file location can be specified through the; PSI_SCRATCH environment variable or through the ~/.psi4rc file; (see section ~/.psi4rc File). Most of the time, PSI_SCRATCH; is preferred, and it overrides any existing ~/.psi4rc setting. Y",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:3755,config,configuration,3755,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,4,['config'],['configuration']
Modifiability,"ng work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubuntu gfortran; conda gfortran_linux-64 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gcc conda package. This provides gcc, g++, and; gfortran compilers for Mac. The two former are 4.8.5 and so are too; old to compile PSI4, but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular systems.; Downstream Dependencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; MKL_ROOT — Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location.; MATH_ROOT — Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so).; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be semicolon-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL. Examples. Build with any LAPACK in standard location. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL not also present).; If NumPy not using native Accelerate LAPACK, then directing Psi4; to use it is Bad Idea!. >>> cmake. Build with native Accelerate LAPACK on Mac (MKL also present); If NumPy not using native Accele",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:35442,variab,variable,35442,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['variab'],['variable']
Modifiability,"ng. is_done(self: psi4.core.AOShellCombinationsIterator) → bool¶; docstring. next(self: psi4.core.AOShellCombinationsIterator) → None¶; docstring. p¶; Returns current P index. q¶; Returns current Q index. r¶; Returns current R index. s¶; Returns current S index. class psi4.core.AngularMomentumInt¶; Bases: psi4.core.OneBodyAOInt; Computes angular momentum integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.BSVec¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. class psi4.core.BasisExtents¶; Bases: pybind11_builtins.pybind11_object; docstring. basis(self: psi4.core.BasisExtents) → psi4.core.BasisSet¶; docstring. delta(self: psi4.core.BasisExtents) → float¶; docstring. maxR(self: psi4.core.BasisExtents) → float¶; docstring. set_delta(self: psi4.core.BasisExtents, arg0: float) → None¶; docstring.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:1357,extend,extend,1357,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,4,['extend'],['extend']
Modifiability,"ng. psi4.GaussianShell.original_coef()¶; Python Library Documentation: method original_coef; original_coef(...) unbound psi4.GaussianShell method. original_coef( (GaussianShell)arg1, (int)arg2) -> float :. docstring; C++ signature :. d original_coef(N3psi13GaussianShellE {lvalue},i). GeometryUnits¶. psi4.GeometryUnits.Angstrom()¶; Python Library Documentation: GeometryUnits in module psi4 object; class GeometryUnits(Boost.Python.enum). docstring. Method resolution order:. GeometryUnits. Boost.Python.enum. __builtin__.int. __builtin__.object. Data and other attributes defined here:. Angstrom = psi4.GeometryUnits.Angstrom. Bohr = psi4.GeometryUnits.Bohr. names = {‘Angstrom’: psi4.GeometryUnits.Angstrom, ‘Bohr’: psi4.Geometr... values = {0: psi4.GeometryUnits.Angstrom, 1: psi4.GeometryUnits.Bohr}. ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() <==> long(x). __lshift__(...). x.__lshift__(y) <==> x<<y. __mod__(...). x.__mod__(y) <==> x%y. __mul__(...). x.__mul__(y) <==> x*y. __neg__(...). x.__neg__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:152666,inherit,inherited,152666,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ng:; molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/ccsd-pte,; pcmsolver/scf,; pcmsolver/opt-fd,; pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/pcmsolver-1.html:4179,config,configure,4179,psi4manual/1.4.0/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/pcmsolver-1.html,9,['config'],['configure']
Modifiability,"nge, and induction; components of the total electronic interaction energy [Eh] for the; given SAPT level of theory that incorporates MP2 induction correction.; The sum of these four components yields the SAPT Level TOTAL ENERGY. SAPT2+DMP2 TOTAL ENERGY¶. SAPT2+(3)DMP2 TOTAL ENERGY¶. SAPT2+3DMP2 TOTAL ENERGY¶. SAPT2+(CCD)DMP2 TOTAL ENERGY¶. SAPT2+(3)(CCD)DMP2 TOTAL ENERGY¶. SAPT2+3(CCD)DMP2 TOTAL ENERGY¶; The total electronic interaction energy [Eh] for the labeled SAPT level; of theory that incorporates MP2 induction correction. SCF ITERATIONS¶. ADC ITERATIONS¶. CCSD ITERATIONS¶. OPTIMIZATION ITERATIONS¶; Number of iterations [] in the named iterative method or optimization procedure. SCF DIPOLE¶; Dipole array [e a0] for the SCF stage, (3,). SCF QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the SCF stage, (3, 3). SCF TOTAL ENERGY¶; The total electronic energy [Eh] of the SCF stage of the calculation.; The method CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding method TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is \(E_{\text{SCF}}\). \begin{align*}; E_{\text{SCF}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} \\; & = E_{\text{FCTL/HF}} + E_{\text{-D}}; \end{align*}Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. SCF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the SCF stage of the calculation, ({nat}, 3). SCF DIPOLE GRADIENT¶; The derivative of the SCF stage dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). SCF TOTAL HESSIAN¶; The total electronic second derivative [Eh/a0/a0] for the SCF stage, (3 * {nat}, 3 * {nat}). SCF STABILITY EIGENVALUES¶; Array of eigenvalues fro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:50098,variab,variables,50098,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['variab'],['variables']
Modifiability,"ngle point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OPEN-SHELL¶. Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) inclusion of the so called “pseudo-triples” beyond the first-order interacting space is also possible. The two-determinant CC method for open-shell singlet states can be activated by TD-CC (=8). Type: string; Possible Values: SPIN-ORBITAL, SR-CC, PSA-CC_FULL, SR-CC_FULL, TD-CC; Default: SPIN-ORBITAL. CFOUR_OPT_MAXCYC¶. Identical to CFOUR_GEO_MAXCYC. Type: integer; Default: 50. CFOUR_ORBITALS¶. Specifies the type of molecular orbitals used in post-HF calculations. STANDARD (=0) requests usage of the orbitals (from a corresponding HF-SCF calculation) without any modification. These are in the case of RHF/UHF the usual canonical HF orbitals and in the case of ROHF calcu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:42645,adapt,adapted,42645,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,24,['adapt'],['adapted']
Modifiability,"nherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ROHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | ROHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | moFa(...); | moFa( (ROHF)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE moFa(N3psi3scf4ROHFE {lvalue}); | ; | moFb(...); | moFb( (ROHF)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE moFb(N3psi3scf4ROHFE {lvalue}); | ; | moFeff(...); | moFeff( (ROHF)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE moFeff(N3psi3scf4ROHFE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from HF:; | ; | occupation_a(...); | occupation_a( (HF)arg1) -> Vector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6VectorEEE occupation_a(N3psi3scf2HFE {lvalue}); | ; | occupation_b(...); | occupation_b( (HF)arg1) -> Vector :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6VectorEEE occupation_b(N3psi3scf2HFE {lvalue}); | ; | semicanonicalize(...); | semicanonicalize( (HF)arg1) -> None :; | docstring; | ; | C++ signature :; | void semicanonicalize(N3psi3scf2HFE {lvalue}); | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE Ca(N3psi12",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:606446,inherit,inherited,606446,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"nic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction’s molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_lagrangian(self, arg0); Sets the orbital Lagr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:5944,variab,variables,5944,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,4,['variab'],['variables']
Modifiability,"nion[None, str, BasisSet]) – Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from BASIS.; quiet (bool) – When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key from self if present. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:13299,variab,variable,13299,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"nion[None, str, BasisSet]) – Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from BASIS.; quiet (bool) – When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key from self if present.; :rtype: None. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:13435,variab,variable,13435,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"nion[None, str, BasisSet]) – Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from BASIS.; quiet (bool) – When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key; from self if present. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:13349,variab,variable,13349,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,4,['variab'],['variable']
Modifiability,"nion[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:24435,variab,variables,24435,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,14,['variab'],['variables']
Modifiability,"nitial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str]) → None¶; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]¶; Exports coordinate info into NumPy arrays. Parameters. dummy (bool) – Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool) – Whether or not to treat ghost atoms as dummies. Return type; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html:34984,variab,variable,34984,psi4manual/1.4.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html,12,['variab'],"['variable', 'variables']"
Modifiability,"nitial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str]) → None¶; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]¶; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool) – Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool) – Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:36908,variab,variable,36908,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,12,['variab'],"['variable', 'variables']"
Modifiability,"nitial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str]) → None¶; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]¶; Exports coordinate info into NumPy arrays. Parameters:; dummy (bool, optional) – Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool, optional) – Whether or not to treat ghost atoms as dummies. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:34215,variab,variable,34215,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,6,['variab'],"['variable', 'variables']"
Modifiability,"nitial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: dict[str, str]) → None¶; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]¶; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool) – Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool) – Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:37186,variab,variable,37186,psi4manual/master/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html,4,['variab'],"['variable', 'variables']"
Modifiability,"nition by string.; | ; | C++ signature :; | void update_geometry(N3psi8MoleculeE {lvalue}); | ; | x(...); | x( (Molecule)arg1, (int)arg2) -> float :; | x position of atom; | ; | C++ signature :; | d x(N3psi8MoleculeE {lvalue},i); | ; | y(...); | y( (Molecule)arg1, (int)arg2) -> float :; | y position of atom; | ; | C++ signature :; | d y(N3psi8MoleculeE {lvalue},i); | ; | z(...); | z( (Molecule)arg1, (int)arg2) -> float :; | z position of atom; | ; | C++ signature :; | d z(N3psi8MoleculeE {lvalue},i); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | create_molecule_from_string(...); | create_molecule_from_string( (str)arg1) -> Molecule :; | Returns a new Molecule with member data from the geometry string arg1 in psi4 format; | ; | C++ signature :; | N5boost10shared_ptrIN3psi8MoleculeEEE create_molecule_from_string(Ss); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | units; | Units (Angstrom or Bohr) used to define the geometry; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | MultipoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:559632,inherit,inherited,559632,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"nits_to_au(self: psi4.core.Molecule, arg0: float) → None; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None; Sets mass of atom (0-indexed) to mass. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str; Returns the symmetry specified in the input. to_arrays(); Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True); Serializes ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:54772,variab,variable,54772,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,2,['variab'],"['variable', 'variables']"
Modifiability,"nnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Localizer:; | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | C++ signature :; | void localize(N3psi9LocalizerE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods inherited from Localizer:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi9LocalizerEEE build(Ss,N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi6MatrixEEE); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Localizer:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CIVector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CIVector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | axpy(...); | axpy( (CIVector)arg1, (float)arg2, (CIVector)arg3, (int)arg4, (int)arg5) -> None :; | docstring; | ; | C++ si",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:384050,inherit,inherited,384050,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['inherit'],['inherited']
Modifiability,"nnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Localizer:; | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | C++ signature :; | void localize(N3psi9LocalizerE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods inherited from Localizer:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi9LocalizerEEE build(Ss,N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi6MatrixEEE); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Localizer:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:576798,inherit,inherited,576798,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['inherit'],['inherited']
Modifiability,"nnamed Boost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimension :; | docstring; | ; | evals(...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> object :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)arg1) -> Matrix :; | docstring; | ; | ----------------------------------------------------------------------; | Data and othe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:57486,inherit,inherited,57486,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. opdm(self, arg0, arg1, arg2, arg3); docstring. pitzer_to_ci_order_onel(self, arg0, arg1); docstring. pitzer_to_ci_order_twoel(self, arg0, arg1); docstring. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. print_vector(self, arg0, arg1); docstring. reference_wavefunction(self); Returns the reference wavefunction. rotate_mcscf_integrals(self, arg0, arg1, arg2); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. semicanonical_orbs(self); docstring. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_ci_guess(self, arg0); docstring. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_orbitals(self, arg0, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:7203,variab,variables,7203,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['variab'],['variables']
Modifiability,"not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:84368,variab,variable,84368,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"not the last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); #PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['property'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-Plesset perturbation theory (MP2) |; +-------------------------+---------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:35343,variab,variables,35343,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['variab'],['variables']
Modifiability,"not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function. """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """"""; import psi4; import pubchem; import re; import os; import sys; from psiexceptions import *. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; raise ValidationError('Unsupported syntax:\n\n%s\n\n' % (line)). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if(dollar):; # This is a python variable, make sure that it starts with a letter; if(re.match(r'^[A-Za-z][\w]*', val)):; return val; else:; print(""Invalid Python variable: %s"" % val); sys.exit(1); elif(re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val)):; # This must be a number, don't wrap it in quotes; return val; elif(re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val)):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % val. [docs]def quotify(string):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; wordre = re.compile(r'(([$]?)([-+()*.\w\""\']+))'); string = wordre.sub(process_word_quotes, string); return string. [docs]def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; value = quotify(value.strip()); temp = """". global_options = False; module = module.uppe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/inputparser.html:1856,variab,variable,1856,psi4manual/4.0b5/_modules/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/inputparser.html,2,['variab'],['variable']
Modifiability,"nput file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/inputparser.html:2148,variab,variable,2148,psi4manual/1.7.x/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/inputparser.html,2,['variab'],['variable']
Modifiability,"nput file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". __all__ = [""process_input""]. import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+:()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:2150,variab,variable,2150,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,2,['variab'],['variable']
Modifiability,"nput for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233564,plugin,plugin,233564,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,4,['plugin'],['plugin']
Modifiability,"nputfile)[source]¶; Function to find array inputs that are spread across multiple; lines and squash them into a single line. process_option(spaces, module, key, value, line)[source]¶; Function to process a line with set or in a set block; into global/local domain and keyword/value. process_pcm_command(matchobj)[source]¶; Function to process match of pcm name? { ... }. process_print_command(matchobj)[source]¶; Function to process match of print and transform; it to psi4.print_out(). process_pubchem_command(matchobj)[source]¶; Function to process match of pubchem in molecule block. process_set_command(matchobj)[source]¶; Function to process match of all individual set (module_list); key {[value_list] or $value or value}. process_set_commands(matchobj)[source]¶; Function to process match of set name? { ... }. process_word_quotes(matchobj)[source]¶; Function to determine if argument needs wrapping in quotes as string. quotify(string)[source]¶; Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. interactive¶. run()[source]¶. pubchem¶. class PubChemObj(cid, mf, iupac)[source]¶. getCartesian()[source]¶; Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. getMoleculeString()[source]¶; Function to obtain a molecule string through; getCartesian() or fail. getSDF()[source]¶; Function to return the SDF (structure-data file) of the PubChem object. getXYZFile()[source]¶; Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. name()[source]¶; Function to return the IUPAC name of the PubChem object. getPubChemResults(name)[source]¶; Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. psiexceptions¶; Module with non-generic exceptions classes. exception PsiException[source]¶; Error class for Psi. exception ValidationError(msg)[source]¶; Error called for problems with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:2912,variab,variables,2912,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['variab'],['variables']
Modifiability,"ns a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whether to write the Psi4 header to the ASCII output file. (Only applicable i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/extras.html:7371,extend,extend,7371,psi4manual/1.8.x/_modules/psi4/extras.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/extras.html,2,['extend'],['extend']
Modifiability,"ns a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]def set_output_file(ofile: str, append: bool = False, *, loglevel: int = 20, execute: bool = True) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path. Returns; -------; ~pathlib.Path; ``Path(ofile)``. Notes; -----; This :py:func:`psi4.set_output_file` command calls :py:func:`psi4.core.set_output_file` and should be used ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/extras.html:6851,extend,extend,6851,psi4manual/1.7.x/_modules/psi4/extras.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/extras.html,2,['extend'],['extend']
Modifiability,"ns are in [cbcy](https://github.com/psi4/psi4meta/blob/master/conda-recipes/conda_build_config.yaml) and [poodle](https://github.com/psi4/psi4meta/blob/master/psinet-nightly/kitandkapoodle.py); A couple weeks before the first “rc” is planned, start going through L/LT in poodle, checking with upstream to see if new versions have been released. If good changes present, rebuild the packages, changing the version numbers in the respective recipes; When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ltrtver with updated version numbers and/or build numbers (only if code changes); Build L/PSI4. If any trouble, edit psi4 code. Iterate until builds and passes. This stage is the only full ctest & pytest on Psi4+upstream; Build L/RT-MP. If any trouble, edit code in L/RT and rebuild those package(s). Iterate until builds and passes. This stage is the only full ctest & pytest of Psi4+downstream; Build L/DEV. If any trouble, edit psi4 build system, plugin system, or OpenMP setup. Iterate until builds and passes; Build L/DOCS. If any trouble, edit the docs or the tests. Iterate until builds and passes; Results of last should upload to psicode.org (docs) and codecov.io (coverage); Changes to targets’ “source” and “version” in individual recipes should be edited in psi4 external/*/*/CMakeLists.txt files; Once everything’s working on Linux, repeat on Mac; At this point, ready to fine-tune builds of “Psi4 stack”. Assemble postrelease changes¶. Collect PRs with “backport” label, and request other backport suggestions on upcoming RN issue; Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_release-1.html:3629,plugin,plugin,3629,psi4manual/1.4.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_release-1.html,7,['plugin'],['plugin']
Modifiability,"ns distance between two points represented by arg1 and arg2; | ; | C++ signature :; | d distance(N3psi7Vector3E {lvalue},N3psi7Vector3E); | ; | dot(...); | dot( (Vector3)arg1, (Vector3)arg2) -> float :; | Returns dot product of arg1 and arg2; | ; | C++ signature :; | d dot(N3psi7Vector3E {lvalue},N3psi7Vector3E); | ; | norm(...); | norm( (Vector3)arg1) -> float :; | Returns Euclidean norm of arg1; | ; | C++ signature :; | d norm(N3psi7Vector3E {lvalue}); | ; | normalize(...); | normalize( (Vector3)arg1) -> None :; | Returns vector of unit length and arg1 direction; | ; | C++ signature :; | void normalize(N3psi7Vector3E {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class View(Boost.Python.instance); | Method resolution order:; | View; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __call__(...); | __call__( (View)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE __call__(N3psi4ViewE {lvalue}); | ; | __init__(...); | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi6MatrixEEE,N3psi9DimensionE,N3psi9DimensionE); | ; | __init__( (object)arg1, (Matrix)arg2, (Dimension)arg3, (Dimension)arg4, (Dimension)arg5, (Dimension)arg6) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi6MatrixEEE,N3psi9Dimen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:646756,inherit,inherited,646756,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ns to the amplitude equations. We replace; the correlation energy, , with generalized shifts for the; doubles and singles equations, and :. (6); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method. cisd. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7); Methods whose shifts ( and ) do not; explicitly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) [or the resolution of the identity (RI)] and Cholesky; decomposition (CD) techniques are popular in quantum chemistry to avoid; the computation and storage of the 4-index electron repulsion integral; (ERI) tensor and even to reduce the computational scaling of some terms.; DF/CD-CCSD(T) computations are available in Psi4, with or without the; use of FNOs, through the FNOCC module. The implementation and accuracy of; the DF/CD-CCSD(T) method are described in Ref. [DePrince:2013:2687].; The DF-CCSD(T) procedure uses two auxiliary basis sets. The first set is; that used in the SCF procedure, defined by the DF_BASIS_SCF; keyword. If this keyword is not specified, an appropriate -JKFIT set is; automatically selected. This auxiliary set defines the ERI’s used to; build the Fock matrix used in the DF-CCSD(T) procedure. The second; auxiliary set is used to approximat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:8204,coupling,coupling,8204,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,2,['coupling'],['coupling']
Modifiability,"ns({""basis"": ""cc-pvdz"",; ""reference"": ""rhf""}); h2_energy = psi4.energy('scf'). h = psi4.geometry(""""""; H; """"""). psi4.set_options({""basis"": ""cc-pvdz"",; ""reference"": ""uhf""}); h_energy = psi4.energy('scf'). D_e = psi4.constants.hartree2kcalmol * (2*h_energy - h2_energy); print(""De = %f"" % D_e). The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available. PSIthonPsiAPIe_mp2 = variable('MP2 TOTAL ENERGY'); e_scs_mp2 = variable('SCS-MP2 TOTAL ENERGY'). e_mp2 = psi4.variable('MP2 TOTAL ENERGY'); e_scs_mp2 = psi4.variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:9143,variab,variable,9143,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,2,['variab'],['variable']
Modifiability,"ns. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS¶. The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC¶. The noise prefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES¶. The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. How to configure CheMPS2 for building Psi4¶; Role and Dependencies. Role — In PSI4, CheMPS2 is a library that provides additional; quantum chemical capabilities (DMRG).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) CheMPS2; Upstream Dependencies — CheMPS2 \(\Leftarrow\) BLAS/LAPACK, HDF5 \(\Leftarrow\) zlib. CMake Variables. ENABLE_CheMPS2 — CMake variable toggling whether Psi4 builds with CheMPS2; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For CheMPS2, set to an installation directory containing include/chemps2/DMRG.h; CheMPS2_DIR — CMake variable to specify where pre-built CheMPS2 can be found. Set to installation directory containing share/cmake/CheMPS2/CheMPS2Config.cmake; CMAKE_DISABLE_FIND_PACKAGE_CheMPS2 — CMake variable to force internal build of CheMPS2 instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_CheMPS2 — CMake variable to force detecting pre-built CheMPS2 and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_CheMPS2=ON. Build without CheMPS2. >>> cmake. Build bundled with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5. Link against pre-built. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root. >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir. Link against pre-built with specific HDF5. >>> cmake -DENABLE_CheMPS2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/chemps2-1.html:5754,variab,variable,5754,psi4manual/1.2.1/chemps2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/chemps2-1.html,26,['variab'],['variable']
Modifiability,"ns. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:17975,variab,variable,17975,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variable']
Modifiability,"ns. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is prov",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:16774,variab,variable,16774,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,3,['variab'],['variable']
Modifiability,"ns. nirrep(self: psi4.core.Wavefunction) → int; Number of irreps in the system. nmo(self: psi4.core.Wavefunction) → int; Number of molecule orbitals. nmopi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of molecular orbitals per irrep. no_occupations(self: psi4.core.Wavefunction) → List[List[Tuple[float, int, int]]]; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction) → int; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of symmetry orbitals per irrep. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]; Returns the dictionary of all double QC variables. set_array(key, val). set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None; Sets the requested external potential. set_frequencies(val). set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None; Sets the Wavefunction’s Hessian. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:25324,variab,variable,25324,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"ns.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25#! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis.; #! Also a bit more to force a second line. nucenergy = 8.801466202085710 #TEST; refenergy = -76.05098402733282 #TEST. molecule h2o {; symmetry c1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pVTZ; scf_type df; df_basis_scf cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy('rhf'). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, get_variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be very descriptive since it is inlined into the manual (unless !nosample is present in this comment) as a sample input.; The reference values are assigned to variables for later use. The compare_values function (along with several relatives in psi4/psi4/driver/p4util/util.py for comparing strings, matrices, etc.) checks that the computed values match these reference values to suitable precision. This function prints an error message and signals that the test failed to the make system, if the values don’t match. Any lines of the input associated with the validation process should be flagged with #TEST at the end of each line, so that they can be removed when copying from the tests to the samples directory.; Finally, add the directory name to the list of tests in psi4/tests/CMakeLists.txt.; In preparing the test case, turn energy, density, amplitude, and; geometry convergence criteria to very tight levels, and use these; results for reference energies, reference geometries, reference cube; files, etc.. Then, either remove or relax the convergence settings,; if these are not a vital part of the test. In choosing the number of; digits fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/add_tests-1.html:2262,variab,variables,2262,psi4manual/1.3.2/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/add_tests-1.html,2,['variab'],['variables']
Modifiability,"ns.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:4680,plugin,plugin,4680,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"ns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶; Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. Return type; bool. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. legacy_frequencies()¶. Deprecated since version 1.4. mintshelper(self: psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:16541,variab,variable,16541,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,7,['variab'],['variable']
Modifiability,ns; PointGroup; PotentialInt; prepare_options_for_module; PrimitiveType; print_global_options; print_options; print_out; print_out; print_variables; Prop; ProtoIntVector; ProtoVector; psi_top_srcdir; psimrcc; psio_entry; PsiReturnType; QuadrupoleInt; reopen_outfile; revoke_global_option_changed; revoke_local_option_changed; RHF; RKSFunctions; ROHF; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; AtomicComputer; banner; basis_helper; cbs; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; libint2_configuration; libint2_print_out; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicates; energie,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1737303,variab,variables,1737303,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['variab'],['variables']
Modifiability,"ns; Section author: Lori A. Burns. psi4.driver.wrapper_database.database(name, db_name[, func, mode, cp, rlxd, symm, zpe, benchmark, tabulate, subset])[source]¶; Function to access the molecule objects and reference energies of; popular chemical databases. Aliases; db(). Returns; (float) Mean absolute deviation of the database in kcal/mol. PSI variables. db_name DATABASE MEAN SIGNED DEVIATION; db_name DATABASE MEAN ABSOLUTE DEVIATION; db_name DATABASE ROOT-MEAN-SQUARE DEVIATION; Python dictionaries of results accessible as DB_RGT and DB_RXN. Note; It is very easy to make a database from a collection of xyz files; using the script psi4/psi4/share/psi4/scripts/ixyz2database.py.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters. name (str) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). db_name (str) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – \(\Rightarrow\) energy \(\Leftarrow\) || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keywo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:1272,variab,variable,1272,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,5,['variab'],['variable']
Modifiability,"ns=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); # component qcvars can be retired at v1.5; for xyz in 'XYZ':; obj.set_variable('CURRENT DIPOLE ' + xyz, obj.variable('SCF DIPOLE ' + xyz)); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf_wfn.to_file(filename); extras.register_numpy_file(filename) # reta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:49327,variab,variable,49327,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"nstallation; Using dd-based continum solvation models; Solvent model and solvent cavity definition; Numerical integration and discretisation parameters; Iterative solver parameters; Further keywords for ddx; How to configure ddx for building Psi4. Interface to DFTD3 by S. Grimme; Empirical Dispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/interfacing.html:2420,config,configure,2420,psi4manual/master/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/master/interfacing.html,1,['config'],['configure']
Modifiability,"nstalled testing) http://doc.pytest.org/en/latest/. PSI4 Documentation (available pre-built at http://www.psicode.org/psi4manual/master/index.html); Sphinx (1.4+) http://sphinx-doc.org; Perl (for some auto-documentation scripts) http://perl.org; nbsphinx (for converting Jupyter notebooks) http://nbsphinx.readthedocs.io/en/jupyter-theme/. CheMPS2 — [what is this?] [min version]; HDF5 https://support.hdfgroup.org/HDF5/; zlib http://www.zlib.net/. libefp — [what is this?] [min version]; erd — [what is this?] [min version]; Fortran Compiler. dkh — [what is this?] [min version]; Fortran Compiler. gdma — [what is this?] [min version]; Fortran Compiler. PCMSolver — [what is this?]; Fortran Compiler; zlib http://www.zlib.net/. simint — [what is this?] [min version]. Additionally, there are runtime-only capabilities:. cfour — [what is this?]; dftd3 — [what is this?]; gcp — [what is this?]; mrcc — [what is this?]. How to configure code to use high angular momentum basis sets¶; The Libint integral code handles arbitrary order; angular momentum, but compiling that is prohibitive. The default of 5; is generally good. 6 has met all of a research group’s needs for; years. 4 is handy for quickly testing other parts of the build. Build with Higher Angular Momentum; >>> cmake -DMAX_AM_ERI=6. Relevant CMake Options:; MAX_AM_ERI=N # The maximum angular momentum level (1=p, 2=d, 3=f,; # etc.) for the libint integrals and derivative; # integrals. A value of N implies a maximum first; # derivative of N-1, and maximum second derivative of; # N-2, so for an atom such as Neon, the default 5 gets; # you conventional cc-pV5Z for energies, cc-pVQZ for; # gradients, cc-pVTZ for frequencies and density-fitted; # cc-pVQZ for energies, cc-pVTZ for gradients, cc-pVDZ; # for frequencies. [default: 5]. Note that since PSI4 1.1, it is possible to build Libint; independently (or install just the libint conda package), then have; any/all PSI4 builds detect that installation at compile-time. How to configu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:5890,config,configure,5890,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['config'],['configure']
Modifiability,"nstance); | docstring; | ; | Method resolution order:; | vector_of_doubles; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (vector_of_doubles)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (vector_of_doubles)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (vector_of_doubles)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (vector_of_doubles)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (vector_of_doubles)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (vector_of_doubles)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> None :; docstring; ; DDOT(...); DDOT( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, (Vector)arg5, (int)arg6) -> float :; docstring; ; DGBMV(...); DGBMV( (int)arg1, (str)arg2, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:147666,extend,extend,147666,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,4,"['extend', 'inherit']","['extend', 'inherited']"
Modifiability,"nstead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def _core_wavefunction_set_frequencies(cls, val):; """"",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:37392,variab,variables,37392,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variables']
Modifiability,"nstead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(self):; """"""Returns the results of a frequency analysis. Parameters; ----------; self; Wavefunction instance. Returns; -------; ~typing.Optional[~typing.Dict[str, ~numpy.ndarray]]; A dictionary of vibrational information. See :py:func:`psi4.driver.qcdb.vib.harmonic_analysis`. """"""; if not hasattr(self, 'frequency_analysis'):; return None. vibinfo = self.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). core.Wavefunction.frequencies = _core_wavefunction_frequencies. def _core_doublet(A, B, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:46200,variab,variables,46200,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"nstead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstrin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:22120,variab,variable,22120,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,16,['variab'],['variable']
Modifiability,"nstructed BasisSet basis. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(save_fock, ...); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested ext",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:3683,variab,variable,3683,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"nstructed BasisSet basis. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(save_fock, ...); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self, arg0); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the request",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:3690,variab,variable,3690,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,8,['variab'],['variable']
Modifiability,"nst¶. qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute()[source]¶; Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. set_coordinates(x, y, z)[source]¶; Given the current set of coordinates, updates the values of this; atom’s coordinates and any variables that may depend on it. type()[source]¶; The type of CoordEntry specialization. class CoordEntry(entry_number, Z, charge, mass, symbol, label='')[source]¶; Class to. Z()[source]¶; The nuclear charge of the current atom (0 if ghosted). static a(a1, a2, a3)[source]¶; Computes the angle (in rad.) between three sets of coordinates. charge()[source]¶; The “atomic charge” of the current atom (for SAD purposes). static d(a1, a2, a3, a4)[source]¶; Computes the dihedral (in rad.) between four sets of coordinates. entry_number()[source]¶; The order in which this appears in the full atom list. everything()[source]¶. is_computed()[source]¶; Whether the current atom’s coordinates are up-to-date. is_equivalent_to(other)[source]¶; Whether this atom has the same mass and ghost status as atom other.; Unlike the libmints version, this does not compare basisset assignment. is_ghosted()[source]¶; Whether the current atom is ghosted or not. label()[s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:39364,variab,variables,39364,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['variab'],['variables']
Modifiability,"ns}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:5012,plugin,plugin,5012,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,8,"['PLUGIN', 'Plugin', 'plugin']","['PLUGIN', 'Plugin', 'plugin', 'pluginutil']"
Modifiability,"ns}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(join_path(template_path, source_file)); with open(join_path(template_path, source_file), 'r') as temp_file:; contents = temp_file.read(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; with open(join_path(name, target_file), 'w') as temp_file:; temp_file.write(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/pluginutil.html:5012,plugin,plugin,5012,psi4manual/1.5.0/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/pluginutil.html,8,"['PLUGIN', 'Plugin', 'plugin']","['PLUGIN', 'Plugin', 'plugin', 'pluginutil']"
Modifiability,"nt code. To remove a conda installation, conda remove erd. Source. If using PSI4 built from source and you want erd built from; from source also,; enable it as a feature with ENABLE_erd,; and let the build system fetch and build it and activate dependent code. How to configure erd for building Psi4¶; Role and Dependencies. Role — In PSI4, ERD is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) erd; Upstream Dependencies — erd \(\Leftarrow\) Fortran. CMake Variables. ENABLE_erd — CMake variable toggling whether PSI4 builds with erd; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For erd, set to an installation directory containing include/ERD/ERD_MANGLE.h; erd_DIR — CMake variable to specify where pre-built erd can be found. Set to installation directory containing share/cmake/erd/erdConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_erd — CMake variable to force internal build of erd instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_erd — CMake variable to force detecting pre-built erd and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_erd=ON. Build without erd. >>> cmake. Link against pre-built. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/erd/root. >>> cmake -DENABLE_erd=ON -Derd_DIR=/path/to/erd/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_erd=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/erd/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_erd=ON. table of contents. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to ERD by N. Flocke and V. Lotrich. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/erd.html:2553,variab,variable,2553,psi4manual/1.7.x/erd.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/erd.html,4,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"nt for the H2O molecule. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. dft2; DFT Functional Test. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. scf3; File retention, docc, socc, and bond distances specified explicitly. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft1; DFT Functional Test. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:30955,variab,variables,30955,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['variab'],['variables']
Modifiability,"nt level of the Wavefunction. get_scratch_filename(filenumber)¶; Return canonical path to scratch file filenumber based on molecule on self.; :rtype: str. Parameters:. self (Wavefunction) – Wavefunction instance.; filenumber (int) – Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key)¶; Whether scalar or array QCVariable key has been set on self.; :rtype: bool. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction) → psi4.core.MintsHelper¶; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. module(self: psi4.core.Wavefunction) → str¶; Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunction’s molecule. nalpha(self: psi4.core.Wavefunc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:18682,variab,variable,18682,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"nt(). get_legacy_gradient(); Returns the global gradient as a (nat, 3) Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(key). get_variables(). get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_array_variable(arg0); Is the Matrix QC variable (case-insensitive) set?. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_scalar_variable(arg0); Is the double QC variable (case-insensitive) set?. has_variable(key). initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:296195,variab,variable,296195,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"nt(save_fock, max_diis_vectors)¶; docstring. Return type; float. Parameters. save_fock (bool) – ; max_diis_vectors (int) – . compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF) → bool¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:19442,variab,variable,19442,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"nt(save_fock, max_diis_vectors)¶; docstring. Return type; float. Parameters. save_fock (bool) – ; max_diis_vectors (int) – . compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:19593,variab,variable,19593,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,8,['variab'],['variable']
Modifiability,"nt: str = ""full"", extras: List = None) -> int:; """"""Runs a test suite through pytest. Parameters; ----------; extent; {'smoke', 'quick', 'full', 'long'}; All choices are defined, but choices may be redundant in some projects. * _smoke_ will be minimal ""is-working?"" test(s).; * _quick_ will be as much coverage as can be got quickly, approx. 1/3 tests.; * _full_ will be the whole test suite, less some exceedingly long outliers.; * _long_ will be the whole test suite.; extras; Additional arguments to pass to `pytest`. Returns; -------; int; Return code from `pytest.main()`. 0 for pass, 1 for fail. """"""; try:; import pytest; except ImportError:; raise RuntimeError('Testing module `pytest` is not installed. Run `conda install pytest`'); abs_test_dir = os.path.sep.join([os.path.abspath(os.path.dirname(__file__)), ""tests""]). command = ['-rws', '-v', '--color', 'yes']; if extent.lower() == 'smoke':; command.extend(['-m', 'smoke']); elif extent.lower() == 'quick':; command.extend(['-m', 'quick or smoke']); elif extent.lower() == 'full':; command.extend(['-m', 'not long']); elif extent.lower() == 'long':; pass; if extras is not None:; command.extend(extras); command.extend(['--capture=sys', abs_test_dir]). retcode = pytest.main(command); return retcode. [docs]; def set_output_file(; ofile: str,; append: bool = False,; *,; loglevel: int = 20,; execute: bool = True,; print_header: Optional[bool] = None,; inherit_loglevel: bool = False) -> Path:; """"""Set the name for output and logging files. Parameters; ----------; ofile; Name of ASCII output file including extension. The logging file is set from this string with a ``.log`` extension.; append; Do append to the output and logging files rather than (the default) truncating them?; loglevel; The criticality level at which to log. 30 for WARN (Python default), 20 for INFO, 10 for DEBUG; execute; Do set ``ofile`` via :py:func:`psi4.core.set_output_file` and add the logger, rather than just returning ``ofile`` path.; print_header; Whethe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/extras.html:7348,extend,extend,7348,psi4manual/1.9.x/_modules/psi4/extras.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/extras.html,4,['extend'],['extend']
Modifiability,ntType; Functional; GaussianShell; GaussianType; GeometryUnits; get_active_molecule; get_array_variable; get_array_variables; get_datadir; get_global_option; get_global_option_list; get_local_option; get_memory; get_num_threads; get_option; get_options; get_output_file; get_variable; get_variables; get_writer_file_prefix; git_version; has_array_variable; has_global_option_changed; has_local_option_changed; has_option_changed; has_scalar_variable; has_variable; HF; IDAMAX; initialize; IntegralFactory; IntegralTransform; IntVector; IO; IOManager; IrreducibleRepresentation; JK; KineticInt; LaplaceDenominator; LibXCFunctional; Localizer; Matrix; MatrixFactory; mcscf; MemDFJK; MintsHelper; MoldenWriter; MolecularGrid; Molecule; MOSpace; MOWriter; mrcc_generate_input; mrcc_load_densities; MultipoleInt; MultipoleSymmetry; NablaInt; NumIntHelper; occ; OEProp; OneBodyAOInt; OneBodySOInt; option_exists_in_module; Options; options_to_python; OrbitalSpace; outfile_name; OverlapInt; PetiteList; plugin; plugin_close; plugin_close_all; plugin_load; PMLocalizer; PointFunctions; PointGroup; PotentialInt; prepare_options_for_module; PrimitiveType; print_global_options; print_options; print_out; print_variables; Prop; ProtoIntVector; ProtoVector; psi_top_srcdir; psimrcc; psio_entry; PsiReturnType; QuadrupoleInt; reopen_outfile; revoke_global_option_changed; revoke_local_option_changed; RHF; RKSFunctions; ROHF; run_gdma; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyA,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:821727,plugin,plugin,821727,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['plugin'],['plugin']
Modifiability,"nt_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the numbe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html:2637,variab,variable,2637,psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,2,['variab'],['variable']
Modifiability,"nt_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self, arg0); Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:2637,variab,variable,2637,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,1,['variab'],['variable']
Modifiability,"nt_orbitals(self: psi4.core.HF) → None¶; docstring. print_preiterations(small=False)¶. push_back_external_potential(self: psi4.core.HF, V: psi4.core.Matrix) → None¶; Add an external potential to the private external_potentials list. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. reset_occupation(self: psi4.core.HF) → None¶; docstring. rotate_orbitals(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self: psi4.core.HF) → None¶; docstring. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. scf_type(self: psi4.core.HF) → str¶; Return the value of scf_type used in the SCF computation. semicanonicalize(self: psi4.core.HF) → None¶; Semicanonicalizes the orbitals for ROHF. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energies(self: psi4.core.HF, arg0: str, arg1: float) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:30232,variab,variables,30232,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,20,['variab'],['variables']
Modifiability,"nt_orbitals(self: psi4.core.HF) → None¶; docstring. print_preiterations(small=False)¶. push_back_external_potential(self: psi4.core.HF, V: psi4.core.Matrix) → None¶; Add an external potential to the private external_potentials list. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. reset_occupation(self: psi4.core.HF) → None¶; docstring. rotate_orbitals(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self: psi4.core.HF) → None¶; docstring. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonicalize(self: psi4.core.HF) → None¶; Semicanonicalizes the orbitals for ROHF. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energies(self: psi4.core.HF, arg0: str, arg1: float) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix]) → None¶; Add an external potential/perturbation to the private ext",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:28637,variab,variables,28637,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['variab'],['variables']
Modifiability,"nt_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(name, ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:134883,variab,variable,134883,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variable']
Modifiability,"nt_preiterations(self: psi4.core.HF) → None; docstring. push_back_external_potential(self: psi4.core.HF, V: psi4.core.Matrix) → None; Add an external potential to the private external_potentials list. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. reset_occ_; Do reset the occupation after the guess to the inital occupation. reset_occupation(self: psi4.core.HF) → None; docstring. rotate_orbitals(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None; docstring. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self: psi4.core.HF) → None; docstring. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonicalize(self: psi4.core.HF) → None; Semicanonicalizes the orbitals for ROHF. set_array(key, val)¶. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energies(self: psi4.core.HF, arg0: str, arg1: float) → None; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:22794,variab,variable,22794,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['variab'],['variable']
Modifiability,"nt_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, fragment_files=None, hint_types=None, geom_hints=None, geom_unsettled=None, variables=None, domain='qm', missing_enabled_return='error', np_out=True, speclabel=True, tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, copy=True, verbose=1)[source]¶; Compose a Molecule dict from unvalidated arrays and variables, returning dict.; See fields of Return molrec below. Required parameters (for QM XYZ); are geom and one of elem, elez, elbl (speclabel=True). Parameters. geom (Union[List[List[float]], numpy.ndarray]) – (nat, 3) or (3 * nat, ) ndarray or list o’lists of Cartesian coordinates.; fragment_separators (Union[List[int], numpy.ndarray]) – (nfr - 1, ) list of atom indices at which to split geom into fragments.; elbl (Union[List[str], numpy.ndarray]) – (nat, ) Label extending elem symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose (float) – Interatom distance (native geom units) nearer than which atoms not allowed.; nonphysical (bool) – Do allow masses outside an element’s natural range to pass validation?; speclabel (bool) – If True, interpret elbl as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., @13C_mine or; He4@4.01. If False, interpret elbl as only the user/tagging; extension to nucleus label, e.g. _mine or 4 in the previous examples.; missing_enabled_return (str) – {‘minimal’, ‘none’, ‘error’}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out (bool) – When True, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use False to get a json-able version. Returns. molrec (dict) – Molecule dictionary spec follows. Its principles are; (1) contents are fully validated and defaulted -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:5929,extend,extending,5929,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,5,['extend'],['extending']
Modifiability,"ntegrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI scalar and array variables that have been set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. del_array_variable(arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key). detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. dmrg(arg0); Runs the DMRG code. doublet(A, B, transA, transB); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). get_array_variables(). get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_global_option(arg0)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:294037,variab,variable,294037,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"nteraction singles and doubles level of theory and root. CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{| \textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn} | }\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:9800,variab,variable,9800,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['variab'],['variable']
Modifiability,"nters to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:25969,variab,variables,25969,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variables']
Modifiability,"ntials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter, …); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. diis_manager(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction’s temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:3807,variab,variable,3807,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"ntical to the above, except that the frac_traverse() call is substituted; for something like:; # Argument is the functional.; # A useful optional argument is nmax, the total number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac.frac_nuke('wb97', molecule=h2o, nmax = 2). Dispersion Corrections¶; DFT-D dispersion corrections are discussed here.; HF-3c and PBEh-3c dispersion and BSSE corrections are discussed here.; DFT-NL dispersion corrections are discussed here. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; New DFT functionals can be created from scratch ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:27774,extend,extending,27774,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['extend'],['extending']
Modifiability,"ntimeError: value for ERI”; How to choose the compilation directory, {objdir}; How to save configuration settings for a future compilation; What is the directory layout of the installed or staged Psi4; How to run Psi4 as executable after compilation; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct”; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to use a local Add-On repository in the Psi4 build. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Installation and Runtime Configuration. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:53058,config,configure,53058,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,8,['config'],['configure']
Modifiability,"ntities on the atomic spheres and DDX_N_LEBEDEV determines the; number of points of the Lebedev angular grid used for integration on the spheres.; DDX_N_LEBEDEV should be chosen higher than DDX_SOLUTE_SPHERICAL_POINTS; and the defaults are usually good. DDX_SOLUTE_RADIAL_POINTS¶. Number of radial points used to compute the integrals for DDX calculations. Type: integer; Default: 35. DDX_SOLUTE_SPHERICAL_POINTS¶. Number of spherical points used to compute the solute electric potential/field integrals for DDX calculations (A Lebedev Points number). Type: integer; Default: 110. DDX_LMAX¶. Maximal degree of modelling spherical harmonics. Type: integer; Default: 9. DDX_N_LEBEDEV¶. Number of Lebedev grid points to use. (A Lebedev Points number). Type: integer; Default: 302. Iterative solver parameters¶; These parameters determine how the forward and adjoint linear systems; of the solvation model are solved. Usually these parameters do not need; to be changed. Occasionally DDX_SOLVATION_CONVERGENCE might need to be adapted,; e.g. if only a very crude or a highly accurate SCF solution is targeted. DDX_DIIS_MAX_VECS¶. Number of previous iterates to use in DIIS acceleration inside DDX. Type: integer; Default: 20. DDX_MAXITER¶. Maximal number of iterations used inside DDX. Type: integer; Default: 100. DDX_SOLVATION_CONVERGENCE¶. Tolerance to which DDX linear systems are solved. Type: conv double; Default: 1e-8. Further keywords for ddx¶; These parameter should rarely require changes.; In particular DDX_ETA, DDX_SHIFT and DDX_LOGFILE; are expert parameters and should not be altered beyond debugging. DDX_ETA¶. Regularization parameter for characteristic function of sphere overlap. Advanced parameter, which usually does not need to be modified. Valid values are within the range [0, 1]. Type: double; Default: 0.1. DDX_FMM_LOCAL_LMAX¶. Maximal degree of local spherical harmonics (near-field FMM interations). Type: integer; Default: 6. DDX_FMM_MULTIPOLE_LMAX¶. Maximal degree of multip",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/ddx.html:7436,adapt,adapted,7436,psi4manual/1.7.x/ddx.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/ddx.html,4,['adapt'],['adapted']
Modifiability,"ntract HCl single-point energy Testing the in line -decontract option for basis sets. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. soscf2; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dft1-alt; DFT Functional Test. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and tri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:4581,plugin,plugins,4581,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['plugin'],['plugins']
Modifiability,"ntributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 5; DF. optimization; 8; 6. frequency; 8; 6. SCF of post-HF; energy; 8; 6; PK [3]. optimization; 10; 7. frequency; 10; 7. CC property [2]; 10; 7. Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. [2]This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:20287,flexible,flexible,20287,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['flexible'],['flexible']
Modifiability,"nts 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction energy [H] for the requested SAPT; level of theory. SAPT0 TOTAL ENERGY¶. SSAPT0 TOTAL ENERGY¶. SAPT2 TOTAL ENERGY¶. SAPT2+ TOTAL ENERGY¶. SAPT2+(3) TOTAL ENERGY¶. SAPT2+3 TOTAL ENERGY¶; The total electronic interaction energy [H] for the labeled SAPT level; of theory. SAPT2+(CCD) TOTAL ENERGY¶. SAPT2+(3)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:17682,config,configuration,17682,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,4,['config'],['configuration']
Modifiability,"nt¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:1229,plugin,plugin-name,1229,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,4,['plugin'],['plugin-name']
Modifiability,"nt¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/plugins-1.html:1168,plugin,plugin-name,1168,psi4manual/1.3.2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/plugins-1.html,2,['plugin'],['plugin-name']
Modifiability,"nt¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/plugins-1.html:1188,plugin,plugin-name,1188,psi4manual/1.4.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/plugins-1.html,9,['plugin'],['plugin-name']
Modifiability,"nual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. fisapt0; 0th-order functional and/or intramolecular SAPT [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based disper",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/energy.html:5632,adapt,adapted,5632,psi4manual/1.1.0/energy.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/energy.html,26,['adapt'],['adapted']
Modifiability,"nual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. casscf; complete active space self consistent field (CASSCF) [manual]. rasscf; restricted active space self consistent field (RASSCF) [manual]. mcscf; multiconfigurational self consistent field (SCF) [manual]. psimrcc; Mukherjee multireference coupled cluster (Mk-MRCC) [manual]. dmrg-scf; density matrix renormalization group SCF [manual]. dmrg-caspt2; density matrix renormalization group CASPT2 [manual]. dmrg-ci; density matrix renormalization group CI [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. ssapt0; 0th-order SAPT with special exchange scaling [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus cha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/energy-1.html:5507,adapt,adapted,5507,psi4manual/1.0.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/energy-1.html,2,['adapt'],['adapted']
Modifiability,"number in thermodynamic computations. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. tdscf-7; TD-HF test variable access. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cepa-module; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:28062,variab,variable,28062,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['variab'],['variable']
Modifiability,"number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Wavefunctions gradient. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Wavefunctions Hessian. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction) → int; Number of frozen core electrons. nirrep(self: psi4.core.Wa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html:18442,variab,variable,18442,psi4manual/1.2.1/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"nvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction) → int¶; Number of frozen core electrons. nirrep(self: psi4.core.Wavefunction) → int¶; Number of irreps in the system. nmo(self: psi4.core.Wavefunction) → int¶; Number of molecule ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:141229,variab,variable,141229,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,3,['variab'],['variable']
Modifiability,"o 4.0 bohr each. Type: array; Default: No Default. Orbital Visualization with VMD¶; Included in PSI4 is functionality to automatically render specified surfaces, including molecular orbitals,; densities, and basis functions, using VMD. The vmd_cube.py script takes the .cube files generated; in a calculation and generates images aligned with user-input specifications. The script is located; in psi4/psi4/share/psi4/scripts/vmd_cube.py. Script Prerequisites¶. VMD must be installed, and it can be downloaded for free at (http://www.ks.uiuc.edu/Research/vmd/). Additionally,; the script needs to know where to find the VMD executable, and this is defined as VMDPATH. VMDPATH must be defined as; an environment variable.; To generate images with multiple surfaces, ImageMagick must also be installed. ImageMagick is a free program which; can be installed using homebrew/pip or from http://www.imagemagick.org/script/binary-releases.php .; With ImageMagick installed, an environment variable called MONTAGE needs to be created which points to the montage executable.; This executable can be found in the /bin/ sub-directory wherever ImageMagick was installed. Running the Script¶. Run a PSI4 calculation, generating .cube files as detailed in the above documentation. Add vmd_cube.py to your path. Call vmd_cube.py and pass the directory containing; the .cube files as an argument:; 1python vmd_cube.py /path/to/cube/files/. By default the script will search for cube files in the directory in which it is called.; In addition to individual image files for each orbital, vmd_cube will also generate an image containing all surfaces in an array; (very useful for hand-picking orbital spaces). As an example, take the cube files generated from the water calculation from the above input file.; Using vmd_cube the alpha molecular orbitals can be rendered and output in one image with:. python vmd_cube.py /path/to/cube/files/ –opacity=0.5 –rx=90 –ry=60; The desired image in this case is called “AlphaMOs.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cubeprop-1.html:6690,variab,variable,6690,psi4manual/1.2.1/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cubeprop-1.html,6,['variab'],['variable']
Modifiability,"o 4.0 bohr each. Type: array; Default: No Default. Orbital Visualization with VMD¶; Included in PSI4 is functionality to automatically render specified surfaces, including molecular orbitals,; densities, and basis functions, using VMD. The vmd_cube.py script takes the .cube files generated; in a calculation and generates images aligned with user-input specifications. The script is located; in psi4/psi4/share/psi4/scripts/vmd_cube.py. Script Prerequisites¶. VMD must be installed, and it can be downloaded for free at (http://www.ks.uiuc.edu/Research/vmd/). Additionally,; the script needs to know where to find the VMD executable, and this is defined as VMDPATH. VMDPATH must be defined as; an environment variable.; To generate images with multiple surfaces, ImageMagick must also be installed. ImageMagick is a free program which; can be installed using homebrew/pip or from http://www.imagemagick.org/script/binary-releases.php .; With ImageMagick installed, an environment variable called MONTAGE needs to be created which points to the montage executable.; This executable can be found in the /bin/ sub-directory wherever ImageMagick was installed. VMDPATH¶; Filesystem path to the VMD executable. MONTAGE¶; Filesystem path to the Montage executable of ImageMagick. Running the Script¶. Run a PSI4 calculation, generating .cube files as detailed in the above documentation.; Add vmd_cube.py to your path. Call vmd_cube.py and pass the directory containing; the .cube files as an argument:; python vmd_cube.py /path/to/cube/files/. By default the script will search for cube files in the directory in which it is called.; In addition to individual image files for each orbital, vmd_cube will also generate an image containing all surfaces in an array; (very useful for hand-picking orbital spaces). As an example, take the cube files generated from the water calculation from the above input file.; Using vmd_cube the alpha molecular orbitals can be rendered and output in one image with:; py",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cubeprop-1.html:7774,variab,variable,7774,psi4manual/1.4.0/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cubeprop-1.html,9,['variab'],['variable']
Modifiability,"o be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE¶. Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. How to configure CheMPS2 for building Psi4¶; Role and Dependencies. Role — In PSI4, CheMPS2 is a library that provides additional; quantum chemical capabilities (DMRG).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) CheMPS2; Upstream Dependencies — CheMPS2 \(\Leftarrow\) HDF5 \(\Leftarrow\) zlib. CMake Variables. ENABLE_CheMPS2 — CMake variable toggling whether Psi4 builds with CheMPS2; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For CheMPS2, set to an installation directory containing include/chemps2/DMRG.h; CheMPS2_DIR — CMake variable to specify where pre-built CheMPS2 can be found. Set to installation directory containing share/cmake/CheMPS2/CheMPS2Config.cmake; CMAKE_DISABLE_FIND_PACKAGE_CheMPS2 — CMake variable to force internal build of CheMPS2 instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_CheMPS2=ON. Build without CheMPS2. >>> cmake. Build bundled with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5. Link against pre-built. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root. >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir. Link against pre-built with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=""/path/to/chemps2/root;/path/to/hdf5/root"". Build bundled despite pre-built being detectable. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/chemps2/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_CheMPS2=ON. How to fix “plugin needed to handle lto object” when building CheMPS2¶; For building with GCC, errors involving unresolved symbols or a message; “plugin needed to handle lto object” may indicate a failure of the; interprocedural optimi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/chemps2-1.html:6043,variab,variable,6043,psi4manual/1.1.0/chemps2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/chemps2-1.html,2,['variab'],['variable']
Modifiability,"o can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/plugins.html:7903,plugin,plugin,7903,psi4manual/1.7.x/plugins.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/plugins.html,5,['plugin'],['plugin']
Modifiability,"o certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233431,plugin,plugin,233431,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,4,['plugin'],['plugin']
Modifiability,"o redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename with any; any “.in” or “.dat” extension replaced by “.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; 1; 2>>> psi4 --version; 0.4.262. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /scratch/user. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/scratch/user",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/external-1.html:18225,variab,variable,18225,psi4manual/1.2.1/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/external-1.html,4,['variab'],['variable']
Modifiability,"o redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename with any; any ”.in” or ”.dat” extension replaced by ”.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; 1; 2>>> psi4 --version; 0.4.262. Environment Variables¶; These environment variables will influence PSI4‘s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /scratch/user. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/scratch/user",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:18114,variab,variable,18114,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,2,['variab'],['variable']
Modifiability,"o root n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [E_h] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [E_h] at 0 [K]. ZPVE¶; Vibrational zero-point energy [E_h] at 0 [K]. 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS¶; The interatomic contributions to the dispersion correction [E_h].; Sums to the dispersion energy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; PSI Variables by Alpha. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/glossary_psivariables.html:63577,variab,variable,63577,psi4manual/1.8.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/glossary_psivariables.html,1,['variab'],['variable']
Modifiability,"o root n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [E_h] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [E_h] at 0 [K]. ZPVE¶; Vibrational zero-point energy [E_h] at 0 [K]. 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS¶; The interatomic contributions to the dispersion correction [E_h].; Sums to the dispersion energy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; PSI Variables by Alpha. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/glossary_psivariables.html:63577,variab,variable,63577,psi4manual/1.9.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/glossary_psivariables.html,1,['variab'],['variable']
Modifiability,"o the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. Warning; As of v1.2rc1, new (conda build 3; updated compilers); conda packages are available for Linux but not Mac).; Psi4conda installers are not ready for either platform. PSI4 is available as a pre-compiled binary for Mac and Linux (and; Windows, through the Ubuntu shell) and native Windows architectures; through Anaconda (formerly Continuum Analytics, the company that produces; Anaconda Python (a; full-fledged scientific python environment with package manager conda) and, more particularly, Miniconda (a lightweight Python; distribution with same package manager conda). Some nice features for us:. cross-platform; no root, administrator, or sudo access required; built with high-performance math libraries; lightweight software stack (<100 MB w/o PSI4; ~1 GB including PSI4, numpy, and MKL); updated nightly so new features accessible; standardizes python distribution so no need to find/install libpython packages; add-ons (plugins, extra features requiring Fortran compiler, etc.) can be made available as conda packages; develop PSI4 through plugins without a pre-existing development environment, see Creating a New Plugin Using a Conda Pre-compiled Binary. The PSI4 binary repository is at Anaconda (formerly Binstar).; For commands to get a default installation, go to How to install a Psi4 binary with the Psi4conda installer, command-line; or the psicode downloads page .; Users proficient with conda may prefer to consult What do the conda packages psi4 & psi4-dev and the installer psi4conda contain.; For more flexibility and a detailed explanation, go to; Detailed Installation of Miniconda and Detailed Installation of . How to install a Psi4 binary with the Psi4conda installer, download site¶; Download one of the nine installers (Linux/Mac/Windows; Py38/39/310).; bash it. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/conda.html:1414,plugin,plugins,1414,psi4manual/1.8.x/conda.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/conda.html,3,['plugin'],['plugins']
Modifiability,"o to find a good starting guess for the SEM method if GUESS_VECTOR is H0_BLOCK. Defaults to 1000. Note that the program may change the given size for Ms=0 cases (MS0 is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 1000. H0_GUESS_SIZE (DETCI)¶DETCI (Expert) — size of H0 block for initial guess. Type: integer; Default: 1000. H_BOND_CONNECT (OPTKING)¶OPTKING — For now, this is a general maximum distance for the definition of H-bonds. Type: double; Default: 4.3. H_GUESS_EVERY (OPTKING)¶OPTKING — Re-estimate the Hessian at every step, i.e., ignore the currently stored Hessian. Type: boolean; Default: false. H_UPDATE_DEN_TOL (OPTKING)¶OPTKING — Denominator check for hessian update. Type: conv double; Default: 1e-7. HD_AVG (DETCI)¶DETCI (Expert) — How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possible Values: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE; Default: EVANGELISTI. HD_OTF (DETCI)¶DETCI (Expert) — Do compute the diagonal elements of the Hamiltonian matr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:142192,coupling,coupling,142192,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['coupling'],['coupling']
Modifiability,"o you’ll have to turn off simint to get an; internal compile of AM>=8 Libint. The keyword is only a lower bound for; detection, so you can set it at 7, have both Libint and simint enabled,; and point CMake toward a pre-built Libint AM8 just fine. How to configure Libint for building Psi4. How to get high angular momentum integrals from conda¶; Libint2 conda packages are available from conda for Linux, Mac, and Windows.; The Linux package has base MAX_AM_ERI=7 and can run 7z energies; and gradients conventional, 6z energies and gradients density-fitted,; and qz Hessians both conventional and density fitted.; The Mac and Windows packages have base MAX_AM_ERI=5 and can run; 5z energies, qz gradients, and tz Hessians, both conventional and; density-fitted.; Details about angular momentum settings are available here; https://github.com/psi4/psi4/blob/master/external/upstream/libint2/CMakeLists.txt; . How to see what build configuration options are available¶; CMake doesn’t provide a summary for this (unless you want to try the CMake; GUI, which the developers have never looked at). However, the top half of; the main CMakeLists.txt is a passable summary:; LANGUAGES C CXX); set(psi4_URL ""http://www.psicode.org/""); set(psi4_EMAIL ""psi4aiqc+cmake@gmail.com""); set(psi4_LICENSE ""GNU Lesser General Public License, version 3 (LGPL-3.0)""); set(psi4_DESCRIPTION ""Open-Source Quantum Chemistry""). list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake). ################ Options: Overview and Not Otherwise Mentioned ###############. # <<< CMake build overview >>>; #; # >>> ls; # external/ COPYING psi4/ tests/ ...; # >>> cmake -S. -Bobjdir -DCMAKE_INSTALL_PREFIX=/path/to/install-psi4 ...; # ...; # -- Generating done; # -- Build files have been written to: /current/dir/objdir; # >>> cmake --build objdir --target install -j`getconf _NPROCESSORS_ONLN`. # <<< Required build dependencies that Psi4 can't build itself >>>; #; # - CMake (e.g., `conda install cmake`); # - C++ and C comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:12873,config,configuration,12873,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,4,['config'],['configuration']
Modifiability,"o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule UNUSED; self.pg = None; # Full point group UNUSED; s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:2324,variab,variables,2324,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['variab'],['variables']
Modifiability,"oElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ElectricFieldInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | ElectricFieldInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Ra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:442689,inherit,inherited,442689,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['inherit'],['inherited']
Modifiability,"oElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ErfERI(TwoElectronInt); | docstring; | ; | Method resolution order:; | ErfERI; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Ra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:449192,inherit,inherited,449192,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['inherit'],['inherited']
Modifiability,"oElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:450857,inherit,inherited,450857,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['inherit'],['inherited']
Modifiability,"oElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class F12DoubleCommutator(TwoElectronInt); | docstring; | ; | Method resolution order:; | F12DoubleCommutator; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:454727,inherit,inherited,454727,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['inherit'],['inherited']
Modifiability,"oElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class F12G12(TwoElectronInt); | docstring; | ; | Method resolution order:; | F12G12; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Ra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:456418,inherit,inherited,456418,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['inherit'],['inherited']
Modifiability,"oElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class F12Squared(TwoElectronInt); | docstring; | ; | Method resolution order:; | F12Squared; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:458083,inherit,inherited,458083,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['inherit'],['inherited']
Modifiability,"oElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FCHKWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | FCHKWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); |",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:459756,inherit,inherited,459756,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['inherit'],['inherited']
Modifiability,"oElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | C++ signature :; | d __getitem__(N3psi6VectorE {lvalue},i); | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | C++ signature :; | d __g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:637678,inherit,inherited,637678,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['inherit'],['inherited']
Modifiability,"o_scratch(‘/tmp/temp’, ‘psi’, ‘’, 32):; -cp /tmp/temp /scratch/parrish/psi.12345.32; copy_file_to_scratch(‘/tmp/temp’, ‘psi’, ‘’, 32, True):; -mv /tmp/temp /scratch/parrish/psi.12345.32. get_memory()[source]¶; Function to return the total memory allocation. get_num_threads()[source]¶; Function to return the number of threads to parallelize across. set_memory(bytes)[source]¶; Function to reset the total memory allocation. set_num_threads(nthread)[source]¶; Function to reset the number of threads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. run_mp2_5(name, **kwargs)[source]¶; Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. Psi variables:. MP2.5 TOTAL ENERGY; MP2.5 CORRELATION ENERGY. >>> energy('mp2.5'). run_plugin_omega(name, **kwargs)[source]¶; Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish’s omega plugin.; >>> energy('plugin_omega'). sherrillgroup_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). Table Of Contents. Python Driver; input; pubchem; psiexceptions; frac; molutil; proc; procutil; driver; physconst; wrappers; qmmm; functional; text; util; aliases. Previous topic; PRINT; Next topic; PsiMod: Linking C++ and Python; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:22944,variab,variables,22944,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['variab'],['variables']
Modifiability,"oad the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(val). Deprecated since version 1.2. set_legacy_gradient(grad); Assigns the global gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:8737,adapt,adapted,8737,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,5,['adapt'],['adapted']
Modifiability,"oad the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(key, value); Sets",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:8294,adapt,adapted,8294,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['adapt'],['adapted']
Modifiability,"obal_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:160319,variab,variable,160319,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variable']
Modifiability,"object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_parent_symmetry(arg0); Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. set_psi_file_prefix(arg0). set_variable(arg0, arg1); Sets a PSI variable, by name. tstart(); docstring. tstop(); docstring. version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DiskSOMCSCF; docstring. Dispersion; docstring. EFP; Class interfacing with libefp. ERI; Computes normal two electron reuplsion integrals. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ErfComplementERI; Computes ERF complement electron repulsion integrals. ErfERI; Computes ERF electron repulsion integrals. ExternalPotential; Stores external potential field, computes external potentia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:250580,adapt,adapted,250580,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['adapt'],['adapted']
Modifiability,"object. Opposite of; from_file(). Parameters:. wfn (Wavefunction) – Wavefunction or inherited class instance.; filename (Optional[str]) – An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:26034,variab,variable,26034,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['variab'],['variable']
Modifiability,"oc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:179322,variab,variables,179322,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"ocal_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(name.upper()); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; # retire components at v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE"", core.variable(""CC DIPOLE"")); # core.set_variable(""CC ROOT n DIPOLE"", core.variable(""CC DIPOLE"")) # P::e CCENERGY; if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")); # core.set_variable(""CC ROOT n QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")) # P::e CCENERGY. n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.rev",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:101104,variab,variable,101104,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"ocal_option_changed in module psi4; revoke_local_option_changed(...). revoke_local_option_changed( (str)arg1, (str)arg2) -> None :. Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; C++ signature :. void revoke_local_option_changed(Ss,Ss). psi4.run_gdma()¶; Python Library Documentation: built-in function run_gdma in module psi4; run_gdma(...). run_gdma( (Wavefunction)arg1, (str)arg2) -> float :. Runs the GDMA code.; C++ signature :. d run_gdma(N5boost10shared_ptrIN3psi12WavefunctionEEE,Ss). psi4.sapt()¶; Python Library Documentation: built-in function sapt in module psi4; sapt(...). sapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :. Runs the symmetry adapted perturbation theory code.; C++ signature :. d sapt(N5boost10shared_ptrIN3psi12WavefunctionEEE,N5boost10shared_ptrIN3psi12WavefunctionEEE,N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.scatter()¶; Python Library Documentation: built-in function scatter in module psi4; scatter(...). scatter( (Molecule)arg1, (float)arg2, (list)arg3, (list)arg4, (list)arg5) -> None :. New Scatter function.; C++ signature :. void scatter(N5boost10shared_ptrIN3psi8MoleculeEEE,d,N5boost6python4listE,N5boost6python4listE,N5boost6python4listE). psi4.scf()¶; Python Library Documentation: built-in function scf in module psi4; scf(...). scf( (Wavefunction)arg1, (object)arg2, (object)arg3) -> Wavefunction :. Runs the SCF code.; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE scf(N5boost10shared_ptrIN3psi12WavefunctionEEE,P7_object,P7_object). psi4.scfgrad()¶; Python Library Documentation: built-in function scfgrad in module psi4; scfgrad(...). scfgrad( (Wavefunction)arg1) -> Matrix :. Run scfgrad, w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:40237,adapt,adapted,40237,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['adapt'],['adapted']
Modifiability,"ocessed into method=”cbs” & CBSMetadata spec;; method=""cbs"", cbsmeta=CBSMetadata – passes through. Parameters:. method (str) – User first argument to driver function. A string hint of the method –; see cases above.; basis (str) – User basis hint.; driver (DriverEnum) – The calling driver function. Note for finite difference that this is; the target driver, not the means driver. Return type:; Tuple[str, str, Dict]. psi4.driver.task_planner.task_planner(driver, method, molecule, **kwargs)[source]¶; Plans a task graph of a complex computation. Canonical Task layering:; ManyBody - BSSE treatment, many-body expansion; FiniteDifference - derivatives through stencils; Composite - basis set extrapolation, focal-point methods; Atomic - analytic single-points. Parameters:. driver (DriverEnum) – The resulting type of computation: e/g/h. Note for finite difference; that this should be the target driver, not the means driver.; method (str) – A string representation of the method such as “HF” or “B3LYP”. Special; cases are: “cbs”.; molecule (Molecule) – A Psi4 base molecule to use.; kwargs – User keyword arguments, often used to configure task computers. Returns:; A simple (AtomicComputer) or layered (CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer) task object. Layered objects contain many and multiple types of computers in a graph. Return type:; Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]. table of contents. External API Objects; Molecule; IPIBroker; auto_fragments(); process_input(); ip_fitting(); frac_traverse(); frac_nuke(); set_output_file(); BaseComputer; BaseComputer.compute(); BaseComputer.plan(). TaskComputers; SubTaskComputers; expand_cbs_methods(); task_planner(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .  · ; 1.10a1.dev61;  · . PSI4. External API Objects. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external_apis.html:8592,config,configure,8592,psi4manual/master/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/master/external_apis.html,1,['config'],['configure']
Modifiability,"ocket; import subprocess. try:; from psi4.driver.p4util.exceptions import *; from psi4 import core; isP4regime = True; except ImportError:; from .exceptions import *; isP4regime = False; from .util import parse_dertype; from .molecule import Molecule. [docs]def run_gcp(self, func=None, dertype=None, verbose=False): # dashlvl=None, dashparam=None; """"""Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.core.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, str):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; # if dashlvl not in dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html:2148,extend,extended,2148,psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,1,['extend'],['extended']
Modifiability,"oconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:3130,config,configure,3130,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,2,['config'],"['configuration', 'configure']"
Modifiability,"ocumented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libefp-1.html:8662,config,configdir,8662,psi4manual/1.2.1/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libefp-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,od). epsilon_b() (psi4.core.Wavefunction method). epsilon_b_subset() (psi4.core.Wavefunction method). erd_coef() (psi4.core.GaussianShell method). erf_complement_eri() (psi4.core.IntegralFactory method). erf_eri() (psi4.core.IntegralFactory method). ERI (class in psi4.core). eri() (psi4.core.IntegralFactory method). ESP AT CENTER n. esp_at_nuclei() (psi4.core.Wavefunction method). ESPPropCalc (class in psi4.core). evals() (psi4.core.OrbitalSpace method). EX_ALLOW (DETCI). EX_LEVEL (DETCI). exch() (psi4.core.FISAPT method). EXCH_SCALE_ALPHA (SAPT). EXCITATION_RANGE (CCEOM). exists() (psi4.core.IO method). exp() (psi4.core.GaussianShell method). expand_cbs_methods() (in module psi4.driver.task_planner). expand_psivars() (in module psi4.driver.p4util). EXPLICIT_HAMILTONIAN (CPHF). exponent() (psi4.core.FittedSlaterCorrelationFactor method). EXT_FORCE_BEND (OPTKING). EXT_FORCE_CARTESIAN (OPTKING). EXT_FORCE_DIHEDRAL (OPTKING). EXT_FORCE_DISTANCE (OPTKING). EXT_FORCE_OOFP (OPTKING). extend() (psi4.core.BSVec method). EXTERN (SCF). external_pot() (psi4.core.Wavefunction method). EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS). ExternalPotential (class in psi4.core). extract_subsets() (psi4.core.Molecule method). extrapolate() (psi4.driver.p4util.DIIS method). extrapolation schemes. Exvals() (psi4.core.OEProp method). Eyvals() (psi4.core.OEProp method). Ezvals() (psi4.core.OEProp method). F. f12() (psi4.core.IntegralFactory method). f12_cgtg() (psi4.core.MintsHelper method). f12_double_commutator() (psi4.core.IntegralFactory method). f12_squared() (psi4.core.IntegralFactory method). f12g12() (psi4.core.IntegralFactory method). F_CUT (DLPNO). Fa() (psi4.core.Wavefunction method). Fa_subset() (psi4.core.Wavefunction method). factory() (psi4.core.MintsHelper method). FAIL_ON_MAXITER (SCF). Failure (psi4.core.PsiReturnType attribute). FAVG (MCSCF). FAVG_CCSD_T (PSIMRCC). FAVG_START (MCSCF). Fb() (psi4.core.Wavefunction method). Fb_subset() (psi4.core.Wavefunction method). fcharge() (psi,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:49710,extend,extend,49710,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,1,['extend'],['extend']
Modifiability,od. epsilon_b() psi4.core.Wavefunction method. epsilon_b_subset() psi4.core.Wavefunction method. ERD. erd_coef() psi4.core.GaussianShell method. erf_complement_eri() psi4.core.IntegralFactory method. erf_eri() psi4.core.IntegralFactory method. ERI class in psi4.core. eri() psi4.core.IntegralFactory method. ERISieve class in psi4.core. ESP AT CENTER n. esp_at_nuclei() psi4.core.Wavefunction method. ESPPropCalc class in psi4.core. evals() psi4.core.OrbitalSpace method. EX_ALLOW (DETCI). EX_LEVEL (DETCI). exch() psi4.core.FISAPT method. EXCH_SCALE_ALPHA (SAPT). EXCITATION_RANGE (CCEOM). exists() psi4.core.IO method. exp() psi4.core.GaussianShell method. expand_cbs_methods() in module psi4.driver.task_planner. expand_psivars() in module psi4.driver.p4util. EXPLICIT_HAMILTONIAN (CPHF). exponent() psi4.core.FittedSlaterCorrelationFactor method. EXT_FORCE_BEND (OPTKING). EXT_FORCE_CARTESIAN (OPTKING). EXT_FORCE_DIHEDRAL (OPTKING). EXT_FORCE_DISTANCE (OPTKING). EXT_FORCE_OOFP (OPTKING). extend() psi4.core.BSVec method. EXTERN (SCF). external_pot() psi4.core.Wavefunction method. EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS). ExternalPotential class in psi4.core. extract_subsets() psi4.core.Molecule method. extrapolate() psi4.driver.p4util.DIIS method. extrapolation schemes. Exvals() psi4.core.OEProp method. Eyvals() psi4.core.OEProp method. Ezvals() psi4.core.OEProp method. F. f12() psi4.core.IntegralFactory method. f12_cgtg() psi4.core.MintsHelper method. f12_double_commutator() psi4.core.IntegralFactory method. f12_squared() psi4.core.IntegralFactory method. f12g12() psi4.core.IntegralFactory method. F_CUT (DLPNO). Fa() psi4.core.Wavefunction method. Fa_subset() psi4.core.Wavefunction method. factory() psi4.core.MintsHelper method. FAIL_ON_MAXITER (SCF). Failure psi4.core.PsiReturnType attribute. FAVG (MCSCF). FAVG_CCSD_T (PSIMRCC). FAVG_START (MCSCF). Fb() psi4.core.Wavefunction method. Fb_subset() psi4.core.Wavefunction method. fcharge() psi4.core.Molecule method. FCHK. fchk() in,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:47999,extend,extend,47999,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['extend'],['extend']
Modifiability,"ode. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_scalar_variable(arg0); Is the double QC variable (case-insensitive) set?. has_variable(key). initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a strin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:297507,plugin,plugin,297507,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,4,['plugin'],['plugin']
Modifiability,"ods; if ""/"" in method:; kwargs[""ptype""] = driver; cbsmeta = cbs_text_parser(method, **kwargs). # Single call detected; if ""cbs_metadata"" not in cbsmeta:; method = cbsmeta[""method""]; basis = cbsmeta[""basis""]; else:; method = ""cbs""; else:; cbsmeta = {}. return method, basis, cbsmeta. [docs]def task_planner(driver: DriverEnum, method: str, molecule: core.Molecule, **kwargs) -> TaskComputers:; """"""Plans a task graph of a complex computation. Canonical Task layering:; - ManyBody - BSSE treatment, many-body expansion; - FiniteDifference - derivatives through stencils; - Composite - basis set extrapolation, focal-point methods; - Atomic - analytic single-points. Parameters; ----------; driver; The resulting type of computation: e/g/h. Note for finite difference; that this should be the target driver, not the means driver.; method; A string representation of the method such as ""HF"" or ""B3LYP"". Special; cases are: ""cbs"".; molecule; A Psi4 base molecule to use.; kwargs; User keyword arguments, often used to configure task computers. Returns; -------; Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]; A simple (:class:`~psi4.driver.AtomicComputer`) or layered (:class:`~psi4.driver.driver_cbs.CompositeComputer`, :class:`~psi4.driver.driver_findif.FiniteDifferenceComputer`, :class:`~psi4.driver.driver_nbody.ManyBodyComputer`) task object. Layered objects contain many and multiple types of computers in a graph. """""". # Only pull the changed options; keywords = p4util.prepare_options_for_set_options(). keywords[""function_kwargs""] = {}; if ""external_potentials"" in kwargs:; keywords[""function_kwargs""].update({""external_potentials"": kwargs.pop(""external_potentials"")}). # Need to add full path to pcm file; if ""PCM__PCMSOLVER_PARSED_FNAME"" in keywords.keys():; fname = keywords[""PCM__PCMSOLVER_PARSED_FNAME""]; keywords[""PCM__PCMSOLVER_PARSED_FNAME""] = os.path.join(os.getcwd(), fname). # Pull basis out of kwargs, override globals if user specified; basis = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html:3693,config,configure,3693,psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,2,['config'],['configure']
Modifiability,"odule calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:126073,variab,variable,126073,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,14,['variab'],['variable']
Modifiability,"odule keyword; 1; 2; 3set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in PSI4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to PSI4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the PSI4; output file and is available from input as get_gradient().; sandwich mode := molecule and cfour list within; Naturally, additional jobs can follow in the input file.; Depending on the nature of preceding or following jobs, it is prudent to; separate them with the following:; 1; 2; 3clean() # removes Psi4 scratch files; clean_variables() # empties the PSI variables list; cfour {} # empties. In this scheme, the contents of the cfour {...} block are tacked onto; the end of the ZMAT file that is otherwise written from psi style; format. It is by this route that, for example %excite* sections can at; present be specified.; The execution of xcfour can be modified by a few parameters. Setting; the option CFOUR_OMP_NUM_THREADS sets the environment variable; OMP_NUM_THREADS for only the duration of the Cfour computation.; That is, portions of an input file that run PSI4 modules are; unaffected. Additionally, there are a few arguments to the function; run_cfour() that control the Cfour scratch; directory. table of contents. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:33868,variab,variables,33868,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,2,['variab'],['variables']
Modifiability,"odule keyword; 1; 2; 3set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in PSI4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to PSI4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the PSI4; output file and is available from input as get_gradient().; sandwich mode := molecule and cfour list within; Naturally, additional jobs can follow in the input file.; Depending on the nature of preceding or following jobs, it is prudent to; separate them with the following:; 1; 2; 3clean() # removes Psi4 scratch files; clean_variables() # empties the PSI variables list; cfour {} # empties. In this scheme, the contents of the cfour {...} block are tacked onto; the end of the ZMAT file that is otherwise written from psi style; format. It is by this route that, for example %excite* sections can at; present be specified.; The execution of xcfour can be modified by a few parameters. Setting; the option CFOUR_OMP_NUM_THREADS sets the environment variable; OMP_NUM_THREADS for only the duration of the Cfour computation.; That is, portions of an input file that run PSI4 modules are; unaffected. Additionally, there are a few arguments to the function; run_cfour() that control the Cfour scratch; directory. table of contents. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:33870,variab,variables,33870,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,4,['variab'],['variables']
Modifiability,"odule or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(key, value); Sets value to Python keyword key scoped only to a single module. set_memory_bytes(memory[, quiet]); Sets the memory available to Psi (in bytes); prefer psi4.driver.set_memory(). set_num_t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:8603,variab,variables,8603,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,2,['variab'],['variables']
Modifiability,"odule"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for dir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, dir)):; available_plugins.append(dir). [docs]def create_plugin(name, template):; """"""Generate plugin in directory with sanitized *name* based upon *template*."""""". name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/plugin.html:3274,plugin,plugins,3274,psi4manual/1.3.2/_modules/psi4/driver/plugin.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/plugin.html,2,['plugin'],['plugins']
Modifiability,"odule"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:3304,plugin,plugins,3304,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,6,['plugin'],['plugins']
Modifiability,"odules) options to the output file. print_options(() -> None); Prints the currently set options (to the output file) for the current module. print_out((arg0: str) -> None); Prints a string (using sprintf-like notation) to the output file. print_variables(() -> None); Prints all PSI variables that have been set internally. psi_top_srcdir(() -> str); Returns the location of the source code. psimrcc((arg0: psi::Wavefunction) -> float); Runs the multireference coupled cluster code. reopen_outfile(() -> None); Reopens the output file. revoke_global_option_changed((arg0: str) -> None); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed((arg0: str, ...); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma((arg0: psi::Wavefunction, ...); Runs the GDMA code. sapt((arg0: psi::Wavefunction, ...); Runs the symmetry adapted perturbation theory code. scatter((arg0: psi::Molecule, arg1: float, ...); New Scatter function. scfgrad((arg0: psi::Wavefunction) -> psi::Matrix); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess((arg0: psi::Wavefunction) -> psi::Matrix); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(...); Activates a previously defined (in the input) molecule, by name. set_array_variable((arg0: str, ...); Sets a PSI variable, by name. set_efp_torque((arg0: psi::Matrix) -> None); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_environment((arg0: str, arg1: str) -> str); Set enviromental vairable. set_frequencies((arg0: psi::Vector) -> None); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python((arg0: str, ...); Sets a global option to a Python object type. set_gradient((arg0: psi::Matrix) -> None",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:169932,adapt,adapted,169932,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['adapt'],['adapted']
Modifiability,"ody of function; # scf_type and wfn are freely changed, LOCALLY; # puream and df_basis_scf are freely changed, GLOBALLY; # PsiMod.scf() and PsiMod.mp2() are run. optstash.restore(). Note; Some options (BASIS, BASIS-like, and PUREAM) should always; be used globally (no module argument) with the OptionsState objects.; Similarly, within the body of the function, they should always be; queried and set globally. Setting-Up Calculations; The other types of options calls in python driver functions are (a); those to query what option value an upcoming c++ module is going to use; (determined by user and defaults) and (b) those to set options to govern; the course of a procedure. Finding out the intended option value for a; molecule should employ the get_option() command; (and has_option_changed() for has_changed), which; (newly) requires a module for scope. (Previously, this command used the; “active module”, which isn’t well-defined in the context of the python; driver, and consequently, the command gave variable results, depending; on whether a get_local/set_local command had been previously executed to; define the active module.); if (PsiMod.get_option('SCF', 'REFERENCE') == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'). Setting of options in python should use the; set_local_option() command. Using the local, rather; than global, scope will ensure that the newly set option will be used by; the module. Otherwise, if the python procedure set in the global scope; and the user had happened to set that option in local scope, the local; user option will take precedence against the programmer’s intent.; (Anyone who has heard advice to “query local, set global” should forget; that and follow the new scheme outlined here.). PsiMod Options Commands¶. PsiMod.get_global_option(keyword)¶; Given a string of keyword name, returns the value associated with the; keyword from the global options. Returns error if keyword is not; recognized. PsiMod.get_local_option(module, keyw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:10440,variab,variable,10440,psi4manual/4.0b3/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html,2,['variab'],['variable']
Modifiability,"of CI ROOT n DIPOLE. CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n.; Deprecated in favor of CI ROOT n QUADRUPOLE. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three components of the dipole [Debye] for the; configuration interaction singles and doubles level of theory and root.; Deprecated in favor of CISD DIPOLE. CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root.; Deprecated in favor of CISD QUADRUPOLE. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:13314,config,configuration,13314,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['config'],['configuration']
Modifiability,"of PSI module calls for; DCT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). core.set_global_option('DERTYPE', 'FIRST'); dct_wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true');; dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in core.OEProp.valid_methods or ""MULTIPOLE("" in prop:; oe.add(prop); oe.compute(); dct_wfn.oeprop = oe. for k, v in dct_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:53684,variab,variables,53684,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variables']
Modifiability,"of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:4362,config,configure,4362,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['config'],['configure']
Modifiability,"of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:245569,variab,variables,245569,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variables']
Modifiability,"of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets spe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:2676,variab,variable,2676,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,6,['variab'],['variable']
Modifiability,"of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). if name in [""mp3"", ""fno-mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). director = {; # Note ""nat_orbs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:170113,variab,variables,170113,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); level = kwargs.get('level', 0). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). core.set_local_option('FNOCC', 'DFCC', False); core.set_local_option('FNOCC', 'RUN_CEPA', False); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # which method?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'RUN_CCSD', True); elif name == 'ccsd(t)':; core.set_local_option('F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:155414,variab,variables,155414,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variables']
Modifiability,"of root in case of open shell system. This becomes ndoub (option #13) int fort.56. Type: integer; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: integer; Default: 0. Table Of Contents. MRCC; General; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS. Expert; MRCC_METHOD; MRCC_OMP_NUM_THREADS; MRCC_RESTART. Previous topic; OMEGA_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__mrcc-1.html:1890,variab,variable,1890,psi4manual/1.0.0/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__mrcc-1.html,2,['variab'],['variable']
Modifiability,"of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction) → int¶; Number of frozen core electrons. nirrep(self: ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:40284,variab,variable,40284,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,6,['variab'],['variable']
Modifiability,"of state-averaged CASSCF for the C2 molecule. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc52; CCSD Response for H2O2. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dft-reference; MP2 with a PBE0 reference computation. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. linK-1; RHF Linear Exchange Algorithm test for water. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:27130,variab,variables,27130,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['variab'],['variables']
Modifiability,"of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_tpdm(self: psi4.core.CIWavefunction, spin: str, symmetrize: bool) → psi4.core.Matrix¶; Returns the two-particle density matrix. Parameters. spin (str) – {“AA”, “AB”, “BB”, “SUM”}; Which spin-block of the TPDM should be returned? SUM sums over all possible spin cases.; symmetrize (bool) – Return a genuine TPDM element (false) or an “average” of TPDM elements that contract with the same integral (true)?; Only working for SUM. Returns; The two-particle density matrix with Pitzer-ordered orbitals, restricted to the active space.; If symmetrize is false, element pqrs is <ψ|a^p a^r a_s a_q|ψ>.; If symmetrize is true, element pqrs is obtained by summing over all “flips” of p/s, q/r, and multiplying by 0.5. Return type; Matrix. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. hamiltonian(self: psi4.core.CIWavefunction, arg0: int) → psi4.core.Matrix¶; docstring. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶; Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. Return type; bool. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. lagrangian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:20327,variab,variable,20327,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,5,['variab'],['variable']
Modifiability,of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC2 level of theory. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CC3 level of theory. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the CCSD(T) level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; T,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:2045,config,configuration,2045,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,2,['config'],['configuration']
Modifiability,"of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶. variables()¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html:16436,inherit,inherited,16436,psi4manual/1.3.2/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html,12,"['inherit', 'variab']","['inherited', 'variable', 'variables']"
Modifiability,"of theory. CFOUR ERROR CODE¶; The non-zero return value from a Cfour execution. CI DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory, (3,). CI QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled conf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:21947,config,configuration,21947,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['config'],['configuration']
Modifiability,"oftware Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import os; import re; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html:1985,variab,variable,1985,psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/inputparser.html,6,['variab'],['variable']
Modifiability,"oftware Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". import re; import os; import sys; import uuid. from psi4 import core; from psi4.driver.p4util.util import set_memory; from psi4.driver.p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/inputparser.html:1962,variab,variable,1962,psi4manual/1.3.2/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/inputparser.html,1,['variab'],['variable']
Modifiability,"ogram orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OMP_NUM_THREADS (CFOUR)¶CFOUR (Expert) — Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect CFOUR. Type: integer; Default: 1. CFOUR_OPEN-SHELL (CFOUR)¶CFOUR — Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) inclusion of the so called “pseudo-triples” beyond the first-order interacting space is also possible. The two",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:61327,variab,variable,61327,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['variab'],['variable']
Modifiability,"ogram orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (whitespace-tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OMP_NUM_THREADS (CFOUR); CFOUR (Expert) — Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect CFOUR. Type: integer; Default: 1. CFOUR_OPEN-SHELL (CFOUR); CFOUR — Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) inclusion of the so called “pseudo-triples” beyond the first-order interacting space is also possible. The tw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:60627,variab,variable,60627,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['variab'],['variable']
Modifiability,"oid clean_variables(). psi4.close_outfile()¶; Python Library Documentation: built-in function close_outfile in module psi4; close_outfile(...). close_outfile() -> None :. Closes the output file.; C++ signature :. void close_outfile(). psi4.compute_shell()¶; Python Library Documentation: built-in function compute_shell in module psi4; compute_shell(...). compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :. docstring; C++ signature :. m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i). psi4.dcft()¶; Python Library Documentation: built-in function dcft in module psi4; dcft(...). dcft( (Wavefunction)arg1) -> Wavefunction :. Runs the density cumulant functional theory code.; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE dcft(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.detci()¶; Python Library Documentation: built-in function detci in module psi4; detci(...). detci( (Wavefunction)arg1) -> Wavefunction :. Runs the determinant-based configuration interaction code.; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE detci(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.dfmp2()¶; Python Library Documentation: built-in function dfmp2 in module psi4; dfmp2(...). dfmp2( (Wavefunction)arg1) -> Wavefunction :. Runs the DF-MP2 code.; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE dfmp2(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.dfocc()¶; Python Library Documentation: built-in function dfocc in module psi4; dfocc(...). dfocc( (Wavefunction)arg1) -> Wavefunction :. Runs the density-fitted orbital optimized CC codes.; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE dfocc(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.displace_atom()¶; Python Library Documentation: built-in function displace_atom in module psi4; displace_atom(...). displace_atom( (Matrix)arg1, (int)arg2, (int)arg3, (int)arg4, (float)arg5) -> Matrix :. Displaces one coordinate of single atom.; C++ signature :. N5boos",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:19250,config,configuration,19250,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['config'],['configuration']
Modifiability,ointFunctions; PointGroup; PotentialInt; prepare_options_for_module; PrimitiveType; print_global_options; print_options; print_out; print_out; print_variables; Prop; ProtoIntVector; ProtoVector; psi_top_srcdir; psimrcc; psio_entry; PsiReturnType; QuadrupoleInt; reopen_outfile; revoke_global_option_changed; revoke_local_option_changed; RHF; RKSFunctions; ROHF; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; AtomicComputer; banner; basis_helper; cbs; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; libint2_configuration; libint2_print_out; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicate,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1737293,variab,variable,1737293,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['variab'],['variable']
Modifiability,"ole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE"", core.variable(""CC DIPOLE"")); # core.set_variable(""CC ROOT n DIPOLE"", core.variable(""CC DIPOLE"")) # P::e CCENERGY; if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")); # core.set_variable(""CC ROOT n QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")) # P::e CCENERGY. n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:101623,variab,variable,101623,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; prop. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 Augu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.prop-1.html:1718,config,configurational,1718,psi4manual/1.4.0/api/psi4.driver.prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.prop-1.html,4,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; properties. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.properties-1.html:1750,config,configurational,1750,psi4manual/1.4.0/api/psi4.driver.properties-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.properties-1.html,4,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Property. © Copyright 2021, The Psi4 Project.; Last updated on Thur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prop-1.html:1758,config,configurational,1758,psi4manual/1.4.0/prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prop-1.html,2,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; prop. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 Novemb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.prop-1.html:1718,config,configurational,1718,psi4manual/1.5.0/api/psi4.driver.prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.prop-1.html,4,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; properties. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.properties-1.html:1750,config,configurational,1750,psi4manual/1.5.0/api/psi4.driver.properties-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.properties-1.html,4,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Property. © Copyright 2021, The Psi4 Project.; Last updated on Sund",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/prop-1.html:1758,config,configurational,1758,psi4manual/1.5.0/prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/prop-1.html,2,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; prop. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.prop.html:1718,config,configurational,1718,psi4manual/1.6.x/api/psi4.driver.prop.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.prop.html,2,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; properties. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.properties.html:1750,config,configurational,1750,psi4manual/1.6.x/api/psi4.driver.properties.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.properties.html,2,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Property. © Copyright 2022, The Psi4 Project.; Last updated on Thur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prop.html:1758,config,configurational,1758,psi4manual/1.6.x/prop.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prop.html,1,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). table of contents. prop; prop(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; prop. © Copyright 2007-2024, The",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.prop.html:1729,config,configurational,1729,psi4manual/master/api/psi4.driver.prop.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.prop.html,2,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). table of contents. prop; prop(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; prop. © Copyright 2007-2023, The Psi4 P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.prop.html:1722,config,configurational,1722,psi4manual/1.8.x/api/psi4.driver.prop.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.prop.html,2,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). table of contents. prop; prop(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; prop. © Copyright 2007-2024, The Psi4 P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.prop.html:1722,config,configurational,1722,psi4manual/1.9.x/api/psi4.driver.prop.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.prop.html,2,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). table of contents. properties; properties(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; properties. © Copyri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.properties.html:1761,config,configurational,1761,psi4manual/master/api/psi4.driver.properties.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.properties.html,2,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). table of contents. properties; properties(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; properties. © Copyright 200",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.properties.html:1754,config,configurational,1754,psi4manual/1.8.x/api/psi4.driver.properties.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.properties.html,2,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). table of contents. properties; properties(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; properties. © Copyright 200",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.properties.html:1754,config,configurational,1754,psi4manual/1.9.x/api/psi4.driver.properties.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.properties.html,2,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Property. © Copyright 2007-2024, The Psi4 Project.; Last",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prop.html:1769,config,configurational,1769,psi4manual/master/prop.html,https://psicode.org,https://psicode.org/psi4manual/master/prop.html,1,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; prop. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.prop.html:1720,config,configurational,1720,psi4manual/1.7.x/api/psi4.driver.prop.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.prop.html,2,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; properties. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tues",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.properties.html:1752,config,configurational,1752,psi4manual/1.7.x/api/psi4.driver.properties.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.properties.html,2,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Property. © Copyright 2007-2022, The Psi4 Project.; Last updated ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/prop.html:1760,config,configurational,1760,psi4manual/1.7.x/prop.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/prop.html,1,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon Functions: Invoking a Calculation; Property. © Copyright 2007-2023, The Psi4 Project.; Last update",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/prop.html:1762,config,configurational,1762,psi4manual/1.8.x/prop.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/prop.html,1,['config'],['configurational']
Modifiability,"ole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Property. © Copyright 2007-2024, The Psi4 Project.; Last update",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/prop.html:1762,config,configurational,1762,psi4manual/1.9.x/prop.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/prop.html,1,['config'],['configurational']
Modifiability,"olstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:37710,variab,variables,37710,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,15,['variab'],['variables']
Modifiability,"olution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE create_matrix(N3psi13MatrixFactoryE {lvalue}); | ; | create_matrix( (MatrixFactory)arg1, (str)arg2) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE create_matrix(N3psi13MatrixFactoryE {lvalue},Ss); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> MatrixFactory :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi13MatrixFactoryEEE shared_object(); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MintsHelper(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MintsHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (BasisSet)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi8BasisSetEEE); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ao_angular_momentum(...); | ao_angular_momentum( (Mints",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:526463,inherit,inherited,526463,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"olution order:; | PMLocalizer; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Localizer:; | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | ----------------------------------------------------------------------; | Static methods inherited from Localizer:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Localizer:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PetiteList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | PetiteList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | aotoso(...); | aotoso( (PetiteList)arg1) -> Matrix :; | docstring; | ; | print(...); | print( (PetiteList)arg1, (object)arg2) -> None :; | docstring; | ; | sotoao(...); | sotoao( (PetiteList)a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:106409,inherit,inherited,106409,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,4,['inherit'],['inherited']
Modifiability,"ol¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:21603,variab,variable,21603,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,16,['variab'],['variable']
Modifiability,"om Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_object() -> Checkpoint :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | disp; | docstring; | ; | e_t; | docstring; | ; | eccsd; | docstring; | ; | ecorr; | docstring; | ; | efzc; | docstring; | ; | emp2; | docstring; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:5469,inherit,inherited,5469,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,8,['inherit'],['inherited']
Modifiability,"om __builtin__.int:; | ; | __new__ = <built-in method __new__ of type object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Psi_Numpy_Interface(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Psi_Numpy_Interface; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | __array_interface__; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class QuadrupoleInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | QuadrupoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:591752,inherit,inherited,591752,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"om a Cfour execution. CI DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory, (3,). CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root.; Deprecated in favor of CI DIPOLE. CI QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root.; Deprecated in favor of CI QUADRUPOLE. CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory.; Deprecated in favor of CI ROOT n -> ROOT m DIPOLE. CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory.; Deprecated in favor of CI ROOT n -> ROOT m QUADRUPOLE. CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:11280,config,configuration,11280,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['config'],['configuration']
Modifiability,"om psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF); option(psi4_SKIP_ENABLE_Fortran ""Suppress enabling Fortran language even when Fortran addons enabled. Use when only linking pre-built, not compiling addon code."" OFF). # Append modules added to pasture as needed; if(ENABLE_ccsort OR ENABLE_transqt2); set(ENABLE_pasture ON); message(STATUS ""Enabling pasture plugins""); endif(). if(ENABLE_gdma OR ENABLE_dkh OR ENABLE_erd OR ENABLE_PCMSolver); if(psi4_SKIP_ENABLE_Fortran); message(STATUS ""NOT Enabling Fortran""); else(). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recursively delete all the “.pyc” files. It; may just run. How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_planning.html:23130,variab,variable,23130,psi4manual/1.9.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_planning.html,1,['variab'],['variable']
Modifiability,"om the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to LIBEFP by I. Kaliman. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/libefp.html:8466,config,configdir,8466,psi4manual/1.7.x/libefp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/libefp.html,2,['config'],"['configdir', 'configure']"
Modifiability,"om):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(na",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:35656,variab,variable,35656,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['variab'],['variable']
Modifiability,"om_fixed(self); Get whether or not COM is fixed. create_molecule_from_string(arg0); Returns a new Molecule with member data from the geometry string arg1 in psi4 format. create_psi4_string_from_molecule(self); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ(self, arg0); Nuclear charge of atom arg1 (0-indexed including dummies). find_point_group(self, arg0); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self, arg0); Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self, arg0); Fix the orientation at its current frame. form_symmetry_information(self, arg0); Uses the point group object obtain by calling point_group(). from_arrays([geom, elea, elez, elem, mass, …]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[, return_dict, verbose]); Construct Molecule from non-Psi4 schema. from_string(molstr[, dtype, name, fix_com, …]). fx(self, arg0); x position of atom arg1 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg1 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); G",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:2373,variab,variables,2373,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['variab'],['variables']
Modifiability,"ometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:89841,variab,variable,89841,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['variab'],['variable']
Modifiability,"ometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn, hess=None, irrep=None, molecule=None, project_trans=True, project_rot=True):; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn : :py:class:`~psi4.core.Wavefunction`; The wavefunction which had its Hessian computed.; hess : ndarray of float, optional; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep : int or string; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans : boolean; Should translations be projected in the harmonic analysis?; project_rot : boolean; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict; A dictionary of vibrational information. See :py:func:`~psi4.driver.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:73768,variab,variables,73768,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['variab'],['variables']
Modifiability,ometryUnits; get_active_molecule; get_array_variable; get_array_variables; get_datadir; get_global_option; get_global_option_list; get_local_option; get_memory; get_num_threads; get_option; get_options; get_output_file; get_variable; get_variables; get_writer_file_prefix; git_version; has_array_variable; has_global_option_changed; has_local_option_changed; has_option_changed; has_scalar_variable; has_variable; HF; IDAMAX; initialize; IntegralFactory; IntegralTransform; IntVector; IO; IOManager; IrreducibleRepresentation; JK; KineticInt; LaplaceDenominator; libint2_solid_harmonics_ordering; LibXCFunctional; Localizer; LS_THC_Computer; Matrix; MatrixFactory; mcscf; MemDFJK; MintsHelper; MoldenWriter; MolecularGrid; Molecule; MOSpace; MOWriter; mrcc_generate_input; mrcc_load_densities; MultipoleInt; MultipoleSymmetry; NablaInt; NumIntHelper; occ; OEProp; OneBodyAOInt; OneBodySOInt; option_exists_in_module; Options; options_to_python; OrbitalSpace; outfile_name; OverlapInt; PetiteList; plugin; plugin_close; plugin_close_all; plugin_load; PMLocalizer; PointFunctions; PointGroup; PotentialInt; prepare_options_for_module; PrimitiveType; print_global_options; print_options; print_out; print_out; print_variables; Prop; ProtoIntVector; ProtoVector; psi_top_srcdir; psimrcc; psio_entry; PsiReturnType; QuadrupoleInt; reopen_outfile; revoke_global_option_changed; revoke_local_option_changed; RHF; RKSFunctions; ROHF; SADGuess; SalcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstar,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1736230,plugin,plugin,1736230,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['plugin']
Modifiability,"ometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Setting geometry variable %s to %f"" % (vstr.upper(), val); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:32751,variab,variable,32751,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,6,['variab'],['variable']
Modifiability,"omic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems. This is the default for; systems of more than one atom. SADNONatural orbitals from Superposition of Atomic Densities. Similar; to the above, but it forms natural orbitals from the SAD density; matrix to get proper orbitals which are used to start the; calculation, see [Lehtola:2019:1593]. GWHA generalized Wolfsberg-Helmholtz modification of the core; Hamiltonian matrix. Usually less accurate than the core guess: the; latter is exact for one-electron systems, GWH is not; see; [Lehtola:2019:1593]). HUCKELAn extended Hückel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]. MODHUCKELLike HUCKEL, an extended Hückel guess based on; on-the-fly atomic UHF calculations alike SAD, see; [Lehtola:2019:1593]. This variant employs an updated rule for the; generalized Wolfsberg-Helmholz formula from [Ammeter:1978:3686]. READRead the previous orbitals from a wfn file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations. SAPSuperposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]; and [Lehtola:2020:012516]. The guess and its implementation have; been described in [Lehtola:2019:1593]. The guess is evaluated on a; DFT qua",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/scf.html:18041,extend,extended,18041,psi4manual/1.9.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/scf.html,2,['extend'],['extended']
Modifiability,"ommands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /scratch/user. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/scratch/user. PSIPATH¶; Path in which PSI4 looks for user extensions to the built-in; libraries. Specifically, directories containing; user basis sets,; EFP fragments,; databases,; plugins, and; interfaced executables (; dmrcc for MRCC and; dftd3 for DFTD3; ) should be placed in this colon-separated list.; PSI4 is designed so that user extensions that are findable through; PSIPATH can be used in input files entirely like their; built-in counterparts, without additional tagging as non-standard.; The typical search path is first the built-in libraries, next each; PSIPATH directory in order, and finally the execution; directory (I won’t swear everything tacks on the execution directory).; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins or databases.; Modify PSIPATH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIPATH /home/user/psiadditions:/home/user/gbs. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIPATH=/home/user/psiadditions:/home/user/gbs. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins or databases. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands.; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH=/home/user/psiadditions:$PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every PSI4 instance.; 1sys.pat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:19898,plugin,plugins,19898,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,6,['plugin'],['plugins']
Modifiability,"ommands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /scratch/user. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/scratch/user. PSIPATH¶; Path in which PSI4 looks for user extensions to the built-in; libraries. Specifically, directories containing; user basis sets,; EFP fragments,; databases,; plugins, and; interfaced executables (; dmrcc for MRCC and; dftd3 for DFTD3; ) should be placed in this colon-separated list.; PSI4 is designed so that user extensions that are findable through; PSIPATH can be used in input files entirely like their; built-in counterparts, without additional tagging as non-standard.; The typical search path is first the built-in libraries, next each; PSIPATH directory in order, and finally the execution; directory (I won’t swear everything tacks on the execution directory).; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins or databases.; Modify PSIPATH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIPATH /home/user/psiadditions:/home/user/gbs. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIPATH=/home/user/psiadditions:/home/user/gbs. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins or databases. Note; While once configuring PSI4 through PSIPATH was preferred; to modifying this environment variable, now PYTHONPATH is preferred for; Python moduels to accommodate QCEngine. Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands.; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH=/home/user/psiadditions:$PYTHONPATH. Place the p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:22680,plugin,plugins,22680,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['plugin'],['plugins']
Modifiability,"ommon-denominator, namely SSE instruction set. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; simint can be obtained through conda install simint.; Then enable it as a feature with ENABLE_simint,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect simint and activate dependent code.; To remove a conda installation, conda remove simint. Source. If using PSI4 built from source and you want simint built from; from source also,; enable it as a feature with ENABLE_simint,; and let the build system fetch and build it and activate dependent code. How to configure simint for building Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Examples. Build bundled. >>> cmake -DENABLE_simint=ON. Build without simint. >>> cmake. Link against pre-built. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_simin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/simint-1.html:1769,variab,variable,1769,psi4manual/1.1.0/simint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/simint-1.html,4,['variab'],['variable']
Modifiability,"ompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: (*float*) Total electronic energy in Hartrees. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. - Check that energy is actually being returned. - Check if some PSI variables ought to be set. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Self-consistent field method(s) |; +-------------------------+---------------------------------------------------------------------------------------+; | cc2 | 2nd-order approximate CCSD |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation-of-motion coupled cluster singles and doubles",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:30397,variab,variables,30397,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['variab'],['variables']
Modifiability,"ompilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/tests directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/tests/plugin_aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:3332,plugin,plugin,3332,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"omplete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. # Always must set SCF dipole (retire components at v1.5); with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for cart in [""X"", ""Y"", ""Z""]:; core.set_variable(""SCF DIPOLE "" + cart, core.variable(name + "" DIPOLE "" + cart)); core.set_variable(""SCF DIPOLE"", core.variable(name + "" DIPOLE"")) # P::e SCF. # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']) # yapf:disable. oneel_properties = core.OEProp.valid_methods; twoel_properties = []; response_properties = ['POLARIZABILITY', 'ROTATION', 'ROA', 'ROA_TENSOR']; excited_properties = ['OSCILLATOR_STRENGTH', 'ROTATIONAL_STRENGTH']. one = []; two = []; response = []; excited =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:95951,variab,variable,95951,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"omprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output:; ==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; -------------------------------------------------------; Total 287 287 5 5 5 0; -------------------------------------------------------. ... Minimum eigenvalue in the overlap matrix is 1.6888063568E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Irrep 0, 1 of 145 possible MOs eliminated.; Irrep 1, 2 of 142 possible MOs eliminated.; Overall, 3 of 287 possible MOs eliminated. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. Initial Guess¶; In each step of the SCF procedure, a new Fock or Kohn–Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:15447,adapt,adapted,15447,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,9,['adapt'],['adapted']
Modifiability,"on 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:9156,config,configure,9156,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,"['config', 'plugin']","['configure', 'plugins']"
Modifiability,"on activating through ``set integral_package erd``, known failures will be caught and halted, but perhaps other types not tested and identified will give *wrong* answers. Consider this your warning.""); endif(). ############################ Options: Build How? #############################; include(psi4OptionsTools); option_with_print(BUILD_SHARED_LIBS ""Build internally built Psi4 add-on libraries as shared, not static"" OFF); option_with_print(ENABLE_OPENMP ""Enables OpenMP parallelization"" ON); option_with_print(ENABLE_AUTO_BLAS ""Enables CMake to auto-detect BLAS"" ON). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recursively delete all the “.pyc” files. It; may just run. How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:21838,variab,variable,21838,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,1,['variab'],['variable']
Modifiability,"on and C++ source; * Modules scraped are the sections of psi4/psi4/src/read_options.cc; * Variables should be all-caps, except where representing substitutions, e.g., ROOT n -> ROOT m and double-quote "" delimited, even in Python; * Scraper looks for Process::environment.globals, set_array_variable, variables_, etc. lines and comments in the C++ code; * C-side, the module for the variable is determined by the directory where it’s found.; * Scraper looks for set_variable together with # P::e MODULE lines and comments in the Python code; * Py-side, the module for the variable is specified by MODULE in the comment; * When a variable is set by code in either language, e.g., variables_[varname.str()] rather than plain string, variables_[""FCI TOTAL ENERGY""], add a plain string line as a single-line comment, so the scraper can find it.; * Add new places to scrape for variables to psi4/doc/sphinxman/document_psivariables.pl; * For now, we’re scraping both global and Wfn variables; * All of these show up in referenceable appendices like apdx:detci_psivar; Plugins: doc.rst text, *.py modules, and C++ keywords in psi4/tests/plugin_* plugin directories (disabled at the moment); PSI Files: scratch file names and numbers in psi4/psi4/include/psi4/psifiles.h. Some documentation is even extracted from PSI4 objects at runtime. psi4: docstrings for the C++ submodule psi4.core and the Python submodule psi4.driver that comprise PSI4. C++ docstrings from “core” and “export” files in psi4/psi4/src/, and Py docstrings from psi4/psi4/driver/.; DFT: functional availability and characteristics as encoded in psi4/psi4/driver/procrouting/dft; BasisFamily: fitting basis sets for each orbital basis as encoded in psi4/psi4/driver/qcdb/basislistdunning.py and psi4/psi4/driver/qcdb/basislistother.py. Building all the documentation takes ~10 minutes. There is now good; dependency structure built into the psi4/doc/sphinxman/CMakeLists.txt; , so very long builds should be infrequent (unless you’re touch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/documentation-1.html:3614,variab,variables,3614,psi4manual/1.4.0/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/documentation-1.html,9,['variab'],['variables']
Modifiability,"on driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:25077,variab,variable,25077,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['variab'],['variable']
Modifiability,"on modules are installed (default: /); # Must start with /"". ############################ Options: Build What? ############################; option(ENABLE_ambit ""Enables the ambit tensor library"" OFF); option(ENABLE_CheMPS2 ""Enables CheMPS2 for DMRG (requires HDF5)"" OFF); option(ENABLE_dkh ""Enables DKH integrals (requires Fortran)"" OFF); option(ENABLE_libefp ""Enables LIBEFP for fragments"" OFF); option(ENABLE_erd ""Enables use of ERD instead of Libint (requires Fortran)"" OFF); option(ENABLE_simint ""Enables use of SIMINT two-electron integral library"" OFF); option(ENABLE_gdma ""Enables Stone's GDMA multipole code (requires Fortran)"" OFF); option(ENABLE_PCMSolver ""Enables PCMSolver library (requires Fortran)"" OFF); # These options are relevant to pasture; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF). # Append modules added to pasture as needed; if(ENABLE_ccsort OR ENABLE_transqt2); set(ENABLE_pasture ON); message(STATUS ""Enabling pasture plugins""); endif(). if(ENABLE_gdma OR ENABLE_dkh OR ENABLE_erd OR ENABLE_PCMSolver); enable_language(Fortran); set(Fortran_ENABLED ON) # communicate required languages with psi4-core; message(STATUS ""Enabling Fortran""); endif(). if(ENABLE_erd); message(WARNING ""ERD will build, link, and run in Psi4 just fine. However, it has not been hooked into Psi4 in all roles, notably gradients, LRC DFT energies, and ESP. So upon activating through ``set integral_package erd``, known failures will be caught and halted, but perhaps other types not tested and identified will give *wrong* answers. Consider this your warning.""); endif(). ############################ Options: Build How? #############################; include(psi4OptionsTools); option_with_print(BUILD_SHARED_LIBS ""Build internally built Psi4 add-on libraries as shared, not static"" OFF); option_with_print(ENABLE_OPENMP ""Enables OpenMP parallelization"" ON); option_with_print(ENAB",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:12227,plugin,plugins,12227,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['plugin'],['plugins']
Modifiability,"on numbers. occupation_b(self); Returns the Beta occupation numbers. onel_Hx(self, arg0); One-electron Hessian-vector products. options(self); Returns the Wavefunction's options object. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. print_energies(). print_header(self); docstring. print_orbitals(self); docstring. print_preiterations([small]). push_back_external_potential(self, V); Add an external potential to the private external_potentials list. reference_wavefunction(self); Returns the reference wavefunction. reset_occupation(self); docstring. rotate_orbitals(self, arg0, arg1); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self); docstring. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energies(self, arg0, arg1); docstring. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_cpscf_perturbation(self, name, ...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_jk(self, arg0); Sets the inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:9512,variab,variable,9512,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,20,['variab'],['variable']
Modifiability,"on of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule) → List[int]¶; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule) → List[int]¶; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → List[str]¶; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule) → str¶; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule) → bool¶; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:23522,variab,variable,23522,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,12,['variab'],"['variable', 'variables']"
Modifiability,"on of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule) → List[int]¶; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule) → List[int]¶; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → List[str]¶; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule) → str¶; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Returns the value of variable arg0 in the structural variables list. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:23247,variab,variable,23247,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,18,['variab'],"['variable', 'variables']"
Modifiability,"on of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule) → list[int]¶; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule) → list[int]¶; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → list[str]¶; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → list[tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule) → str¶; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule) → bool¶; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → list[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html:23756,variab,variable,23756,psi4manual/master/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Molecule.html,4,['variab'],"['variable', 'variables']"
Modifiability,"on options]. 4. Compile. Compile the code (optional -j triggers parallel compilation). >>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest and Pytest to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. >>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; >>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux and Mac) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++14 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (3.6+) https://www.python.org/; CMake (3.15+) https://cmake.org/download/; NumPy (needed at runtime and buildtime) https://numpy.org/; System utilities: GNU make and GNU install or Ninja, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download and build. gau2grid — [what is gau2grid?] [gau2grid min version]; Libint — [what is Libint?] [Libint min version] (Libint2 as of Nov 2020; added by v1.4). Eigen https://eigen.tuxfamily.org/index.php?title=Main_Page; MPFR https://www.mpfr.org/. Libxc — [what is Libxc?] [Libxc min version]; pybind11 — [what is Pybind11?] [Pybind11 min version]; QCElemental — [what is QCElemental?]; QCEngine — [what is QCEngine?] (March 2019; added by v1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:4225,config,configure,4225,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,4,['config'],['configure']
Modifiability,"on options]. 4. Compile. Compile the code (optional -j triggers parallel compilation). >>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest and Pytest to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. >>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; >>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux and Mac) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++17 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (3.8+) https://www.python.org/; CMake (3.15+) https://cmake.org/download/; NumPy (needed at runtime and buildtime) https://numpy.org/; System utilities: GNU make and GNU install or Ninja, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download and build. gau2grid — [what is gau2grid?] [gau2grid min version]; Libint — [what is Libint?] [Libint min version] (Libint2 as of Nov 2020; added by v1.4). Eigen https://eigen.tuxfamily.org/index.php?title=Main_Page. Libxc — [what is Libxc?] [Libxc min version]; pybind11 — [what is Pybind11?] [Pybind11 min version]; QCElemental — [what is QCElemental?]; QCEngine — [what is QCEngine?] (March 2019; added by v1.4). Additionally, there are",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:4226,config,configure,4226,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,1,['config'],['configure']
Modifiability,"on options]. 4. Compile. Compile the code (optional -j triggers parallel compilation). >>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest and Pytest to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. >>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; >>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux and Mac) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++17 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (3.8+) https://www.python.org/; CMake (3.15+) https://cmake.org/download/; NumPy (needed at runtime and buildtime) https://numpy.org/; System utilities: GNU make and GNU install or Ninja, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download and build. gau2grid — [what is gau2grid?] [gau2grid min version]; Libint — [what is Libint?] [Libint min version] (Libint2 as of Nov 2020; added by v1.4). Eigen https://eigen.tuxfamily.org/index.php?title=Main_Page. Libxc — [what is Libxc?] [Libxc min version]; pybind11 — [what is Pybind11?] [Pybind11 min version]; QCElemental — [what is QCElemental?]; QCEngine — [what is QCEngine?] (March 2019; added by v1.4); optking — [what is optk",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/build_planning.html:4226,config,configure,4226,psi4manual/1.7.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/build_planning.html,1,['config'],['configure']
Modifiability,"on order:; | DipoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:433356,inherit,inherited,433356,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. 4; Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. 5; The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. 6; The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. 7(1,2,3); For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; E_CONVERGENCE and D_CONVERGENCE for SCF of HF or DFT, 11; for E_CONVERGENCE and D_CONVERGENCE for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. Recommendations¶; The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless converge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:41490,flexible,flexible,41490,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,5,['flexible'],['flexible']
Modifiability,"on to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (dict, optional) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (int or str, optional) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int, optional) – Amount of printing. Returns. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters. func (str, optional) – Name of method/basis combination or composite method for which to compute the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:30244,extend,extending,30244,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,4,['extend'],['extending']
Modifiability,"on to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; Psi4 code is not necessary.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of Psi4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main Psi4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:6331,plugin,plugin,6331,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"on ». Database¶; Code author: Lori A. Burns; Section author: Lori A. Burns. database(name, db_name[, func, mode, cp, rlxd, symm, zpe, benchmark, tabulate, subset])[source]¶; Function to access the molecule objects and reference energies of; popular chemical databases. Aliases :db(). Returns:(float) Mean absolute deviation of the database in kcal/mol. Psi variables:. db_name DATABASE MEAN SIGNED DEVIATION; db_name DATABASE MEAN ABSOLUTE DEVIATION; db_name DATABASE ROOT-MEAN-SQUARE DEVIATION; Python dictionaries of results accessible as DB_RGT and DB_RXN. Note; It is very easy to make a database from a collection of xyz files; using the script psi4/lib/scripts/ixyz2database.pl.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/lib/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/db-1.html:1227,variab,variable,1227,psi4manual/4.0b5/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/db-1.html,2,['variab'],['variable']
Modifiability,"on(...); | fix_orientation( (Molecule)arg1, (bool)arg2) -> None :; | Fix the orientation at its current frame; | ; | C++ signature :; | void fix_orientation(N3psi8MoleculeE {lvalue},b); | ; | form_symmetry_information(...); | form_symmetry_information( (Molecule)arg1, (float)arg2) -> None :; | Uses the point group object obtain by calling point_group(); | ; | C++ signature :; | void form_symmetry_information(N3psi8MoleculeE {lvalue},d); | ; | geometry(...); | geometry( (Molecule)arg1) -> Matrix :; | Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr); | ; | C++ signature :; | N3psi6MatrixE geometry(N3psi8MoleculeE {lvalue}); | ; | get_full_point_group(...); | get_full_point_group( (Molecule)arg1) -> str :; | Gets point group name such as C3v or S8; | ; | C++ signature :; | Ss get_full_point_group(N3psi8MoleculeE {lvalue}); | ; | get_variable(...); | get_variable( (Molecule)arg1, (str)arg2) -> float :; | Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not; | ; | C++ signature :; | d get_variable(N3psi8MoleculeE {lvalue},Ss); | ; | is_variable(...); | is_variable( (Molecule)arg1, (str)arg2) -> bool :; | Checks if variable arg2 is in the list, returns true if it is, and returns false if not; | ; | C++ signature :; | b is_variable(N3psi8MoleculeE {lvalue},Ss); | ; | label(...); | label( (Molecule)arg1, (int)arg2) -> str :; | Gets the original label of the atom as given in the input file (C2, H4); | ; | C++ signature :; | Ss label(N3psi8MoleculeE {lvalue},i); | ; | mass(...); | mass( (Molecule)arg1, (int)arg2) -> float :; | Gets mass of atom arg2; | ; | C++ signature :; | d mass(N3psi8MoleculeE {lvalue},i); | ; | molecular_charge(...); | molecular_charge( (Molecule)arg1) -> int :; | Gets the molecular charge; | ; | C++ signature :; | i molecular_charge(N3psi8MoleculeE {lvalue}); | ; | move_to_com(...); | move_to_com( (Molecule)arg1) -> None :; | Moves molecule to center of mass; | ; | C++ signature :; |",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:548621,variab,variable,548621,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['variab'],['variable']
Modifiability,"on(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, **kwargs); steps_since_last_hessian = 0; core.set_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = { 'energy' : step_energies ,; 'gradient' : step_gradi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:64166,variab,variables,64166,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['variab'],['variables']
Modifiability,"on(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, **kwargs); steps_since_last_hessian = 0; core.set_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_wfn:; return (thisenergy, wfn); else:; return thisenergy. elif optking_rv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:61783,variab,variables,61783,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['variab'],['variables']
Modifiability,"on(1, True); psi4.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, **kwargs); steps_since_last_hessian = 0; psi4.set_gradient(G); psi4.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and psi4.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; psi4.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; psi4.set_legacy_molecule(moleculeclone); optking_rval = psi4.optking(); moleculeclone = psi4.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == psi4.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if psi4.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); psi4.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if psi4.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if psi4.get_option('OPTKING', 'KEEP_INTCOS') == False:; psi4.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); psi4.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; psi4.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_wfn:; return (thisenergy, wfn); else:; return thisenergy. elif optking_rv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:59941,variab,variables,59941,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['variab'],['variables']
Modifiability,"on(ENABLE_cppe ""Enables CPPE for Polarizable Embedding"" OFF); option(ENABLE_adcc ""Enables adcc for algebraic-diagrammatic construction methods (requires libtensorlight; can also be added at runtime)"" OFF); option(ENABLE_ddx ""Enables ddx for domain-decomposition contiuum solvation models (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_dkh ""Enables DKH integrals (requires Fortran)"" OFF); option(ENABLE_ecpint ""Enables libecpint for effective core potentials (ECP)"" OFF); option(ENABLE_libefp ""Enables LIBEFP and PylibEFP for fragments"" OFF); option(ENABLE_Einsums ""Enables the Einsums tensor library"" OFF); option(ENABLE_simint ""Enables use of SIMINT two-electron integral library"" OFF); option(ENABLE_gauxc ""Enables use of GauXC density functional library"" OFF); option(ENABLE_gdma ""Enables Stone's GDMA multipole code (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_PCMSolver ""Enables PCMSolver library (requires Fortran)"" OFF); option(ENABLE_snsmp2 ""Enables SNSMP2 plugin (can also be added at runtime)"" OFF); option(ENABLE_v2rdm_casscf ""Enables V2RDM_CASSCF plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_psi4fockci ""Enables Psi4FockCI plugin (can also be added at runtime)"" OFF); option(ENABLE_cct3 ""Enables cct3 plugin (requires Fortran; can also be added at runtime)"" OFF); option(ENABLE_gpu_dfcc ""Enables GPU_DFCC plugin for gpu-accelerated df-cc (requires CUDA; can also be added at runtime)"" OFF); option(ENABLE_mdi ""Enables MolSSI driver interface"" OFF); option(ENABLE_BrianQC ""Enables the BrianQC GPU module (requires CUDA; requires separate installation and licensing of the BrianQC module)"" OFF); # These options are relevant to pasture, expert only; option(ENABLE_ccsort ""Enables ccsort plugin installed from psi4pasture"" OFF); option(ENABLE_transqt2 ""Enables transqt2 plugin installed from psi4pasture"" OFF); option(psi4_SKIP_ENABLE_Fortran ""Suppress enabling Fortran language even when Fortran addons enabled.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:21484,plugin,plugin,21484,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,7,['plugin'],['plugin']
Modifiability,"on(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis, quiet]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self); docstring. cleanup_ci(self); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, ...); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_opdm(self); docstring. form_tpdm(self); docstring. freq",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html:2702,variab,variable,2702,psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,2,['variab'],['variable']
Modifiability,"on(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. rotate_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector, arg2: psi4.core.Vector) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:25266,variab,variable,25266,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"on) → int¶; Number of molecule orbitals. nmopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of molecular orbitals per irrep. no_occupations(self: psi4.core.Wavefunction) → List[List[Tuple[float, int, int]]]¶; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction) → int¶; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of symmetry orbitals per irrep. opdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. pitzer_to_ci_order_onel(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector) → None¶; docstring. pitzer_to_ci_order_twoel(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector) → None¶; docstring. potential_variable(self: psi4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). print_vector(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: int) → None¶; docstring. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. rotate_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector, arg2: psi4.core.Vector) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:23811,variab,variable,23811,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"on, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; docstring. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. set_variable(key, val)¶; Sets scalar or array QCVariable key to val on cls. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sigma(*args, **kwargs)¶; Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:27428,variab,variable,27428,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,5,['variab'],['variable']
Modifiability,"on, arg0: psi::detci::CIvect, arg1: int) → None¶; docstring. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. rotate_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector, arg2: psi4.core.Vector) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. set_array(key, val)¶. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_orbitals(self: psi4.core.CIWavefunction, arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:32106,variab,variable,32106,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"on, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:243796,variab,variables,243796,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,4,['variab'],['variables']
Modifiability,"on, performed by applying a finite electric field and numerical differentiation. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. adc1; ADC/6-31G** on H2O. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. dft2; DFT Functional Test. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a tes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:30121,plugin,plugins,30121,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['plugin'],['plugins']
Modifiability,"on, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233251,plugin,plugin,233251,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,4,['plugin'],['plugin']
Modifiability,"on. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]; class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - method_type : (str, str), raw value and str repr of governing variable and algorithm; - reference : (str, str), raw value and str repr of reference type; - qc_module : (str, str), raw value and str repr of targeted implementation; - fcae : (str, str), raw value and str repr of all-electron/frozen-core status. """"""; message: str; stats: Dict[str, Any]. def __init__(self, circs: List[str]):. if circs[0].endswith(""_property""):; driver = ""properties""; derivative_int = ""prop"" # differs from QCSchema Driver.derivative_int that uses `0` here; elif circs[0].endswith(""_hessian""):; driver = ""hessian""; derivative_int = 2; elif circs[0].endswith(""_gradient""):; driver = ""gradient""; derivative_int = 1; else:; driver = ""energy""; derivative_int = 0. docslink = docs_table_link(circs[1], mode=(""summary"" if circs[5] == """" else ""details"")); all_electron = circs[6] if (len(circs) == 7) else ""(n/a)"". stats = {; # use QCSchema AtomicInput keys where available; ""driver"": driver,; ""derivative_int"": derivative_int,; ""method"": circs[1],; ""link"": docslink",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:10884,variab,variable,10884,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,6,['variab'],['variable']
Modifiability,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:1527,variab,variables,1527,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,4,['variab'],['variables']
Modifiability,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hart",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:1555,variab,variables,1555,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,8,['variab'],['variables']
Modifiability,"on. In; this section we will describe the essential features of the Psithon language.; Psi4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level Psi4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all Psi4 input files.; For convenience, the physical constants used within the Psi4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within Psi4, which are automatically; made available within all Psi4 input files.; # @END LICENSE; #. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:1577,variab,variables,1577,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['variab'],['variables']
Modifiability,"on. Whenever the molecule is supplied in PSI4 format, the job control; keywords must be too. All Cfour keywords are the usual; ones, prepended by cfour_ to avoid any possible name conflicts. As; detailed in Job Control Keywords, setting keywords is flexible in; format. The previous example translates to:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23# UHF-SCF energy calculation. molecule {; 0 2 # multiplicity from the MULT keyword; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0; }. set {; cfour_CALC_level=HF # only full keyword names allowed; cfour_BASIS=qz2p; #MULT=2 # now in molecule {...} block; cfour_REFerence=UHF; cfour_OCCUPATION [[3, 1, 1, 0], [3,0,1,0] ] # arrays in python notation; cfour_SCF_CONV=12; cfour_MEMORY=20000000; }. energy('cfour'). Here, note that none of capitalization, equals sign, or whitespace matter; for the keyword commands. Specification of strings and integers requires no; translation; booleans have extended freedom of; format; arrays must be translated into Python-style (square-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into PSI4 format. Note; PSI4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in PSI4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; PSI4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:5841,extend,extended,5841,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['extend'],['extended']
Modifiability,"on.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:3973,inherit,inherited,3973,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Dispersion(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Dispersion; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | a1(...); | a1( (Dispersion)arg1) -> float :; | docstring; | ; | a2(...); | a2( (Dispersion)arg1) -> float :; | docstring; | ; | bibtex(...); | bibtex( (Dispersion)arg1) -> str :; | Get the BibTeX key for the literature reference.; | ; | citation(...); | citation( (Dispersion)arg1) -> str :; | docstring; | ; | compute_energy(...); | compute_energy(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:22864,inherit,inherited,22864,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ElectrostaticInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | ElectrostaticInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherite",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:29906,inherit,inherited,29906,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 384; | ; | ----------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:31449,inherit,inherited,31449,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Localizer(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | ---------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:68261,inherit,inherited,68261,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (int)arg2, (Molecule)arg3, (IntegralFactory)arg4, (MatrixFactory)arg5) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrices(...); | create_matrices( (MultipoleSymmetry)arg1, (str)arg2) -> matrix_vector :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:95634,inherit,inherited,95634,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | set_title(...); | set_title( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:98947,inherit,inherited,98947,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PMLocalizer(Localizer); | docstring; | ; | Method resolution order:; | PMLocalizer; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Localizer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:105045,inherit,inherited,105045,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | environment; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 24; | ; | ----------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:110380,inherit,inherited,110380,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PsiReturnType(Boost.Python.enum); | docstring; | ; | Method resolution order:; | PsiReturnType; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Balk = psi4.PsiReturnType.Balk; | ; | EndLoop = psi4.PsiReturnType.EndLoop; | ; | Failure = psi4.PsiReturnType.Failure; | ; | Success = psi4.PsiReturnType.Success; | ; | names = {'Balk': psi4.PsiReturnType.Balk, 'EndLoop': psi4.PsiReturnTyp...; | ; | values = {0: psi4.PsiReturnType.Success, 1: psi4.PsiReturnType.Failure...; | ; | ---------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:114179,inherit,inherited,114179,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:119936,inherit,inherited,119936,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class TwoBodyAOInt(Boost.Python.instance); | docstring; | ; | Method resolution order:; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> None :; | docstring; | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:133369,inherit,inherited,133369,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"on; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/interfacing-1.html:2050,config,configure,2050,psi4manual/1.4.0/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/interfacing-1.html,2,['config'],['configure']
Modifiability,"onError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). if name in [""mp3"", ""fno-mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:170062,variab,variables,170062,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"onError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); level = kwargs.get('level', 0). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). core.set_local_option('FNOCC', 'DFCC', False); core.set_local_option('FNOCC', 'RUN_CEPA', False); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # which method?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'RUN_CCSD', True); elif name == ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:155363,variab,variables,155363,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variables']
Modifiability,"on_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; core.set_variable('CURRENT ENERGY', core.variable('SCS-MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; core.set_variable('CURRENT ENERGY', core.variable('MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('MP2 CORRELATION ENERGY')). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:93305,variab,variable,93305,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"on_python(key, value); Sets value to Python keyword key scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes); prefer psi4.set_memory(). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_psi_file_prefix(). Deprecated since version 1.4. set_scalar_variable(key, value); Sets the double QCVariable key (case-insensitive); prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val in global memory. timer_off(label); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C, transA, transB, transC); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Deprecated since version 1.4. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:11027,variab,variables,11027,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,"on_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:32652,variab,variable,32652,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"on_with_default(FC_SYMBOL ""The type of Fortran name mangling"" 2); option_with_default(BUILD_FPIC ""Compile static libraries with position independent code"" ON). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to fix error “RuntimeError: value for ERI“¶; You will need to rebuild Libint. Reissue cmake or edit; CMakeCache.txt with larger MAX_AM_ERI and rebuilt. How to configure code to use high angular momentum basis sets. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir; cd {top-level-psi4-dir} && cmake -H. -Bobjdir; cd {top-level-psi4-dir} && cmake -H. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-level-psi4-dir are permitted. How to save configuration set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:15298,plugin,plugins,15298,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,4,"['plugin', 'variab']","['plugins', 'variable']"
Modifiability,"onal number in lowest terms. imag. the imaginary part of a complex number. numerator. the numerator of a rational number in lowest terms. real. the real part of a complex number. ———————————————————————-. Data and other attributes inherited from __builtin__.int:. __new__ = <built-in method __new__ of type object>. T.__new__(S, ...) -> a new object with type S, a subtype of T. psi4.PsiReturnType.EndLoop()¶; Python Library Documentation: PsiReturnType in module psi4 object; class PsiReturnType(Boost.Python.enum). docstring. Method resolution order:. PsiReturnType. Boost.Python.enum. __builtin__.int. __builtin__.object. Data and other attributes defined here:. Balk = psi4.PsiReturnType.Balk. EndLoop = psi4.PsiReturnType.EndLoop. Failure = psi4.PsiReturnType.Failure. Success = psi4.PsiReturnType.Success. names = {‘Balk’: psi4.PsiReturnType.Balk, ‘EndLoop’: psi4.PsiReturnTyp... values = {0: psi4.PsiReturnType.Success, 1: psi4.PsiReturnType.Failure... ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:279510,inherit,inherited,279510,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"onal number in lowest terms. imag. the imaginary part of a complex number. numerator. the numerator of a rational number in lowest terms. real. the real part of a complex number. ———————————————————————-. Data and other attributes inherited from __builtin__.int:. __new__ = <built-in method __new__ of type object>. T.__new__(S, ...) -> a new object with type S, a subtype of T. psi4.PsiReturnType.Failure()¶; Python Library Documentation: PsiReturnType in module psi4 object; class PsiReturnType(Boost.Python.enum). docstring. Method resolution order:. PsiReturnType. Boost.Python.enum. __builtin__.int. __builtin__.object. Data and other attributes defined here:. Balk = psi4.PsiReturnType.Balk. EndLoop = psi4.PsiReturnType.EndLoop. Failure = psi4.PsiReturnType.Failure. Success = psi4.PsiReturnType.Success. names = {‘Balk’: psi4.PsiReturnType.Balk, ‘EndLoop’: psi4.PsiReturnTyp... values = {0: psi4.PsiReturnType.Success, 1: psi4.PsiReturnType.Failure... ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:283037,inherit,inherited,283037,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"onal number in lowest terms. imag. the imaginary part of a complex number. numerator. the numerator of a rational number in lowest terms. real. the real part of a complex number. ———————————————————————-. Data and other attributes inherited from __builtin__.int:. __new__ = <built-in method __new__ of type object>. T.__new__(S, ...) -> a new object with type S, a subtype of T. psi4.PsiReturnType.Success()¶; Python Library Documentation: PsiReturnType in module psi4 object; class PsiReturnType(Boost.Python.enum). docstring. Method resolution order:. PsiReturnType. Boost.Python.enum. __builtin__.int. __builtin__.object. Data and other attributes defined here:. Balk = psi4.PsiReturnType.Balk. EndLoop = psi4.PsiReturnType.EndLoop. Failure = psi4.PsiReturnType.Failure. Success = psi4.PsiReturnType.Success. names = {‘Balk’: psi4.PsiReturnType.Balk, ‘EndLoop’: psi4.PsiReturnTyp... values = {0: psi4.PsiReturnType.Success, 1: psi4.PsiReturnType.Failure... ———————————————————————-. Methods inherited from Boost.Python.enum:. __repr__(...). x.__repr__() <==> repr(x). __str__(...). x.__str__() <==> str(x). ———————————————————————-. Data descriptors inherited from Boost.Python.enum:. name. ———————————————————————-. Methods inherited from __builtin__.int:. __abs__(...). x.__abs__() <==> abs(x). __add__(...). x.__add__(y) <==> x+y. __and__(...). x.__and__(y) <==> x&y. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __coerce__(...). x.__coerce__(y) <==> coerce(x, y). __div__(...). x.__div__(y) <==> x/y. __divmod__(...). x.__divmod__(y) <==> divmod(x, y). __float__(...). x.__float__() <==> float(x). __floordiv__(...). x.__floordiv__(y) <==> x//y. __format__(...). __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getnewargs__(...). __hash__(...). x.__hash__() <==> hash(x). __hex__(...). x.__hex__() <==> hex(x). __index__(...). x[y:z] <==> x[y.__index__():z.__index__()]. __int__(...). x.__int__() <==> int(x). __invert__(...). x.__invert__() <==> ~x. __long__(...). x.__long__() ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:286564,inherit,inherited,286564,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"onary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)¶; Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False)¶; Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:26240,variab,variable,26240,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,8,['variab'],['variable']
Modifiability,"onary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the numbe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:2557,variab,variable,2557,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,4,['variab'],['variable']
Modifiability,"onary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:2557,variab,variable,2557,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,3,['variab'],['variable']
Modifiability,"onda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin:. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Gener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/plugins-1.html:3171,plugin,plugin,3171,psi4manual/1.4.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/plugins-1.html,9,['plugin'],['plugin']
Modifiability,"onda has; already been installed (instructions at Quick Installation),; Libint can be obtained through conda install libint -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect Libint and activate dependent code. To remove a conda installation, conda remove libint. Source. Note that PSI4 uses v1. If using PSI4 built from source and you want Libint built from; from source also,; let the build system fetch and build it and activate dependent code. How to configure Libint for building Psi4¶; Role and Dependencies. Role — In PSI4, Libint is a library that provides essential; two-body molecular integrals over Gaussian functions.; Downstream Dependencies — PSI4 \(\Leftarrow\) Libint; Upstream Dependencies — Libint \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For Libint, set to an installation directory containing include/libint/libint.h; Libint_DIR — CMake variable to specify where pre-built Libint can be found. Set to installation directory containing share/cmake/Libint/LibintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_Libint — CMake variable to force internal build of Libint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_Libint — CMake variable to force detecting pre-built Libint and not falling back on internal build; MAX_AM_ERI — CMake variable to specify minimum highest angular momentum built or detected. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/libint/root. >>> cmake -DLibint_DIR=/path/to/libint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/libint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_Libint=ON. Build bundled shared library with AM=6. >>> cmake -DMAX_AM_ERI=6 -DBUILD_SHARED_LIBS=ON. table of contents. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/libint-1.html:2073,variab,variable,2073,psi4manual/1.4.0/libint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/libint-1.html,4,['variab'],['variable']
Modifiability,"one:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += "" %5d %11s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); text += "" %5d %11s %5d %11s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(6); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(6); text += "" %5d %11s %5d %11s %5d %11s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:12425,variab,variables,12425,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,2,['variab'],['variables']
Modifiability,"one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")). n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if not 'DF' in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_uti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:80780,variab,variable,80780,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"onf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> cd madness; >>> autoreconf; >>> cd .. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-configure; >>> cd obj; >>> ../do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compila",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:4644,config,configuration,4644,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['config'],['configuration']
Modifiability,"onian (). The transformation ( ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984] treatment.; In the X2C treatment, the positive-energy block of the Hamiltonian ( ); is given by the sum; of a transformed kinetic () and potential energy ( ) contribution.; Relativistic kinetic energy ( ) and nuclear-electron interaction potential ( ) is given interms of non-relativisitc kinetic () energy and nuclear-electron interaction potential (), coupling matrix ( ) and renormalization matrix ( ). The coupling matrix ( ) is obtained from the large () and small () components of the positive energy solutions of the Dirac equation.; The renormalization matrix; ,; depends on the modified overlap matrix; . The integrals can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators and . It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. REL_BASIS¶. Whether to uncontract the basis set in a dual basis calculation. Type: string; Default: No Default. Table Of Contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; REL_BASIS. Previous topic; ADC: Ab Initio Polarization Propagator; Next topic; Geometry Optimization. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». © Copyright 2016",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/relativistic-1.html:3906,extend,extended,3906,psi4manual/1.0.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/relativistic-1.html,2,['extend'],['extended']
Modifiability,"onic orbital extents. molecule(self); Returns the Wavefunction’s molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val). shallow_copy(self, arg0); Copies",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:5053,variab,variable,5053,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"onical. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [Eh] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [Eh] at 0 [K]. ZPVE¶; Vibrational zero-point energy [Eh] at 0 [K]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; PSI Variables by Alpha. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:60477,variab,variable,60477,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['variab'],['variable']
Modifiability,"only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOrder.Descending; EndLoop = PsiMod.PsiReturnType.EndLoop; Failure = PsiMod.PsiReturnType.Failure; Success = PsiMod.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:115441,variab,variable,115441,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['variab'],['variable']
Modifiability,"only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi.; ; wavefunction(...); wavefunction() -> Wavefunction :; Returns the current wavefunction object from the most recent computation. DATA; Ascending = PsiMod.DiagonalizeOrder.Ascending; Balk = PsiMod.PsiReturnType.Balk; Descending = PsiMod.DiagonalizeOrder.Descending; EndLoop = PsiMod.PsiReturnType.EndLoop; Failure = PsiMod.PsiReturnType.Failure; Success = PsiMod.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:115874,variab,variable,115874,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['variab'],['variable']
Modifiability,"only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (float)arg3) -> bool :; Sets a double option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (int)arg3) -> bool :; Sets an integer option scoped only to a specific module.; ; set_local_option( (str)arg1, (str)arg2, (list)arg3 [, (object)arg4]) -> bool; ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; stability(...); stability() -> int :; Runs the (experimental version) of HF stability analysis.; ; thermo(...); thermo() -> float :; Computes thermodynamic data.; ; transqt(...); transqt() -> float :; Runs the (deprecated) transformation code.; ; transqt2(...); transqt2() -> float :; Runs the (deprecated) transformation code.; ; version(...); version() -> str :; Returns the version ID of this copy of Psi.; ; wavefunction(...); wavefunction() -> Wavefunction :; Returns the current wavefunction object from the most recent computation. DATA; Ascending = psi4.DiagonalizeOrder.Ascending; Balk = psi4.PsiReturnType.Balk; Descending = psi4.DiagonalizeOrder.Descending; EndLoop = psi4.PsiReturnType.EndLoop; Failure = psi4.PsiReturnType.Failure; Success = psi4.PsiReturnType.Success. Previous topic; Python Driver; Next topic; Appendices; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:165821,variab,variable,165821,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['variab'],['variable']
Modifiability,"only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:33807,variab,variables,33807,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:4256,variab,variable,4256,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['variab'],['variable']
Modifiability,"onment Variables¶; These environment variables will influence PSI4‘s behavior. CONDA_PREFIX¶; Set when a conda environment is activated. Note that if PSI4 has been; built against any library in CONDA_PREFIX, the path has been baked into the; program, so any available dependencies are liable to been loaded from the environment. HOST¶; Set when a conda environment with conda compilers is activated. Used; when compatibly building PSI4 from source against conda; dependencies. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; While once configuring PSI4 through PSIPATH was preferred; to modifying this environment variable, now PATH is preferred for; executables to accommodate QCEngine. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /scratch/user. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/scratch/user. PSIPATH¶; Path in which PSI4 looks for user extensions to the built-in; libraries. Specifically, directories containing; user basis sets,; EFP fragments",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:20987,config,configuring,20987,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,18,"['config', 'variab']","['configuring', 'variable']"
Modifiability,"ons(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. opdm(self, arg0, arg1, arg2, arg3); docstring. options(self); Returns the Wavefunction's options object. pitzer_to_ci_order_onel(self, arg0, arg1); docstring. pitzer_to_ci_order_twoel(self, arg0, arg1); docstring. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. print_vector(self, arg0, arg1); docstring. reference_wavefunction(self); Returns the reference wavefunction. reset_ci_H0block(self); docstring. rotate_mcscf_integrals(self, arg0, arg1, arg2); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. semicanonical_orbs(self); docstring. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_ci_guess(self, arg0); docstring. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:7240,variab,variable,7240,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,4,['variab'],['variable']
Modifiability,"onstinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:4151,Plugin,Plugin,4151,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,3,['Plugin'],['Plugin']
Modifiability,"ontinuum.io/miniconda/Miniconda2-latest-MacOSX-x86_64.sh""; >>> curl -o Miniconda-latest.sh ""https://repo.continuum.io/miniconda/Miniconda3-latest-MacOSX-x86_64.sh"". >>> bash; >>> bash Miniconda-latest.sh -b -p $HOME/miniconda # agrees to conda's license terms; >>> echo ""export PATH=$HOME/miniconda/bin:\$PATH"" >> ~/.bashrc # Mac: use ~/.bash_profile; # log out, log back in so conda in path; >>> conda update --yes --all; >>> conda config --add channels http://conda.anaconda.org/psi4; >>> conda install --yes psi4; >>> psi4 ""$(dirname $(which psi4))""/../share/psi4/samples/sapt1/test.in # test installation. works b/c PSI_SCRATCH defaults to /tmp. That last command tested that psi4 is in your path, and it’s finding; all the libraries it needs. Now you need only specify a scratch directory; (see Scratch Files) by replacing the placeholder in the following:; >>> echo ""export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files"" >> ~/.bashrc; # log out, log back in so variable takes effect. All done!. Note; Above commands use bash for installation and set up your environment for bash at runtime. To use csh at runtime, follow the on-screen directions at the end of the installation or consult step 7 below. Detailed Installation of Miniconda¶; https://docs.conda.io/en/latest/miniconda.html. Detailed Installation of PSI4¶. Subscribe to PSI4. Subscribe to our channel at https://anaconda.org/psi4 that contains the PSI4 package and several dependency packages. Make sure this shows up in your ~/.condarc file. >>> conda config --add channels http://conda.anaconda.org/psi4; # check; >>> cat ~/.condarc; channels:; - http://conda.anaconda.org/psi4; - defaults. Install PSI4. You can install into the main conda environment so that whenever commands conda or (Ana/Miniconda’s) python are available, then psi4 is available, too. >>> conda install psi4; # check; >>> which psi4; /path/to/miniconda/bin/psi4. Or, you can install into a conda environment that places",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/conda-1.html:14053,variab,variable,14053,psi4manual/1.4.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/conda-1.html,9,['variab'],['variable']
Modifiability,"on¶; Bases: psi4.core.Wavefunction; docstring; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶. Get dict of converged T amplitudes. amps : dict (spacestr, SharedMatrix); spacestr is a description of the amplitude set using the following conventions.; I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF: “tIA”, “tIjAb”; UHF: tIA, tia, tIjAb, tIJAB, tijab; ROHF: tIA, tia, tIjAb, tIJAB, tijab. Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”“”; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ccwavefunction.html:1151,variab,variable,1151,psi4manual/1.3.2/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ccwavefunction.html,1,['variab'],['variable']
Modifiability,"on¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns; Whether some form of DIIS is enabled during SCF. Return type; bool. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:35109,variab,variable,35109,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,10,['variab'],['variable']
Modifiability,"oolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. DFCC¶. Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). Table Of Contents. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; BASIS; FREEZE_CORE; R_CONVERGENCE; E_CONVERGENCE; MAXITER; DIIS_MAX_VECS; NAT_ORBS; OCC_TOLERANCE; TRIPLES_LOW_MEMORY; CC_TIMINGS; DF_BASIS_CC; CHOLESKY_TOLERANCE; CEPA_NO_SINGLES; DIPMOM. Advanced FNOCC Keywords; SCS_MP2; MP2_SCALE_OS; MP2_SCALE_SS; SCS_CCSD; CC_SCALE_OS; CC_SCALE_SS; RUN_MP2; RUN_MP3; RUN_MP4; RUN_CCSD; RUN_CEPA; COMPUTE_TRIPLES; COMPUTE_MP4_TRIPLES; DFCC; CEPA_LEVEL. Previous topic; CC: Coupled Cluster Methods; Next topic; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:16996,config,configuration,16996,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,2,['config'],['configuration']
Modifiability,"oolean; Default: true. EFP_ELST_DAMPING (EFP); EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP); EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. EFP_POL_DAMPING (EFP); EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. Type: string; Possible Values: TT, OFF; Default: TT. EKT_EA (OCC); OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC); DFOCC — Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (OCC); OCC — Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. ENERGY_LEVEL_SHIFT (DCFT); DCFT (Expert) — Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the DCFT energy. Type: double; Default: 0.0. ENSURE_BT_CONVERGENCE (OPTKING); OPTKING — Reduce step size as necessary to ensure back-transformation of internal coordinate step to cartesian coordinates. Type: boolean; Default: false. EOM_GUESS (CCEOM); CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. EOM_REFE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:116915,extend,extended,116915,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['extend'],['extended']
Modifiability,"oordinate. (This information could be used to animate the vibrational frequency using visualization software.); Because the vibrational frequencies are available, a thermodynamics analysis is automatically performed at the end of the computation. You can see this in the next section of the output file output.dat. The vibrational frequencies are sufficient to obtain vibrational contributions to enthalpy (H), entropy (S), and Gibbs free energy (G). Similarly, the molecular geometry is used to obtain rotational constants, which are then used to obtain rotational contributions to H, S, and G.; Note: Psi4 has several synonyms for the functions called in this example. For instance, psi4.frequency() API will compute molecular vibrational frequencies, and psi4.optimize() API will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains code to analyze the nature of intermolecular interactions between two molecules, via symmetry-adapted perturbation theory (SAPT) (Jeziorski:1994:1887). This kind of analysis gives a lot of insight into the nature of intermolecular interactions, and Psi4 makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two distinct molecules. This is very easy, we just give a Z-matrix or set of Cartesian coordinates for each molecule, and separate the two with two dashes, like this:. [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:11514,adapt,adapted,11514,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['adapt'],['adapted']
Modifiability,"op object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: object; docstring. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; docstring. print_out(self: psi4.core.CdSalcList) → None¶; docstring. class psi4.core.CorrelationFactor¶; Bases: object; docstring. set_params(self: psi4.core.CorrelationFactor, arg0: psi4.core.Vector, arg1: psi4.core.Vector) → None¶; docstring. class psi4.core.CorrelationTable¶; Bases: object; docstring. degen(self: psi4.core.CorrelationTable, arg0: int) → int¶; docstring. group(*args, **kwargs)¶; Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. docstring. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. docstring. n(self: psi4.core.CorrelationTable) → int¶; docstring. ngamma(self: psi4.core.CorrelationTable, arg0: int) → int¶; docstring. subdegen(self: psi4.core.CorrelationTable, arg0: int) → int¶; docstring. subgroup(self: ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:25801,variab,variables,25801,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,"op object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.ROHF¶; Bases: psi4.core.HF; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefuncti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:105691,variab,variables,105691,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,"op object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.SOBasisSet¶; Bases: object; docstring. petite_list(self: psi4.core.SOBasisSet) → psi4.core.PetiteList¶; docstring. class psi4.core.SOMCSCF¶; Bases: object; docstring. Ck(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶. H_approx_diag(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. approx_solve(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. compute_AFock(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix) → psi4.core.Matrix¶. current_AFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_IFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_ci_en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:115163,variab,variables,115163,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,"op object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.VBase¶; Bases: object; docstring. C(self: psi4.core.VBase) → List[psi4.core.Matrix]¶; doctsring. C_add(self: psi4.core.VBase, arg0: psi4.core.Matrix) → None¶. C_clear(self: psi4.core.VBase) → None¶. D(self: psi4.core.VBase) → List[psi4.core.Matrix]¶; doctsring. V(self: psi4.core.VBase) → List[psi4.core.Matrix]¶; doctsring. basis(self: psi4.core.VBase) → psi4.core.BasisSet¶; doctsring. build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str) → psi4.core.VBase¶. compute(self: psi4.core.VBase) → None¶; doctsring. compute_gradient(self: psi4.core.VBase) → psi4.core.Matrix¶; doctsring. finalize(self: psi4.core.VBase) → None¶; doctsring. functional(self: psi4.core.VBase) → psi4.core.SuperFunctional¶; doctsring. initialize(self: psi4.core.VBase) → None¶; doctsring. quadrature_values(self: psi4.core.VBase) → Dict[str, float]¶; doctsring. class psi4.core.Vector¶; Base",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:131739,variab,variables,131739,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,"op object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. class psi4.core.IO¶; Bases: object; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str) → None¶; docstring. close(self: psi4.core.IO, arg0: int, arg1: int) → None¶; docstring. get_default_namespace() → str¶; docstring. open(self: psi4.core.IO, arg0: int, arg1: int) → None¶; docstring. open_check(self: psi4.core.IO, arg0: int) → int¶; docstring. rehash(self: psi4.core.IO, arg0: int) → None¶; docstring. set_default_namespace(ns: str) → None¶; docstring. set_pid(self: psi4.core.IO, arg0: str) → None¶; docstring. shared_object() → psi4.core.IO¶; docstring. state(self: psi4.core.IO) → int¶; docstring. tocclean(self: psi4.core.IO, arg0: int, arg1: str) → None¶; docstring. tocprint(self: psi4.core.IO, arg0: int) → None¶; docstring. tocwrite(self: psi4.core.IO, arg0: int) → None¶; docstring. class psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:55524,variab,variables,55524,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,op() (in module psi4.core). TURN_ON_ACTV (MCSCF). TWO-ELECTRON ENERGY. TwoBodyAOInt (class in psi4.core). twoel_Hx() (psi4.core.HF method). twoel_Hx_full() (psi4.core.RHF method). TwoElectronInt (class in psi4.core). U. U (psi4.core.Localizer attribute). UHF (class in psi4.core). UHF_NOONS (SCF). UKSFunctions (class in psi4.core). UNCP-CORRECTED 2-BODY INTERACTION ENERGY. unify() (psi4.core.FISAPT method). unify_part2() (psi4.core.FISAPT method). unit() (psi4.core.SymmetryOperation method). units. ; molecule. units() (psi4.core.Molecule method). Unnormalized (psi4.core.PrimitiveType attribute). up (psi4.driver.p4util.InPsight attribute). UPDATE (DETCI). update() (psi4.core.SOMCSCF method). update_density() (psi4.core.TwoBodyAOInt method). update_geometry() (psi4.core.Molecule method). (psi4.driver.p4util.InPsight method). update_orbitals() (psi4.core.IntegralTransform method). UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() (psi4.core.HF method). Va() (psi4.core.HF method). VAL_EX_LEVEL (DETCI). valid_methods (psi4.core.OEProp attribute). validate_diis() (psi4.core.HF method). validate_options() (psi4.core.Options method). ValidationError. value (psi4.core.DerivCalcType attribute). (psi4.core.DiagonalizeOrder attribute). (psi4.core.FragmentType attribute). (psi4.core.GaussianType attribute). (psi4.core.GeometryUnits attribute). (psi4.core.PrimitiveType attribute). (psi4.core.PsiReturnType attribute). (psi4.core.SaveType attribute). value() (psi4.core.SuperFunctional method). values() (psi4.core.SuperFunctional method). variable() (in module psi4.core). (psi4.core.Wavefunction method). variables() (in module psi4.core). (psi4.core.Wavefunction method). Vb() (psi4.core.HF method). VBase (class in psi4.core). vdot() (psi4.core.CIVector method). VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector (class in psi4.core). Vector3 (class in psi4.core). vector_axpy() (psi4.driver.p4util.SolverEngine,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/genindex.html:128981,plugin,plugin,128981,psi4manual/1.9.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/genindex.html,1,['plugin'],['plugin']
Modifiability,"op)arg1, (int)arg2) -> float :; | docstring; | ; | set_caxis(...); | set_caxis( (GridProp)arg1, (float)arg2, (float)arg3) -> None :; | docstring; | ; | set_filename(...); | set_filename( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_format(...); | set_format( (GridProp)arg1, (str)arg2) -> None :; | docstring; | ; | set_l(...); | set_l( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | set_n(...); | set_n( (GridProp)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | set_o(...); | set_o( (GridProp)arg1, (float)arg2, (float)arg3, (float)arg4) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class HF(Wavefunction); | docstring; | ; | Method resolution order:; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:26899,inherit,inherited,26899,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,8,['inherit'],['inherited']
Modifiability,"op-level-psi4-dir}; Find-the-code Quiz; Binary Installer; Clone from GitHub Repository; Fork from GitHub Repository; Tarball from GitHub Repository; Psi3 from SourceForge; How to update and rebuild Psi4. Configuring and Installing PSI4 via Binary¶. How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; How to get high angular momentum integrals from conda. Configuring, Building, and Installing PSI4 via Source¶. Planning: how to configure Psi4 and invoke CMake; How to build and install Psi4, the compact version; How to build, test, and install Psi4, in detail; How to see what build configuration options are available; How to choose the compilation directory, {objdir}; How to install elsewhere than /usr/local/psi4; How to configure code to use high angular momentum basis sets; How to see the actual compiling commands (or errors) with cmake; How to save configuration settings for a future compilation; How to configure a Psi4 build on Cray. Non-QC Dependencies¶. What are the tools and dependencies strictly required for building Psi4; How to configure Python for building Psi4; How to handle “runtime library may be hidden” when building with Anaconda Python; How to configure BLAS/LAPACK for building Psi4; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew. QC Dependencies and Extensions¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_faq-1.html:988,config,configure,988,psi4manual/1.2.1/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_faq-1.html,30,['config'],"['configuration', 'configure']"
Modifiability,"opi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:6556,variab,variable,6556,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,12,['variab'],['variable']
Modifiability,"opi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:6385,variab,variable,6385,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['variab'],['variable']
Modifiability,"oping anything to contribute back to the code base.; Provided I still get good, threaded BLAS/LAPACK, I’m willing to; sacrifice processor architecture fine tuning to avoid compiling it myself.; I’m on Linux or Mac or Windows with Ubuntu Bash Shell.; I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself for best performance on my computer.; I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4.; In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub; I want to develop using PSI4 infrastructure and libraries, not; on them; I think a plugin might do.; I’ve got a PSI4 compilation. Use it, then consult plugins; I’d rather not compile PSI4 or I don’t have compilers —; Goto Binary-Package then consult; plugins through conda. I really like parentheses and/or DBOC, so I want Psi3. —; Goto Psi3-from-SourceForge. Binary Installer¶. Get Initially; Just go to http://www.psicode.org/downloads.html and follow the; instructions there. Build; Not applicable as binary is pre-built. Get Updates directions; >>> conda update psi4. Contribute Back; Not applicable as not under git control. Conda Binary Package¶. Get Initially; The pre-compiled conda packages at https://anaconda.org/psi4/psi4; can be installed into an existing Anaconda or Miniconda distribution; according to directions. Locally, install into; a conda environment as below.; >>> conda create -n p4env psi4 -c psi4; >>> conda activate p4env. Build; Not applicable as binary is pre-built. Get Updates directions; >>> conda update",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_obtaining-1.html:1702,plugin,plugin,1702,psi4manual/1.2.1/build_obtaining-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_obtaining-1.html,2,['plugin'],['plugin']
Modifiability,"option('DETCI', 'FCI', 'TRUE'); elif name == 'cisd':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 2); elif name == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:134511,variab,variables,134511,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"option. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str) → float¶; Runs the GDMA code. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction) → float¶; Runs the symmetry adapted perturbation theory code. psi4.core.scalar_variable(arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. psi4.core.scalar_variables() → Dict[str, float]¶; Returns dictionary of all double QC variables. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list) → None¶; New Scatter function. psi4.core.scfgrad(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfgrad, which is a specialized DF-SCF gradient program. psi4.core.scfhess(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfhess, which is a specialized DF-SCF hessian program. psi4.core.set_active_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. psi4.core.set_datadir(arg0: str) → None¶; Returns the amount of memory available to Psi (in bytes). psi4.core.set_global_option(*args, **kwargs)¶; Overloaded function. set_global_option(arg0: str, arg1: list) -> bool. Sets value arg2 to array keyword arg1 for all modules. set_global_option(arg0: str, arg1: int) -> bool. Sets value arg2 to integer keyword arg1 for all modules. set_global_option(arg0: str, arg1: float) -> bool. Sets value arg2 to double keyword arg1 for all modules. set_global_option(arg0: str, arg1: str) -> bool. Sets value arg2 to string keyword arg1 for all modules. psi4.core.set_legacy_gradient(arg0: psi::Matrix) → None¶; Assigns the global gradient to the values in the (nat, 3) Matrix argument. FOR INTERNAL OPTKING USE ONLY. psi4.core.set_legacy_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_legacy_wavefunction(arg0: psi::Wavefunction) → N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:287530,variab,variable,287530,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variable']
Modifiability,"options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scalar_variable(arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(); Returns dictionary of all double QC variables. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(val). set_legacy_gradient(arg0); Assigns the global gradient to the values in the (nat, 3) Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:298913,variab,variables,298913,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variables']
Modifiability,"options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variable(key); Returns the double QCVariable key (case-insensitive); prefer variable(). scalar_variables(); Returns dictionary of all double QCVariables; prefer variables(). scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(ref_wfn); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(ref_wfn); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(molecule); Activates a previously defined molecule in global memory so next computations use it. set_array_variable(key, value); Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). set_datadir(psidatadir); Sets the path to shared text resources, PSIDATADIR. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(key, value); Sets value to Python keyword key scoped only to a single module. set_memory_bytes(memory[, quiet]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:8518,variab,variable,8518,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,2,['variab'],['variable']
Modifiability,"opy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; # retire components at v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE"", core.variable(""CC DIPOLE"")); # core.set_variable(""CC ROOT n DIPOLE"", core.variable(""CC DIPOLE"")) # P::e CCENERGY; if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")); # core.set_variable(""CC ROOT n QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")) # P::e CCENERGY. n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:101442,variab,variable,101442,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False)¶; Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. Added in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str]) – Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool]) – Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NO’s. If unspecified (None), value taken from; MOLDEN_WITH_VIRT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:27016,variab,variables,27016,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variables']
Modifiability,"or Matrix. Raises:; KeyError – If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables; from self. Parameters:. self – Wavefunction instance.; include_deprecated_keys (bool) – Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False)¶; Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str]) – Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool]) – Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NO’s. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:26864,variab,variables,26864,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['variab'],['variables']
Modifiability,"or building Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_simint — CMake variable to force detecting pre-built simint and not falling back on internal build; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Examples. Build bundled. >>> cmake -DENABLE_simint=ON. Build without simint. >>> cmake. Link against pre-built. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. table of contents. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to SIMINT by B. Pritchard. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/simint-1.html:3102,config,configdir,3102,psi4manual/1.4.0/simint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/simint-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,"or building Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_simint — CMake variable to force detecting pre-built simint and not falling back on internal build; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Examples. Build bundled. >>> cmake -DENABLE_simint=ON. Build without simint. >>> cmake. Link against pre-built. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. table of contents. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to SIMINT by B. Pritchard. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/simint-1.html:3102,config,configdir,3102,psi4manual/1.5.0/simint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/simint-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,"or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:247261,plugin,plugin,247261,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['plugin'],['plugin']
Modifiability,"or desired configuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; >>> cmake -S. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation). >>> cd {objdir}; >>> cmake --build . -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest and Pytest to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. >>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; >>> cmake --install . 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux and Mac) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++17 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (3.8+) https://www.python.org/; CMake (3.15+) https://cmake.org/download/; NumPy (needed at runtime and buildtime) https://numpy.org/; System utilities: GNU make and GNU install or Ninja, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:4244,config,configure,4244,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,2,"['config', 'variab']","['configure', 'variables']"
Modifiability,"or desired configuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; >>> cmake -S. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation). >>> cd {objdir}; >>> cmake --build . -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest and Pytest to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. >>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; >>> cmake --install . 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux and Mac) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it.; See psi4/codedeps.yaml for a structured listing and history of dependencies. C++ and C Compilers (C++17 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (3.8+) https://www.python.org/; CMake (3.15+) https://cmake.org/download/; NumPy (needed at runtime and buildtime) https://numpy.org/; System utilities: GNU make and GNU install or Ninja, POSIX threads (Pthre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_planning.html:4336,config,configure,4336,psi4manual/1.9.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_planning.html,2,"['config', 'variab']","['configure', 'variables']"
Modifiability,"or desired configuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; >>> cmake -S. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation). >>> cd {objdir}; >>> cmake --build . -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest and Pytest to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. >>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; >>> cmake --install . 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux and Mac) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it.; See psi4/codedeps.yaml for a structured listing and history of dependencies. C++ and C Compilers (C++20 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (3.8+) https://www.python.org/; CMake (3.15+) https://cmake.org/download/; NumPy (needed at runtime and buildtime) https://numpy.org/; System utilities: GNU make and GNU install or Ninja, POSIX threads (Pthre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:4343,config,configure,4343,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,2,"['config', 'variab']","['configure', 'variables']"
Modifiability,"or iterative triples excitations?. Type: boolean; Default: false. USE_SPIN_SYM¶. Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. WFN_SYM¶. The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering). Type: string; Possible Values: A, AG, AU, AP, APP, A1, A2, B, BG, BU, B1, B2, B3, B1G, B2G, B3G, B1U, B2U, B3U, 0, 1, 2, 3, 4, 5, 6, 7, 8; Default: 1. ZERO_INTERNAL_AMPS¶. Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?. Type: boolean; Default: true. Expert¶. PERTURB_CBS¶. Do compute the perturbative corrections for basis set incompleteness?. Type: boolean; Default: false. PERTURB_CBS_COUPLING¶. Do include the terms that couple different reference determinants in perturbative CBS correction computations?. Type: boolean; Default: true. TIKHONOW_TRIPLES¶. Do use Tikhonow regularization in (T) computations?. Type: boolean; Default: false. USE_SPIN_SYMMETRY¶. Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency. Type: boolean; Default: true. table of contents. PSIMRCC; General; CC_NUM_THREADS; CORR_ANSATZ; CORR_CCSD_T; CORR_CHARGE; CORR_MULTP; CORR_WFN; COUPLING; COUPLING_TERMS; DAMPING_PERCENTAGE; DIAGONALIZE_HEFF; DIAGONAL_CCSD_T; DIIS_MAX_VECS; DIIS_START; E_CONVERGENCE; FAVG_CCSD_T; FOLLOW_ROOT; HEFF4; HEFF_PRINT; LOCK_SINGLET; MAXITER; MP2_CCSD_METHOD; MP2_GUESS; NO_SINGLES; OFFDIAGONAL_CCSD_T; PT_ENERGY; R_CONVERGENCE; SMALL_CUTOFF; TIKHONOW_MAX; TIKHONOW_OMEGA; TRIPLES_ALGORITHM; TRIPLES_DIIS; USE_SPIN_SYM; WFN_SYM; ZERO_INTERNAL_AMPS. Expert; PERTURB_CBS; PERTURB_CBS_COUPLING; TIKHONOW_TRIPLES; USE_SPIN_SYMMETRY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__psimrcc-1.html:5126,config,configurations,5126,psi4manual/1.2.1/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__psimrcc-1.html,2,['config'],['configurations']
Modifiability,"or k, v in _programs_qcng.items() if k in _engine_can_do}; programs_disp[""libdisp""] = True; programs_disp[""nl""] = True. capable = collections.defaultdict(list); capable_sorted_by_available = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; capable[disp].append(eng); for disp, engines in capable.items():; capable_sorted_by_available[disp] = sorted(engines, key=lambda x: (not programs_disp[x], x)). return capable_sorted_by_available. [docs]; class EmpiricalDispersion():; """"""Lightweight unification of empirical dispersion calculation modes. Attributes; ----------; dashlevel : str; {""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"", ""nl"", ""dmp2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ""d4bjeeqatm""}; Name of dispersion correction to be applied. Resolved; from `name_hint` and/or `level_hint` into a key of; `empirical_dispersion_resources.dashcoeff`.; dashparams : dict; Complete set of parameter values defining the flexible parts; of :py:attr:`dashlevel`. Number and parameter names vary by; :py:attr:`dashlevel`. Resolved into a complete set (keys of; dashcoeff[dashlevel]['default']) from `name_hint` and/or; `dashcoeff_supplement` and/or user `param_tweaks`.; fctldash : str; If :py:attr:`dashparams` for :py:attr:`dashlevel` corresponds to a defined,; named, untweaked ""functional-dashlevel"" set, then that; functional. Otherwise, empty string.; description : str; Tagline for dispersion :py:attr:`dashlevel`.; dashlevel_citation : str; Literature reference for dispersion :py:attr:`dashlevel` in general,; *not necessarily* for :py:attr:`dashparams`.; dashparams_citation : str; Literature reference for dispersion parameters, if :py:attr:`dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcengine.programs.empirical_dispersion_resources.from_arrays`. Used; here to ""ble",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:3841,flexible,flexible,3841,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,2,['flexible'],['flexible']
Modifiability,"or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:7042,plugin,plugin,7042,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,6,['plugin'],['plugin']
Modifiability,"or whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable((arg0: str) -> bool); Returns true if the PSI variable exists/is set. initialize(() -> bool). legacy_wavefunction(() -> psi::Wavefunction); Returns the current legacy_wavefunction object from the most recent computation. libfock(...); Runs a CPHF calculation, using libfock. mcscf(...); Runs the MCSCF code, (N.B. mrcc_generate_input(...); Generates an input for Kallay’s MRCC code. mrcc_load_densities(...); Reads in the density matrices from Kallay’s MRCC code. occ(...); Runs the orbital optimized CC codes. opt_clean(() -> None); Cleans up the optimizer’s scratch files. optking(() -> int); Runs the geometry optimization / frequency analysis code. outfile_name(() -> str); Returns the name of the output file. plugin((arg0: str, ...); Call the plugin of name arg0. plugin_close((arg0: str) -> None); Close the plugin of name arg0. plugin_close_all(() -> None); Close all open plugins. plugin_load((arg0: str) -> int); Load the plugin of name arg0. prepare_options_for_module((arg0: str) -> None); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(() -> None); Prints the currently set global (all modules) options to the output file. print_options(() -> None); Prints the currently set options (to the output file) for the current module. print_out((arg0: str) -> None); Prints a string (using sprintf-like notation) to the output file. print_variables(() -> None); Prints all PSI variables that have been set internally. psi_top_srcdir(() -> str); Returns the location of the source code. psimrcc((arg0: psi::Wavefunction) -> float); Runs the multireference coupled cluster code. reopen_outfile(() -> None); Reopens the output file. revoke_global_option_changed((arg0: str) -> None); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_lo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:168661,plugin,plugins,168661,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['plugin'],['plugins']
Modifiability,"or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. fsapt-ext-abc2; FSAPT with external charge on dimer. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. scf-response3; UHF Dipole Polarizability Test. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc36; CC2(RHF)/cc-pVDZ energy of H2O. opt11; Transition-state optimizations of HOOH to both torsional transition states. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. sapt11; sapt example with orbital freezing with alkali metal and dMP2. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. cc52; CCSD Response for H2O2. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc56; EOM-CCSD/6-31g excited state transition dat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:12352,plugin,plugins,12352,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['plugin'],['plugins']
Modifiability,"or(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = core.get_gradient(); wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). def cfour_hessian_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_hessian_list(). def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). def write_zmat(name, dertype, molecule):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * core.get_memory()); if mem == 524:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; core.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.tagline = molecule.name(); molcmd, molkw = qcdbmolecule.format_molecule_for_cfour(). if core.get_global_option('BASIS') == '':; bascmd, baskw = '', {}; else:; user_pg = molecule.schoenflies_symbol(); mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/interface_cfour.html:14344,Variab,Variables,14344,psi4manual/1.5.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/interface_cfour.html,2,['Variab'],['Variables']
Modifiability,"or('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:103900,variab,variable,103900,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,14,['variab'],['variable']
Modifiability,"or; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Vector)arg2, (Vector)arg3, (float)arg4) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE,d); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | denominator_occ(...); | denominator_occ( (LaplaceDenominator)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE denominator_occ(N3psi18LaplaceDenominatorE {lvalue}); | ; | denominator_vir(...); | denominator_vir( (LaplaceDenominator)arg1) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE denominator_vir(N3psi18LaplaceDenominatorE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class LibParallelHelper(Boost.Python.instance); | Method resolution order:; | LibParallelHelper; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | AddTask(...); | AddTask( (LibParallelHelper)arg1, (str)arg2, (int)arg3) -> None :; | ; | C++ signature :; | void AddTask(N3psi11LibParallel17LibParallelHelperE {lvalue},N5boost6python3strE {lvalue},i); | ; | Begin(...); | Begin( (LibParallelHelper)arg1) -> str :; | ; | C++ signature :; | N5boost6python3strE Begin(N3psi11LibParallel17LibParallelHelperE {lvalue}); | ; | Done(...); | Done( (LibParallelHelper)arg1) -> bool :; | ; | C++ signature :; | b Done(N3psi11LibParallel17LibParallelHelperE {lvalue}); | ; | MakeJob(...); | MakeJob( (LibParallelHelper)arg1) -> None :; | ;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:508903,inherit,inherited,508903,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"or[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not None else None. for label in wfn_dimension:; tup = wfn_dimension[label]; wfn_dimension[label] = core.Dimension.from_list(tup, name=label) if tup is not None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn, filename=None):; """"""Converts a Wavefunction object to a base class. Parameters; ----------; wfn : Wavefunction; A Wavefunction or inherited class; filename : None, optional; An optional filename to write the data to. Returns; -------; dict; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),; 'matrix': {; 'Ca': wfn.Ca().to_array() if wfn.Ca() else None,; 'Cb': wfn.Cb().to_array() if wfn.Cb() else None,; 'Da': wfn.Da().to_array() if wfn.Da() else None,; 'Db': wfn.Db().to_array() if wfn.Db() else None,; 'Fa': wfn.Fa().to_array() if wfn.Fa() else None,; 'Fb': wfn.Fb().to_array() if wfn.Fb() else None,; 'H': wfn.H().to_array() if wfn.H() else None,; 'S': wfn.S().to_array() if wfn.S() else None,; 'X': wfn.X().to_array() if wfn.X() else None,; 'aotoso': wfn.aotoso().to_array() if wfn.aotoso() else N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:6873,inherit,inherited,6873,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['inherit'],['inherited']
Modifiability,"ord arg2 scoped only to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: str) -> bool. Sets value arg3 to string keyword arg2 scoped only to a specific module arg1. psi4.core.set_local_option_python(arg0: str, arg1: object) → None¶; Sets an option to a Python object, but scoped only to a single module. psi4.core.set_memory_bytes(memory: int, quiet: bool=False) → None¶; Sets the memory available to Psi (in bytes). psi4.core.set_num_threads(nthread: int, quiet: bool=False) → None¶; Sets the number of threads to use in SMP parallel computations. psi4.core.set_output_file(*args, **kwargs)¶; Overloaded function. set_output_file(arg0: str) -> None; set_output_file(arg0: str, arg1: bool) -> None. psi4.core.set_parent_symmetry(arg0: str) → None¶; Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. psi4.core.set_psi_file_prefix(arg0: str) → None¶. psi4.core.set_variable(arg0: str, arg1: float) → None¶; Sets a PSI variable, by name. psi4.core.tstart() → None¶; docstring. psi4.core.tstop() → None¶; docstring. psi4.core.version() → str¶; Returns the version ID of this copy of Psi. Functions¶. DASUM(arg0, arg1, arg2, arg3); docstring. DAXPY(arg0, arg1, arg2, arg3, arg4, arg5, arg6); docstring. DCOPY(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DDOT(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DGBMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGEEV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGEMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGEMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGER(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGETRF(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DGETRI(arg0, arg1, arg2, arg3, arg4, arg5, arg6); docstring. DGETRS(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DNRM2(arg0, arg1, arg2, arg3); docstring. DPOTRF(arg0, arg1, arg2, arg3, arg4); docstring. DPOTRI(arg0, arg1, arg2, arg3, arg4); docst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:238808,variab,variable,238808,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variable']
Modifiability,"order:; | MultipoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MultipoleSymmetry(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MultipoleSymmetry; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:561073,inherit,inherited,561073,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"order:; | PotentialInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Process(Boost.Python.instance); | Method resolution order:; | Process; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ sign",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:581144,inherit,inherited,581144,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradient_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.compute_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_fin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:66732,variab,variables,66732,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['variab'],['variables']
Modifiability,"ore.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector) → None; docstring. pitzer_to_ci_order_twoel(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector) → None; docstring. print_vector(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int) → None; docstring. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. rotate_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector, arg2: psi4.core.Vector) → None; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None; docstring. set_array(key, val)¶. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_legacy_frequencies(self: psi4.core.Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ciwavefunction.html:15114,variab,variables,15114,psi4manual/1.3.2/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ciwavefunction.html,1,['variab'],['variables']
Modifiability,ore.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. TwoElectronInt class in psi4.core. U. U psi4.core.BoysLocalizer attribute. psi4.core.Localizer attribute. psi4.core.PMLocalizer attribute. UHF class in psi4.core. UHF_NOONS (SCF). UKSFunctions class in psi4.core. UNCP-CORRECTED 2-BODY INTERACTION ENERGY. unify() psi4.core.FISAPT method. unit() psi4.core.SymmetryOperation method. units. ; molecule. units qcelemental.datum.Datum attribute. units() psi4.core.Molecule method. Unnormalized psi4.core.PrimitiveType attribute. UPDATE (DETCI). update() psi4.core.DFSOMCSCF method. psi4.core.DiskSOMCSCF method. psi4.core.SOMCSCF method. update_density() psi4.core.ERI method. psi4.core.TwoBodyAOInt method. psi4.core.TwoElectronInt method. update_geometry() psi4.core.Molecule method. update_orbitals() psi4.core.IntegralTransform method. UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. Va() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute. validate_options() psi4.core.Options method. ValidationError. class in qcelemental. value psi4.core.DerivCalcType attribute. psi4.core.DiagonalizeOrder attribute. psi4.core.FragmentType attribute. psi4.core.GaussianType attribute. psi4.core.GeometryUnits attribute. psi4.core.PrimitiveType attribute. psi4.core.PsiReturnType attribute. psi4.core.SaveType attribute. value() psi4.core.SuperFunctional method. values() psi4.core.SuperFunctional method. variable() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF m,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:147495,plugin,plugin,147495,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['plugin'],['plugin']
Modifiability,"ore.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dimension(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Dimension¶; docstring. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_opdm(self: psi4.core.CIWavefunction, arg0: int, arg1: int, arg2: str, arg3: bool) → psi4.core.Matrix¶; docstring. get_orbitals(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Matrix¶; docstring. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_tpdm(self: psi4.core.CIWavefunction, arg0: str, arg1: bool) → psi4.core.Matrix¶; docstring. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. hamiltonian(self: psi4.core.CIWavefunction, arg0: int) → psi4.core.Matrix¶; docstring. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. mcscf_object(self: psi4.core.CIWavefunction) → psi4.core.SOMCSCF¶; docstring. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:15568,variab,variable,15568,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['variab'],['variable']
Modifiability,"ore.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:30802,variab,variable,30802,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"ore.PrimitiveType attribute, [1], [2]. Unrestricted psi4.core.IntegralTransform.TransformationType attribute, [1]. UPDATE (DETCI). update() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF method, [1], [2]. update_geometry() psi4.core.Molecule method, [1], [2]. update_orbitals() psi4.core.IntegralTransform method, [1], [2]. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. V_potential() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. Va() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute, [1], [2]. validate_options() psi4.core.Options method, [1], [2]. ValidationError. value() psi4.core.SuperFunctional method, [1], [2]. values() psi4.core.SuperFunctional method, [1], [2]. variables() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Vb() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. VBase class in psi4.core, [1]. vdot() psi4.core.CIVector method, [1], [2]. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class in psi4.core, [1]. Vector3 class in psi4.core, [1]. vector_dot() psi4.core.Matrix method, [1], [2]. vector_multiply() psi4.core.CIVector method, [1], [2]. VectorMatrix class in psi4.core, [1]. version() in module psi4.core, [1]. vibanal_wfn() in module psi4.driver. vibrational analysis. ; function call. output. vir() psi4.core.MOSpace method, [1], [2]. VirOnly psi4.core.IntegralTransform.FrozenOrbitals attribute, [1]. visualization, [1]. VMDPATH. vmfc. ; settin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:125592,variab,variables,125592,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['variab'],['variables']
Modifiability,"ore.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key from self if present. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters:. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:13664,variab,variable,13664,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"ore.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key from self if present.; :rtype: None. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters:. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:13800,variab,variable,13800,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"ore.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key; from self if present. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters:. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:13714,variab,variable,13714,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,4,['variab'],['variable']
Modifiability,"ore.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.revoke_local_option_changed(arg0: str, arg1: str) → None¶; Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:154763,variab,variables,154763,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,6,['variab'],['variables']
Modifiability,"ore.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 2); elif name == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif name == 'ci':; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = kwargs['level']; core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), core.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n"");; core.print_out(""\t\t\t - Starship Troopers\n\n"");; core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n"");; core.print_out(""\t\t\t - Edward Valeev\n"");. if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:91195,variab,variable,91195,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"ore.set_local_option('SAPT', 'DO_CCD_DISP', True). core.print_out('\n'). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis); if core.get_global_option(""DF_BASIS_ELST"") == """":; dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tup",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:109590,variab,variable,109590,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"ore.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE"", core.variable(""CC DIPOLE"")); # core.set_variable(""CC ROOT n DIPOLE"", core.variable(""CC DIPOLE"")) # P::e CCENERGY; if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")); # core.set_variable(""CC ROOT n QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")) # P::e CCENERGY. n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if not 'DF' in core.get_global_option('SCF_TY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:101881,variab,variable,101881,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"ore_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:32431,variab,variables,32431,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PMLocalizer(Localizer); | docstring; | ; | Method resolution order:; | PMLocalizer; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Localizer:; | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | C++ signature :; | void localize(N3psi9LocalizerE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods inherited from Localizer:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi9LocalizerEEE build(Ss,N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi6MatrixEEE); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Localizer:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | -------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:576140,inherit,inherited,576140,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"orm_cholesky_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | form_eig_inverse(...); | form_eig_inverse( (FittingMetric)arg1, (float)arg2) -> None :; | docstring; | ; | form_fitting_metric(...); | form_fitting_metric( (FittingMetric)arg1) -> None :; | docstring; | ; | form_full_inverse(...); | form_full_inverse( (FittingMetric)arg1) -> None :; | docstring; | ; | get_algorithm(...); | get_algorithm( (FittingMetric)arg1) -> str :; | docstring; | ; | get_metric(...); | get_metric( (FittingMetric)arg1) -> Matrix :; | docstring; | ; | get_pivots(...); | get_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | get_reverse_pivots(...); | get_reverse_pivots( (FittingMetric)arg1) -> IntVector :; | docstring; | ; | is_inverted(...); | is_inverted( (FittingMetric)arg1) -> bool :; | docstring; | ; | is_poisson(...); | is_poisson( (FittingMetric)arg1) -> bool :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Functional(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Functional; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | alpha(...); | alpha( (Functional)arg1) -> float :; | docstring; | ; | citation(...); | citation( (Functional)arg1) -> str :; | docstring; | ; | description(...); | description( (Functional)arg1) -> str :; | docstring; | ; | is_gga(...); | is_gga( (Functional)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:20528,inherit,inherited,20528,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,8,['inherit'],['inherited']
Modifiability,"ormation for both users; and programmers in separate sections. From the top-level object directory,; build the following target (note that a working version of the PSI4; executable is a requirement for building the; documentation). Only GNU Makefiles, not Ninja, works for the docs:; >>> make sphinxman; # -OR-; >>> cmake --build . --target sphinxman. This will build a full set of documentation in the html directory that can be viewed offline through any browser.; doc/sphinxman/html/index.html. Much of the documentation is auto-generated from the source. At present,; this covers:. Physical Constants: psi4/psi4/include/psi4/physconst.h; Python Driver: docstrings from *.py files in psi4/psi4/driver; Databases: docstrings from *.py files in psi4/psi4/share/psi4/databases; Basis Sets: *.gbs files in psi4/psi4/share/psi4/basis; C++ Keywords: psi4/psi4/src/read_options.cc; Sample Inputs: input.dat files in psi4/samples; PSI Variables: variables and associated modules extracted from code and comments in the Python and C++ source; * Modules scraped are the sections of psi4/psi4/src/read_options.cc; * Variables should be all-caps, except where representing substitutions, e.g., ROOT n -> ROOT m and double-quote "" delimited, even in Python; * Scraper looks for Process::environment.globals, set_array_variable, variables_, etc. lines and comments in the C++ code; * C-side, the module for the variable is determined by the directory where it’s found.; * Scraper looks for set_variable together with # P::e MODULE lines and comments in the Python code; * Py-side, the module for the variable is specified by MODULE in the comment; * When a variable is set by code in either language, e.g., variables_[varname.str()] rather than plain string, variables_[""FCI TOTAL ENERGY""], add a plain string line as a single-line comment, so the scraper can find it.; * Add new places to scrape for variables to psi4/doc/sphinxman/document_psivariables.pl; * For now, we’re scraping both global and Wfn variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/documentation-1.html:2561,variab,variables,2561,psi4manual/1.4.0/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/documentation-1.html,9,['variab'],['variables']
Modifiability,"ort PATH=/path/to/dir/of/python/interpreter/against/which/psi4/compiled:$PATH; >>> export PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPATH. >>> python -c ""import psi4"". >>> python -c ""import psi4;print(psi4.__file__, psi4.__version__)"". How to run Psi4 as Python module after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH {prefix}/lib:$PYTHONPATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH={prefix}/lib:$PYTHONPATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. How to configure paths for PsiAPI. Run PSI4.; >>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable or Python module from conda installation¶; The configuration commands below are generic versions of the ones printed; to your screen as advice upon installing PSI4 into a Anaconda,; Miniconda, or Psi4conda distribution, condadist =; ana|mini|psi4conda. To see the message again after initial installation,; with the conda environment active, run .psi4-post-link.sh.; If which conda python psi4 points to your; condadist and echo $PSI_SCRATCH is set, skip ahead to the; “Run PSI4"" commands below. Otherwise, issue the following; commands directly in your terminal or place them into your “rc” file and; open a new terminal.; If you installed the Psi4conda distribu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:28356,config,configure,28356,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['config'],['configure']
Modifiability,"ort PSI_SCRATCH=/scratch/user. Psi4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are written to the; designated scratch numbered by content and labeled; with the process id, then are deleted at the end of the computation,; unless otherwise instructed by the user.; A Python callable handle to the Psi4 I/O management routines is available,; and is called psi4_io. To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to your input; file:; psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where Psi4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). which is equivalent to; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the Psi4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running sim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:3165,variab,variable,3165,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['variab'],['variable']
Modifiability,"ort PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPATH. >>> export PATH=/path/to/dir/of/python/interpreter/against/which/psi4/compiled:$PATH; >>> export PYTHONPATH=/path/to/dir/of/psi4/core-dot-so:$PYTHONPATH. >>> python -c ""import psi4"". How to run Psi4 as Python module after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH {prefix}/lib:$PYTHONPATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH={prefix}/lib:$PYTHONPATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. How to configure paths for PsiAPI. Run PSI4.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable or Python module from conda installation¶; The configuration commands below are generic versions of the ones printed; to your screen as advice upon installing PSI4 into a Anaconda,; Miniconda, or Psi4conda distribution, condadist =; ana|mini|psi4conda. To see the message again after initial installation,; with the conda environment active, run .psi4-post-link.sh.; If which conda python psi4 points to your; condadist and echo $PSI_SCRATCH is set, skip ahead to the; “Run PSI4” commands below. Otherwise, issue the following; commands directly in your terminal or place them into your “rc” file and; open a new terminal.; If you install",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:25359,config,configure,25359,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['config'],['configure']
Modifiability,"ort and an extended version. Both are read from; ###$HOME/.gcppar.$HOSTNAME by default. If the option -local is specified the file is read in from; ###the current working directory: .gcppar; ###The short version reads in: basis-keywo. # Write dftd3_geometry file that supplies geometry to dispersion calc; numAtoms = self.natom(); geom = self.save_string_xyz(); reals = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; numAtoms -= 1; else:; reals.append(line). geomtext = str(numAtoms) + '\n\n'; for line in reals:; geomtext += line.strip() + '\n'; geomfile = './gcp_geometry.xyz'; with open(geomfile, 'w') as handle:; handle.write(geomtext); # TODO somehow the variations on save_string_xyz and; # whether natom and chgmult does or doesn't get written; # have gotten all tangled. I fear this doesn't work; # the same btwn libmints and qcdb or for ghosts. # Call gcp program; command = ['gcp', geomfile]; command.extend(['-level', func]); if derint != 0:; command.append('-grad'); try:; #print('command', command); dashout = subprocess.Popen(command, stdout=subprocess.PIPE, env=lenv); except OSError as e:; raise ValidationError('Program gcp not found in path. %s' % e); out, err = dashout.communicate(). # Parse output; success = False; for line in out.splitlines():; line = line.decode('utf-8'); if re.match(' Egcp:', line):; sline = line.split(); dashd = float(sline[1]); if re.match(' normal termination of gCP', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful gCP run.""""""). # Parse grad output; if derint != 0:; derivfile = './gcp_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; rais",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html:7785,extend,extend,7785,psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,1,['extend'],['extend']
Modifiability,"ort p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.qcdb import intf_dftd3; from psi4.driver.qcdb import interface_gcp as gcp. _engine_can_do = collections.OrderedDict([('libdisp', ['d1', 'd2', 'chg', 'das2009', 'das2010']),; ('dftd3', ['d2', 'd3zero', 'd3bj', 'd3mzero', 'd3mbj']),; ('nl', ['nl']),; ]) # yapf: disable. _capable_engines_for_disp = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; _capable_engines_for_disp[disp].append(eng). [docs]class EmpiricalDispersion(object):; """"""Lightweight unification of empirical dispersion calculation modes. Attributes; ----------; dashlevel: {'d1', 'd2', 'd3zero', 'd3bj', 'd3mzero', 'd3mbj', 'chg', 'das2009', 'das2010', 'nl'}; Name of dispersion correction to be applied. Resolved; from `name_hint` and/or `level_hint` into a key of; `dashparam.dashcoeff`.; dashparams : dict; Complete (number and parameter names vary by `dashlevel`); set of parameter values defining the flexible parts; of `dashlevel`. Resolved into a complete set (keys of; dashcoeff[dashlevel]['default']) from `name_hint` and/or; `dashcoeff_supplement` and/or user `param_tweaks`.; fctldash : str; If `dashparams` for `dashlevel` corresponds to a defined,; named, untweaked ""functional-dashlevel"" set, then that; functional. Otherwise, empty string.; description : str; Tagline for dispersion `dashlevel`.; dashlevel_citation : str; Literature reference for dispersion `dashlevel` in general,; *not necessarily* for `dashparams`.; dashparams_citation : str; Literature reference for dispersion parameters, if `dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcdb.intf_dftd3.dashparam.from_arrays`. Used; here to ""bless"" the dispersion definitions attached to; the procedures/dft/*_functionals-defined dictionaries; as legit, non-c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/empirical_dispersion.html:2249,flexible,flexible,2249,psi4manual/1.3.2/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['flexible'],['flexible']
Modifiability,"ort uuid; import shutil; import socket; import subprocess. try:; from psi4.driver.p4util.exceptions import *; from psi4 import core; isP4regime = True; except ImportError:; from .exceptions import *; isP4regime = False; from .dashparam import *; from .molecule import Molecule. [docs]def run_dftd3(mol, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False):; """"""Compute dispersion correction using Grimme's DFTD3 executable. Function to call Grimme's dftd3 program to compute the -D correction; of level `dashlvl` using parameters for the functional `func`.; `dashparam` can supply a full set of dispersion parameters in the; absence of `func` or individual overrides in the presence of `func`. The DFTD3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`. Parameters; ----------; mol : qcdb.Molecule or psi4.core.Molecule or str; 	 Molecule on which to run dispersion calculation. Both qcdb and; 	 psi4.core Molecule classes have been extended by this method, so; 	 either allowed. Alternately, a string that can be instantiated; 	 into a qcdb.Molecule.; func : str or None; 	 Density functional (Psi4, not Turbomole, names) for which to; 	 load parameters from dashcoeff[dashlvl][func]. This is not; 	 passed to DFTD3 and thus may be a dummy or `None`. Any or all; 	 parameters initialized can be overwritten via `dashparam`.; dashlvl : {'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}; 	 Flavor of a posteriori dispersion correction for which to load; 	 parameters and call procedure in DFTD3. Must be a keys in; 	 dashcoeff dict (or a key in dashalias that resolves to one).; dashparam : dict, optional; 	 Dictionary of the same keys as dashcoeff[dashlvl] used to; 	 override any or all values initialized by; 	 dashcoeff[dashlvl][func].; dertype : {None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional; 	 Maximum derivative level at which to run DFTD3. For large; 	 `mol`, energy-only calculations can",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:2242,extend,extended,2242,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,1,['extend'],['extended']
Modifiability,"ort. import re; import os; import sys; import uuid; from psi4.driver import pubchem; from psi4.driver.p4util.exceptions import *; from psi4.driver.p4util.util import set_memory; from psi4 import core. # globally available regex strings; pubchemre = re.compile(r'^(\s*pubchem\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE). # inputfile contents to be preserved from the processor; literals = {}. # experimental - whether to run py statements as they're parsed from psithon; runalso = False. def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. def dequotify(string):; if string[0] == '""' and str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/inputparser.html:2417,variab,variable,2417,psi4manual/1.1.0/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/inputparser.html,1,['variab'],['variable']
Modifiability,"ory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to Psi4 for available templates. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; >>> psi4 --version; 0.4.262. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence Psi4‘s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring Psi4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that Psi4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh; >>> setenv PSI_SCRATCH /scratch/user. # bash; >>> export PSI_SCRATCH=/scratch/user. You can also include the above commands in the respective rc file, i.e.; ~/.tcshrc for csh and tcsh or ~/.bashrc for Bash. PSIPATH¶; Path in which Psi4 looks for user extensions to the built-in; libraries. Specifically, directories containing; user basis sets,; EFP fragments,; databases,; p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:15877,variab,variable,15877,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['variab'],['variable']
Modifiability,"ory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction’s molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. occupation_a(self); Returns the Alpha occupation numbers. occupation_b(self); Returns the Beta occupation numbers. onel_Hx(self, arg0); One-electron Hessian-vector products. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. print_energies(). print_header(self); docstring. print_orbitals(self); docstring. print_preiterations([small]). push_back_external_potential(self, V); Add an external potential to the private external_potentials list. reference_wavefunction(self); Returns the reference wavefunction. reset_occupation(self); docstring. rotate_orbitals(self, arg0, arg1); docstring. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self); docstring. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_array(key, val). Deprecated since version 1.4. set_ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:8574,variab,variable,8574,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"ory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s optio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:3665,plugin,plugins,3665,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,2,['plugin'],['plugins']
Modifiability,"ory, (3, 3). CISD QUADRUPOLE XX¶. CISD QUADRUPOLE XY¶. CISD QUADRUPOLE XZ¶. CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root.; Deprecated in favor of CISD QUADRUPOLE. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [Eh] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [Eh] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [Eh] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). CURRENT HESSIAN¶; The total electronic Hessian [E_h/a0/a0] of the most recent stage of a; calculation, (3 * {nat}, 3 * {nat}). CUSTOM SCS-MP2 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:14849,variab,variable,14849,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['variab'],['variable']
Modifiability,"ory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [Eh] from the polarizable continuum model for solvation. PE ENERGY¶; The energy contribution [Eh] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [Eh] for the requested SAPT; level of theory. SAPT ELST10,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT0. SAPT ELST EXTERN-EXTERN ENERGY¶; Electrostatic interaction [Eh] between the point charges in fragments; A and B in F/I-SAPT. SAPT EXCH10 ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:34770,config,configuration,34770,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['config'],['configuration']
Modifiability,"ory=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:36500,variab,variables,36500,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,6,['variab'],['variables']
Modifiability,"os, Jorgensen, and Aa. Jensen [Olsen:1988]. Excitation-class; selected multi-reference CI wavefunctions, such as second-order CI,; can be formulated as RAS CI’s. A RAS CI selects determinants for the; model space as those which have no more than \(n\) holes in the lowest set; of orbitals (called RAS I) and no more than \(m\) electrons in the highest; set of orbitals (called RAS III). An intermediate set of orbitals, if; present (RAS II), has no restrictions placed upon it. All determinants; satisfying these rules are included in the RAS CI.; The DETCI module is also very efficient at computing full configuration; interaction; wavefunctions, and it is used in this capacity in the complete-active-space; self-consistent-field (CASSCF) code. It can also perform approximate; CASSCF computations in which one uses RAS restrictions on the CI excitations,; rather than doing a full CI in the active space. This is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in sec:mcscf.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:3549,config,configurational,3549,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['config'],['configurational']
Modifiability,"os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:36168,variab,variable,36168,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['variab'],['variable']
Modifiability,"ossible Values: RHF, ROHF, UHF; Default: RHF. RESTART¶. Do restart the coupled-cluster iterations from old \(t_1\) and \(t_2\) amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. SCSN_MP2¶. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SCS_CCSD¶. Do spin-component-scaled CCSD. Type: boolean; Default: false. SCS_MP2¶. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SEMICANONICAL¶. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SPINADAPT_ENERGIES¶. Do print spin-adapted pair energies?. Type: boolean; Default: false. T2_COUPLED¶. Type: boolean; Default: false. T3_WS_INCORE¶. Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. Expert¶. AO_BASIS¶. The algorithm to use for the \(\left\langle VV||VV\right\rangle\) terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. FORCE_RESTART¶. Do restart the coupled-cluster",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__ccenergy-1.html:5516,adapt,adapted,5516,psi4manual/1.3.2/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__ccenergy-1.html,14,['adapt'],['adapted']
Modifiability,"ossible. Direct Inversion is automatically invoked if the newer algorithm; is not available.; The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but at present, it is only available for UHF \(\rightarrow\) UHF stability; analysis. The capabilities of both algorithms are summarized below:. Stability analysis methods available in PSI4¶. Algorithm; REFERENCE; Stability checked; STABILITY_ANALYSIS; SCF_TYPE. Direct Inversion; RHF; Internal, External (\(\rightarrow\) UHF); CHECK; PK only. ROHF; Internal; CHECK; PK only. Davidson; UHF; Internal; CHECK or FOLLOW; Anything. The best algorithm is automatically selected, i.e. Davidson for UHF \(\rightarrow\) UHF and Direct Inversion otherwise.; In addition to the options available for Direct Inversion, the Davidson algorithm can automatically; adapt FOLLOW_STEP_SCALE to find a new SCF minimum. If MAX_ATTEMPTS > 1, additional attempts; will automatically increment FOLLOW_STEP_SCALE by 0.2 every time the SCF falls back to the previously; found unstable minimum. The increment can be adjusted by setting FOLLOW_STEP_INCREMENT.; The default value is 0.2; adjust if needed to try different values of FOLLOW_STEP_SCALE in a single computation.; The Davidson solver for the eigenvalues is controlled through several keywords. In the following; we only report the most pertinent for stability analysis, see documentation for the CPHF; module for a complete list.; Some default values were modified for the stability analysis code, in that case they are; explicitly indicated here. SOLVER_MAXITER: maximum number of iterations; SOLVER_CONVERGENCE: eigenvector convergence threshold; SOLVER_N_ROOT: Solve for N eigenvectors in each irreducible representation; SOLVER_N_GUESS: Use N guess vectors, this needs to be larger tha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/scf-1.html:30825,adapt,adapt,30825,psi4manual/1.2.1/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/scf-1.html,9,['adapt'],['adapt']
Modifiability,"ossible. Direct Inversion is automatically invoked if the newer algorithm; is not available.; The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but at present, it is only available for UHF \(\rightarrow\) UHF stability; analysis. The capabilities of both algorithms are summarized below:. Stability analysis methods available in PSI4¶. Algorithm; REFERENCE; Stability checked; STABILITY_ANALYSIS; SCF_TYPE. Direct Inversion; RHF; Internal, External (\(\rightarrow\) UHF); CHECK; PK only. ROHF; Internal; CHECK; PK only. Davidson; UHF; Internal; CHECK or FOLLOW; Anything. The best algorithm is automatically selected, i.e. Davidson for UHF \(\rightarrow\) UHF and Direct Inversion otherwise.; In addition to the options available for Direct Inversion, the Davidson algorithm can automatically; adapt FOLLOW_STEP_SCALE to find a new SCF minimum. If MAX_ATTEMPTS > 1, additional attempts; will automatically increment FOLLOW_STEP_SCALE by 0.2 every time the SCF falls back to the previously; found unstable minimum. The increment can be adjusted by setting FOLLOW_STEP_INCREMENT.; The default value is 0.2; adjust if needed to try different values of FOLLOW_STEP_SCALE in a single computation.; The Davidson solver for the eigenvalues is controlled through several keywords. SOLVER_MAXITER: maximum number of iterations; SOLVER_CONVERGENCE: eigenvector convergence threshold; SOLVER_N_ROOT: Solve for N eigenvectors in each irreducible representation; SOLVER_ROOTS_PER_IRREP: The number of eigenvectors to solve in each irreducible representation. An array of as many integers as there are irreducible representations.; SOLVER_N_GUESS: Use N guess vectors, this needs to be larger than the number of roots so that the lowest ones can be captured reliably. Defaults to 4 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:40721,adapt,adapt,40721,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,4,['adapt'],['adapt']
Modifiability,"ost.Python function>(...); | ; | basisset(...); | basisset( (OrbitalSpace)arg1) -> BasisSet :; | docstring; | ; | dim(...); | dim( (OrbitalSpace)arg1) -> Dimension :; | docstring; | ; | evals(...); | evals( (OrbitalSpace)arg1) -> Vector :; | docstring; | ; | id(...); | id( (OrbitalSpace)arg1) -> str :; | docstring; | ; | integral(...); | integral( (OrbitalSpace)arg1) -> IntegralFactory :; | docstring; | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | build_ri_space(...); | build_ri_space( (BasisSet)arg1, (BasisSet)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OverlapInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | OverlapInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ---------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:103514,inherit,inherited,103514,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ot make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccsd', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:62663,variab,variables,62663,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variables']
Modifiability,"ot needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortran, g77, ifort, f77, f2c.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:8868,config,configure,8868,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configure']
Modifiability,"ot needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. For distributed-parallel compilation, MPI is required and; you need to use mpicxx (where this has been added to your PATH). --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:9552,config,configure,9552,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['configure']
Modifiability,"ot needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with Xcode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a C++ compiler.; One should use compilers that generate reentrant code, if possible.; The default search order for compilers is: xlC_r (AIX only), g++, c++,; icpc, cxx. --with-fc=compiler — Use this option to specify a Fortran-77 compiler,; which is used to determine linking coventions for BLAS and LAPACK libraries; and to provide system routines for those libraries. Note that no fortran; compiler is necessary on Mac OS X systems (see below). The default search; order for compilers is: xlf_r (AIX only), gfortran, g77, ifort, f77, f2c.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:9668,config,configure,9668,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['config'],['configure']
Modifiability,"ot unique because oribital spaces vary. DMRG-CASPT2 TOTAL ENERGY¶; The total DMRG plus CASPT2 total electonic energy [E_h] . Not unique because orbital spaces vary. EFP DISP ENERGY¶. EFP ELST ENERGY¶. EFP EXCH ENERGY¶. EFP IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for EFP/EFP; computations. The sum of these four components yields; EFP TOTAL ENERGY. EFP TOTAL ENERGY¶; The total electronic interaction energy [E_h] for EFP/EFP computations. EFP TORQUE¶; The torque, not gradient for EFP/EFP computations. ENTHALPY¶; Total enthalpy H [E_h] at given temperature. ENTHALPY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the enthalpy at given temperature. ESP AT CENTER n¶; Property of electrostatic potential [E_h / e] at location, usually atom center, n. FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the full configuration interaction level of theory. GIBBS FREE ENERGY¶; Total Gibbs free energy [E_h], free enthalpy at given temperature. GIBBS FREE ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the free enthalpy at given temperature. GRID ELECTRONS TOTAL¶. GRID ELECTRONS ALPHA¶. GRID ELECTRONS BETA¶; The number of electrons integrated by the xc quadrature grid. HF TOTAL ENERGY¶; The total electronic energy [E_h] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). HF KINETIC ENERGY¶; The total kinetic energy [E_h] of the Hartree–Fock method. HF POTENTIAL ENERGY¶; The total potential energy [E_h] of the Hartree–Fock method. HF VIRIAL RATIO¶; The virial ratio of the Hartree–Fock method. Only defined for a fully quantum mechanical computation, i.e., not QM/MM. HF TOTAL GRADIENT¶; The tota",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:31713,config,configuration,31713,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['config'],['configuration']
Modifiability,"otations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : ~typing.Dict[str, ~numpy.ndarray]; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`. """""". if hess is None:; nmwhes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:88288,variab,variables,88288,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,6,['variab'],['variables']
Modifiability,"ote: MPICH2-1.1.0 had trouble with some header files. MPICH2-1.2.1; seems to fix it.). GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures, to compile with MADNESS, or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). To make a distributed-parallel version with MADNESS, you may also need:. libtool (called by autoreconf). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Distributed-parallel compilation.; Not recommended at this time except for developers. Shared-memory; parallelization is already enabled by default in the standard; compilation.; Distributed-parallel versions of PSI4 require madness. If you select; mpicxx as the compiler, the distributed-parallel version (including; madness) will compile. For distributed-parallel compilation, you must; run the following command in the madness directory, otherwise the PSI4; configure script will fail (autoreconf is provided by package autoconf,; but it calls another program provided by libtool, so that package must; also be installed):; >>> ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:2830,config,configure,2830,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['configure']
Modifiability,"otential + Kinetic) Integrals. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the dictionary of all Matrix QC variables. arrays()¶. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. attempt_number_; Current macroiteration (1-indexed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 sy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:12069,variab,variable,12069,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['variab'],['variable']
Modifiability,"otential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix) → None; docstring. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sigma(*args, **kwargs); Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ciwavefunction.html:16720,variab,variable,16720,psi4manual/1.3.2/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"otential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | C++ signature :; | void addCharge(N3psi17ExternalPotentialE {lvalue},d,d,d,d); | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | C++ signature :; | void clear(N3psi17ExternalPotentialE {lvalue}); | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE computePotentialMatrix(N3psi17ExternalPotentialE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE); | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi17ExternalPotentialE {lvalue}); | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void setName(N3psi17ExternalPotentialE {lvalue},Ss); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class F12(TwoElectronInt); | docstring; | ; | Method resolution order:; | F12; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class can",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:453262,inherit,inherited,453262,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"otentialE {lvalue}); | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE computePotentialMatrix(N3psi17ExternalPotentialE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE); | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi17ExternalPotentialE {lvalue}); | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void setName(N3psi17ExternalPotentialE {lvalue},Ss); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class F12(TwoElectronInt); | docstring; | ; | Method resolution order:; | F12; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:453442,inherit,inherited,453442,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"otentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self, arg0, arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:4136,variab,variable,4136,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['variab'],['variable']
Modifiability,"otentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. fin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html:3884,variab,variable,3884,psi4manual/1.5.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html,2,['variab'],['variable']
Modifiability,"otentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self, arg0); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html:3891,variab,variable,3891,psi4manual/1.6.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html,2,['variab'],['variable']
Modifiability,"otential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIEN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:21952,variab,variables,21952,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variables']
Modifiability,"otential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:21680,variab,variables,21680,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,4,['variab'],['variables']
Modifiability,"otential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction) → dict[str, float]¶; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIEN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:21772,variab,variables,21772,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variables']
Modifiability,"ou must enable the psi4 executable to be found through any of:. prepending to PATH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file; activating the conda environment (p4env above) in shell, ~/.bashrc, or PBS cmd file; supplying full path to executable (shell or PBS cmd file). Similarly, the scratch directory (see Scratch Files and Elementary Restart) must be specified through:. defining PSI_SCRATCH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file. Suitable values for these variables have been printed to screen during installation (see last codeblock in step 6). Useful Commands¶. Initially install PSI4 stable release. # equivalent; >>> conda install psi4 -c psi4; >>> conda install psi4 –channel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.6 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=0.1.12 -c psi4. Uninstall PSI4 from current environment. >>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 –channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. >>> conda install psi4 python=3.6 -c psi4/label/dev. Update to latest PSI4 nightly build. >>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=0.1.12 -c psi4/label/dev. Troubleshooting¶. If the target computer doesn’t have libc >= 2.7 (released c.2007; for reference, 2.10 is n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/conda-1.html:21021,sandbox,sandbox,21021,psi4manual/1.3.2/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/conda-1.html,2,['sandbox'],['sandbox']
Modifiability,"ou must specify the Python executable as the program. Arguments are provided using the --args flag. Here’s an example.::$~> gdb –args /usr/bin/python3 /path/to/psi4 input.dat. In order to debug properly, Psi4 needs to be built with the CMAKE_BUILD_TYPE variable set to either Debug or RelWithDebInfo. These will output debugging symbols that will allow gdb to print line numbers and; inline function names.:; > cmake [your options here] -DCMAKE_BUILD_TYPE=Debug; > cmake [your options here] -DCMAKE_BUILD_TYPE=RelWithDebInfo. Certain symbols may not be output even with this flag set. In general, any template function used should be visible, and anything with the PSI_API modifier will be visible. Other variables, functions, and classes will; likely be hidden from the user. To make these symbols visible, you must modify a few variables. For an example, see TiborGY’s debug branch.; Also see more debugger directions; and a [presentation] .; If building using psi4-path-advisor cmake, one should run it straight, not within eval $(...), note the usage command it outputs, then edit the cache file it has produced to change CMAKE_BUILD_TYPE to Debug and CMAKE_CXX_FLAGS to -O0, then execute the noted cmake ... -C cache command to configure. VSCode¶; When using gdb wath VSCode, you should set the program entry to the Python executable, just as before. Arguments can then be placed in the args entry. If you are debugging a C++ plugin or backend code,; the launch type should be cppdbg. Profiling¶; Instructions on using Psi4 with a profiler, or/and discuss how timers work; in Psi4… they are hierarchical…. I think we have special timers for; parallel blocks. table of contents. Debugging and Profiling; Debugging; VSCode. Profiling. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Debugging and Profiling. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_debug_profile.html:1492,config,configure,1492,psi4manual/master/prog_debug_profile.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_debug_profile.html,2,"['config', 'plugin']","['configure', 'plugin']"
Modifiability,"oubly and singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies()¶; Returns the results of a frequency analysis. Parameters:; self – Wavefunction instance. Returns:; A dictionary of vibrational information. See psi4.driver.qcdb.vib.harmonic_analysis(). Return type:; Optional[Dict[str, ndarray]]. static from_file(wfn_data)¶; Build Wavefunction from data laid out like; to_file(). Parameters:; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to; numpy.load() to read from disk. Returns:; A deserialized Wavefunction object. Return type:; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → Annotated[List[float], FixedSize(3)]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Return canonical path to scratch file filenumber based on molecule on self.; :rtype: str. Parameters:. self (Wavefunction) – Wavefunction instance.; filenumber (int) – Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:17161,variab,variable,17161,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"oubly and singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies()¶; Returns the results of a frequency analysis. Parameters:; self – Wavefunction instance. Returns:; A dictionary of vibrational information. See psi4.driver.qcdb.vib.harmonic_analysis(). Return type:; Optional[Dict[str, ndarray]]. static from_file(wfn_data)¶; Build Wavefunction from data laid out like; to_file(). Parameters:; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to; numpy.load() to read from disk. Returns:; A deserialized Wavefunction object. Return type:; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → Annotated[list[float], FixedSize(3)]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefunction) – Wavefunction instance.; filenumber (int) – Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: psi4.core.Wavefu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:17010,variab,variable,17010,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"oubly and singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies()¶; Returns the results of a frequency analysis. Parameters:; self – Wavefunction instance. Returns:; A dictionary of vibrational information. See psi4.driver.qcdb.vib.harmonic_analysis(). Return type:; Optional[Dict[str, ndarray]]. static from_file(wfn_data)¶; Build Wavefunction from data laid out like; to_file(). Parameters:; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to; numpy.load() to read from disk. Returns:; A deserialized Wavefunction object. Return type:; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefunction) – Wavefunction instance.; filenumber (int) – Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:17061,variab,variable,17061,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,4,['variab'],['variable']
Modifiability,"ouched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. libint2_solid_harmonics_ordering(); The solid harmonics setting of Libint2 currently active for Psi4. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:7279,plugin,plugin,7279,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,4,['plugin'],['plugin']
Modifiability,"ough conda install gau2grid -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gau2grid and activate dependent code. Previous bullet had details. To build PSI4 from source and use; gau2grid from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/gau2grid-1.html:1787,variab,variable,1787,psi4manual/1.2.1/gau2grid-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/gau2grid-1.html,2,['variab'],['variable']
Modifiability,"ough conda install gau2grid -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gau2grid and activate dependent code. Previous bullet had details. To build PSI4 from source and use; gau2grid from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/gau2grid-1.html:1787,variab,variable,1787,psi4manual/1.3.2/gau2grid-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/gau2grid-1.html,2,['variab'],['variable']
Modifiability,"ould not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; (Path(name) / target_file).write_text(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/pluginutil.html:5076,plugin,plugin,5076,psi4manual/master/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/pluginutil.html,8,"['PLUGIN', 'Plugin', 'plugin']","['PLUGIN', 'Plugin', 'plugin', 'pluginutil']"
Modifiability,"ound here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in PSI4 multiple jobs can be run in succession from the input file.; Control optimizations with optking keywords HERE. Cfour GRD file is; written to PSI4 output file. Gradient transformed back into the frame; in which it was shipped off to Cfour is also written to the PSI4; output file and is available from input as get_gradient().; sandwich mode := molecule and cfour list within; Naturally, additional jobs can follow in the input file.; Depending on the nature of preceding or following jobs, it is prudent to; separate them with the following:; 1; 2; 3clean() # removes Psi4 scratch files; clean_variables() # empties the PSI variables list; cfour {} # empties. In this scheme, the contents of the cfour {...} block are tacked onto; the end of the ZMAT file that is otherwise written from psi style; format. It is by this route that, for example %excite* sections can at; present be specified.; The execution of xcfour can be modified by a few parameters. Setting; the option CFOUR_OMP_NUM_THREADS sets the environment variable; OMP_NUM_THREADS for only the duration of the Cfour computation.; That is, portions of an input file that run PSI4 modules are; unaffected. Additionally, there are a few arguments to the function; run_cfour() that control the Cfour scratch; directory. table of contents. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cfour-1.html:34263,variab,variable,34263,psi4manual/1.3.2/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cfour-1.html,2,['variab'],['variable']
Modifiability,"oup(self: psi4.core.Molecule, arg0: str) → None¶; Overrides symmetry from outside the molecule string. rotational_constants(self: psi4.core.Molecule, arg0: float) → psi4.core.Vector¶; Prints the rotational constants of the molecule. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:86124,extend,extended,86124,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,3,['extend'],['extended']
Modifiability,"oupled electron pair approximation variant 0 level of theory, (3, 3). CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory.; Deprecated in favor of CEPA(0) QUADRUPOLE. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested variant of coupled electron pair approximation level of theory. CFOUR ERROR CODE¶; The non-zero return value from a Cfour execution. CI DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory, (3,). CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root.; Deprecated in favor of CI DIPOLE. CI QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root.; Deprecated in favor of CI QUADRUPOLE. CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory.; Deprecated in favor of CI ROOT n -> ROOT m DIPOLE. CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:10462,config,configuration,10462,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['config'],['configuration']
Modifiability,"our Users; Output; Functionality; Specification Details; Misc. Running. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/interfacing-1.html:1616,config,configure,1616,psi4manual/1.3.2/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/interfacing-1.html,10,['config'],['configure']
Modifiability,"our/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/kw-1; testing best practices options, part i. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. Previous topic; MRCC; Next topic; LIBEFP. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Test Suite and Sample Inputs ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html:4606,variab,variables,4606,psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,2,['variab'],['variables']
Modifiability,"ource and you want simint built from; from source also,; enable it as a feature with ENABLE_simint,; and let the build system fetch and build it and activate dependent code. How to configure simint for building Psi4¶; Role and Dependencies. Role — In PSI4, simint is a library that provides alternate; integrals.; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) simint; Upstream Dependencies — simint \(\Leftarrow\) None. CMake Variables. ENABLE_simint — CMake variable toggling whether PSI4 builds with simint; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing include/simint/simint.h; simint_DIR — CMake variable to specify where pre-built simint can be found. Set to installation directory containing share/cmake/simint/simintConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_simint — CMake variable to force internal build of simint instead of detecting pre-built; SIMINT_VECTOR — CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is avx, not detected, so sse may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. Examples. Build bundled. >>> cmake -DENABLE_simint=ON. Build without simint. >>> cmake. Link against pre-built. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. table of contents. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/simint-1.html:2745,config,configdir,2745,psi4manual/1.1.0/simint-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/simint-1.html,4,['config'],"['configdir', 'configure']"
Modifiability,"ource, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; gau2grid can be obtained through conda install gau2grid -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gau2grid and activate dependent code. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabiliti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/gau2grid.html:1709,variab,variable,1709,psi4manual/master/gau2grid.html,https://psicode.org,https://psicode.org/psi4manual/master/gau2grid.html,1,['variab'],['variable']
Modifiability,"ource, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; gau2grid can be obtained through conda install gau2grid -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gau2grid and activate dependent code. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Inter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gau2grid-1.html:1700,variab,variable,1700,psi4manual/1.4.0/gau2grid-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gau2grid-1.html,2,['variab'],['variable']
Modifiability,"ource, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; gau2grid can be obtained through conda install gau2grid -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gau2grid and activate dependent code. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Inter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/gau2grid-1.html:1700,variab,variable,1700,psi4manual/1.5.0/gau2grid-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/gau2grid-1.html,2,['variab'],['variable']
Modifiability,"ource, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; gau2grid can be obtained through conda install gau2grid -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gau2grid and activate dependent code. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Inter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/gau2grid.html:1700,variab,variable,1700,psi4manual/1.6.x/gau2grid.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/gau2grid.html,1,['variab'],['variable']
Modifiability,"ource, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; gau2grid can be obtained through conda install gau2grid -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gau2grid and activate dependent code. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Inter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gau2grid.html:1700,variab,variable,1700,psi4manual/1.7.x/gau2grid.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gau2grid.html,1,['variab'],['variable']
Modifiability,"ource, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; gau2grid can be obtained through conda install gau2grid -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gau2grid and activate dependent code. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/gau2grid.html:1702,variab,variable,1702,psi4manual/1.8.x/gau2grid.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/gau2grid.html,1,['variab'],['variable']
Modifiability,"ource, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; gau2grid can be obtained through conda install gau2grid -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gau2grid and activate dependent code. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/gau2grid.html:1702,variab,variable,1702,psi4manual/1.9.x/gau2grid.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/gau2grid.html,1,['variab'],['variable']
Modifiability,"ource]¶; Set whether the coordinate value is fixed or not. class NumberValue(value, fixed=False)[source]¶; Specialization of CoordValue that is simply a number to be stored. clone()[source]¶; Returns new, independent NumberValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class VariableValue(name, geometryVariables, negate=False, fixed=False)[source]¶; Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. clone()[source]¶; Returns new, independent VariableValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. name()[source]¶; Gets the name of the variable. negated()[source]¶; Gets whether the coordinate value is actually the negative of the variable value. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class ZMatrixEntry(entry_number, Z, charge, mass, symbol, label, rto=None, rval=0, ato=None, aval=0, dto=None, dval=0)[source]¶; Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. clone()[source]¶; Returns new, independent ZMatrixEntry object. compute()[source]¶; Compute the Cartesian coordinates in Bohr of current atom’s entry. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. set_coordinates(x, y, z)[source]¶; Given the current set of coordinates, updates the values of this; atom’s coordinates, and any variables th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:38354,variab,variable,38354,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,6,['variab'],['variable']
Modifiability,"ource]¶; Set whether the coordinate value is fixed or not. class NumberValue(value, fixed=False)[source]¶; Specialization of CoordValue that is simply a number to be stored. clone()[source]¶; Returns new, independent NumberValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class VariableValue(name, geometryVariables, negate=False, fixed=False)[source]¶; Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. clone()[source]¶; Returns new, independent VariableValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. name()[source]¶; Gets the name of the variable. negated()[source]¶; Gets whether the coordinate value is actually the negative of the variable value. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class ZMatrixEntry(entry_number, Z, charge, mass, symbol, label, rto=None, rval=0, ato=None, aval=0, dto=None, dval=0, basis=None, shells=None)[source]¶; Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. clone()[source]¶; Returns new, independent ZMatrixEntry object. compute()[source]¶; Compute the Cartesian coordinates in Bohr of current atom’s entry. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. print_in_input_format_cfour()[source]¶; Prints the updated geometry, in the format provided by the user. set_coordin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:117701,variab,variable,117701,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['variab'],['variable']
Modifiability,"out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if not 'DF' in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; core.set_variable('CURRENT ENERGY', core.variable('SCS-MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; core.set_variable('CURRENT ENERGY', core.variable('MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. optstash.restore(); core.tstop(); return dfmp2_wfn. def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:82545,variab,variable,82545,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"out, log back in so conda and psi4 in path; >>> psi4 ""$(dirname $(which psi4))""/../share/psi4/samples/sapt1/test.in # test installation. works b/c PSI_SCRATCH defaults to /tmp. # Mac; >>> curl -o ""http://www.psicode.org/downloads/Psi4conda2-latest-MacOSX.sh"" --keepalive-time 2; >>> bash; >>> bash Psi4conda-latest-MacOSX.sh -b -p $HOME/psi4conda # agrees to license terms; >>> echo ""export PATH=$HOME/psi4conda/bin:\$PATH"" >> ~/.bash_profile; # log out, log back in so conda and psi4 in path; >>> psi4 ""$(dirname $(which psi4))""/../share/psi4/samples/sapt1/test.in # test installation. works b/c PSI_SCRATCH defaults to /tmp. That last command tested that psi4 is in your path, and it’s finding; all the libraries it needs. Now you need only specify a scratch directory; (see Scratch Files and Elementary Restart) by replacing the placeholder in the following:; >>> echo ""export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files"" >> ~/.bashrc; # log out, log back in so variable takes effect. All done!. Note; Above commands use bash for installation and set up your environment for bash at runtime. To use csh at runtime, follow the on-screen directions at the end of the installation or consult step 7 below. Conda Proficients¶; The Psi4conda Installer uses a conda constructor to package up Miniconda,; the psi4 conda packages, the psi4 add-on conda packages, dependencies; thereof (possibly from particular channels), and the psi4 channel; as a default. This is very convenient for novice users and robust; against differing channel settings in ~/.condarc. But proficient; conda users may prefer to treat psi4 as a normal conda package and; not have another large Miniconda installation (including the hefty MKL); lying around just for Psi4. Installing just the psi4 package; itself will get you Psi4, whatever add-ons require linking in to; Psi4 (e.g., CheMPS2 and PCMSolver), and the correct versions of; packages. However, just the psi4 package won’t get yo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/conda-1.html:3006,variab,variable,3006,psi4manual/1.0.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/conda-1.html,2,['variab'],['variable']
Modifiability,"owername = name.lower(); kwargs = kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). #def run_mp2_5(name, **kwargs):; # r""""""Function that computes MP2.5 energy from results of a FNOCC; # MP3 calculation.; #; # .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}; #; # :PSI variables: ; #; # .. hlist:: ; # :columns: 1 ; # ; # * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>` ; # * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` ; #; # >>> energy('mp2.5'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:2402,variab,variables,2402,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,2,['variab'],['variables']
Modifiability,ows() (built-in function). psi4.Matrix.save() (built-in function). psi4.Matrix.scale() (built-in function). psi4.Matrix.scale_column() (built-in function). psi4.Matrix.scale_row() (built-in function). psi4.Matrix.schmidt() (built-in function). psi4.Matrix.set() (built-in function). psi4.Matrix.set_name() (built-in function). psi4.Matrix.shape() (built-in function). psi4.Matrix.subtract() (built-in function). psi4.Matrix.sum_of_squares() (built-in function). psi4.Matrix.symmetrize_gradient() (built-in function). psi4.Matrix.symmetry() (built-in function). psi4.Matrix.to_array() (built-in function). psi4.Matrix.trace() (built-in function). psi4.Matrix.transform() (built-in function). psi4.Matrix.vector_dot() (built-in function). psi4.Matrix.zero() (built-in function). psi4.Matrix.zero_diagonal() (built-in function). psi4.Matrix.zero_lower() (built-in function). psi4.Matrix.zero_upper() (built-in function). psi4.matrix_vector.append() (built-in function). psi4.matrix_vector.extend() (built-in function). psi4.MatrixFactory.create_matrix() (built-in function). psi4.MatrixFactory.shared_object() (built-in function). psi4.mcscf() (built-in function). psi4.MintsHelper.ao_angular_momentum() (built-in function). psi4.MintsHelper.ao_erf_eri() (built-in function). psi4.MintsHelper.ao_eri() (built-in function). psi4.MintsHelper.ao_eri_shell() (built-in function). psi4.MintsHelper.ao_f12() (built-in function). psi4.MintsHelper.ao_f12_double_commutator() (built-in function). psi4.MintsHelper.ao_f12_scaled() (built-in function). psi4.MintsHelper.ao_f12_squared() (built-in function). psi4.MintsHelper.ao_f12g12() (built-in function). psi4.MintsHelper.ao_kinetic() (built-in function). psi4.MintsHelper.ao_nabla() (built-in function). psi4.MintsHelper.ao_overlap() (built-in function). psi4.MintsHelper.ao_potential() (built-in function). psi4.MintsHelper.basisset() (built-in function). psi4.MintsHelper.cdsalcs() (built-in function). psi4.MintsHelper.factory() (built-in function). psi4.Min,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:92517,extend,extend,92517,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['extend'],['extend']
Modifiability,"ozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set?. has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. has_variable(key)¶. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. legacy_frequencies()¶. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunction’s molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction) → int¶; Number of frozen core electrons. nirrep(self: psi4.core.Wavefunction) → int¶; Number of irreps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html:7214,variab,variable,7214,psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,6,['variab'],['variable']
Modifiability,"p for GS density; oe = core.OEProp(ccwfn); oe.set_title(""CC""); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")). n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:80491,variab,variable,80491,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"p(*args, **kwargs)¶; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.prop-1.html:1238,config,configurational,1238,psi4manual/1.3.2/api/psi4.driver.prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.prop-1.html,2,['config'],['configurational']
Modifiability,"p(self: psi4.core.Wavefunction) → int¶; Number of irreps in the system. nmo(self: psi4.core.Wavefunction) → int¶; Number of molecule orbitals. nmopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of molecular orbitals per irrep. no_occupations(self: psi4.core.Wavefunction) → List[List[Tuple[float, int, int]]]¶; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction) → int¶; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of symmetry orbitals per irrep. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. set_array(key, val)¶. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html:9188,variab,variable,9188,psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,9,['variab'],['variable']
Modifiability,"p. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential Q",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:6408,variab,variables,6408,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,12,['variab'],['variables']
Modifiability,"p. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstrin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:6237,variab,variables,6237,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['variab'],['variables']
Modifiability,"p. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:6156,variab,variables,6156,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variables']
Modifiability,"p.ndarray]]:; """"""Return all scalar or array QCVariables from global memory."""""". dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(cls, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from *cls*."""""". dicary = {**cls.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:33682,variab,variables,33682,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variables']
Modifiability,"p.ndarray]]:; """"""Return all scalar or array QCVariables from global memory."""""". dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(cls, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array QCVariables from *cls*."""""". dicary = {**cls.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:31459,variab,variables,31459,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,p; KMLYP Hyb-GGA Exchange-Correlation Functional. td-kmlyp; TDDFT KMLYP Hyb-GGA Exchange-Correlation Functional. ksdt; KSDT Exchange-Correlation Functional. td-ksdt; TDDFT KSDT Exchange-Correlation Functional. kt2; KT2 GGA Exchange-Correlation Functional. td-kt2; TDDFT KT2 GGA Exchange-Correlation Functional. lc-bop; LC-BOP GGA Exchange-Correlation Functional. td-lc-bop; TDDFT LC-BOP GGA Exchange-Correlation Functional. lc-vv10; LC-VV10 GGA Exchange-Correlation Functional. td-lc-vv10; TDDFT LC-VV10 GGA Exchange-Correlation Functional. lda0; LDA0 Exchange-Correlation Functional. td-lda0; TDDFT LDA0 Exchange-Correlation Functional. lrc-wpbe; LRC-WPBE GGA Exchange-Correlation Functional. td-lrc-wpbe; TDDFT LRC-WPBE GGA Exchange-Correlation Functional. lrc-wpbeh; LRC-wPBEh Hyb-GGA Exchange-Correlation Functional. td-lrc-wpbeh; TDDFT LRC-wPBEh Hyb-GGA Exchange-Correlation Functional. m05; M05 Meta-GGA XC Functional. td-m05; TDDFT M05 Meta-GGA XC Functional. m05-2x; Heavily Parameterized Hybrid M05-2X Meta-GGA XC Functional. td-m05-2x; TDDFT Heavily Parameterized Hybrid M05-2X Meta-GGA XC Functional. m05-2x-d3zero2b. m05-2x-d3zeroatm. m05-d3zero2b. m05-d3zeroatm. m06; M06 Meta-GGA XC Functional. td-m06; TDDFT M06 Meta-GGA XC Functional. m06-2x; Hybrid M06-2X Meta-GGA XC Functional. td-m06-2x; TDDFT Hybrid M06-2X Meta-GGA XC Functional. m06-2x-d3zero2b. m06-2x-d3zeroatm. m06-d3zero2b. m06-d3zeroatm. m06-hf; Minnesota M06-HF Hybrid XC Functional. td-m06-hf; TDDFT Minnesota M06-HF Hybrid XC Functional. m06-hf-d3zero2b. m06-hf-d3zeroatm. m06-l; M06-L Meta-GGA XC Functional. td-m06-l; TDDFT M06-L Meta-GGA XC Functional. m06-l-d3zero2b. m06-l-d3zeroatm. m08-hx; Minnesota M08-HX Hybrid XC Functional. td-m08-hx; TDDFT Minnesota M08-HX Hybrid XC Functional. m08-hx-d3zero2b. m08-hx-d3zeroatm. m08-so; Minnesota M08-SO Hybrid XC Functional. td-m08-so; TDDFT Minnesota M08-SO Hybrid XC Functional. m11; M11 Meta-GGA XC Functional. td-m11; TDDFT M11 Meta-GGA XC Functional. m11-d3bj2b. m1,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html:18977,Parameteriz,Parameterized,18977,psi4manual/1.7.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html,2,['Parameteriz'],['Parameterized']
Modifiability,"paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_dkh — CMake variable to force detecting pre-built dkh and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/dkh.html:3190,config,configdir,3190,psi4manual/1.6.x/dkh.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/dkh.html,2,['config'],"['configdir', 'configure']"
Modifiability,"pcmsolver/dft, and; pcmsolver/dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, zlib. CMake Variables. ENABLE_PCMSolver — CMake variable toggling whether Psi4 builds with PCMSolver; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing include/PCMSolver/pcmsolver.h; PCMSolver_DIR — CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing share/cmake/PCMSolver/PCMSolverConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_PCMSolver — CMake variable to force internal build of PCMSolver instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_PCMSolver — CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_PCMSolver=ON. Build without PCMSolver. >>> cmake. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to PCMSolver by R. Di Remigio. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/pcmsolver.html:4794,variab,variable,4794,psi4manual/1.6.x/pcmsolver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/pcmsolver.html,4,"['config', 'variab']","['configure', 'variable']"
Modifiability,"pd_interface(). timer_off(label); Stop timer with label. timer_on(label); Start timer with label. triplet(A, B, C[, transA, transB, transC]); Returns the multiplication of three matrices, with options to transpose each beforehand. tstart(); Start module-level timer. tstop(); Stop module-level timer. variable(key); Return copy of scalar or array QCVariable key from global memory. variables([include_deprecated_keys]); Return all scalar or array QCVariables from global memory. version(). Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CompositeJK; docstring. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ExternalPotential; St",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:10865,adapt,adapted,10865,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,1,['adapt'],['adapted']
Modifiability,"pdate() psi4.core.SOMCSCF method. update_density() psi4.core.TwoBodyAOInt method. update_geometry() psi4.core.Molecule method. psi4.driver.p4util.InPsight method. update_orbitals() psi4.core.IntegralTransform method. UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() psi4.core.HF method. Va() psi4.core.HF method. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute. validate_diis() psi4.core.HF method. validate_options() psi4.core.Options method. ValidationError. value psi4.core.DerivCalcType attribute. psi4.core.DiagonalizeOrder attribute. psi4.core.FragmentType attribute. psi4.core.GaussianType attribute. psi4.core.GeometryUnits attribute. psi4.core.PrimitiveType attribute. psi4.core.PsiReturnType attribute. psi4.core.SaveType attribute. value() psi4.core.SuperFunctional method. values() psi4.core.SuperFunctional method. variable() in module psi4.core. psi4.core.Wavefunction method. variables() in module psi4.core. psi4.core.Wavefunction method. Vb() psi4.core.HF method. VBase class in psi4.core. vdot() psi4.core.CIVector method. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class in psi4.core. Vector3 class in psi4.core. vector_axpy() psi4.driver.p4util.SolverEngine method. vector_copy() psi4.driver.p4util.SolverEngine method. vector_dot() psi4.core.Matrix method. psi4.core.Vector method. psi4.driver.p4util.SolverEngine static method. vector_multiply() psi4.core.CIVector method. vector_scale() psi4.driver.p4util.SolverEngine method. vectors() psi4.core.FISAPT method. verbose psi4.driver.driver_cbs.CompositeComputer attribute. version() in module psi4.core. vibanal_wfn() in module psi4.driver. vibrational analysis. ; function call. output. vir() psi4.core.MOSpace static method. visualization, [1]. VMDPATH. vmfc. ; setting keywords. vmfc psi4.driver.driver_nbody.BsseEnum attribute. vv10_b() psi4.core.SuperFunctional method. vv10_c() psi4.core.SuperFunctional method. Vvals() p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:125275,variab,variables,125275,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['variab'],['variables']
Modifiability,"pe. Type: string; Possible Values: NO, X2C; Default: NO. DKH_ORDER¶. Order of Douglas-Kroll-Hess. Type: integer; Default: 2. Reference¶; When using this code please make reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For dkh, set to an installation directory containing include/DKH/DKH_MANGLE.h; dkh_DIR — CMake variable to specify where pre-built dkh can be found. Set to installation directory containing share/cmake/dkh/dkhConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_dkh — CMake variable to force internal build of dkh instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_dkh=ON. Build without dkh. >>> cmake. Link against pre-built. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/dkh/root. >>> cmake -DENABLE_dkh=ON -Ddkh_DIR=/path/to/dkh/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_dkh=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/dkh/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_dkh=ON. table of contents. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; RELATIVISTIC; DKH_ORDER. Reference; How to configure dkh for building Psi4. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dkh-1.html:2734,variab,variable,2734,psi4manual/1.1.0/dkh-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dkh-1.html,6,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"pe. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. efp = core.get_active_efp(); efp_present = efp.nfragments() > 0. translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and; not core.get_option('SCF', 'PERTURB_H') and; not efp_present); rotations_projection_sound = (translations_projection_sound and; stationary_point). return translations_projection_sound, rotations_projection_sound. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type restart_file: string; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Binary data files to be renamed for calculation restart. .. _`table:energy_gen`:. +-------------------------+-----------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:4951,variab,variables,4951,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['variab'],['variables']
Modifiability,"pe; dict. tpdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool) → None¶; docstring. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:29672,variab,variable,29672,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,5,['variab'],['variable']
Modifiability,"pecific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:72164,variab,variables,72164,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['variab'],['variables']
Modifiability,"pectrum; in matplotlib. See the adcc calculations documentation; for details. Tips for convergence issues.; If you encounter convergence issues inside adcc, the following parameters; are worth tweaking:. MAX_NUM_VECS: Specifies the maximal number of subspace vectors; in the Jacobi-Davidson scheme before a restart occurs. The defaults are usually; good, but do not be shy to increase this value if you encounter convergence problems.; NUM_GUESSES: By default adcc uses twice as many guess vectors as; states to be computed. Sometimes increasing this value by a few vectors can be helpful.; If you encounter a convergence to zero eigenvalues, than decreasing this parameter might; solve the problems. Built-in ADC(2) code¶; Code author: Masaaki Saitow; Section author: Masaaki Saitow; The ADC code built into PSI4 is capable of ADC(2) computations; of singlet excited states only.; It makes use of the libtrans library for efficient and flexible; integral-transformation and also the libdpd library to; utilize molecular symmetry in the tensorial manipulations in framework; of the direct-product decomposition algorithm. By this feature, the Ritz; space and intermediate tensors are blocked according to the irreducible; representations of the point group, and the excited states that belong; to different symmetry are sought separately.; In the output of ADC, the ADC(2) results may look as follows:; -> 1 B1 state : 0.2565095 (a.u.), 6.9799824 (eV); Non-iterative: 0.2565636 (a.u.), 6.9814532 (eV); Occ Vir Coefficient; ---------------------------------------------; 3 0 -0.9017047264; 3 2 0.3038332241; 3 1 0.2907567119; 3 5 -0.0790167706; 3 4 -0.0425829926. Converged in 4 iteration.; Squared norm of the S component: 0.9315336; The S vector is rotated up to 8.102 (deg.). in which the ADC(2) excitation energy is indicated with arrow symbol; and the pseudo-perturbative value, which is calculated in very similar; fashion to the CIS(D) energy, is also presented on the following line. In; this i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/adc-1.html:12440,flexible,flexible,12440,psi4manual/1.4.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/adc-1.html,4,['flexible'],['flexible']
Modifiability,"pedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3742,plugin,plugin,3742,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,6,['plugin'],['plugin']
Modifiability,"peid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = core.get_datadir(); plugin_path = join_path(psidatadir, ""plugin""); for sdir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, sdir)):; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template : {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html:3712,plugin,plugin,3712,psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/pluginutil.html,6,['plugin'],['plugin']
Modifiability,"per irrep. no_occupations(self: psi4.core.Wavefunction) → List[List[Tuple[float, int, int]]]¶; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction) → int¶; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of symmetry orbitals per irrep. occupation_a(self: psi4.core.HF) → psi4.core.Vector¶; Returns the Alpha occupation numbers. occupation_b(self: psi4.core.HF) → psi4.core.Vector¶; Returns the Beta occupation numbers. onel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; One-electron Hessian-vector products. potential_variable(self: psi4.core.Wavefunction, key: str) → psi4.core.ExternalPotential¶; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction) → Dict[str, psi4.core.ExternalPotential]¶; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). print_energies()¶. print_header(self: psi4.core.HF) → None¶; docstring. print_orbitals(self: psi4.core.HF) → None¶; docstring. print_preiterations(small=False)¶. push_back_external_potential(self: psi4.core.HF, V: psi4.core.Matrix) → None¶; Add an external potential to the private external_potentials list. reference_wavefunction(self: psi4.core.Wavefunction) → psi4.core.Wavefunction¶; Returns the reference wavefunction. reset_occupation(self: psi4.core.HF) → None¶; docstring. rotate_orbitals(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; docstring. same_a_b_dens(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. save_density_and_energy(self: psi4.core.HF) → None¶; docstring. scalar_variable(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:27450,variab,variables,27450,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['variab'],['variables']
Modifiability,"per version). Type: integer; Default: 25. CFOUR_UNITS (CFOUR); CFOUR — Specifies the units used for molecular geometry input. ANGSTROM (= 0) uses Angstrom units, BOHR (= 1) specifies atomic units. Psi4 Interface: Keyword set from active molecule, always ANGSTROM. Type: string; Possible Values: ANGSTROM, BOHR; Default: ANGSTROM. CFOUR_UPDATE_HESSIAN (CFOUR); CFOUR — Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a FCMINT file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION (CFOUR); CFOUR — Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF, EXACT; Default: NO. CFOUR_VTRAN (CFOUR); CFOUR — This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the \((ab \vert cd)\) integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD (CFOUR);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:83366,adapt,adapted,83366,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['adapt'],['adapted']
Modifiability,"per version). Type: integer; Default: 25. CFOUR_UNITS (CFOUR); CFOUR — Specifies the units used for molecular geometry input. ANGSTROM (= 0) uses Angstrom units, BOHR (= 1) specifies atomic units. Psi4 Interface: Keyword set from active molecule, always ANGSTROM. Type: string; Possible Values: ANGSTROM, BOHR; Default: ANGSTROM. CFOUR_UPDATE_HESSIAN (CFOUR); CFOUR — Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a FCMINT file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION (CFOUR); CFOUR — Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF; Default: NO. CFOUR_VTRAN (CFOUR); CFOUR — This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the \((ab \vert cd)\) integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD (CFOUR); CFOUR ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:83147,adapt,adapted,83147,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['adapt'],['adapted']
Modifiability,"per version). Type: integer; Default: 25. CFOUR_UNITS (CFOUR); CFOUR — Specifies the units used for molecular geometry input. ANGSTROM (= 0) uses Angstrom units, BOHR (= 1) specifies atomic units. Psi4 Interface: Keyword set from active molecule, always ANGSTROM. Type: string; Possible Values: ANGSTROM, BOHR; Default: ANGSTROM. CFOUR_UPDATE_HESSIAN (CFOUR); CFOUR — Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a FCMINT file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION (CFOUR); CFOUR — Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF; Default: NO. CFOUR_VTRAN (CFOUR); CFOUR — This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD (CFOUR); CFOUR — Specifies the X-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:82821,adapt,adapted,82821,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['adapt'],['adapted']
Modifiability,"perFunctional)arg1) -> float :; | docstring; | ; | C++ signature :; | d x_omega(N3psi15SuperFunctionalE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi15SuperFunctionalEEE blank(); | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi15SuperFunctionalEEE build(Ss,i,i); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | Set equal to E; | ; | C++ signature :; | void E(N3psi17SymmetryOperationE {lvalue}); | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,N3psi17SymmetryOperationE); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_x(...); | ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:627252,inherit,inherited,627252,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"peration)arg1) -> float :; | Returns trace of transformation matrix; | ; | C++ signature :; | d trace(N3psi17SymmetryOperationE {lvalue}); | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | Performs the transform arg2 * arg1 * arg2~; | ; | C++ signature :; | N3psi17SymmetryOperationE transform(N3psi17SymmetryOperationE {lvalue},N3psi17SymmetryOperationE); | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | Performs transposition of matrix operation; | ; | C++ signature :; | void transpose(N3psi17SymmetryOperationE {lvalue}); | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | Set equal to a unit matrix; | ; | C++ signature :; | void unit(N3psi17SymmetryOperationE {lvalue}); | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | Zero out the symmetry operation; | ; | C++ signature :; | void zero(N3psi17SymmetryOperationE {lvalue}); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ThreeCenterOverlapInt(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ThreeCenterOverlapInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | compute_shell(...); | compute_shell( (ThreeCenterOverlapInt)arg1, (int)arg2, (int)arg3, (int)arg4) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi21ThreeCenterOverla",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:631295,inherit,inherited,631295,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"perposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. to_file([filename]); Converts a Wavefunction object to a base class. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbita",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:12127,variab,variables,12127,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,8,['variab'],['variables']
Modifiability,"perties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table above.; The syntax above works well for computing properties using the SCF; wavefunction, however, may be difficult (or impossible) to use for some of the; correlated levels of theory. Alternatively, one-electron properties can be; computed using the built-in property() function, e.g.:; property('ccsd', properties=['dipole']). The property() function provides limited functionality, but is a lot easier to; use for correlated methods. For capabilities of property() see the; corresponding section of the manual. Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; globa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/oeprop-1.html:2458,variab,variables,2458,psi4manual/1.0.0/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/oeprop-1.html,2,['variab'],['variables']
Modifiability,"pha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector; Returns the requested Beta Eigenvalues subset. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet; Returns the requested auxiliary basis. get_variable(self: psi4.core.Wavefunction, arg0: str) → float; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Wavefunctions gradient. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Wavefunctions Hessian. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction) → int; Number of frozen core electrons. nirrep(self: psi4.core.Wavefunction) → int; Number of irreps in the system. nmo(self: psi4.core.Wavefunction) → int; Number of molecule orbitals. n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html:16144,variab,variable,16144,psi4manual/1.1.0/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"phastr, betastr] specifies the absolute alpha and beta string numbers of the target determinant. This could be useful for trying to exclude states that have a nonzero CI coefficient for the given determinant. However, this option was experimental and may not be effective. Type: array; Default: No Default. FINAL_GEOM_WRITE (OPTKING); OPTKING — Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. FIRST_TMP_FILE (TRANSQT); TRANSQT — First temporary file. Type: integer; Default: 150. FITTING_ALGORITHM (CPHF); CPHF — Fitting algorithm (0 for old, 1 for new). Type: integer; Default: 0. FITTING_CONDITION (CPHF); CPHF — The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. FLEXIBLE_G_CONVERGENCE (OPTKING); OPTKING — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. FOCK_TOLERANCE (LMP2); LMP2 — Minimum absolute value below which parts of the Fock matrix are skipped. Type: conv double; Default: 1e-2. FOLLOW (STABILITY); STABILITY — Do follow the most negative eigenvalue of the Hessian towards a lower energy HF solution? Follow a UHF UHF instability of same symmetry?. Type: boolean; Default: false. FOLLOW_ROOT (CLAG); CLAG — Root to get OPDM. Type: integer; Default: 1. FOLLOW_ROOT (DETCI); DETCI — The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 1. FOLLOW_ROOT (MCSCF); MCSCF — Which solution of the SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FOLLOW_ROOT (PSIMRCC); PSIMRCC — Which root of the effective hamiltonian is the target state?. Type: inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:41815,flexible,flexible,41815,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,['flexible'],['flexible']
Modifiability,"pilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:3349,plugin,plugin,3349,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"piler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:. Ubuntu gfortran; conda gfortran_linux-64 or gfortran_osx-64 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gfortran_osx-64 conda package. This provides; gfortran compilers for Mac. The version is 4.8.5, which is quite old,; but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular systems.; Downstream Dependencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be “;”-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL.; OpenMP_LIBRARY_DIRS — CMake variable to specify OpenMP library (iomp5/gomp/omp) directories explicitly. Should be “;”-separated list of full directory paths. Usually the solution to error Could NOT find MathOpenMP. MKL_ROOT¶; Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location. MATH_ROOT¶; Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:40946,variab,variable,40946,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['variab'],['variable']
Modifiability,"piler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubuntu gfortran; conda gfortran_linux-64 or gfortran_osx-64 to get gfortran. How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew¶; Xcode does not provide a Fortran compiler. A way to get one is to download; the gfortran_osx-64 conda package. This provides; gfortran compilers for Mac. The version is 4.8.5, which is quite old,; but the Fortran compiler will work. How to configure BLAS/LAPACK for building Psi4¶; Role and Dependencies. Role — In PSI4, BLAS and LAPACK control much of the speed; and efficiency of the code since computational chemistry is essentially; linear algebra on molecular systems.; Downstream Dependencies — PSI4 \(\Leftarrow\) LAPACK Libraries. CMake Variables. BLAS_TYPE — CMake variable to specify which BLAS libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; LAPACK_TYPE — CMake variable to specify which LAPACK libraries to look for among MKL|OPENBLAS|ESSL|ATLAS|ACML|SYSTEM_NATIVE.; MKL_ROOT — Environment variable set by Intel compilervars scripts. Sufficient to trigger math detection of MKL at this location.; MATH_ROOT — Environment variable to specify root directory in which BLAS/LAPACK libraries should be detected (e.g., ${MATH_ROOT}/lib64/libblas.so and ${MATH_ROOT}/lib64/liblapack.so).; LAPACK_LIBRARIES — CMake variable to specify BLAS/LAPACK libraries explicitly, bypassing math detection. Should be “;”-separated list of full paths.; LAPACK_INCLUDE_DIRS — CMake variable to specify BLAS/LAPACK header location explicitly, bypassing math detection. Only needed for MKL.; OpenMP_LIBRARY_DIRS — CMake variable to specify OpenMP library (iomp5/gomp/omp) directories explicitly. Should be “;”-separated list of full directory paths. Usually the solution to error Could NOT find MathOpen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:37793,variab,variable,37793,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['variab'],['variable']
Modifiability,"ple.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; 1; 2; 3>>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/lib/psi4/core.cpython-{ext_will_vary}.so ../psi4/core.cpython-{ext_will_vary}.so; >>> python ../psi4/run_psi4.py --inplace input.dat. Why not to set PSIDATADIR¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is for developer use only. In PSI4 1.1; and beyond, the program always knows where its resources are, and the; only reason to set this variable is to point to another location.; Previously in PSI4 1.0 and previous, only installed executables knew; the location, so it always needed to be explicitly set when run from the; compilation directory.; At runtime; >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4. Or in the shell; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIDATADIR {top-level-psi4-dir}/psi4/share/psi4. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIDATADIR={top-level-psi4-dir}/psi4/share/psi4. How to configure C++ and C compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a C++ compiler is vital for building the code.; Downstream Dependencies — PSI4 \(\Leftarrow\) C++ Compiler. CMake Variables. CMAKE_CXX_COMPILER — CMake variable to specify name or full path to C++ compiler.; CMAKE_C_COMPILER — CMake variable to specify name or full path to C compiler.; CMAKE_CXX_FLAGS — CMake variable to specify any additiona",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:28816,variab,variable,28816,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['variab'],['variable']
Modifiability,"pled cluster code.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; sapt(...); sapt() -> float :; Runs the symmetry adapted perturbation theory code.; ; scf(...); scf( (object)arg1, (object)arg2) -> float :; Runs the SCF code.; ; scf() -> float :; Runs the SCF code.; ; scfgrad(...); scfgrad() -> int :; Run scfgrad, which is a specialized DF-SCF gradient program.; ; scfhess(...); scfhess() -> int :; Run scfhess, which is a specialized DF-SCF hessian program.; ; set_active_molecule(...); set_active_molecule( (Molecule)arg1) -> None :; Activates a previously defined (in the input) molecule, by name.; ; set_frequencies(...); set_frequencies( (Vector)arg1) -> None :; Assigns the global frequencies to the values stored in the 3N-6 Vector argument.; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; Sets a string option for all modules.; ; set_global_option( (str)arg1, (float)arg2) -> bool :; Sets a double option for all modules.; ; set_global_option( (str)arg1, (int)arg2) -> bool :; Sets an integer option for all modules.; ; set_global_option( (str)arg1, (list)arg2 [, (object",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:163386,adapt,adapted,163386,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['adapt'],['adapted']
Modifiability,"pled cluster code.; ; reopen_outfile(...); reopen_outfile() -> None :; Reopens the output file.; ; revoke_global_option_changed(...); revoke_global_option_changed( (str)arg1) -> None :; Given a string of a keyword name, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; revoke_local_option_changed(...); revoke_local_option_changed( (str)arg1, (str)arg2) -> None :; Given a string of a keyword name and a particular module, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option.; ; sapt(...); sapt() -> float :; Runs the symmetry adapted perturbation theory code.; ; scf(...); scf( (object)arg1, (object)arg2) -> float :; Runs the SCF code.; ; scf() -> float :; Runs the SCF code.; ; scfgrad(...); scfgrad() -> int :; Run scfgrad, which is a specialized DF-SCF gradient program.; ; set_active_molecule(...); set_active_molecule( (Molecule)arg1) -> None :; Activates a previously defined (in the input) molecule, by name.; ; set_global_option(...); set_global_option( (str)arg1, (str)arg2) -> bool :; Sets a string option for all modules.; ; set_global_option( (str)arg1, (float)arg2) -> bool :; Sets a double option for all modules.; ; set_global_option( (str)arg1, (int)arg2) -> bool :; Sets an integer option for all modules.; ; set_global_option( (str)arg1, (list)arg2 [, (object)arg3]) -> bool; ; set_global_option_python(...); set_global_option_python( (str)arg1, (object)arg2) -> bool :; Sets a global option to a Python object type.; ; set_gradient(...); set_gradient( (Matrix)arg1) -> None :; Assigns the global gradien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:113684,adapt,adapted,113684,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['adapt'],['adapted']
Modifiability,"ples; PSI Variables: Process::environment.globals lines and comments in the C++ code; Plugins: doc.rst text, *.py modules, and C++ keywords in psi4/tests/plugin_* plugin directories (disabled at the moment); PSI Files: scratch file names and numbers in psi4/psi4/include/psi4/psifiles.h. Some documentation is even extracted from PSI4 objects at runtime. psi4: docstrings for the psi4 built-in module constructed in psi4/psi4/src/psi4; DFT: functional availability and characteristics as encoded in psi4/psi4/driver/procedures/dft_functional.py; BasisFamily: fitting basis sets for each orbital basis as encoded in psi4/psi4/driver/qcdb/basislistdunning.py and psi4/psi4/driver/qcdb/basislistother.py. Building all the documentation takes ~15 minutes. There is now good; dependency structure built into the psi4/doc/sphinxman/CMakeLists.txt; , so very long builds should be infrequent (unless you’re touching; psi4/psi4/src/read_options.cc or the driver. Note that not all dependencies are; encoded (PSI variables, for instance, depend on every .cc file in the; source tree), so for a definitive doc build, remove (in the object; directory) doc/sphinxman and start from scratch.; Even ~15 minutes of build time can be annoying when developing; documentation and testing rst files. In that situation, use the target; below which builds only the written docs (not autodocs) in; psi4/doc/sphinxman/source quickly, though with a lot of warnings for; unresolved links:; 1>>> make sphinxmini. reStructuredText¶; Sphinx files are written in reStructuredText (*.rst). In the html; documentation, source code is available from the sidebar. Here are a; few resources on Sphinx formatting. reStructuredText; rendered test document; vs. source test document; A third reStructuredText and Sphinx; Sphinx Docs. Math in the Codebase¶; It is often useful to have mathematical expressions in docstrings or; comments in the code that are auto-documented into the manual. Such; locations include the #! comment comments",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/documentation-1.html:3338,variab,variables,3338,psi4manual/1.2.1/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/documentation-1.html,6,['variab'],['variables']
Modifiability,"ployed ('on') or whether it is forced to \(C_1\) symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (string) – \(\Rightarrow\) 'default' \(\Leftarrow\) || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (string or array of strings) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'; Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || 'HB' || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the databas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:4281,flexible,flexible,4281,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,6,['flexible'],['flexible']
Modifiability,"plugin directory; >>> make # compile the plugin to product testplugin.so; >>> psi4 # run sample input.dat; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; Psi4 code is not necessary.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of Psi4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main Psi4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:5908,plugin,plugin,5908,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:. # Skip swp files; if source_file.endswith("".swp""):; continue. target_file = source_file. if source_file.endswith('.template'):; target_file = source_file[0:-9]. try:; print(template_path / source_file); contents = (template_path / source_file).read_text(); except IOError as err:; tty.error(""""""Unable to open {} template."""""".format(source_file)); tty.error(err); sys.exit(1). contents = contents.replace('@plugin@', name); contents = contents.replace('@Plugin@', name.capitalize()); contents = contents.replace('@PLUGIN@', name.upper()); contents = contents.replace('@sources@', ' '.join(source_files)). try:; (Path(name) / target_file).write_text(contents); created_files.append(target_file); except IOError as err:; tty.error(""""""Unable to create {}"""""".format(target_file)); tty.error(err); sys.exit(1). tty.info(""Created plugin files (in {} as {}): "".format(name, template), "", "".join(created_files)). sys.exit(0). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.pluginutil. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html:5074,plugin,plugin,5074,psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html,8,"['PLUGIN', 'Plugin', 'plugin']","['PLUGIN', 'Plugin', 'plugin', 'pluginutil']"
Modifiability,"plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:4920,plugin,plugin,4920,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/tests/plugin_backtrans/backtrans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mp2/mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:3273,plugin,plugin,3273,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,8,['plugin'],"['plugin', 'plugins']"
Modifiability,"plugins or databases.; Modify PSIPATH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIPATH /home/user/psiadditions:/home/user/gbs. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIPATH=/home/user/psiadditions:/home/user/gbs. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins or databases. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands.; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH=/home/user/psiadditions:$PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every PSI4 instance.; 1sys.path.insert(0, '/home/user/psiadditions'). Place the path in the input file, either absolute or relative.; 1; 2sys.path.insert(0, '../../psiadditions'); sys.path.insert(0, '/home/user/psiadditions'). PSIDATADIR¶; Path in which the PSI4 executable looks for its non-compiled; dependencies (i.e., basis sets, databases, quadratures, etc.).; This path is always known by the PSI4 program or shared library,; so this variable is relevant primarily to developers wanting a; non-standard location. Value should be set; to directory containing driver, basis, etc. directories, generally; ending in share/psi4. table of contents. Installation and Runtime Configuration; Scratch Files and Elementary Restart; ~/.psi4rc File; Threading; PBS job file; Command Line Options; Environment Variables. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/external-1.html:21414,variab,variable,21414,psi4manual/1.2.1/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/external-1.html,2,['variab'],['variable']
Modifiability,"plus CT :ref:`[manual] <sec:saptct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc | 2nd-order algebraic diagrammatic construction (ADC), deprecated :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(1) | (with ADCC) 1st-order algebraic diagrammatic construction (ADC) :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(2) | (with ADCC) 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(2)-x | (with ADCC) extended 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | adc(3) | (with ADCC) 3rd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(1) | (with ADCC) core-valence separation (CVS) 1st-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(2) | (with ADCC) CVS 2nd-order ADC :ref:`[manual] <sec:adc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cvs-adc(2)-x | (with ADCC) CVS extended 2nd-order A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:32563,extend,extended,32563,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['extend'],['extended']
Modifiability,"point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; Only returns if Zmat or variable input. """"""; text = """"; if self.nallatom():; # It's only worth echoing these if the user either input some variables,; # or they used a Z matrix for input; if self.full_atoms[0].type() == 'ZMatrixCoord' or len(self.geometry_variables):; text += """"""\n\tFinal optimized geometry and variables (in %s):\n\n"""""" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""bohr""); for i in range(self.nallatom()):; text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""\t%-10s=%16.10f\n"""""" % (vb, val); text += ""\n""; print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:27813,variab,variables,27813,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['variab'],['variables']
Modifiability,"polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. Plugin v2rdm_casscf by A. E. DePrince; Installation. Interface to Libxc by M. A. L. Marques; Installation; How to configure Libxc for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/interfacing-1.html:2265,config,configure,2265,psi4manual/1.5.0/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/interfacing-1.html,2,['config'],['configure']
Modifiability,"pole [Debye Ang] for the requested; configuration interaction level of theory and root.; Deprecated in favor of CI QUADRUPOLE. CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory.; Deprecated in favor of CI ROOT n -> ROOT m DIPOLE. CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory.; Deprecated in favor of CI ROOT n -> ROOT m QUADRUPOLE. CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n.; Deprecated in favor of CI ROOT n DIPOLE. CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n.; Deprecated in favor of CI ROOT n QUADRUPOLE. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:11865,config,configuration,11865,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['config'],['configuration']
Modifiability,"port *; from psi4 import core; isP4regime = True; except ImportError:; from .exceptions import *; isP4regime = False; from .dashparam import *; from .molecule import Molecule. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html:2301,extend,extended,2301,psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,1,['extend'],['extended']
Modifiability,"port. For; PSI4, these are generally plugins or databases.; Modify PSIPATH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIPATH /home/user/psiadditions:/home/user/gbs. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIPATH=/home/user/psiadditions:/home/user/gbs. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins or databases. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands.; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH=/home/user/psiadditions:$PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every PSI4 instance.; 1sys.path.insert(0, '/home/user/psiadditions'). Place the path in the input file, either absolute or relative.; 1; 2sys.path.insert(0, '../../psiadditions'); sys.path.insert(0, '/home/user/psiadditions'). PSIDATADIR¶; Path in which the PSI4 executable looks for its non-compiled; dependencies (i.e., basis sets, databases, quadratures, etc.).; This path is always known by the PSI4 program or shared library,; so this variable is relevant primarily to developers wanting a; non-standard location. Value should be set; to directory containing driver, basis, etc. directories, generally; ending in share/psi4. table of contents. Installation and Runtime Configuration; Scratch Files and Elementary Restart; ~/.psi4rc File; Threading; PBS job file; Command Line Options; Environment Variables. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:21303,variab,variable,21303,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,2,['variab'],['variable']
Modifiability,"pped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:15396,adapt,adapted,15396,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['adapt'],['adapted']
Modifiability,"pped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multipli",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:13106,adapt,adapted,13106,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['adapt'],['adapted']
Modifiability,"pped. For example, reducing the symmetry to; (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as:. SOCC = [0, 1]; Some caution is required, however. The state can be obtained with; the. SOCC = [1, 0, 0, 0]; specification, which would become. SOCC = [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; Psi4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. Psi4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:13592,adapt,adapted,13592,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['adapt'],['adapted']
Modifiability,"pposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on Orbital-Optimized Methods,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:15067,extend,extended,15067,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,17,['extend'],['extended']
Modifiability,"pproximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the closed-shell SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency.; The latest addition to the SAPT code is the SAPT0 method for open-shell; monomers [Gonthier:2016:134106]. This code is available for both exact and density fitted integrals,; except for the dispersion terms which implementation relies on a density fitting; factorization. Both UHF and ROHF REFERENCE can be used, but coupled; induction computations are currently not supported with ROHF. This means that orbital; relaxation is not included for ROHF and the uncoupled induction term is computed instead.; If both monomers are open-shell, their coupling is assumed to be high spin, i.e.; two doublets would interact to form a triplet. The S2 approximation and scaling¶; All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and B. Taking into account exchange of all possible; electron pairs between the two monomers yields to complicated formulae.; For this reason, exchange terms are often evaluated in the \(S^{2}\); approximation, that can be interpreted as the exchange of a single electron; pair between monomers.; The \(S^{2}\) approximation is usually pretty good, but may; break down for short intermolecular distance, particularly in high-order; terms. To compensate for these deviations, in 2014 Parker et al. [Parker:2014:094106]; recommended to scale all \(S^{2}\) approximated exchange terms by the ratio:. \[p_{EX}(\alpha) = \left( \frac{E_{exch}^{(10)}}{E_{exch}^{(10)}(S^{2})} \right)^{\alpha}\]; and recommended using the ratio with exponent \(\alpha = 1\). To obtain SAPT energies w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/sapt.html:9446,coupling,coupling,9446,psi4manual/1.9.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/sapt.html,2,['coupling'],['coupling']
Modifiability,"pproximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the closed-shell SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency.; The latest addition to the SAPT code is the SAPT0 method for open-shell; monomers [Gonthier:2016:134106]. This code is available for both exact and density fitted integrals,; except for the dispersion terms which implementation relies on a density fitting; factorization. Both UHF and ROHF REFERENCE can be used, but coupled; induction computations are currently not supported with ROHF. This means that orbital; relaxation is not included for ROHF and the uncoupled induction term is computed instead.; If both monomers are open-shell, their coupling is assumed to be high spin, i.e.; two doublets would interact to form a triplet. The S2 approximation and scaling¶; All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and B. Taking into account exchange of all possible; electron pairs between the two monomers yields to complicated formulae.; For this reason, exchange terms are often evaluated in the \(S^{2}\); approximation, that can be interpreted as the exchange of a single electron; pair between monomers.; The \(S^{2}\) approximation is usually pretty good, but may; break down for short intermolecular distance, particularly in high-order; terms. To compensate these deviations, Parker et al. [Parker:2014:094106]; recommend to scale all \(S^{2}\) approximated exchange terms by the ratio:. \[p_{EX}(\alpha) = \left( \frac{E_{exch}^{(10)}}{E_{exch}^{(10)}(S^{2})} \right)^{\alpha}\]; where the recommended exponent is \(\alpha = 1\). To obtain SAPT energies with this scaling,; simply ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:6326,coupling,coupling,6326,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,13,['coupling'],['coupling']
Modifiability,"precated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self); docstring. cleanup_ci(self); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, ...); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:2601,variab,variable,2601,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,2,['variab'],['variable']
Modifiability,"previous file can; be provided through the``restart_file`` option; energy('scf',restart_file='./psi.PID.name.filenumber'). Only the filenumber is necessary for the driver to appropriately rename the; file and copy it to the scratch directory where PSI4 will expect it.; The restart capabilities of a specific method (if any) are found in that method’s documentation.; To provide multiple files, pass them as arguments of a Python list; energy('scf',restart_file=['./file1.filenumber','./file2.filenumber']). Note that the restart_file options is only available for energy procedures as of now.; Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. The mechanism for restarting HF/DFT calculations is described in details here. Saving the Wavefunction¶; A core object of PSI4 is the Wavefunction (short wfn) object; energy, wfn = energy('scf',return_wfn=True). This C++/Python object (psi4.core.Wavefunction) contains orbital; data, basis set information, result variables and more.; It can be saved either to a numpy file or converted to a python dictionary; # write the wavefunction to file; wfn.to_file('my_wfn'). # alternatively store the dict representation of the wavefunction in memory; wfn_dict = wfn.to_file(). In either form, its attributes can be set and edited.; This is an expert-level feature, though.; In general, let PSI4 create the Wavefunction, then treat it as read-only.; The back conversion to a Wavefunction object uses the .from_file() functionality; # read wavefunction from file; wfn_from_file = psi4.core.Wavefunction.from_file('my_wfn'). # make a wavefunction from the dict; wfn_from_dict = psi4.core.Wavefunction.from_file(wfn_dict). ~/.psi4rc File¶. Caution; The ~/.psi4rc file is only read for Psithon input, not PsiAPI.; It does nothing that can’t be done in other more transparent ways.; It should be avoided.; It is very easy to forget about the ~/.psi4rc file you once; created, leading to great confusion",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:8565,variab,variables,8565,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['variab'],['variables']
Modifiability,"print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135644,variab,variable,135644,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for envv in db_tabulate:; tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:46549,variab,variable,46549,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['variab'],['variable']
Modifiability,"problem with icpc 12.0.2 and possibly earlier; 12.0 versions, giving an error like:; error: identifier ""__is_trivial"" is undefined. Use at least version 12.0.4. g++, optimized; ../configure --prefix=/usr/local/psi4. g++, for debugging; ../configure --prefix=/usr/local/psi4 --without-opt --with-debug. Compiling for Mac; PSI4 has been compiled on OS X 10.7 (Lion) and 10.8 (Mountain Lion).; To get the compilers needed, it’s easiest to install XCode.; However, XCode does not provide a Fortran compiler. Although; Fortran compilers are not needed to compile Psi, a broken one can; prevent Psi from configuring properly. Do not download the latest; version of GFortran from the HPC website; this is unlikely to be; compatible with your version of GCC. Instead, you should run gcc; -v to find out what version of GCC you’re using, and then; download the corresponding GFortran from; http://r.research.att.com/tools/. If you configure Psi on a Mac; without any Fortran compiler it will set itself up correctly, so; this is only necessary if you want a Fortran compiler for other; purposes. You can configure Psi by adding something like; ../configure --with-plugins. to the do-configure script. If you want to use the new LLVM compilers that; ship with XCode 4 (they compile quicker than GCC), use; ../configure --with-plugins --with-cxx=llvm-g++. Warning; If you still happen to encouter an error like:; checking Fortran symbols... giving up; configure: error: could not determine fortran symbol names. adding the following tag to your configure may help; --with-f77symbol=lcu. List of Specific Configuration Options; The example configuration options in the previous subsection are usually; sufficient. However, if not, you may need to make use of one or more; of the following options to the configure script:. --prefix=directory — Use this option if you wish to install the; PSI4 package somewhere other than the default directory, /usr/local/psi. --with-cxx=compiler — Use this option to specify a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:8940,config,configure,8940,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,1,['config'],['configure']
Modifiability,"problems with the stability of the correlation hole. Don’t worry, it; will definitely NaN on you if you try to use it.; Meta Functionals; We have recently implemented the M05 classes of meta functionals in; PSI4. Note that these functionals are not appropriate for modeling; dispersion interactions, as they lack dispersion physics. A -D functional (Such; as the much cheaper B97-D) should be used instead.; Hybrid Functionals; Many common hybrid functionals, including the ubiquitous B3LYP. PBE0 and the; B97 series are also quite good for many thermochemical problems.; LRC Functionals; LRC functionals are a particular area of interest of the PSI4 DFT team.; LRC functionals are all denoted by a lower-case “w” in front of the standard DFA; functional, such as wPBE. We offer a stable implementation of the Gill; association function for wS and Head-Gordon’s wB97/wB97X functionals.; Additionally, we are pleased to have recently completed a heavily conditioned; implementation of the HJS exchange-hole model, which provides an analytical form; for the short-range enhancement factor for wPBE, wPBEsol, and wB88. From a; physics perspective, this implementation of wPBE is extremely useful for; theoretical investigations, as it is parameter free, and properly integrated; against the partition function in the exchange hole. We would like to thank Dr.; Scuseria for providing helpful advice and a reference implementations of the; older HSE exchange-hole model which led to the successful implementation of the; HJS model.; -D Functionals; We have several -D2 functionals implemented, and will shortly be adding many; more combinations of -D2 and -D3 functionals. For now, the pure-GGA B97-D; functional of Grimme is remarkably accurate, and the hybrid B3LYP-D; functional is also quite reliable. Note: we have made a sincere effort to rigorously test all functionals; implemented in PSI4 for both numerical stability and correctness. If you; observe any unexpected results, please email Rob Parr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dft-1.html:13233,enhance,enhancement,13233,psi4manual/4.0b2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dft-1.html,2,['enhance'],['enhancement']
Modifiability,"problems with the stability of the correlation hole. Don’t worry, it; will definitely NaN on you if you try to use it.; Meta Functionals; We have recently implemented the M05 classes of meta functionals in; PSI4. Note that these functionals are not appropriate for modeling; dispersion interactions, as they lack dispersion physics. A -D functional (Such; as the much cheaper B97-D) should be used instead.; Hybrid Functionals; Many common hybrid functionals, including the ubiquitous B3LYP. PBE0 and the; B97 series are also quite good for many thermochemical problems.; LRC Functionals; LRC functionals are a particular area of interest of the PSI4 DFT team.; LRC functionals are all denoted by a lower-case “w” in front of the standard DFA; functional, such as wPBE. We offer a stable implementation of the Gill; association function for wS and Head-Gordon’s wB97/wB97X functionals.; Additionally, we are pleased to have recently completed a heavily conditioned; implementation of the HJS exchange-hole model, which provides an analytical form; for the short-range enhancement factor for wPBE, wPBEsol, and wB88. From a; physics perspective, this implementation of wPBE is extremely useful for; theoretical investigations, as it is parameter free, and properly integrated; against the partition function in the exchange hole. We would like to thank Dr.; Scuseria for providing helpful advice and a reference implementations of the; older HSE exchange-hole model which led to the successful implementation of the; HJS model.; Double-Hybrid Functionals; Double hybrids are percolating into PSI4. Note that these are; only available with density-fitted, not conventional, MP2 algorithms.; -D Functionals; We have several -D2 functionals implemented. -D3 functionls are available; with the installation of Grimme’s DFTD3 program.; For now, the pure-GGA B97-D; functional of Grimme is remarkably accurate, and the hybrid B3LYP-D; functional is also quite reliable. Note: we have made a sincere effort t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:17462,enhance,enhancement,17462,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['enhance'],['enhancement']
Modifiability,"problems with the stability of the correlation hole. Don’t worry, it; will definitely NaN on you if you try to use it.; Meta Functionals; We have recently implemented the M05 classes of meta functionals in; PSI4. Note that these functionals are not appropriate for modeling; dispersion interactions, as they lack dispersion physics. A -D functional (Such; as the much cheaper B97-D) should be used instead.; Hybrid Functionals; Many common hybrid functionals, including the ubiquitous B3LYP. PBE0 and the; B97 series are also quite good for many thermochemical problems.; LRC Functionals; LRC functionals are a particular area of interest of the PSI4 DFT team.; LRC functionals are all denoted by a lower-case “w” in front of the standard DFA; functional, such as wPBE. We offer a stable implementation of the Gill; association function for wS and Head-Gordon’s wB97/wB97X functionals.; Additionally, we are pleased to have recently completed a heavily conditioned; implementation of the HJS exchange-hole model, which provides an analytical form; for the short-range enhancement factor for wPBE, wPBEsol, and wB88. From a; physics perspective, this implementation of wPBE is extremely useful for; theoretical investigations, as it is parameter free, and properly integrated; against the partition function in the exchange hole. We would like to thank Dr.; Scuseria for providing helpful advice and a reference implementations of the; older HSE exchange-hole model which led to the successful implementation of the; HJS model.; Double-Hybrid Functionals; Double hybrids are percolating into PSI4. Note that these are; only available with density-fitted, not conventional, mp2 algorithms.; -D Functionals; We have several -D2 functionals implemented, -D3 functionls are available; with the installation of Grimme’s DFTD3 program, and we; will shortly be adding many; more combinations of -D2 and -D3 functionals. For now, the pure-GGA B97-D; functional of Grimme is remarkably accurate, and the hybrid",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dft-1.html:13258,enhance,enhancement,13258,psi4manual/4.0b3/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dft-1.html,6,['enhance'],['enhancement']
Modifiability,"problems with the stability of the correlation hole. Don’t worry, it; will definitely NaN on you if you try to use it.; Meta Functionals; We have recently implemented the M05 classes of meta functionals in; PSI4. Note that these functionals are not appropriate for modeling; dispersion interactions, as they lack dispersion physics. A -D functional (Such; as the much cheaper B97-D) should be used instead.; Hybrid Functionals; Many common hybrid functionals, including the ubiquitous B3LYP. PBE0 and the; B97 series are also quite good for many thermochemical problems.; LRC Functionals; LRC functionals are a particular area of interest of the PSI4 DFT team.; LRC functionals are all denoted by a lower-case “w” in front of the standard DFA; functional, such as wPBE. We offer a stable implementation of the Gill; association function for wS and Head-Gordon’s wB97/wB97X functionals.; Additionally, we are pleased to have recently completed a heavily conditioned; implementation of the HJS exchange-hole model, which provides an analytical form; for the short-range enhancement factor for wPBE, wPBEsol, and wB88. From a; physics perspective, this implementation of wPBE is extremely useful for; theoretical investigations, as it is parameter free, and properly integrated; against the partition function in the exchange hole. We would like to thank Dr.; Scuseria for providing helpful advice and a reference implementations of the; older HSE exchange-hole model which led to the successful implementation of the; HJS model.; Double-Hybrid Functionals; Double hybrids are percolating into PSI4. Note that these are; only available with density-fitted, not conventional, mp2 algorithms.; -D Functionals; We have several -D2 functionals implemented. -D3 functionls are available; with the installation of Grimme’s DFTD3 program.; For now, the pure-GGA B97-D; functional of Grimme is remarkably accurate, and the hybrid B3LYP-D; functional is also quite reliable. Note: we have made a sincere effort t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:17445,enhance,enhancement,17445,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,4,['enhance'],['enhancement']
Modifiability,"problems with the stability of the correlation hole. Don’t worry, it; will definitely NaN on you if you try to use it.; Meta Functionals; We have recently implemented the M05 classes of meta functionals in; PSI4. Note that these functionals are not appropriate for modeling; dispersion interactions, as they lack dispersion physics. A -D functional (Such; as the much cheaper B97-D) should be used instead.; Hybrid Functionals; Many common hybrid functionals, including the ubiquitous B3LYP. PBE0 and the; B97 series are also quite good for many thermochemical problems.; LRC Functionals; LRC functionals are a particular area of interest of the Psi4 DFT team.; LRC functionals are all denoted by a lower-case “w” in front of the standard DFA; functional, such as wPBE. We offer a stable implementation of the Gill; association function for wS and Head-Gordon’s wB97/wB97X functionals.; Additionally, we are pleased to have recently completed a heavily conditioned; implementation of the HJS exchange-hole model, which provides an analytical form; for the short-range enhancement factor for wPBE, wPBEsol, and wB88. From a; physics perspective, this implementation of wPBE is extremely useful for; theoretical investigations, as it is parameter free, and properly integrated; against the partition function in the exchange hole. We would like to thank Dr.; Scuseria for providing helpful advice and a reference implementations of the; older HSE exchange-hole model which led to the successful implementation of the; HJS model.; Double-Hybrid Functionals; Double hybrids are percolating into Psi4. Note that these are; only available with density-fitted, not conventional, mp2 algorithms.; -D Functionals; We have several -D2 functionals implemented, -D3 functionls are available; with the installation of Grimme’s DFTD3 program, and we; will shortly be adding many; more combinations of -D2 and -D3 functionals. For now, the pure-GGA B97-D; functional of Grimme is remarkably accurate, and the hybrid",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:13343,enhance,enhancement,13343,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['enhance'],['enhancement']
Modifiability,"proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:86444,variab,variables,86444,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variables']
Modifiability,"process_from_file_command() in module inputparser. PROCESS_GRID (SCF). process_input() in module inputparser. process_literal_blocks() in module inputparser. process_memory_command() in module inputparser. process_molecule_command() in module inputparser. process_multiline_arrays() in module inputparser. process_option() in module inputparser. process_pcm_command() in module inputparser. process_print_command() in module inputparser. process_pubchem_command() in module inputparser. process_set_command() in module inputparser. process_set_commands() in module inputparser. process_word_quotes() in module inputparser. promote_Subset() Database method. prop(); . see property(); . PROP_ALL (CCDENSITY). (CCLAMBDA). PROP_ROOT (CCDENSITY). (CCEOM). (CCLAMBDA). PROP_SYM (CCDENSITY). (CCEOM). (CCLAMBDA). PROPERTIES (GLOBALS). PROPERTIES_ORIGIN (GLOBALS). PROPERTY (CCENERGY). (CCRESPONSE). (CCSORT). property(); . setting keywords. property() in module driver. psi4 command line option; . --new-plugin <name>. -V, --version. -a, --append. -d, --debug. -h, --help. -i <filename>, --input <filename>. -l <name>, --psidatadir <name>. -m, --messy. -n <threads>, --nthread <threads>. -o <filename>, --output <filename>. -p <prefix>, --prefix <prefix>. -s <name>, --scratch <name>. -v, --verbose. -w, --wipe. psi4.adc() (built-in function). psi4.AngularMomentumInt.basis() (built-in function). psi4.AngularMomentumInt.basis1() (built-in function). psi4.AngularMomentumInt.basis2() (built-in function). psi4.AngularMomentumInt.compute_shell() (built-in function). psi4.AngularMomentumInt.origin() (built-in function). psi4.AngularMomentumInt.py_buffer() (built-in function). psi4.AngularMomentumInt.py_buffer_object() (built-in function). psi4.AngularMomentumInt.set_enable_pybuffer() (built-in function). psi4.AOShellCombinationsIterator.first() (built-in function). psi4.AOShellCombinationsIterator.is_done() (built-in function). psi4.AOShellCombinationsIterator.next() (built-in function). psi4.AOShellC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:60595,plugin,plugin,60595,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['plugin'],['plugin']
Modifiability,"program to handle more; general CI wavefunctions which may be helpful in more challenging cases; such as highly strained molecules or bond breaking reactions. The CI; code is based on the fast, determinant-based string formalism; of Handy [Handy:1980]. It can solve for restricted active space; configuration interaction (RAS CI) wavefunctions as described by Olsen,; Roos, Jorgensen, and Aa. Jensen [Olsen:1988]. Excitation-class; selected multi-reference CI wavefunctions, such as second-order CI,; can be formulated as RAS CI’s. A RAS CI selects determinants for the; model space as those which have no more than holes in the lowest set; of orbitals (called RAS I) and no more than electrons in the highest; set of orbitals (called RAS III). An intermediate set of orbitals, if; present (RAS II), has no restrictions placed upon it. All determinants; satisfying these rules are included in the CI.; The DETCI module is also very efficient at computing full configuration; interaction; wavefunctions, and it is used in this capacity in the complete-active-space; self-consistent-field (CASSCF) code. Use of DETCI for CASSCF; wavefunctions is described in another section of this manual.; As just mentioned, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; The division of the molecular orbitals into various subspaces such as; RAS ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:2780,config,configuration,2780,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,10,['config'],['configuration']
Modifiability,"provides; many of the benefits of integral-direct SCF algorithms, including no disk I/O,; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with system size; while simultaneously providing a formally-exact computation of the; Exchange term. See Linear Exchange for more information. SNLINKAn algorithm based on the “seminumerical Linear Exchange” (sn-LinK); approach described in [Laqua:2020:1456], SNLINK is only available if PSI4; is compiled with the GauXC library, described in [Williams-Young:2023:234104].; Algorithmically, SNLINK is very similar to COSX, differing primarily in screening of; the analytic 3-center integrals. In terms of implementation, SNLINK is more efficient,; owing to more highly-optimized integral contraction kernels; and supports execution; on Graphics Processing Units (GPUs). See Seminumerical Linear Exchange for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert user",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:31074,config,configurations,31074,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,1,['config'],['configurations']
Modifiability,"psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to Psi4 for available templates. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; >>> psi4 --version; 0.4.262. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence Psi4‘s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring Psi4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that Psi4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh; >>> setenv PSI_SCRATCH /scratch/user. # bash; >>> export PSI_SCRATCH=/scratch/user. You can also include the above commands in the respective rc file, i.e.; ~/.tcshrc for csh and tcsh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:15644,variab,variable,15644,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['variab'],['variable']
Modifiability,"psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:13560,variab,variable,13560,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,1,['variab'],['variable']
Modifiability,"psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html:13634,variab,variable,13634,psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,4,['variab'],['variable']
Modifiability,"psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns; Whether some form of DIIS is enabled during SCF. Return type; bool. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:35221,variab,variables,35221,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,10,['variab'],['variables']
Modifiability,"psi4.core.Matrix) → None¶; Returns the requested internal array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp) → None¶; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html:8927,variab,variable,8927,psi4manual/1.1.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.cuhf.html,12,['variab'],"['variable', 'variables']"
Modifiability,"psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:42939,variab,variable,42939,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variable"", ""psi4.core.variable"", 1.9, f"" Replace `get_variable` with `variable` (or `scalar_variable` for scalar variables only).""). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_variables` with `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only).""). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variable"", ""psi4.core.variable"", 1.9, f"" Replace `psi4.core.get_array_variable` with `psi4.core.variable` (or `psi4.core.array_variable` for array variables only).""). def ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:45008,variab,variable,45008,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"psi4.core.Molecule, arg0: int) → None; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list) → None; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float) → None; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float) → None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None; Translates molecule by arg1. units; Units (Angstrom or Bohr) used to define the geometry. update_geometry(self: psi4.core.Molecule) → None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int) → float; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int) → float; z position of atom arg1 (0-indexed in Bohr). Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:32239,variab,variable,32239,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['variab'],['variable']
Modifiability,"psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. variable(key)¶. variables()¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html:11174,inherit,inherited,11174,psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,6,"['inherit', 'variab']","['inherited', 'variable', 'variables']"
Modifiability,"psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:35996,variab,variable,35996,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,6,['variab'],['variable']
Modifiability,"psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([('libdisp', ['d1', 'd2', 'chg', 'das2009', 'das2010']),; ('dftd3', ['d2', 'd3zero', 'd3bj', 'd3mzero', 'd3mbj']),; ('nl', ['nl']),; ('mp2d', ['dmp2']),; (""dftd4"", [""d4bjeeqatm""]),; ]) # yapf: disable. _capable_engines_for_disp = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; _capable_engines_for_disp[disp].append(eng). [docs]class EmpiricalDispersion(object):; """"""Lightweight unification of empirical dispersion calculation modes. Attributes; ----------; dashlevel : str; {'d1', 'd2', 'd3zero', 'd3bj', 'd3mzero', 'd3mbj', 'chg', 'das2009', 'das2010', 'nl', 'dmp2', ""d4bjeeqatm""}; Name of dispersion correction to be applied. Resolved; from `name_hint` and/or `level_hint` into a key of; `empirical_dispersion_resources.dashcoeff`.; dashparams : dict; Complete set of parameter values defining the flexible parts; of :py:attr:`dashlevel`. Number and parameter names vary by; :py:attr:`dashlevel`. Resolved into a complete set (keys of; dashcoeff[dashlevel]['default']) from `name_hint` and/or; `dashcoeff_supplement` and/or user `param_tweaks`.; fctldash : str; If :py:attr:`dashparams` for :py:attr:`dashlevel` corresponds to a defined,; named, untweaked ""functional-dashlevel"" set, then that; functional. Otherwise, empty string.; description : str; Tagline for dispersion :py:attr:`dashlevel`.; dashlevel_citation : str; Literature reference for dispersion :py:attr:`dashlevel` in general,; *not necessarily* for :py:attr:`dashparams`.; dashparams_citation : str; Literature reference for dispersion parameters, if :py:attr:`dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcengine.programs.empirical_dispersion_resources.from_arrays`. Used; here to ""ble",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:2356,flexible,flexible,2356,psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,4,['flexible'],['flexible']
Modifiability,"psi4/lib/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html:2422,variab,variable,2422,psi4manual/4.0b5/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html,2,['variab'],['variable']
Modifiability,"psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1. DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2. DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3. DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_blas-1.html:3366,variab,variable,3366,psi4manual/1.4.0/prog_blas-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_blas-1.html,9,['variab'],['variable']
Modifiability,"ptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. PROPERTY (CCSORT); CCSORT — The response property desired. The unique acceptable values is POLARIZABILITY for dipole-polarizabilitie. Type: string; Default: POLARIZABILITY. PT_ENERGY (PSIMRCC); PSIMRCC — The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. PUREAM (GLOBALS); GLOBALS — Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_COUPLING (DCFT); DCFT — Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS); GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:187189,coupling,coupling,187189,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['coupling'],['coupling']
Modifiability,"ption(""OPTKING"", ""CARTESIAN_SYM_TOLERANCE"")). if molecule.schoenflies_symbol() != initial_sym:; raise ValidationError(""Point group changed! (%s <-- %s) You should restart ""; ""using the last geometry in the output, after ""; ""carefully making sure all symmetry-dependent ""; ""input, such as DOCC, is correct."" % (current_sym, initial_sym)). kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # We'll currently ignore the possibility that the gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Print summary to output for user; opt_object.molsys.geom = molecule.geometry().np; core.print_out(opt_object.pre_step_str()) # print optking's molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); exce",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:73780,variab,variable,73780,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['variab'],['variable']
Modifiability,"ption('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). necp_ab = dimer_wfn.basisset().n_ecp_core(); share_df_ints = ((sapt_basis == 'dimer') and (ri == 'DF') and not (necp_ab and (os.name == 'nt'))); if (sapt_basis == 'dimer') and (ri == 'DF') and not share_df_ints:; core.print_out(f""\n Turning off SAPT DF integrals sharing because of ECP: {necp_ab}\n\n""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if share_df_ints:; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if share_df_ints:; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if share_df_ints:; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:148713,variab,variable,148713,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"ptional); | If a single dense numpy array is given, a dimension can be supplied to; | apply irreps to this array. Note that this discards all extra information; | given in the matrix besides the diagonal blocks determined by the passed; | dimension.; | dim2 :; | Same as dim1 only if using a Psi4.Dimension object.; | ; | Returns; | -------; | ret : psi4.Vector or psi4.Matrix; | Returns the given Psi4 object ; | ; | Notes; | -----; | This is a generalized function to convert a NumPy array to ; | ; | Examples; | --------; | ; | >>> data = np.random.rand(20); | >>> vector = array_to_matrix(data); | ; | >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; | >>> matrix = array_to_matrix(irrep_data); | >>> print matrix.rowspi().to_tuple(); | >>> (2, 0, 4); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | __array_interface__; | docstring; | ; | np; | ; | shape; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MatrixFactory(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MatrixFactory; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | create_matrix(...); | create_matrix( (MatrixFactory)arg1) -> Matrix :; | ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:524848,inherit,inherited,524848,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ptional); | If a single dense numpy array is given, a dimension can be supplied to; | apply irreps to this array. Note that this discards all extra information; | given in the matrix besides the diagonal blocks determined by the passed; | dimension.; | dim2 :; | Same as dim1 only if using a Psi4.Dimension object.; | ; | Returns; | -------; | ret : psi4.Vector or psi4.Matrix; | Returns the given Psi4 object ; | ; | Notes; | -----; | This is a generalized function to convert a NumPy array to ; | ; | Examples; | --------; | ; | >>> data = np.random.rand(20); | >>> vector = array_to_matrix(data); | ; | >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; | >>> matrix = array_to_matrix(irrep_data); | >>> print matrix.rowspi().to_tuple(); | >>> (2, 0, 4); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | __array_interface__; | docstring; | ; | np; | ; | shape; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector3(Boost.Python.instance); | Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; | ; | Method resolution order:; | Vector3; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (Vector3)arg1, (Vector3)arg2) -> object :; | ; | C++ signature :; | P7_object __add__(N3psi7Vector3E {lvalue},N3psi7Vector3E); | ; | __ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:642906,inherit,inherited,642906,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ptions, part ii. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/kw-1; testing best practices options, part i. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Test Suite and Sample Inputs; CFOUR. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html:4828,variab,variables,4828,psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,2,['variab'],['variables']
Modifiability,"ptions; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total SAPT energy psivars were renamed. Caution; February 7, 2020, a missing term in \(E^{(30)}_{ind}\) was added, causing; possible discrepancies with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. Caution; August 2021, the number of frozen core orbitals used in the dMP2 computations; is now standardized. Specifically, we now rigorously enforce that the number of core orbitals; frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively); a charged alkali metal. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in \(V\). For; a complete description of SAPT, the reader",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/sapt-1.html:1956,adapt,adapted,1956,psi4manual/1.5.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/sapt-1.html,2,['adapt'],['adapted']
Modifiability,"published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. """"""; import math; import copy; from vecutil import *; from exceptions import *. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print '\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:1411,variab,variables,1411,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,2,['variab'],['variables']
Modifiability,"put files, start with the skeleton docstring in psi4/lib/python/example_docstring and replace anything that looks like <this>. For a behind-the-scenes function or if you don’t want the bother of dealing with reStructuredText, just write an ordinary docstring. It will get slurped into the documentation in plain text. Your python function should follow PEP8 conventions (without the line-length restriction). I’m aiming for files to pass the line below, unless for good reason. The second line is for database Python files.; >>> pep8.py -r --ignore=E501 pythonfile.py; >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py. Your python function should not prevent any test case (make tests, NOT make longtests) from passing. A test case(s) should be written and checked in for any major python function, so that others do not break your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap_ is suggested. Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the ‘current energy’ variable. This last is needed to communicate with the optimizer.; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). Once your python function is fairly stable on its own, it’s potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/bestpractices_py-1.html:4151,variab,variables,4151,psi4manual/4.0b2/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/bestpractices_py-1.html,6,['variab'],['variables']
Modifiability,"put files, start with the skeleton docstring in psi4/lib/python/example_docstring and replace anything that looks like <this>. For a behind-the-scenes function or if you don’t want the bother of dealing with reStructuredText, just write an ordinary docstring. It will get slurped into the documentation in plain text. Your python function should follow PEP8 conventions (without the line-length restriction). I’m aiming for files to pass the line below, unless for good reason. The second line is for database Python files.; >>> pep8.py -r --ignore=E501 pythonfile.py; >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py. Your python function should not prevent any test case (make tests, NOT make longtests) from passing. A test case(s) should be written and checked in for any major python function, so that others do not break your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap_ is suggested. Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the ‘current energy’ variable. This last is needed to communicate with the optimizer.; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25). Once your python function is fairly stable on its own, it’s potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reass",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/bestpractices_py-1.html:4164,variab,variables,4164,psi4manual/4.0b5/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/bestpractices_py-1.html,2,['variab'],['variables']
Modifiability,"put line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/psi4/share/psi4/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/psi4/share/psi4/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/quickadddatabase.html:3476,variab,variable,3476,psi4manual/1.8.x/quickadddatabase.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/quickadddatabase.html,1,['variab'],['variable']
Modifiability,"put line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/psi4/share/psi4/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/psi4/share/psi4/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/quickadddatabase.html:3476,variab,variable,3476,psi4manual/1.9.x/quickadddatabase.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/quickadddatabase.html,1,['variab'],['variable']
Modifiability,"pvdz; freeze_core true; }; energy('df-ccsd(t)'). The accuracy of the Cholesky decomposition may be controlled through the; keyword CHOLESKY_TOLERANCE. Note that the keyword; SCF_TYPE has not been specified here. By default, a DF-CCSD(T); computation exploits DF technology in the SCF procedure, but one can; override this behavior through this keyword. Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are detailed; in Table FNOCC Methods. Note that these methods; are implemented for closed-shell references only. For open-shell references,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to the DETCI implementations of these methods. name; calls method. qcisd; quadratic configuration interaction singles doubles. qcisd(t); qcisd with perturbative triples. mp2.5; average of second- and third-order perturbation theories. mp3; third-order perturbation theory. mp4(sdq); fourth-order perturbation theory, minus triples contribution. mp4; full fourth-order perturbation theory. cepa(0); coupled electron pair approximation, variant 0. cepa(1); coupled electron pair approximation, variant 1. cepa(3); coupled electron pair approximation, variant 3. acpf; averaged coupled-pair functional. aqcc; averaged quadratic coupled-cluster. sdci; configuration interaction with single and double excitations. dci; configuration interaction with double excitations. fno-qcisd; qcisd with frozen natural orbitals. fno-qcisd(t); qcisd(t) with frozen natural orbitals. fno-ccsd; coupled cluster singles doubles with frozen natural orbitals. fno-ccsd(t); ccsd with perturbative triples and frozen natural orbitals. fno-mp3; mp3 with frozen natural orbitals. fno-mp4(sdq); mp4(sdq) with frozen natural",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/fnocc-1.html:9869,config,configuration,9869,psi4manual/4.0b4/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/fnocc-1.html,2,['config'],['configuration']
Modifiability,"python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute()[source]¶; Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. print_in_input_format_cfour()[source]¶; Prints the updated geometry, in the format provided by the user.; This, for Cfour, not different from regular version. set_coordinates(x, y, z)[source]¶; Given the current set of coordinates, updates the values of this; atom’s coordinates and any variables that may depend on it. type()[source]¶; The type of CoordEntry specialization. class CoordEntry(entry_number, Z, charge, mass, symbol, label='', basis=None, shells=None)[source]¶; Class to store all the attributes associated with an atom, not the; larger Molecule. Specialized into CartesianEntry and ZMatrixEntry. Z()[source]¶; The nuclear charge of the current atom (0 if ghosted). static a(a1, a2, a3)[source]¶; Computes the angle (in rad.) between three sets of coordinates. basisset(role='BASIS')[source]¶; Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. basissets()[source]¶; Returns basisset to atom map. charge()[source]¶; The “atomic charge” of the current atom (for SAD purposes). static d(a1, a2, a3, a4)[source]¶; Computes the dihedral (in rad.) between four sets of coordinates. entry_number()[source]¶; The order in which this appears in the full atom list",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:114058,variab,variables,114058,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['variab'],['variables']
Modifiability,"python2.6-config. If you cannot find the config program the; developer libraries will not be detected and the PSI4 configure script; will fail. The library is called python-devel for Fedora and; python-dev for Ubuntu. GNU utilities: (see http://www.gnu.org). make. autoconf (version 2.52 or higher). Note; autoconf is only needed for special; architectures or to compile the; development branch. aclocal. fileutils (esp. install). For documentation: (available pre-built off http://www.psicode.org). latex; sphinx (version 1.1 or higher); dvipng (for latex math in html). For Ubuntu users, you will need the following packages installed:; gfortran [for linking to BLAS/LAPACK], g++, autoconf, python-dev. II. Brief Summary of Configuration, Compilation, and Installation¶; This section outlines the main steps of configuring, compiling, and; installing PSI. More detail is given below in Section III. Autoconf. For unusual architectures (or for developers working in the development; branch), one needs to first run autoconf to generate; the file “configure” in the top-level psi4 directory. For most Linux; and Mac compilations, this should not be necessary because the configure; file provided with PSI4 should be sufficient. To replace the general; configure file with one specific to your architecture, in the top-level; psi4 directory, run autoconf:; >>> autoconf. Configuration and Compilation; Make an object directory in which you can compile the code; >>> mkdir obj. Next you need to configure the code. Find a configuration; option line or combination of; configuration options at Section III(1)A. Either, use the line directly:; >>> cd obj; >>> ../configure [your compilation configuration options here]. or, save your configuration options for a future compilation.; In the top-level psi4 directory, create a file like “do-configure” with; the configure command and options on one line.; >>> cat do-configure; ../configure [your compilation configuration options here]; >>> chmod u+x do-co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/installfile.html:2519,config,configure,2519,psi4manual/4.0b4/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/installfile.html,1,['config'],['configure']
Modifiability,"qcvar_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:32060,variab,variables,32060,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"quations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORBITAL_LEVEL_SHIFT (DCT)¶DCT (Expert) — The shift applied to the denominator in the orbital update iterations. Type: double; Default: 0.0. ORBITALS_WRITE (SCF)¶SCF — File name (case sensitive) to which to serialize Wavefunction orbital data. Type: string; Default: No Default. ORTH_TYPE (DFOCC)¶DFOCC — The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. ORTH_TYPE (OCC)¶OCC — The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. OS_SCALE (OCC)¶OCC — A custom scaling parameter for opposite-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. OVERLAP_CHECK (CCEOM)¶CCEOM — Report overlaps with old excited-state wave functions, if available, and store current wave functions for later use. Type: boolean; Default: false. P (THERMO)¶THERMO — Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. PAIR_ENERGIES_PRINT (CCENERGY)¶CCENERGY — Do print MP2 and CCSD pair energies for RHF references?. Type: boolean; Default: false. PARALLEL (SCF)¶SCF (Expert) — Do run in parallel?. Type: boolean; Default: false. PARENT_SYMMETRY (GLOBALS)¶GLOBALS (Expert) — For displacements, symmetry (Schoenflies symbol) of ‘parent’ (undisplaced) reference molecule. Internal use only for finite difference. Type: string; Default: No Default. PCG_BETA_TYPE (DFOCC)¶DFOCC — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: FLETCHER_REEVES, POLAK_RIBIERE; Default: FLETCHER_REEVES. PCG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:184799,variab,variable,184799,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['variab'],['variable']
Modifiability,"quested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:22349,config,configuration,22349,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['config'],['configuration']
Modifiability,"question). If it does not, use the; DF_BASIS_MP2 keyword to manually specify the basis.; DFMP2 likes memory. At a minimum, \(2Q^2\) doubles are required,; where \(Q\) is the size of the auxiliary basis set. However, there is; one disk transpose of the \((Q|ov)\) tensor in the RHF-MP2 algorithm; [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.; If you notice DFMP2 using more memory than allowed, it is possible that; the threaded three-index ERI computers are using too much overhead memory.; Set the DF_INTS_NUM_THREADS to a smaller number to prevent this; in this section (does not affect threaded efficiency in the rest of the; code).; DFMP2 likes disk. At a minimum, \(2Qov\) doubles are required for; RHF-MP2, and \(4Qov\) doubles are required for UHF-MP2.; DFMP2 likes threads. Some of the formation of the \((Q|ov)\) tensor; relies on threaded BLAS (such as MKL) for efficiency. The main; \({\cal O}(N^5)\) step is done via small/medium-sized DGEMMs inside of; OpenMP, so make sure to set the OMP_NESTED environment variable; to FALSE to prevent thread thrash (or just as well, do not define; OMP_NESTED at all).; Freezing core is good for both efficiency and correctness purposes.; Freezing virtuals is not recommended. The DFMP2 module will remind you how; many frozen/active orbitals it is using in a section just below the title.; ROHF-MBPT(2) may be preferred to UHF-MP2, as the latter can suffer from; severe spin contamination in some cases.; MP2 is not suitable for systems with multireference character. The; orbital energies will come together and an explosion will occur. table of contents. DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; Introduction; Theory; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dfmp2-1.html:8519,variab,variable,8519,psi4manual/1.2.1/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dfmp2-1.html,2,['variab'],['variable']
Modifiability,"r :; | docstring; | ; | x_alpha(...); | x_alpha( (SuperFunctional)arg1) -> float :; | docstring; | ; | x_functional(...); | x_functional( (SuperFunctional)arg1, (str)arg2) -> Functional :; | docstring; | ; | x_omega(...); | x_omega( (SuperFunctional)arg1) -> float :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | blank(...); | blank() -> SuperFunctional :; | docstring; | ; | build(...); | build( (str)arg1, (int)arg2, (int)arg3) -> SuperFunctional :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class SymmetryOperation(Boost.Python.instance); | docstring; | ; | Method resolution order:; | SymmetryOperation; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | E(...); | E( (SymmetryOperation)arg1) -> None :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (SymmetryOperation)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | c2_x(...); | c2_x( (SymmetryOperation)arg1) -> None :; | docstring; | ; | c2_y(...); | c2_y( (SymmetryOperation)arg1) -> None :; | docstring; | ; | i(...); | i( (SymmetryOperation)arg1) -> None :; | docstring; | ; | operate(...); | operate( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; |",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:74708,inherit,inherited,74708,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,8,['inherit'],['inherited']
Modifiability,"r CCD calculation. run_bccd_t(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. run_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. run_cc_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; all CC property calculations. run_ccenergy(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. run_cepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a cepa-like calculation.; >>> energy('cepa(1)'). run_dcft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. run_dcft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; DCFT gradient calculation. run_detci(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. run_dfmp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. run_dfmp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. run_dft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory calculation. run_dft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. run_eom_cc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. run_eom_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. run_libfock(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a calculation through li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:8838,config,configuration,8838,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['config'],['configuration']
Modifiability,"r General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import os; import re; import math; import pickle; import collections. from psi4.driver import constants; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:1808,variab,variables,1808,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['variab'],['variables']
Modifiability,"r MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/psi4/driver/aliases.py.; The rationale for the changes is indicated in the comments below.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/quickaddalias-1.html:1870,variab,variable,1870,psi4manual/1.1.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/quickaddalias-1.html,6,['variab'],['variable']
Modifiability,"r a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of the molecule specification below). In this example, we will also specify the bond length and bond angle as variables (\(R\) and \(A\)), whose values are first stored and then inserted into the geometry specification using Python 3 string formatting. [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analys",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:5407,variab,variables,5407,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['variab'],['variables']
Modifiability,"r array QCVariable key to val on cls. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – ; val (Union[psi4.core.Matrix, numpy.ndarray, float]) – . shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. total_index(self: psi4.core.CCWavefunction, i: int, h: int) → int¶; Map an index (i) within irrep (h) to its energy-sorted index among all roots. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:25701,variab,variable,25701,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variable']
Modifiability,"r for; this purpose.; As an example, the MP2.5 method; (which admittedly is already built in to Psi4); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/share/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html:1621,variab,variable,1621,psi4manual/1.0.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html,2,['variab'],['variable']
Modifiability,"r identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any chang",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:4946,plugin,plugins,4946,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,15,['plugin'],['plugins']
Modifiability,"r modules used, the user may also wish to; cite some of the following references for theoretical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below).; Regardless of the type of the calculation, an initial guess is; necessary. PSI4 features several initial guesses for the; molecular orbitals. The default guess is the superposition of atomic; densities (SAD), discussed in. “Principles for a direct SCF approach to LCAO-MO ab-initio; calculations”, J. Almlöf, K. Faegri, and K. Korsell,; J. Comput. Chem. 3, 385 (1982).; (doi: 10.1002/jcc.540030314).; “Starting SCF calculations by superposition of atomic; densities”, J. H. Van Lenthe, R. Zwaans, H. J. J. Van Dam,; and M. F. Guest, J. Comput. Chem. 27, 926 (2006).; (doi: 10.1002/jcc.20393). PSI4 also features a SAD natural orbital guess, an extended; Hückel guess that employs on-the-fly atomic calculations alike the SAD; guess, as well as a superposition of atomic potentials (SAP) guess; that is based on screening of atomic nuclei. The SAD natural orbitals,; Hückel and SAP guesses have been described in. “An assessment of initial guesses for self-consistent field; calculations. Superposition of Atomic Potentials: simple yet; efficient”, S. Lehtola, J. Chem. Theory Comput. 15,; 1593 (2019) (doi: 10.1021/acs.jctc.8b01089). Density Cumulant Theory (DCT)¶; PSI4 features several formulations of newly-developed density cumulant; theory (DCT), also known as density cumulant functional theory (DCFT).; The theory and benchmark of this theory are discussed in the following papers:; DC-06 (also known as DCT-06):. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/introduction-1.html:5854,extend,extended,5854,psi4manual/1.4.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/introduction-1.html,7,['extend'],['extended']
Modifiability,"r molecular hydrogen. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. scf6; Tests RHF/ROHF/UHF SCF gradients. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. pywrap-align; apply linear fragmentation algorithm to a water cluster. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. cc13c; Tests RHF CCSD(T)gradients. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. casscf-fzc-sp; CASSCF/6-31",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:19556,variab,variables,19556,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['variab'],['variables']
Modifiability,"r of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script, probably as $PSIDATADIR/scripts/ixyz2database.py. (If you; run it in place, there won’t be any path problems. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Customization: Adding Simple Extensions ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/quickadddatabase-1.html:3598,variab,variable,3598,psi4manual/4.0b3/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/quickadddatabase-1.html,2,['variab'],['variable']
Modifiability,"r of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script, probably as $PSIDATADIR/scripts/ixyz2database.py. (If you; run it in place, there won’t be any path problems. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/quickadddatabase-1.html:3598,variab,variable,3598,psi4manual/4.0b4/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/quickadddatabase-1.html,2,['variab'],['variable']
Modifiability,"r of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/lib/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script, probably as $PSIDATADIR/scripts/ixyz2database.py. (If you; run it in place, there won’t be any path problems. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/lib/databases. Previous topic; Defining a Method Alias; Next topic; Contributions: Intro to Programming in PSI4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/quickadddatabase-1.html:3598,variab,variable,3598,psi4manual/4.0b5/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/quickadddatabase-1.html,2,['variab'],['variable']
Modifiability,"r of threads to parallelize across. oeprop(*args, **kwargs)[source]¶. set_memory(bytes)[source]¶; Function to reset the total memory allocation. set_num_threads(nthread)[source]¶; Function to reset the number of threads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. basislistdunning¶; Module (auto-generated from make_dunning.pl script); with commands building BasisFamily objects that; encode the Dunning basis set orbital definitions in; psi4/lib/basis/NOTES and fitting bases designed for those; orbital bases. load_basfam_dunning()[source]¶. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. run_mp2_5(name, **kwargs)[source]¶; Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. Psi variables:. MP2.5 TOTAL ENERGY; MP2.5 CORRELATION ENERGY. >>> energy('mp2.5'). sherrillgroup_gold_standard(name='conv-mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:34190,variab,variables,34190,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['variab'],['variables']
Modifiability,"r private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy();",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html:3790,variab,variable,3790,psi4manual/1.5.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html,2,['variab'],['variable']
Modifiability,"r private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self, arg0); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html:3797,variab,variable,3797,psi4manual/1.6.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html,2,['variab'],['variable']
Modifiability,"r psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int) → None¶; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs)¶; Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. atom_at_position(self: psi4.core.Molecule, coord: List[float[3]], tol: float) -> int. Tests to see if an atom is at the position coord with a given tolerance tol. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int) → float¶; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:15812,extend,extended,15812,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,3,['extend'],['extended']
Modifiability,"r them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, Psi4 will complain.; >>> psi4 --new-plugin myplugin. Psi4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the default input file.; Psi4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction; >>> psi4 --new-plugin myplugin +scf; >>> psi4 --new-plugin myplugin +ambit. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; psi4/plugins/backtrans/backtrans.cc; A test of the one- and two-particle density matrix backtransformation code.; psi4/plugins/mointegrals/mointegrals.cc; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/mollerplesset2/mp2.cc; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Creating a New Plugin Using a Conda Pre-compiled Binary¶; Psi4 plugins can also be created using Conda for both Psi4 binary and; development environment.; To compile a plugin ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:3156,plugin,plugin,3156,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,4,['plugin'],"['plugin', 'plugins']"
Modifiability,"r with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:35898,variab,variable,35898,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['variab'],['variable']
Modifiability,"r"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma""; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = os.environ.get('PSIDATADIR', None); plugin_path = join_path(psidatadir, ""plugin""); for dir in os.listdir(plugin_path):; if os.path.isdir(join_path(plugin_path, dir)):; available_plugins.append(dir). [docs]def create_plugin(name, template):; """"""Generate plugin in directory with sanitized *name* based upon *template*."""""". name = sanitize_name(name); template_path = join_path(plugin_path, template). # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.endswith('.cc.template'):; source_files.append(target_file). tty.hline(""""""Creating ""{}"" with ""{}"" template."""""".format(name, template)). os.mkdir(name); created_files = []; for source_file in template_files:; target_file = source_file. if source_file.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/plugin.html:3368,plugin,plugin,3368,psi4manual/1.1.0/_modules/psi4/driver/plugin.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/plugin.html,1,['plugin'],['plugin']
Modifiability,"r'^\s*(-?\d+)\s+(\d+)\s*$'); frag = re.compile(r'^\s*--\s*$'); variable = re.compile(r'^\s*(\w+)\s*=\s*(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:14722,variab,variable,14722,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,6,['variab'],['variable']
Modifiability,"r(""""""Invalid method %s"""""" % name). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:74853,variab,variables,74853,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variables']
Modifiability,"r(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_MAXITER', False); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_occ(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; # Stash these options so we can reload them at computation end.; optstash = p4util.OptionsState(; ['OCC', 'SPIN_SCALE_TYPE'],; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE']). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },; ""scs-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCS"", },; ""scs(n)-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSN"", },; ""scs-mp2-vdw"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSVDW"",},; ""sos-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SOS"", },; ""sos-pi-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SOSPI"", },; ""custom-scs-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""omp2"": ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:73832,variab,variables,73832,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"r). fz(self, arg0); z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_variable(self, arg0); Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self, arg0); Gets the original label of the atom as given in the input file (C2, H4). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self, dipole_field, …); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self, arg0); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:3730,variab,variable,3730,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['variab'],['variable']
Modifiability,"r)arg2, (list)arg3 [, (object)arg4]) -> bool :; ; C++ signature :; b set_local_option(Ss,Ss,N5boost6python4listE [,PN3psi8DataTypeE]); ; set_local_option_python(...); set_local_option_python( (str)arg1, (object)arg2) -> None :; Sets an option to a Python object, but scoped only to a single module.; ; C++ signature :; void set_local_option_python(Ss,N5boost6python3api6objectE {lvalue}); ; set_memory(...); set_memory( (int)arg1) -> None :; Sets the memory available to Psi (in bytes).; ; C++ signature :; void set_memory(m); ; set_nthread(...); set_nthread( (int)arg1) -> None :; Sets the number of threads to use in SMP parallel computations.; ; C++ signature :; void set_nthread(i); ; set_parent_symmetry(...); set_parent_symmetry( (str)arg1) -> None :; Sets the symmetry of the 'parent' (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation.; ; C++ signature :; void set_parent_symmetry(Ss); ; set_variable(...); set_variable( (str)arg1, (float)arg2) -> None :; Sets a PSI variable, by name.; ; C++ signature :; void set_variable(Ss,d); ; thermo(...); thermo( (Wavefunction)arg1, (Vector)arg2) -> float :; Computes thermodynamic data.; ; C++ signature :; d thermo(N5boost10shared_ptrIN3psi12WavefunctionEEE,N5boost10shared_ptrIN3psi6VectorEEE); ; transqt2(...); transqt2( (Wavefunction)arg1) -> float :; Runs the (deprecated) transformation code.; ; C++ signature :; d transqt2(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; version(...); version() -> str :; Returns the version ID of this copy of Psi.; ; C++ signature :; PKc version(). DATA; Angstrom = psi4.GeometryUnits.Angstrom; Ascending = psi4.DiagonalizeOrder.Ascending; Balk = psi4.PsiReturnType.Balk; Bohr = psi4.GeometryUnits.Bohr; Descending = psi4.DiagonalizeOrder.Descending; EndLoop = psi4.PsiReturnType.EndLoop; Failure = psi4.PsiReturnType.Failure; Success = psi4.PsiReturnType.Success. Table Of Contents. psi4: Linking C++ and Python; psi4; AOShellCombinationsIterator; AngularMoment",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:698403,variab,variable,698403,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['variab'],['variable']
Modifiability,"r/path/2/psi4/build/directory/tests; Start 248: tu1-h2o-energy; 1/2 Test #248: tu1-h2o-energy ................... Passed 1.73 sec; Start 6: cc1; 2/2 Test #6: cc1 ..............................***Failed 0.07 sec; ... When ctest reports that some (or all) tests have failed, look in your; build directory for file; objdir/tests/Testing/Temporary/LastTest.log. It may have a; .tmp extension, depending on whether the last test was interrupted and; a few other factors. Either way, this file should contain CMake’s testing; output, as well as everything that was printed to the screen. How to test a Psi4 installation¶; ctest requires a connection to source files and cmake; machinery and so can only be performed from objdir; (staged installation). To test an installed PSI4 (full or staged; installation), a limited number of “smoke” tests are available to be; run via pytest. From the executable:; psi4 –test. From the library (PSI4 must be detectable as a Python; module. See setup at How to configure paths for PsiAPI; if needed.):; python -c “import psi4; psi4.test()”. Output looks something like the below. PASSED in green is good; (means test ran correctly); SKIPPED in yellow is good (means that; not all software required for test is available); XPASS or XFAIL; in yellow is fine (unexpected pass or expected fail happens when we; include tests that need particular conditions (e.g., multiple cores); to run correctly); FAILED in red is bad.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19test_addons.py::test_gdma PASSED; test_addons.py::test_mrcc SKIPPED; test_addons.py::test_chemps2 PASSED; test_addons.py::test_dftd3 PASSED; test_addons.py::test_libefp PASSED; test_addons.py::test_pcmsolver PASSED; test_addons.py::test_erd PASSED; test_addons.py::test_simint PASSED; test_addons.py::test_json PASSED; test_addons.py::test_cfour SKIPPED; test_addons.py::test_v2rdm_casscf PASSED; test_addons.py::test_grimme_3c PASSED; test_addons.py::test_dkh PASSED; test_psi4.py::tes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:47641,config,configure,47641,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['config'],['configure']
Modifiability,"r/path/2/psi4/build/directory/tests; Start 248: tu1-h2o-energy; 1/2 Test #248: tu1-h2o-energy ................... Passed 1.73 sec; Start 6: cc1; 2/2 Test #6: cc1 ..............................***Failed 0.07 sec; ... When ctest reports that some (or all) tests have failed, look in your; build directory for file; objdir/tests/Testing/Temporary/LastTest.log. It may have a; .tmp extension, depending on whether the last test was interrupted and; a few other factors. Either way, this file should contain CMake’s testing; output, as well as everything that was printed to the screen. How to test a Psi4 installation¶; ctest requires a connection to source files and cmake; machinery and so can only be performed from objdir; (staged installation). To test an installed PSI4 (full or staged; installation), a limited number of “smoke” tests are available to be; run via pytest. From the executable; psi4 --test. From the library (PSI4 must be detectable as a Python; module. See setup at How to configure paths for PsiAPI; if needed.); python -c ""import psi4; psi4.test()"". From pytest directly. If package pytest-xdist is installed,. can run in parallel, though final file cleanup may not exit cleanly. pytest {prefix}/lib/{PYMOD_INSTALL_LIBDIR}/psi4/tests/ -n`getconf _NPROCESSORS_ONLN`. Output looks something like the below. PASSED in green is good; (means test ran correctly); SKIPPED in yellow is good (means that; not all software required for test is available); XPASS or XFAIL; in yellow is fine (unexpected pass or expected fail happens when we; include tests that need particular conditions (e.g., multiple cores); to run correctly); FAILED in red is bad.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19test_addons.py::test_gdma PASSED; test_addons.py::test_mrcc SKIPPED; test_addons.py::test_chemps2 PASSED; test_addons.py::test_dftd3 PASSED; test_addons.py::test_libefp PASSED; test_addons.py::test_pcmsolver PASSED; test_addons.py::test_erd PASSED; test_addons.py::test_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:50590,config,configure,50590,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['config'],['configure']
Modifiability,"r3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3) → float¶; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3) → None¶; Returns vector of unit length and arg1 direction. class psi4.core.VectorMatrix¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi::Matrix], x: psi::Matrix) → None¶; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int¶; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. class psi4.core.Wavefunction¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:214591,extend,extend,214591,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,4,['extend'],['extend']
Modifiability,"r: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:5323,plugin,plugin,5323,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,15,['plugin'],['plugin']
Modifiability,"r:; | ElectricFieldInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ElectrostaticInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | ElectrostaticInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Bo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:444332,inherit,inherited,444332,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"r:; | ElectrostaticInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:446187,inherit,inherited,446187,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"r_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; fragment_files=None,; hint_types=None,; geom_hints=None,; geom_unsettled=None,; variables=None,; domain=""qm"",; missing_enabled_return: str = ""error"",; np_out: bool = True,; speclabel: bool = True,; tooclose: float = 0.1,; zero_ghost_fragments=False,; nonphysical: bool = False,; mtol=1.0e-3,; copy=True,; verbose=1,; ):; r""""""Compose a Molecule dict from unvalidated arrays and variables, returning dict. See fields of Return molrec below. Required parameters (for QM XYZ); are `geom` and one of `elem`, `elez`, `elbl` (`speclabel=True`). Parameters; ----------; geom : Union[List[List[float]], numpy.ndarray]; (nat, 3) or (3 * nat, ) ndarray or list o'lists of Cartesian coordinates.; fragment_separators : Union[List[int], numpy.ndarray]; (nfr - 1, ) list of atom indices at which to split `geom` into fragments.; elbl : Union[List[str], numpy.ndarray]; (nat, ) Label extending `elem` symbol, possibly conveying ghosting, isotope, mass, tagging information.; tooclose; Interatom distance (native `geom` units) nearer than which atoms not allowed.; nonphysical; Do allow masses outside an element's natural range to pass validation?; speclabel; If `True`, interpret `elbl` as potentially full nucleus spec including; ghosting, isotope, mass, tagging information, e.g., `@13C_mine` or; `He4@4.01`. If `False`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:4450,extend,extending,4450,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,6,['extend'],['extending']
Modifiability,"r_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]; def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:3453,plugin,plugins,3453,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,6,['plugin'],['plugins']
Modifiability,"r_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""requires"",; ""return"", ""short"", ""signed"", ""sizeof"", ""static"", ""static_assert"",; ""static_cast"", ""struct"", ""switch"", ""synchronized"", ""template"",; ""this"", ""thread_local"", ""throw"", ""true"", ""try"", ""typedef"", ""typeid"",; ""typename"", ""union"", ""unsigned"", ""using"", ""virtual"", ""void"",; ""volatile"", ""wchar_t"", ""while"", ""xor"", ""xor_eq"",. # Identifiers with special meanings""; ""override"", ""final"", ""transaction_safe"", ""transaction_safe_dynamic"",. # Preprocessor tokens; ""if"", ""elif"", ""else"", ""endif"", ""defined"", ""ifdef"", ""ifndef"",; ""define"", ""undef"", ""include"", ""line"", ""error"", ""pragma"",; ""_pragma"",. # C++20; ""char8_t"", ""consteval"", ""constinit"", ""co_await"", ""co_return"",; ""co_yield"", ""reflexpr"",; ]. if temp in cpp_keywords:; tty.die(""The plugin name you provided is a C++ reserved keyword. Please provide a different name.""). return temp; else:; tty.die(""Plugin name must begin with a letter.""). # Determine the available plugins; available_plugins = []; psidatadir = Path(core.get_datadir()); plugin_path = psidatadir / ""plugin""; for sdir in os.listdir(plugin_path):; if (plugin_path / sdir).is_dir():; available_plugins.append(sdir). [docs]def create_plugin(name: str, template: str) -> None:; f""""""Generate plugin in directory with sanitized *name* based upon *template*. Parameters; ----------; name; Name of plugin. Should not have any fancy characters or reserved keywords.; template; {{{available_plugins}}}; Which existing template to model off of. """"""; name = sanitize_name(name); template_path = plugin_path / template. # Create, but do not overwrite, plugin directory; if os.path.exists(name):; tty.error(""""""Plugin directory ""{}"" already exists."""""".format(name)). # Do a first pass to determine the template temp_files; template_files = os.listdir(template_path); source_files = []; for temp_file in template_files:; target_file = temp_file. if temp_file.endswith('.template'):; target_file = temp_file[0:-9]. if temp_file.ends",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html:3449,plugin,plugins,3449,psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html,2,['plugin'],['plugins']
Modifiability,"r_reshape_get(k, v) for k, v in cls.array_variables().items()}}. if include_deprecated_keys:; for old_key, current_key in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:34283,variab,variables,34283,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variables']
Modifiability,"r_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:33028,variab,variables,33028,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"raction energies (in kcal mol-1) at each geometry. Doing all this; in a single input is surprisingly easy in PSI4. Here’s the input; (available as tu6-cp-ne2).; #! Example potential energy surface scan and CP-correction for Ne2. memory 250 mb. molecule dimer {; Ne; --; Ne 1 R; }. Rvals=[2.5, 3.0, 4.0]. set basis aug-cc-pVDZ; set freeze_core True. # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work); ecp = {}. for R in Rvals:; dimer.R = R; ecp[R] = cp('ccsd(t)'). PsiMod.print_out(""\n""); PsiMod.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies\n\n""); PsiMod.print_out("" R (Ang) E_int (kcal/mol) \n""); PsiMod.print_out(""-----------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * 627.5095; PsiMod.print_out("" %3.1f %10.6f\n"" % (R, e)). First, you can see the molecule block has a couple dashes to; separate the monomers from each other. Also note we’ve used a Z-matrix to; specify the geometry, and we’ve used a variable (R) as the; interatomic distance. We have not specified the value of R in; the molecule block like we normally would. That’s because we’re; going to vary it during the scan across the potential energy surface.; Below the molecule block, you can see the Rvals array; specified. This is a Python array holding the interatomic distances we; want to consider. In Python, arrays are surrounded by square brackets, and; elements are separated by commas.; The next lines, set basis aug-cc-pVDZ and set freeze_core True,; are familiar from previous test cases. Next comes a slightly; unusual-looking line, ecp = {}. This is Python’s way of initializing; a “dictionary”. We’re going to use this dictionary to store the; counterpoise-corrected energies as they become available. A dictionary is; like an array, but we can index it using strings or floating-point numbers; instead of integers if we want. Here, we will index it using; floating-point numbers, namely, the R values. This",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:16997,variab,variable,16997,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,4,['variab'],['variable']
Modifiability,"raction energies. Option available; (See Available Databases) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. symm (boolean) – 'on' || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || 'off' ; Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (string) – 'default' || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (array of strings) – [] || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (string or array of strings) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'; Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || 'HB' || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/db-1.html:3935,variab,variable,3935,psi4manual/1.0.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/db-1.html,8,['variab'],['variable']
Modifiability,"raction energies. Option available; (See Available Databases) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. symm (boolean) – 'on' || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || 'off' ; Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (string) – 'default' || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (array of strings) – [] || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (string or array of strings) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'; Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file. [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/db-1.html:3620,variab,variable,3620,psi4manual/4.0b2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/db-1.html,2,['variab'],['variable']
Modifiability,rad; scfhess; scfhess; set_active_molecule; set_active_molecule; set_array_variable; set_array_variable; set_datadir; set_datadir; set_global_option; set_global_option; set_global_option_python; set_global_option_python; set_gradient; set_gradient; set_legacy_gradient; set_legacy_gradient; set_legacy_molecule; set_legacy_molecule; set_legacy_wavefunction; set_legacy_wavefunction; set_local_option; set_local_option; set_local_option_python; set_local_option_python; set_memory_bytes; set_memory_bytes; set_num_threads; set_num_threads; set_output_file; set_output_file; set_psi_file_prefix; set_psi_file_prefix; set_scalar_variable; set_scalar_variable; set_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; TaskListComputer; ThreeCenterOverlapInt; timer_off; timer_off; timer_on; timer_on; TracelessQuadrupoleInt; triplet; triplet; tstart; tstart; tstop; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variable; variables; variables; VBase; Vector; Vector3; version; version; Wavefunction; activate; activate; ancestor; ancestor; banner; banner; basis_helper; basis_helper; cbs; cbs; check_iwl_file_from_scf_type; check_iwl_file_from_scf_type; compare_fchkfiles; compare_fchkfiles; compare_fcidumps; compare_fcidumps; ConvergenceError; copy_file_from_scratch; copy_file_from_scratch; copy_file_to_scratch; copy_file_to_scratch; create_plugin; create_plugin; CSXError; cubeprop; cubeprop; Dftd3Error; dynamic_variable_bind; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energies_from_fcidump; energy; energy; fchk; fchk; fchkfile_to_string; fchkfile_to_string; fcidump; fcidump; fcidump_from_file; fcidump_from_file; find_approximate_string_matches; find_approximate_string_matches; free_atom_volumes; free_atom_volumes; freq; freq; frequencies; frequencies; frequency; frequency; gdma; gdma; geometry; geometry; get_memory; get_memory; gradient; gradient; hessian; hessian; ipi_broker; ipi_broker; join_path,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:551306,variab,variables,551306,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['variab'],['variables']
Modifiability,"rags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) None. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/libefp/root. >>> cmake -DENABLE_libefp=ON -Dlibefp_DIR=/path/to/libefp/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_libefp=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/libefp/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_libefp=ON. table of contents. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:7898,variab,variable,7898,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,2,['variab'],['variable']
Modifiability,"raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(name.upper()); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; # retire components at v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE"", core.variable(""CC DIPOLE"")); # core.set_variable(""CC ROOT n DIPOLE"", core.variable(""CC DIPOLE"")) # P::e CCENERGY; if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")); # core.set_variable(""CC ROOT n QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")) # P::e CCENERGY. n_root = sum(core.get_global_option(""ROOTS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:100770,variab,variable,100770,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"ral(N3psi12OrbitalSpaceE {lvalue}); | ; | name(...); | name( (OrbitalSpace)arg1) -> str :; | docstring; | ; | C++ signature :; | Ss name(N3psi12OrbitalSpaceE {lvalue}); | ; | nirrep(...); | nirrep( (OrbitalSpace)arg1) -> int :; | docstring; | ; | C++ signature :; | i nirrep(N3psi12OrbitalSpaceE {lvalue}); | ; | print_out(...); | print_out( (OrbitalSpace)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi12OrbitalSpaceE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build_cabs_space(...); | build_cabs_space( (OrbitalSpace)arg1, (OrbitalSpace)arg2, (float)arg3) -> OrbitalSpace :; | docstring; | ; | C++ signature :; | N3psi12OrbitalSpaceE build_cabs_space(N3psi12OrbitalSpaceE,N3psi12OrbitalSpaceE,d); | ; | build_ri_space(...); | build_ri_space( (Molecule)arg1, (str)arg2, (str)arg3, (float)arg4) -> OrbitalSpace :; | docstring; | ; | C++ signature :; | N3psi12OrbitalSpaceE build_ri_space(N5boost10shared_ptrIN3psi8MoleculeEEE,Ss,Ss,d); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OverlapInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | OverlapInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:573375,inherit,inherited,573375,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ralFactory)arg1) -> ThreeCenterOverlapInt :; | docstring; | ; | C++ signature :; | PN3psi21ThreeCenterOverlapIntE overlap_3c(N3psi15IntegralFactoryE {lvalue}); | ; | shells_iterator(...); | shells_iterator( (IntegralFactory)arg1) -> AOShellCombinationsIterator :; | docstring; | ; | C++ signature :; | PN3psi27AOShellCombinationsIteratorE shells_iterator(N3psi15IntegralFactoryE {lvalue}); | ; | so_multipoles(...); | so_multipoles( (IntegralFactory)arg1, (int)arg2) -> object :; | docstring; | ; | C++ signature :; | PN3psi12OneBodySOIntE so_multipoles(N3psi15IntegralFactoryE {lvalue},i); | ; | so_overlap(...); | so_overlap( (IntegralFactory)arg1 [, (int)arg2]) -> object :; | docstring; | ; | C++ signature :; | PN3psi12OneBodySOIntE so_overlap(N3psi15IntegralFactoryE {lvalue} [,i]); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class JK(Boost.Python.instance); | docstring; | ; | Method resolution order:; | JK; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | C_left(...); | C_left( (JK)arg1) -> matrix_vector :; | ; | C++ signature :; | St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue} C_left(N3psi2JKE {lvalue}); | ; | C_right(...); | C_right( (JK)arg1) -> matrix_vector :; | ; | C++ signature :; | St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE {lvalue} C_right(N3psi2JKE {lvalue}); | ; | D(...); | D( (JK)arg1) -> matrix_vector :; | ; | C++ signature :; | St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE D(N3psi2JKE {lvalue}); | ; | J(...); | J( (JK)arg1) -> matrix_vector :; | ; | C++ signature :; | St6vectorIN5boost10",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:503061,inherit,inherited,503061,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"rals version. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. stability3; Test LDA stability analysis against QChem. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. options1; check all variety of options parsing. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cc13b; Tests RHF CCSD(T)gradients. sapt-sf1; Tests the Psi4 SF-SAPT code. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:41830,variab,variables,41830,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['variab'],['variables']
Modifiability,"rans.cc.in; A test of the one- and two-particle density matrix backtransformation code.; psi4/tests/plugin_ccsort/plugin_ccsort.cc.in; psi4/tests/plugin_mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/tests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin dir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:4560,config,configure,4560,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,4,"['config', 'plugin']","['configure', 'plugins']"
Modifiability,"ration :; | docstring; | ; | rotate_n(...); | rotate_n( (SymmetryOperation)arg1, (int)arg2) -> None :; | docstring; | ; | rotate_theta(...); | rotate_theta( (SymmetryOperation)arg1, (float)arg2) -> None :; | docstring; | ; | sigma_xy(...); | sigma_xy( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class TracelessQuadrupoleInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | TracelessQuadrupoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Pyt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:131814,inherit,inherited,131814,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ration :; | docstring; | ; | rotate_n(...); | rotate_n( (SymmetryOperation)arg1, (int)arg2) -> None :; | docstring; | ; | rotate_theta(...); | rotate_theta( (SymmetryOperation)arg1, (float)arg2) -> None :; | docstring; | ; | sigma_xy(...); | sigma_xy( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_xz(...); | sigma_xz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | sigma_yz(...); | sigma_yz( (SymmetryOperation)arg1) -> None :; | docstring; | ; | trace(...); | trace( (SymmetryOperation)arg1) -> float :; | docstring; | ; | transform(...); | transform( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :; | docstring; | ; | transpose(...); | transpose( (SymmetryOperation)arg1) -> None :; | docstring; | ; | unit(...); | unit( (SymmetryOperation)arg1) -> None :; | docstring; | ; | zero(...); | zero( (SymmetryOperation)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 96; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Vector(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Vector; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Vector)arg1, (int)arg2) -> float :; | docstring; | ; | __getitem__( (Vector)arg1, (tuple)arg2) -> float :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __init__( (object)arg1, (int)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:76776,inherit,inherited,76776,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"rational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. CFOUR_FD_PROJECT (CFOUR); CFOUR — Specifies whether or not rotational degrees of freedoms are projected out from the symmetry-adapted coordinates in a finite difference calculations. ON (=0) uses rotationally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE (CFOUR); CFOUR — Specifies the step length in mass-weighted coordinates (in ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP (CFOUR); CFOUR — In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Type: string; Possible Values: FULL, COMP; Default: FULL. CFOUR_FILE_RECSIZ (CFOUR); CFOUR — This specifies the physical length (in integer words) of the records used in the word-addressable direct access files used by CFOUR. This value should always be chosen as a multiple of 512 bytes, as your local system manager certainly understands. Type: integer; Default: 2048. CFOUR_FILE_STRIPE (CFOUR); CFOUR — This option allows the splitting of files. Input is required in the form N1/N2/N3/N4/N5, where N1, N2, N3, N4, and N5 specify the number of files in which MOINTS, GAMLAM, MOABCD, DERINT, and DERGAM are splitted, respectively. Type: string; Default: 0/0/0/0/0. CFOUR_FINITE_PERTURBATION (CFOUR); CFOUR — Specifies the field strength for a perturbation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:43258,adapt,adapted,43258,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['adapt'],['adapted']
Modifiability,"rbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace; docstring. static build(mol, basis=None). c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int; Removes the requested (case-insensitive) double QC variable. del_variable(key). density_fitted(self: psi4.core.Wavefunction) → bool; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:20412,variab,variable,20412,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"rbital( (Molecule)arg1, (str)arg2, (str)arg3 [, (int)arg4]) -> BasisSet :; | Returns new BasisSet for Molecule arg1 for target keyword name arg2 and target keyword value arg3. This suffices for orbital basis sets. For auxiliary basis sets, a default fitting role (e.g., RIFIT, JKFIT) arg4 and orbital keyword value arg5 are required. An optional argument to force the puream setting is arg4 for orbital basis sets and arg6 for auxiliary basis sets.; | ; | C++ signature :; | N5boost10shared_ptrIN3psi8BasisSetEEE pyconstruct_orbital(N5boost10shared_ptrIN3psi8MoleculeEEE,Ss,Ss [,i]); | ; | zero_ao_basis_set(...); | zero_ao_basis_set() -> BasisSet :; | Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0.; | ; | C++ signature :; | N5boost10shared_ptrIN3psi8BasisSetEEE zero_ao_basis_set(); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This cl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:381530,inherit,inherited,381530,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"rbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dcft4; DCFT calculation for the HF+ using DCFT-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. pywrap-db3; Test that Python Molecule class processes geometry like PsiMod Molecule class. fci-h2o; 6-31G H2O Test FCI Energy Point. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. dft1-alt; DFT Functional Test. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. psimrcc-fd-freq2; Mk-MRCCSD frequencies. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specific",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:2622,variab,variables,2622,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['variab'],['variables']
Modifiability,"rbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:17710,variab,variable,17710,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variable']
Modifiability,"rbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:16509,variab,variable,16509,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,3,['variab'],['variable']
Modifiability,"rbitals per irrep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → Annotated[list[float], FixedSize(3)]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Return canonical path to scratch file filenumber based on molecule on self. Parameters:. self (Wavefunction) – Wavefunction instance.; filenumber (int) – Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key)¶; Whether scalar or array QCVariable key has been set on self. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessian. lagrangian(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:17908,variab,variable,17908,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"rc file is to control the; handling of scratch files. PSI4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are sequentially; numbered and are written to /tmp, then deleted at the end of the computation,; unless otherwise instructed by the user.; A Python callable handle to the PSI4 I/O management routines is available,; and is called psi4_io. To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to the ~/.psi4rc; file (note the trailing “/”):; psi4_io.set_default_path('/scratch/user/'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be send to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in fir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:2428,variab,variable,2428,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,2,['variab'],['variable']
Modifiability,rce Quantum Chemistry. _downloads; . /15093ea218ca0a61a6f46db92e78ed97; ; gdma-2.3.pdf. _modules; . /psi4; . /driver; . /p4util; ; psi4.driver.p4util.exceptions; psi4.driver.p4util.fchk; psi4.driver.p4util.fcidump; psi4.driver.p4util.inpsight; psi4.driver.p4util.numpy_helper; psi4.driver.p4util.optproc; psi4.driver.p4util.procutil; psi4.driver.p4util.prop_util; psi4.driver.p4util.python_helpers; psi4.driver.p4util.solvers; psi4.driver.p4util.spectrum; psi4.driver.p4util.text; psi4.driver.p4util.util. /procrouting; ; psi4.driver.procrouting.empirical_dispersion; psi4.driver.procrouting.interface_cfour; psi4.driver.procrouting.proc. /qcdb; ; psi4.driver.qcdb.molecule; psi4.driver.qcdb.vib. psi4.driver.aliases; psi4.driver.diatomic; psi4.driver.driver; psi4.driver.driver_cbs; psi4.driver.driver_cbs_helper; psi4.driver.driver_findif; psi4.driver.driver_nbody; psi4.driver.frac; psi4.driver.inputparser; psi4.driver.ipi_broker; psi4.driver.mdi_engine; psi4.driver.molutil; psi4.driver.pluginutil; psi4.driver.qmmm; psi4.driver.task_base; psi4.driver.task_planner; psi4.driver.wrapper_autofrag; psi4.driver.wrapper_database. psi4.extras. /qcdb; ; qcdb.vib. /qcelemental; ; qcelemental.testing. Overview: module code. _static; ; autodoc_pydantic.css; basic.css; cloud.base.js; cloud.css; cloud.js; doctools.js; documentation_options.js; favicon-psi4.ico; graphviz.css; jquery.cookie.js; language_data.js; nbsphinx-code-cells.css; psi4.css; pygments.css; searchtools.js; sphinx_highlight.js; tabs.css; tabs.js. PSI4: Open-Source Quantum Chemistry; ADC: Ab Initio Polarization Propagator; Interface to adcc by M. F. Herbst and M. Scheurer; Test Suite. api; ; AngularMomentumInt; AOShellCombinationsIterator; array_variable; array_variables; BasisExtents; BasisFunctions; BasisSet; be_quiet; benchmark_blas1; benchmark_blas2; benchmark_blas3; benchmark_disk; benchmark_integrals; benchmark_math; BlockOPoints; BoysLocalizer; BSVec; ccdensity; ccenergy; cceom; cchbar; cclambda; ccresponse; cctransor,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1764509,plugin,pluginutil,1764509,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['plugin'],['pluginutil']
Modifiability,"rce]¶; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/prop-1.html:1275,config,configurational,1275,psi4manual/1.2.1/prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prop-1.html,2,['config'],['configurational']
Modifiability,"rce]¶; Function to process match of molecule name? { ... }. process_multiline_arrays(inputfile)[source]¶; Function to find array inputs that are spread across multiple; lines and squash them into a single line. process_option(spaces, module, key, value, line)[source]¶; Function to process a line with set or in a set block; into global/local domain and keyword/value. process_print_command(matchobj)[source]¶; Function to process match of print and transform; it to PsiMod.print_out(). process_pubchem_command(matchobj)[source]¶; Function to process match of pubchem in molecule block. process_set_command(matchobj)[source]¶; Function to process match of all individual set (module_list); key {[value_list] or $value or value}. process_set_commands(matchobj)[source]¶; Function to process match of set name? { ... }. process_word_quotes(matchobj)[source]¶; Function to determine if argument needs wrapping in quotes as string. quotify(string)[source]¶; Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. pubchem¶. class PubChemObj(cid, mf, iupac)[source]¶. getCartesian()[source]¶; Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. getMoleculeString()[source]¶; Function to obtain a molecule string through; getCartesian() or fail. getSDF()[source]¶; Function to return the SDF (structure-data file) of the PubChem object. getXYZFile()[source]¶; Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. name()[source]¶; Function to return the IUPAC name of the PubChem object. getPubChemResults(name)[source]¶; Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. psiexceptions¶; Module with non-generic exceptions classes. exception PsiException[source]¶; Error class for Psi. exception ValidationError(msg)[source]¶; Error called for problems with the input file. Prints; error",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:5002,variab,variables,5002,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,4,['variab'],['variables']
Modifiability,"rd DMA. Type: double; Default: 4.0. How to configure gdma for building Psi4¶; Role and Dependencies. Role — In PSI4, GDMA is a library that provides additional; quantum chemical capabilities (multipole analysis).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) gdma; Upstream Dependencies — gdma \(\Leftarrow\) Fortran. CMake Variables. ENABLE_gdma — CMake variable toggling whether Psi4 builds with gdma; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gdma, set to an installation directory containing include/GDMA/GDMA_MANGLE.h; gdma_DIR — CMake variable to specify where pre-built gdma can be found. Set to installation directory containing share/cmake/gdma/gdmaConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gdma — CMake variable to force internal build of gdma instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gdma — CMake variable to force detecting pre-built gdma and not falling back on internal build. Examples. Build bundled. >>> cmake -DENABLE_gdma=ON. Build without gdma. >>> cmake. Link against pre-built. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/gdma/root. >>> cmake -DENABLE_gdma=ON -Dgdma_DIR=/path/to/gdma/configdir. Build bundled despite pre-built being detectable. >>> cmake -DENABLE_gdma=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/gdma/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gdma=ON. table of contents. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; GDMA_LIMIT; GDMA_ORIGIN; GDMA_MULTIPOLE_UNITS; GDMA_RADIUS; GDMA_SWITCH. How to configure gdma for building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(). © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/gdma.html:6389,config,configdir,6389,psi4manual/master/gdma.html,https://psicode.org,https://psicode.org/psi4manual/master/gdma.html,2,['config'],"['configdir', 'configure']"
Modifiability,"rd mode; (translate the PSI4 molecule and append additional input from the; cfour block) is intended. The latter is what actually occurs. If; there is both a PSI4 molecule and a molecule in the cfour block,; ZMAT will end up with multiple molecules and multiple *CFOUR(...); blocks, and it will not run. Therefore, if mixing sandwich and; standard or pure-PSI4 computations in an input file, place all; the sandwich jobs at the beginning before declaring PSI4; molecules. If necessary, clear the cfour block with cfour {} before; commencing standard P4C4 jobs. Output¶; The output of xcfour invoked from a PSI4 input file is; written to the PSI4 output file as the computation progresses. If a; Cfour module terminates with a non-zero error code, the value will show up; in CFOUR ERROR CODE.; Energies & Scalars; After execution of xcfour has completed, the output string is; extensively parsed and appropriate results are stored in PSI; Variables. All gleaned variables are printed in the; Cfour output section of the PSI4 output file, as shown below.; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-ccsd(t) Energy Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. Variable Map:; ----------------------------------------------------------------------------; ""(T) CORRECTION ENERGY"" => -0.007263598030; ""CCSD CORRELATION ENERGY"" => -0.275705492359; ""CCSD TOTAL ENERGY"" => -76.338453952539; ""CCSD(T) CORRELATION ENERGY"" => -0.007263598030; ""CCSD(T) TOTAL ENERGY"" => -76.345717550569; ""CFOUR ERROR CODE"" => 0.000000000000; ""CURRENT CORRELATION ENERGY"" => -0.007263598030; ""CURRENT ENERGY"" => -76.345717550569; ""CURRENT REFERENCE ENERGY"" => -76.062748460180; ""MP2 CORRELATION ENERGY"" => -0.270191667755; ""MP2 OPPOSITE-SPIN ENERGY"" => -0.204890356651; ""MP2 SAME-SPIN ENERGY"" => -0.065301311104; ""MP2 TOTAL ENERGY"" => -76.332940127935; ""NUCLEAR REPULSION ENERGY"" => 9.187331653300; ""SCF TOTAL ENERGY"" => -76.062748460180. The PSI Variables are also available from the input file for manipulation.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:19039,variab,variables,19039,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['variab'],['variables']
Modifiability,"rd mode; (translate the PSI4 molecule and append additional input from the; cfour block) is intended. The latter is what actually occurs. If; there is both a PSI4 molecule and a molecule in the cfour block,; ZMAT will end up with multiple molecules and multiple *CFOUR(...); blocks, and it will not run. Therefore, if mixing sandwich and; standard or pure-PSI4 computations in an input file, place all; the sandwich jobs at the beginning before declaring PSI4; molecules. If necessary, clear the cfour block with cfour {} before; commencing standard P4C4 jobs. Output¶; The output of xcfour invoked from a PSI4 input file is; written to the PSI4 output file as the computation progresses. If a; Cfour module terminates with a non-zero error code, the value will show up; in CFOUR ERROR CODE.; Energies & Scalars; After execution of xcfour has completed, the output string is; extensively parsed and appropriate results are stored in PSI; Variables. All gleaned variables are printed in the; Cfour output section of the PSI4 output file, as shown below.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-ccsd(t) Energy Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. Variable Map:; ----------------------------------------------------------------------------; ""(T) CORRECTION ENERGY"" => -0.007263598030; ""CCSD CORRELATION ENERGY"" => -0.275705492359; ""CCSD TOTAL ENERGY"" => -76.338453952539; ""CCSD(T) CORRELATION ENERGY"" => -0.007263598030; ""CCSD(T) TOTAL ENERGY"" => -76.345717550569; ""CFOUR ERROR CODE"" => 0.000000000000; ""CURRENT CORRELATION ENERGY"" => -0.007263598030; ""CURRENT ENERGY"" => -76.345717550569; ""CURRENT REFERENCE ENERGY"" => -76.062748460180; ""MP2 CORRELATION ENERGY"" => -0.270191667755; ""MP2 OPPOSITE-SPIN ENERGY"" => -0.204890356651; ""MP2 SAME-SPIN ENERGY"" => -0.065301311104; ""MP2 TOTAL ENERGY"" => -76.332940127935; ""NUCLEAR REPULSION ENERGY"" => 9.187331653300; ""SCF TOTAL ENERGY"" => -76.06274846018",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:19660,variab,variables,19660,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['variab'],['variables']
Modifiability,"rd mode; (translate the Psi4 molecule and append additional input from the; cfour block) is intended. The latter is what actually occurs. If; there is both a Psi4 molecule and a molecule in the cfour block,; ZMAT will end up with multiple molecules and multiple *CFOUR(...); blocks, and it will not run. Therefore, if mixing sandwich and; standard or pure-Psi4 computations in an input file, place all; the sandwich jobs at the beginning before declaring Psi4; molecules. If necessary, clear the cfour block with cfour {} before; commencing standard P4C4 jobs. Output¶; The output of xcfour invoked from a Psi4 input file is; written to the Psi4 output file as the computation progresses. If a; Cfour module terminates with a non-zero error code, the value will show up; in CFOUR ERROR CODE.; Energies & Scalars; After execution of xcfour has completed, the output string is; extensively parsed and appropriate results are stored in PSI; Variables. All gleaned variables are printed in the; Cfour output section of the Psi4 output file, as shown below.; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-ccsd(t) Energy Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. Variable Map:; ----------------------------------------------------------------------------; ""(T) CORRECTION ENERGY"" => -0.007263598030; ""CCSD CORRELATION ENERGY"" => -0.275705492359; ""CCSD TOTAL ENERGY"" => -76.338453952539; ""CCSD(T) CORRELATION ENERGY"" => -0.007263598030; ""CCSD(T) TOTAL ENERGY"" => -76.345717550569; ""CFOUR ERROR CODE"" => 0.000000000000; ""CURRENT CORRELATION ENERGY"" => -0.007263598030; ""CURRENT ENERGY"" => -76.345717550569; ""CURRENT REFERENCE ENERGY"" => -76.062748460180; ""MP2 CORRELATION ENERGY"" => -0.270191667755; ""MP2 OPPOSITE-SPIN ENERGY"" => -0.204890356651; ""MP2 SAME-SPIN ENERGY"" => -0.065301311104; ""MP2 TOTAL ENERGY"" => -76.332940127935; ""NUCLEAR REPULSION ENERGY"" => 9.187331653300; ""SCF TOTAL ENERGY"" => -76.062748460180. The PSI Variables are also available from the input file for manipulation.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:19104,variab,variables,19104,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['variab'],['variables']
Modifiability,"rd'). qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute()[source]¶; Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. set_coordinates(x, y, z)[source]¶; Given the current set of coordinates, updates the values of this; atom’s coordinates and any variables that may depend on it. type()[source]¶; The type of CoordEntry specialization. class CoordEntry(entry_number, Z, charge, mass, symbol, label='')[source]¶; Class to. Z()[source]¶; The nuclear charge of the current atom (0 if ghosted). static a(a1, a2, a3)[source]¶; Computes the angle (in rad.) between three sets of coordinates. charge()[source]¶; The “atomic charge” of the current atom (for SAD purposes). static d(a1, a2, a3, a4)[source]¶; Computes the dihedral (in rad.) between four sets of coordinates. entry_number()[source]¶; The order in which this appears in the full atom list. everything()[source]¶. is_computed()[source]¶; Whether the current atom’s coordinates are up-to-date. is_equivalent_to(other)[source]¶; Whether this atom has the same mass and ghost status as atom other.; Unlike the libmints version, this does not compare basisset assignment. is_ghosted()[source]¶; Whether the current atom is ghosted or not. label()[s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:35678,variab,variables,35678,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,4,['variab'],['variables']
Modifiability,"rder Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations; Advanced Functional Use and Manipulation. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; Introduction; Theory; Recommendations. CC: Coupled Cluster Theory; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; Advanced OCC Keywords; Basic DFOCC Keywords; Advanced DFOCC Keywords; Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Computations with Mid-bonds; Interpreting SAPT ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/methods-1.html:1691,config,configuration,1691,psi4manual/1.2.1/methods-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/methods-1.html,4,['config'],['configuration']
Modifiability,"rder:; | QuadrupoleInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class RHF(HF, Wavefunction); | docstring; | ; | Method resolution order:; | RHF; | HF; | Wavefunction; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python funct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:593015,inherit,inherited,593015,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"rds; Environment Variables. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; How to configure PCMSolver for building Psi4. Interface to SIMINT by B. Pritchard; Installation; How to configure simint for building Psi4. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/interfacing-1.html:1815,config,configure,1815,psi4manual/1.4.0/interfacing-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/interfacing-1.html,2,['config'],['configure']
Modifiability,"re compilation; What is the directory layout of the installed or staged Psi4; How to run Psi4 as executable after compilation; How to solve ModuleNotFoundError: No module named 'psi4'; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct”; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to get a Psi4 logo file; How to use a local Add-On repository in the Psi4 build. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:60886,config,configure,60886,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,8,['config'],['configure']
Modifiability,"re compilation; What is the directory layout of the installed or staged Psi4; How to run Psi4 as executable after compilation; How to solve ModuleNotFoundError: No module named 'psi4'; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct”; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to get a Psi4 logo file; How to use a local Add-On repository in the Psi4 build. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/build_planning-1.html:60886,config,configure,60886,psi4manual/1.5.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/build_planning-1.html,8,['config'],['configure']
Modifiability,"re good, while H$_2$O and LaTeX tables; are not translated correctly. Python docstrings are absorbed as-is, so; please use reST math formatting (essentially $latex math$ \(\Rightarrow\); :math:`latex math`).; Starting around PSI4 1.1, MathJax is used for in-browser LaTeX; rendering in place of offline PNG generation of math images. Check the; online rendering, as occasionally there will be errors even when the LaTeX; looked sound. The Map of the Sphinx¶. Adding a new Appendix or First-TOC-Level page; Create your reST file and fill it with information. Add the name of your; file to psi4/doc/sphinxman/source/appendices.rst for an appendix or; to psi4/doc/sphinxman/source/index.rst for a first-TOC-level.; Finally, add your file to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your; new page. Adding a new module to “Theoretical Methods”; Copy the file of a well-established module, like; psi4/doc/sphinxman/source/sapt.rst. Change the title, author, sec; label, ref, and source labels at the top of the file to point instead to; your code. Edit psi4/doc/sphinxman/source/methods.rst to add the; name of your file so that it will appear in the TOC tree. Add your file; to the STATICDOC variable in; psi4/doc/sphinxman/CMakeLists.txt. Sphinx will now build with your new; file. Follow the models in existing methods pages to write your; documentation. If you don’t get all the keyword links, bibliography; links, sample inputs, math, tables, etc. working in Sphinx, don’t worry; about it. A genie will probably come through and tidy up all your; source. table of contents. Updating the PSI4 Users’ and Programmers’ Manual; Installing Sphinx; Documentation Structure; reStructuredText; Math in the Codebase; The Map of the Sphinx. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/documentation-1.html:6195,variab,variable,6195,psi4manual/1.3.2/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/documentation-1.html,2,['variab'],['variable']
Modifiability,"re two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, ...); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, ...); Function to compare two vectors. copy_file_from_scratch(filename, prefix, ...); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, ...); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. extract_cluster_indexing(mol[, cluster_size]); Function to returns a LIST of all subclusters of the molecule mol of real size cluster_size. extract_clusters(mol[, ghost, cluster_size]); Function to return all subclusters of the molecule mol of real size cluster_size and all other atoms ghosted if ghost equals true, all other atoms discarded if ghost is false. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, ...); Function to compute approximate string matches fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:197102,variab,variables,197102,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variables']
Modifiability,"re.OEProp(ccwfn); oe.set_title(name.upper()); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; # retire components at v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE"", core.variable(""CC DIPOLE"")); # core.set_variable(""CC ROOT n DIPOLE"", core.variable(""CC DIPOLE"")) # P::e CCENERGY; if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")); # core.set_variable(""CC ROOT n QUADRUPOLE"", core.variable(""CC QUADRUPOLE"")) # P::e CCENERGY. n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:101266,variab,variable,101266,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"re.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp) → None¶; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: object; docstring. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; docstring. print_out(self: psi4.core.CdSalcList) → None¶; docstring. class psi4.core.CorrelationFactor¶; Bases: object; docstring. set_params(self: psi4.core.CorrelationFactor, arg0: psi4.core.Vector, arg1: psi4.core.Vector) → None¶; docstring. class psi4.core.CorrelationTable¶; Bases: object; docstring. degen(self: psi4.core.CorrelationTable, arg0: int) → int¶; docstring. group(*args, **kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:25445,variab,variable,25445,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variable']
Modifiability,"re.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp) → None¶; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.ROHF¶; Bases: psi4.core.HF; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:105335,variab,variable,105335,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variable']
Modifiability,"re.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp) → None¶; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.SOBasisSet¶; Bases: object; docstring. petite_list(self: psi4.core.SOBasisSet) → psi4.core.PetiteList¶; docstring. class psi4.core.SOMCSCF¶; Bases: object; docstring. Ck(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶. H_approx_diag(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. approx_solve(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. compute_AFock(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Hk(self: psi4.co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:114807,variab,variable,114807,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variable']
Modifiability,"re.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp) → None¶; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.VBase¶; Bases: object; docstring. C(self: psi4.core.VBase) → List[psi4.core.Matrix]¶; doctsring. C_add(self: psi4.core.VBase, arg0: psi4.core.Matrix) → None¶. C_clear(self: psi4.core.VBase) → None¶. D(self: psi4.core.VBase) → List[psi4.core.Matrix]¶; doctsring. V(self: psi4.core.VBase) → List[psi4.core.Matrix]¶; doctsring. basis(self: psi4.core.VBase) → psi4.core.BasisSet¶; doctsring. build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str) → psi4.core.VBase¶. compute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:131383,variab,variable,131383,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variable']
Modifiability,"re.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_oeprop(self: psi4.core.Wavefunction, arg0: psi4.core.OEProp) → None¶; Associate an OEProp object with this wavefunction. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. class psi4.core.IO¶; Bases: object; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str) → None¶; docstring. close(self: psi4.core.IO, arg0: int, arg1: int) → None¶; docstring. get_default_namespace() → str¶; docstring. open(self: psi4.core.IO, arg0: int, arg1: int) → None¶; docstring. open_check(self: psi4.core.IO, arg0: int) → int¶; docstring. rehash(self: psi4.core.IO, arg0: int) → None¶; docstring. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:55168,variab,variable,55168,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['variab'],['variable']
Modifiability,"re.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n"");; core.print_out(""\t\t\t - Starship Troopers\n\n"");; core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n"");; core.print_out(""\t\t\t - Edward Valeev\n"");. if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; # retire components in v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")); core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:124817,variab,variable,124817,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['variab'],['variable']
Modifiability,"re.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). sapt_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"",; core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = core.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:113136,variab,variable,113136,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"re.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:25148,variab,variable,25148,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,1,['variab'],['variable']
Modifiability,"re.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(""CC""); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")). n_root = sum(core.get_global_option(""ROOTS_PER_IRREP"")); for rn in range(n_root):; oe.set_title(""CC ROOT {}"".format(rn + 1)); Da = ccwfn.variable(""CC ROOT {} Da"".format(rn + 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Fun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:80086,variab,variable,80086,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variable']
Modifiability,"re.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(HOMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(HOMO) - 1)). occs.append(occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Traverse Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. core.print_out(""""""; You trying to be a hero Watkins?; Just trying to kill some bugs sir!; -Starship Troopers""""""). # Drop the files out; wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:7860,variab,variable,7860,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,8,['variab'],['variable']
Modifiability,"re.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:96737,variab,variable,96737,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variable']
Modifiability,"re.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'); elif name == 'custom-scs-olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'CUSTOM'). else:; raise ValidationError(""""""Invalid method %s"""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). if name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); core.set_loc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:72171,variab,variables,72171,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['variab'],['variables']
Modifiability,"re_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. compare_wavefunctions(expected, computed[, …]); Function to compare two wavefunctions. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump). energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, …); Find list of approximate (within max_distance) matches to string seq1 among options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:310163,plugin,plugin,310163,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['plugin'],['plugin']
Modifiability,"re_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.varia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:35430,variab,variables,35430,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,2,['variab'],['variables']
Modifiability,"reaching; accurate energies even in the presence of significant linear; dependencies [Lehtola:2020:134108].; In PSI4, symmetric orthogonalization is used by default, unless; the smallest overlap eigenvalue falls below the user-supplied double; option S_TOLERANCE, which defaults to 1E-7. If the smallest; eigenvalue is below this cutoff, canonical orthogonalization is; forced, and all eigenvectors corresponding to eigenvalues below the; cutoff are eliminated.; If the eigendecomposition is detected to be numerically unstable - the; reciprocal condition number of the overlap matrix to be smaller than; the machine epsilon - the partial Cholesky decomposition is undertaken; until S_CHOLESKY_TOLERANCE, which defaults to 1E-8.; Use of symmetric, canonical, and partial Cholesky orthogonalization; can be forced by setting the S_ORTHOGONALIZATION option to; SYMMETRIC, CANONICAL, or PARTIALCHOLESKY,; respectively.; Note that in practice, the MOs and OSOs are built separately within; each irrep from the symmetry-adapted combinations of AOs known as; Unique Symmetry Orbitals (USOs). For canonical orthogonalization,; this implies that the number of MOs and OSOs per irrep may be slightly; smaller than the number of USOs per irrep.; A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output:; ==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; -------------------------------------------------------; Total 287 287 5 5 5 0; -------------------------------------------------------. ... Minimum ei",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:14084,adapt,adapted,14084,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,3,['adapt'],['adapted']
Modifiability,"reagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:44854,variab,variable,44854,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['variab'],['variable']
Modifiability,"reagents is; employed ('on') or whether it is forced to \(C_1\) symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (str) – \(\Rightarrow\) 'default' \(\Leftarrow\) || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (Union[str, List[str]]) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || 'HB' || etc.For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database pyth",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:4303,flexible,flexible,4303,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,9,['flexible'],['flexible']
Modifiability,"ream Dependencies — PSI4 (\(\Leftarrow\) optional) CheMPS2; Upstream Dependencies — CheMPS2 \(\Leftarrow\) HDF5 \(\Leftarrow\) zlib. CMake Variables. ENABLE_CheMPS2 — CMake variable toggling whether Psi4 builds with CheMPS2; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For CheMPS2, set to an installation directory containing include/chemps2/DMRG.h; CheMPS2_DIR — CMake variable to specify where pre-built CheMPS2 can be found. Set to installation directory containing share/cmake/CheMPS2/CheMPS2Config.cmake; CMAKE_DISABLE_FIND_PACKAGE_CheMPS2 — CMake variable to force internal build of CheMPS2 instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_CheMPS2=ON. Build without CheMPS2. >>> cmake. Build bundled with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/hdf5. Link against pre-built. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/chemps2/root. >>> cmake -DENABLE_CheMPS2=ON -DCheMPS2_DIR=/path/to/chemps2/configdir. Link against pre-built with specific HDF5. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=""/path/to/chemps2/root;/path/to/hdf5/root"". Build bundled despite pre-built being detectable. >>> cmake -DENABLE_CheMPS2=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/chemps2/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_CheMPS2=ON. How to fix “plugin needed to handle lto object” when building CheMPS2¶; For building with GCC, errors involving unresolved symbols or a message; “plugin needed to handle lto object” may indicate a failure of the; interprocedural optimization. This can be resolved by passing full; locations to gcc toolchain utilities to setup or cmake:; -DCMAKE_RANLIB=/path/to/gcc-ranlib -DCMAKE_AR=/path/to/gcc-ar .; Details at https://github.com/psi4/psi4/issues/414. table of contents. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; DMRG_CASPT2_CALC; DMRG_CASPT2_IMAG; DMRG_CASPT2_IPEA; DMRG_CASPT2_ORBS;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/chemps2-1.html:6466,config,configdir,6466,psi4manual/1.1.0/chemps2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/chemps2-1.html,2,['config'],['configdir']
Modifiability,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make.; PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --new-plugin myplugin +aointegrals; >>> psi4 --new-plugin myplugin +mointegrals; >>> psi4 --new-plugin myplugin +sointegrals; >>> psi4 --new-plugin myplugin +wavefunction. Several stable sample plugin directories are available to consult in the; psi4/plugins directory. Other plugin directories can be used as models; but are in active development. For documentation on plugin modules, see; Available Plugins. psi4/plugins/aointegrals/aointegrals.cc.in; An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals. psi4/plugins/mointegrals/mointegrals.cc.in; An example that uses the LibTrans library to generate and print MO basis integrals.; psi4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so execut",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:3255,plugin,plugin,3255,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,2,['plugin'],['plugin']
Modifiability,"reate basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment:. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/plugins-1.html:1780,plugin,plugin-name,1780,psi4manual/1.4.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/plugins-1.html,108,['plugin'],"['plugin-name', 'plugin-template']"
Modifiability,"recated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:42480,variab,variables,42480,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"recated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variable"", ""psi4.core.variable"", 1.9, f"" Replace `get_variable` with `variable` (or `scalar_variable` for scalar variables only).""). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_variables` with `psi4.core.variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:44549,variab,variables,44549,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:5405,plugin,plugin,5405,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import psi4; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; psi4.plugin_load(sofile).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/plugins-1.html:5405,plugin,plugin,5405,psi4manual/4.0b5/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL¶. Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Possible Values: SCF, HF, MBPT(2), MP2, MBPT(3), MP3, SDQ-MBPT(4), SDQ-MP4, MBPT(4), MP4, CCD, CCSD, CCSD(T), CCSDT-1, CCSDT-1b, CCSDT-2, CCSDT-3, CCSDT-4, CCSDT, CC2, CC3, QCISD, QCISD(T), CID, CISD, UCC(4), B-CCD; Default: SCF. CFOUR_CC_CONV¶. Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than \(10^N\), where \(N\) is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER¶. Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in the solution of the CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION¶. Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Purvis and Bartlett, DIIS (=1) uses the DIIS approach by Pulay, NOJACOBI (=2) uses RLE with continuous extrapolation, OFF (=3) uses no convergence acceleration. In general, DIIS provides the best results and is recommended, while OFF often results in poor convergence and thus cannot be recommended. Type: string; Possible Values: RLE, DIIS, NOJACOBI, OFF; Default: DIIS. CFOUR_CC_MAXCYC¶. Specifies the maximum number of iterations in solving the CC amplitude equations. Type: integer; Default: 50. CFOUR_CC_PROGRAM¶. Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC sho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html:9184,enhance,enhance,9184,psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,4,['enhance'],['enhance']
Modifiability,"rection for deformation energy is; employed in computing interaction energies. Option available; (See Available Databases) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. symm (boolean) – 'on' || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || 'off' ; Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (string) – 'default' || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (array of strings) – [] || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (string or array of strings) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'; Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || 'HB' || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/db-1.html:3861,variab,variables,3861,psi4manual/1.0.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/db-1.html,8,['variab'],['variables']
Modifiability,"rection for deformation energy is; employed in computing interaction energies. Option available; (See Available Databases) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. symm (boolean) – 'on' || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || 'off' ; Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (string) – 'default' || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (array of strings) – [] || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (string or array of strings) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'; Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file. [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Speci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/db-1.html:3546,variab,variables,3546,psi4manual/4.0b2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/db-1.html,2,['variab'],['variables']
Modifiability,"recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Arguments:; mdi_arguments: MDI configuration options; """"""; MDI_Init(mdi_arguments). [docs]def mdi_run(scf_method, **kwargs):; """""" Begin functioning as an MDI engine. Arguments:; scf_method: Method used when calculating energies or gradients; """"""; engine = MDIEngine(scf_method, **kwargs); engine.listen_for_commands(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; psi4.driver.mdi_engine. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html:12967,config,configuration,12967,psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,2,['config'],['configuration']
Modifiability,"red in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:39524,variab,variable,39524,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"red in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array varia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:37452,variab,variable,37452,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"red; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:; if asp not in computed and asp in forgive:; continue. if toldict is not None and asp in toldict:; ktol = toldict[asp]; else:; ktol = tol. if asp in 'qwx':; ccnc = _phase_cols_to_max_element(computed[asp].data); eenc = _phase_cols_to_max_element(expected[asp].data); ccnc = _check_degen_modes(ccnc, computed['omega'].data); eenc = _check_degen_modes(eenc, expected['omega'].data); same = np.allclose(eenc, ccnc, atol=ktol); print_stuff(asp=asp, same=same, ref=eenc, val=ccnc, space='\n'); same = _check_rank_degen_modes(ccnc, computed[""omega""].data, eenc, difftol=ktol, svdtol=svdtol). elif asp in ['gamma', 'TRV']:; same = all([computed[asp].data[idx] == val for idx, val in enumerate(expected[asp].data)]); print_stuff(asp=asp, same=same, ref=expected[asp].data, val=computed[asp].data). elif isinstance(expected[asp].data, float):; same = abs(expected[asp].data - computed[asp].data) < ktol; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html:3285,extend,extend,3285,psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,24,['extend'],['extend']
Modifiability,"red_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:59550,variab,variables,59550,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['variab'],['variables']
Modifiability,"reduce__ = <unnamed Boost.Python function>(...); | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimitive( (BasisSet)arg1) -> int :; | docstring; | ; | nshell(...); | nshell( (BasisSet)arg1) -> int :; | docstring; | ; | print_detail_out(...); | print_detail_out( (BasisSet)arg1) -> None :; | docstring; | ; | print_out(...); | print_out( (BasisSet)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | construct(...); | construct( (BasisSetParser)arg1, (Molecule)arg2, (str)arg3) -> BasisSet :; | docstring; | ; | make_filename(...); | make_filename( (str)arg1) -> str :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSetParser(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSetParser; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:3275,inherit,inherited,3275,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ree components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory.; Deprecated in favor of CI ROOT n -> ROOT m DIPOLE. CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory.; Deprecated in favor of CI ROOT n -> ROOT m QUADRUPOLE. CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n.; Deprecated in favor of CI ROOT n DIPOLE. CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n.; Deprecated in favor of CI ROOT n QUADRUPOLE. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for state-averaged CI/CASSCF levels of theory. CI TOTAL E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:12207,config,configuration,12207,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['config'],['configuration']
Modifiability,"ree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:24221,variab,variables,24221,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['variab'],['variables']
Modifiability,"reet, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #; from __future__ import absolute_import; from __future__ import print_function; from decimal import Decimal, ROUND_FLOOR, ROUND_CEILING; from .exceptions import *. [docs]class PreservingDict(dict):; """"""Class to store quantum chemical quantities extracted from output; files. Extends the dictionary object to (1) store key as all-caps; version of itself and (2) validate value for duplicate values for the; same key by testing which has more decimal places and whether value; the same within a plausing rounding error. Allows consistency checks; when parsing output files without loss of precision. """""". def __init__(self, *args, **kwargs):; self.update(*args, **kwargs). def __setitem__(self, key, value):; try:; key = key.upper(); except AttributeError:; raise AttributeError('Keys stored as upper-case strings: %s unsuitable' % (key)); value = Decimal(value); if key in self.keys() and not 'CURRENT' in key:; # Validate choosing more detailed value for variable; existing_exp = self[key].as_tuple().exponent # 0.1111 --> -4; candidate_exp = value.as_tuple().exponent; if existing_exp > candidate_exp: # candidate has more digits; places = Decimal(10) ** (existing_exp + 1) # exp+1 permits slack in rounding; best_value = value; else: # existing has more digits; places = Decimal(10) ** (candidate_exp + 1); best_value = self[key]; # Validate values are the same; places = max(places, Decimal('1E-11')) # for computed psivars; #print('FLOOR: ', self[key].quantize(places, rounding=ROUND_FLOOR) - value.quantize(places, rounding=ROUND_FLOOR)); #print('CEIL: ', self[key].quantize(places, rounding=ROUND_CEILING) - value.quantize(places, rounding=ROUND_CEILING)); if (self[key].quantize(places, rounding=ROUND_CEILING).compare(value.quantize(places, rounding=ROUND_CEILING)) != 0) and \; (self[key].quantize(places, rounding=ROUND_FLOOR).compare(value.quantize(places, rounding=ROUND_FLOOR)) != 0):; raise ParsingValidationError(; """"""O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html:1926,variab,variable,1926,psi4manual/1.0.0/_modules/qcdb/pdict.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/pdict.html,1,['variab'],['variable']
Modifiability,"referred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /scratch/user. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/scratch/user. PSIPATH¶; Path in which PSI4 looks for user extensions to the built-in; libraries. Specifically, directories containing; user basis sets,; EFP fragments,; databases,; plugins, and; interfaced executables (; dmrcc for MRCC and; dftd3 for DFTD3; ) should be placed in this colon-separated list.; PSI4 is designed so that user extensions that are findable through; PSIPATH can be used in input files entirely like their; built-in counterparts, without additional tagging as non-standard.; The typical search path is first the built-in libraries, next each; PSIPATH directory in order, and finally the execution; directory (I won’t swear everything tacks on the execution directory).; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins or databases.; Modify PSIPATH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIPATH /home/user/psiadditions:/home/user/gbs. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSIPATH=/home/user/psiadditions:/home/user/gbs. PYTHONPATH¶; Path in which the Python interpreter looks for modules to im",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:19287,plugin,plugins,19287,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,6,['plugin'],['plugins']
Modifiability,"refix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation).; 1; 2>>> cd {objdir}; >>> make -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. 1>>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run Psi4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that Python,; CMake, NumPy, and Libint (and even C++ compilers on Linux) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++11 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (2.7, 3.5, or 3.6) https://www.python.org/; CMake (3.3+) http://www.cmake.org/download/; NumPy (needed at runtime, not buildtime) http://www.numpy.org/; System utilities: GNU make, GNU install, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download and build. Libint — [what is this?] [min version]; pybind11 — [what is this?] [min version]. What are the add-on capabilities for Psi4 and what are their dependencies¶; Each of the items below is an independent additional capability that can; be built with PSI4. Sub-items below are the respective additional; dependencies of the add-on. Select which, if any, you want, and examine; the links for appropriate enabling arguments to c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:3762,config,configure,3762,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['config'],['configure']
Modifiability,"rence rhf\"".'). do_delta_mp2 = True if name.endswith('dmp2') else False; do_empirical_disp = True if '-d' in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). # raise Exception(""""). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:134262,variab,variable,134262,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variable']
Modifiability,"rent helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/prog_tour.html:2708,variab,variables,2708,psi4manual/1.7.x/prog_tour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/prog_tour.html,1,['variab'],['variables']
Modifiability,"rep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → Annotated[List[float], FixedSize(3)]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Return canonical path to scratch file filenumber based on molecule on self.; :rtype: str. Parameters:. self (Wavefunction) – Wavefunction instance.; filenumber (int) – Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → bool¶; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key)¶; Whether scalar or array QCVariable key has been set on self.; :rtype: bool. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction’s Hessi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:18073,variab,variable,18073,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['variab'],['variable']
Modifiability,"requested Alpha Orbital subset. Cb(self); Returns the Beta Orbitals. Cb_subset(self, arg0, arg1); Returns the requested Beta Orbital subset. Da(self); Returns the Alpha Density Matrix. Da_subset(self, arg0); Returns the requested Alpha Density subset. Db(self); Returns the Beta Density Matrix. Db_subset(self, arg0); Returns the requested Beta Density subset. Fa(self); Returns the Alpha Fock Matrix. Fa_subset(self, arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self, arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. X(self); Returns the Lagrangian Matrix. alpha_orbital_space(self, arg0, arg1, arg2); docstring. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:1356,variab,variable,1356,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Summary. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). gradient(self); Returns the Wavefunction’s gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key). hessian(self); Returns the Wavefunction’s Hessian. legacy_frequencies(). mo_extents(self); returns the wavefunction’s electronic orbital extents. molecule(self); Returns the Wavefunction’s molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(sel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:3840,variab,variable,3840,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variable']
Modifiability,"requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [E_h] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [E_h] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [E_h] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). CURRENT HESSIAN¶; The total electronic Hessian [E_h/a0/a0] of the most recent stage of a; calculation, (3 * {nat}, 3 * {nat}). CUSTOM SCS-M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:23613,variab,variable,23613,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['variab'],['variable']
Modifiability,"requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶. variables()¶. class psi4.core.CdSalc¶; Bases: pybind11_builtins.pybind11_object; Cartesian displacement SALC. irrep(self: psi4.core.CdSalc) → str¶; Return the irrep bit representation. irrep_index(self: psi4.core.CdSalc) → int¶; Return the irrep index. print_out(self: psi4.core.CdSalc) → None¶; Print the irrep index and the coordinates of the SALC of Cartesian displacements. Irrep index is 0-indexed and Cotton ordered. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList) → int¶; Return the number of irreps. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CharacterTable¶; Bases: pybind11_builtins.pybind11_object; Contains the character table of the point group. gamma(self: ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:51652,adapt,adapted,51652,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['adapt'],['adapted']
Modifiability,requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three c,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:7717,config,configuration,7717,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['config'],['configuration']
Modifiability,requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD DIPOLE X¶. CISD DIPOLE Y¶. CISD DIPOLE Z¶; The three c,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:7209,config,configuration,7209,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,8,['config'],['configuration']
Modifiability,requested; configuration interaction level of theory and root. CI QUADRUPOLE XX¶. CI QUADRUPOLE XY¶. CI QUADRUPOLE XZ¶. CI QUADRUPOLE YY¶. CI QUADRUPOLE YZ¶. CI QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root. CI ROOT n -> ROOT m DIPOLE X¶. CI ROOT n -> ROOT m DIPOLE Y¶. CI ROOT n -> ROOT m DIPOLE Z¶; The three components of the transition dipole [Debye] between roots n; and m for the requested configuration interaction level of theory. CI ROOT n -> ROOT m QUADRUPOLE XX¶. CI ROOT n -> ROOT m QUADRUPOLE XY¶. CI ROOT n -> ROOT m QUADRUPOLE XZ¶. CI ROOT n -> ROOT m QUADRUPOLE YY¶. CI ROOT n -> ROOT m QUADRUPOLE YZ¶. CI ROOT n -> ROOT m QUADRUPOLE ZZ¶; The three components of the transition quadrupole [Debye Ang] between; roots n and m for the requested configuration interaction level of; theory. CI ROOT n DIPOLE X¶. CI ROOT n DIPOLE Y¶. CI ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; configuration interaction level of theory and root n. CI ROOT n QUADRUPOLE XX¶. CI ROOT n QUADRUPOLE XY¶. CI ROOT n QUADRUPOLE XZ¶. CI ROOT n QUADRUPOLE YY¶. CI ROOT n QUADRUPOLE YZ¶. CI ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; configuration interaction level of theory and root n. CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root; n (numbering starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL E,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:2816,config,configuration,2816,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,2,['config'],['configuration']
Modifiability,"resh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:5219,plugin,plugin,5219,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,4,['plugin'],['plugin']
Modifiability,"residual vector of preconditioned conjugate gradient method. Type: conv double; Default: 1e-6. PCG_MAXITER¶. Maximum number of preconditioned conjugate gradient iterations. Type: integer; Default: 30. RELAXED¶. Do consider orbital response contributions for PDMs and GFM?. Type: boolean; Default: true. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SS_SCALE¶. A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SYMMETRIZE¶. Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. Expert¶. SPIN_SCALE_TYPE¶. Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. table of contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_DIIS_MAX_VECS; CC_DIIS_MIN_VECS; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DIIS_MAX_VECS; DIIS_M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__occ-1.html:7637,variab,variable,7637,psi4manual/1.4.0/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__occ-1.html,8,['variab'],['variable']
Modifiability,"residual vector of preconditioned conjugate gradient method. Type: conv double; Default: 1e-6. PCG_MAXITER¶. Maximum number of preconditioned conjugate gradient iterations. Type: integer; Default: 30. RELAXED¶. Do consider orbital response contributions for PDMs and GFM?. Type: boolean; Default: true. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SS_SCALE¶. A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SYMMETRIZE¶. Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. Expert¶. SPIN_SCALE_TYPE¶. Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. table of contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DIIS_MAX_VECS; DIIS_MIN_VECS; DO_DIIS; DO_LEVEL_SHIFT; DO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__occ.html:7367,variab,variable,7367,psi4manual/1.6.x/autodir_options_c/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__occ.html,2,['variab'],['variable']
Modifiability,"responding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import print_function; """"""Module with utility classes and functions related; to data tables and text. """"""; import sys; import re; from psi4 import core; from psi4.driver import constants; from .exceptions import *. [docs]class Table(object):; """"""Class defining a flexible Table object for storing data."""""". def __init__(self, rows=(),; row_label_width=10,; row_label_precision=4,; cols=(),; width=16, precision=10):; self.row_label_width = row_label_width; self.row_label_precision = row_label_precision; self.width = width; self.precision = precision; self.rows = rows. if isinstance(cols, str):; self.cols = (cols,); else:; self.cols = cols. self.labels = []; self.data = []. [docs] def format_label(self):; """"""Function to pad the width of Table object labels.""""""; #str = lambda x: (('%%%d.%df' % (self.row_label_width, self.row_label_precision)) % x); str = lambda x: (('%%%ds' % (self.row_label_width)) % x); return "" "".join(map(str, self.labels)). [docs] def format_values(self, values):; """"""Function to pad the width of Table object data cells.""""""; str = lambda x: (('%%%d.%df' % (self.width, self.precision)) % x); return "" "".join(map(str, values)). def __getitem__(self, value):; self.labels.append(value); return self. def __setitem__(self, name, va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/text.html:1358,flexible,flexible,1358,psi4manual/1.1.0/_modules/psi4/driver/p4util/text.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/text.html,1,['flexible'],['flexible']
Modifiability,"return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level). # Load the fort.56 file; # and dump a copy int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:151315,variab,variables,151315,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variables']
Modifiability,"return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level). # Load the fort.56 file; # and dump a copy into ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:157117,variab,variables,157117,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variables']
Modifiability,"return {**cls.scalar_variables(), **cls.array_variables()}. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:21608,variab,variables,21608,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['variab'],['variables']
Modifiability,"returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html:4298,variab,variable,4298,psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,4,['variab'],['variable']
Modifiability,"returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction’s gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction’s Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction’s electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction’s molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:4282,variab,variable,4282,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,3,['variab'],['variable']
Modifiability,"reviously.; # Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState(...) was set up previously; optstash.restore(). Current best practice is to store as much as possible on the wavefunction, not in globals. The; driver should handle interactions with globals. When QCVariables are stored on the wavefunction in; the module, copy to globals with the below:; # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). The function should return the wavefunction, except for rare cases like EFP where no wavefunction available.; For now, CURRENT ENERGY will be set by; energy(), etc. In future, this will be extracted from the wavefunction.; # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods¶; There are several conditions when a method and derivative combination should be managed:. when functionality overlaps between modules, a pattern is needed to; access each route through the code;; when functionality doesn’t overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; FREEZE_CORE state (AE/FC).; for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn’t; exactly match energy functionality, a pattern is needed to decide analytic vs. finite difference.; when default typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/proc_py.html:3790,variab,variables,3790,psi4manual/1.7.x/proc_py.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/proc_py.html,4,['variab'],['variables']
Modifiability,"rg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self, dipole_field, …); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self, …); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:4680,variab,variable,4680,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,6,['variab'],"['variable', 'variables']"
Modifiability,"rg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self[, dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[, ...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (nato",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:4698,variab,variable,4698,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,8,['variab'],"['variable', 'variables']"
Modifiability,"rg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html:4396,variab,variable,4396,psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,4,['variab'],['variable']
Modifiability,"rg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction’s gradient. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction’s Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction’s electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction’s molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:4380,variab,variable,4380,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,3,['variab'],['variable']
Modifiability,"rg0, arg1); Returns the requested Beta Orbital subset. Da(self); Returns the Alpha Density Matrix. Da_subset(self, arg0); Returns the requested Alpha Density subset. Db(self); Returns the Beta Density Matrix. Db_subset(self, arg0); Returns the requested Beta Density subset. Fa(self); Returns the Alpha Fock Matrix. Fa_subset(self, arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self, arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. X(self); Returns the Lagrangian Matrix. alpha_orbital_space(self, arg0, arg1, arg2); docstring. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key). density_fitted(self); Returns whether this wavefunction was ob",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:1429,variab,variables,1429,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variables']
Modifiability,"rg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. variable(key)¶. variables()¶. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix; Returns the Alpha Fock Matrix. Fa_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix; Returns the Alpha Fock ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:16932,variab,variables,16932,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['variab'],['variables']
Modifiability,"rg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. variable(key)¶. variables()¶. class psi4.core.CIVector¶; Bases: pybind11_builtins.pybind11_object; docstring. axpy(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int, arg3: int) → None¶; docstring. close_io_files(self: psi4.core.CIVector, arg0: int) → None¶; docstring. copy(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int) → None¶; docstring. dcalc(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int) → float¶; docstring. divide(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: float, arg2: int, arg3: int) → None¶; docstring. init_io_files(self: psi4.core.CIVector, arg0: bool) → None¶; docstring. norm(self: psi4.core.CIVector, arg0: int) → float¶; docstring. np¶; Returns a view of the CIVector’s buffer. read(self: psi4.core.CIVector, arg0: int, arg1: int) → int¶; docstring. scale(self: psi4.core.CIVector, arg0: float, arg1: int) → None¶; docstring. set_nvec(self: psi4.core.CIVector, arg0: int) → None¶; docstring. shift(self: psi4.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:19569,variab,variables,19569,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variables']
Modifiability,"rg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. variable(key)¶. variables()¶. class psi4.core.DFHelper¶; Bases: pybind11_builtins.pybind11_object; docstring. add_space(self: psi4.core.DFHelper, arg0: str, arg1: psi4.core.Matrix) → None¶. add_transformation(self: psi4.core.DFHelper, name: str, key1: str, key2: str, order: str='Qpq') → None¶. clear_all(self: psi4.core.DFHelper) → None¶. clear_spaces(self: psi4.core.DFHelper) → None¶. get_AO_core(self: psi4.core.DFHelper) → bool¶. get_AO_size(self: psi4.core.DFHelper) → int¶. get_MO_core(self: psi4.core.DFHelper) → bool¶. get_memory(self: psi4.core.DFHelper) → int¶. get_method(self: psi4.core.DFHelper) → str¶. get_schwarz_cutoff(self: psi4.core.DFHelper) → float¶. get_space_size(self: psi4.core.DFHelper, arg0: str) → int¶. get_tensor(*args, **kwargs)¶; Overloaded function. get_tensor(self: psi4.core.DFHelper, arg0: str) -> psi4.core.Matrix; get_tensor(self: psi4.core.DFHelper, arg0: str, arg1: List[int], arg2: List[int], arg3: List[int]) -> psi4.core.Matrix. get_tensor_shape(self: psi4.core.DFHelper, arg0: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:66081,variab,variables,66081,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variables']
Modifiability,"rg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. set_variable(key, val)¶. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters:; wfn (Wavefunction) – A Wavefunction or inherited class; filename (None, optional) – An optional filename to write the data to. Returns:A dictionary and NumPy representation of the Wavefunction. Return type:dict. variable(key)¶. variables()¶. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.array_variable(arg0: str) → psi::Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. psi4.core.array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of all Matrix QC variables. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas3(arg0: int, arg1: float, arg2: int) → None¶; docstring. psi4.core.benchmark_disk(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_integrals(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_math(arg0: float) → None¶; docstring. psi4.core.ccdensity(arg0: psi::Wavefunction) → float¶; Runs the code to compute coupled cluster density matrices. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:276796,variab,variables,276796,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variables']
Modifiability,"rg3, arg4, arg5, …); docstring. DSYMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYR(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYR2(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(arg0); Runs the ADC propagator code, for excited states. array_variable(arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(); Returns dictionary of all Matrix QC variables. be_quiet(); Redirects output to /dev/null. benchmark_blas1(arg0, arg1); docstring. benchmark_blas2(arg0, arg1); docstring. benchmark_blas3(arg0, arg1, arg2); docstring. benchmark_disk(arg0, arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:292772,variab,variables,292772,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['variab'],['variables']
Modifiability,"rg5); docstring. DSYEV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:2378,variab,variable,2378,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['variab'],['variable']
Modifiability,"rg; Perl (for some auto-documentation scripts) http://perl.org; nbsphinx (for converting Jupyter notebooks) http://nbsphinx.readthedocs.io/en/jupyter-theme/; sphinx-psi-theme https://github.com/psi4/sphinx-psi-theme; See [“message” lines] for advice on obtaining docs dependencies. CheMPS2 — [what is this?] [min version]; HDF5 https://support.hdfgroup.org/HDF5/; zlib http://www.zlib.net/. libefp — [what is this?] [min version]; erd — [what is this?] [min version]; Fortran Compiler. dkh — [what is this?] [min version]; Fortran Compiler. gdma — [what is this?] [min version]; Fortran Compiler. PCMSolver — [what is this?]; Fortran Compiler; zlib http://www.zlib.net/. simint — [what is this?] [min version]. Additionally, there are runtime-only capabilities:. cfour — [what is this?]; dftd3 — [what is this?]; gcp — [what is this?]; mrcc — [what is this?]; v2rdm_casscf — [what is this?]; snsmp2 — [what is this?]. How to configure code to use high angular momentum basis sets¶; The Libint integral code handles arbitrary order; angular momentum, but compiling that is prohibitive. The default of 5; is generally good. 6 has met all of a research group’s needs for; years. 4 is handy for quickly testing other parts of the build. Build with Higher Angular Momentum; >>> cmake -DMAX_AM_ERI=6. Relevant CMake Options:; MAX_AM_ERI=N # The maximum angular momentum level (1=p, 2=d, 3=f,; # etc.) for the libint integrals and derivative; # integrals. A value of N implies a maximum first; # derivative of N-1, and maximum second derivative of; # N-2, so for an atom such as Neon, the default 5 gets; # you conventional cc-pV5Z for energies, cc-pVQZ for; # gradients, cc-pVTZ for frequencies and density-fitted; # cc-pVQZ for energies, cc-pVTZ for gradients, cc-pVDZ; # for frequencies. [default: 5]. Note that since PSI4 1.1, it is possible to build Libint; independently (or install just the libint conda package), then have; any/all PSI4 builds detect that installation at compile-time. How to configu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:6476,config,configure,6476,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['config'],['configure']
Modifiability,"rget install -j`getconf _NPROCESSORS_ONLN`. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. >>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/local/psi4. 2. Plan Configuration. Examine the strict and optional software requirements to make sure the; target computer has all the necessary dependencies installed. What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies. Prepare any necessary or desired configuration options for cmake,; hereafter [your configuration options]. How to see what build configuration options are available; Planning: how to configure Psi4 and invoke CMake. 3. Configure. Run CMake with planned options and directories, as below. It reports on; software found or unfound as it scans the computer, then (upon success); creates objdir ready for compilation.; >>> cmake -S. -B{objdir} -DCMAKE_INSTALL_PREFIX={prefix} [your configuration options]. 4. Compile. Compile the code (optional -j triggers parallel compilation). >>> cd {objdir}; >>> cmake --build . -j`getconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest and Pytest to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. >>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; >>> cmake --install . 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. W",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:3342,config,configuration,3342,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,6,['config'],"['configuration', 'configure']"
Modifiability,"rget molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MASSES"": self.send_masses,; ""<",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2971,variab,variables,2971,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,6,['variab'],['variables']
Modifiability,"rgs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # CC_LAMBDA keyword was being set TRUE sporadically, but that's covered c-side. director = {; ""mp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:65948,variab,variables,65948,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['variab'],['variables']
Modifiability,"rguments; BasisSet; BasisSetParser; Gaussian94BasisSetParser; CdSalcList; Checkpoint; DFChargeFitter; Dimension; Dispersion; Environment; ExternalPotential; FittingMetric; Functional; GridProp; IO; IOManager; IntVector; Matrix; MatrixFactory; MintsHelper; MoldenWriter; Molecule; MultipoleSymmetry; NBOWriter; OEProp; OrbitalSpace; PetiteList; PointGroup; Process; PseudoTrial; SOBasisSet; SuperFunctional; SymmetryOperation; Vector; Vector3; View; Wavefunction; HF; RHF(HF, Wavefunction); matrix_vector; ; class Arguments(Boost.Python.instance); | Method resolution order:; | Arguments; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Arguments)arg1, (int)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 56; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BasisSet(Boost.Python.instance); | docstring; | ; | Method resolution order:; | BasisSet; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __add__(...); | __add__( (BasisSet)arg1, (BasisSet)arg2) -> object; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | max_am(...); | max_am( (BasisSet)arg1) -> int :; | docstring; | ; | nao(...); | nao( (BasisSet)arg1) -> int :; | docstring; | ; | nbf(...); | nbf( (BasisSet)arg1) -> int :; | docstring; | ; | nprimitive(...); | nprimit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:1478,inherit,inherited,1478,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"rgy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for envv in db_tabulate:; tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:46291,variab,variables,46291,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,"['VARIAB', 'variab']","['VARIABLE', 'variables']"
Modifiability,"rgy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: int, arg2: psi4.core.Matrix, arg3: psi4.core.CIVector) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:15115,variab,variable,15115,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"rgy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: int, arg2: psi4.core.Matrix, arg3: psi4.core.CIVector) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitz",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:15226,variab,variable,15226,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,4,['variab'],['variable']
Modifiability,"ri=integer — Specifies the maximum angular momentum; level for the primitive Gaussian basis functions when computing; electron repulsion integrals. This is set to h-type functions (AM=5); by default. --with-max-am-deriv1=integer — Specifies the maximum angular; momentum level for first derivatives of the primitive Gaussian; basis functions. This is set to g-type functions (AM=4) by default. --with-max-am-deriv2=integer — Specifies the maximum angular; momentum level for second derivatives of the primitive Gaussian; basis functions. This is set to f-type functions (AM=3) by default. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.53.0 that comes bundled with the distribution.; By default, PSI4 will look in your include/library paths for; a compatible and complete boost installation (boost 1.46 or newer). A; boost installation in a nonstandard location can be specified by the; --with-boost=PATH and --with-boost-libdir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:13924,variab,variable,13924,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['variab'],['variable']
Modifiability,"riable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:39076,variab,variable,39076,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"riable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:33183,variab,variables,33183,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variables']
Modifiability,"riable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis, quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[, assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self, arg0, arg1); Specialized expert use only. frequencies(); Returns ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:2338,variab,variable,2338,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['variab'],['variable']
Modifiability,"riable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis, quiet]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self); docstring. cleanup_ci(self); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, ...); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html:2500,variab,variable,2500,psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,2,['variab'],['variable']
Modifiability,"riable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. total_index(self, i, h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to fil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:7430,variab,variable,7430,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['variab'],['variable']
Modifiability,"riable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction's energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction's gradient. set_hessian(self, arg0); Sets the Wavefunction's Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:7383,variab,variable,7383,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,10,['variab'],['variable']
Modifiability,"riable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:7309,variab,variable,7309,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,4,['variab'],['variable']
Modifiability,"riables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available. PSIthonPsiAPIe_mp2 = variable('MP2 TOTAL ENERGY'); e_scs_mp2 = variable('SCS-MP2 TOTAL ENERGY'). e_mp2 = psi4.variable('MP2 TOTAL ENERGY'); e_scs_mp2 = psi4.variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:9834,variab,variables,9834,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['variab'],['variables']
Modifiability,"rianQC GPU module by the BrianQC team; Installing BrianQC; Building BrianQC’s user-built components; Building PSI4 with BrianQC; Using BrianQC from PSI4; Keywords; Environment Variables. Interface to CFOUR by J. Stanton & J. Gauss; Installation; Cfour for PSI4 Users; PSI4 for Cfour Users; Output; Functionality; Specification Details; Misc. Running. Interface to CheMPS2 by S. Wouters; Installation; Methods; DMRG Keywords; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2. Interface to CPPE by M. Scheurer; Installation; Using the polarizable embedding model; Keywords for CPPE; How to configure CPPE for building Psi4. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Installation; Input; Keywords; Reference; How to configure dkh for building Psi4. Interface to LibECPInt by R. Shaw; Installation; How to configure LibECPInt for building Psi4. Interface to LIBEFP by I. Kaliman; Installation; EFP Fragments; Molecule Specification; Running EFP; Fragment Library; How to configure libefp for building Psi4. Interface to ERD by N. Flocke and V. Lotrich; Installation; How to configure erd for building Psi4. Interface to programs through FCHK files — fchk(); Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Installation; Sample Input. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. Interface to gCP by S. Grimme; Installation; Running gCP. Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Installation; Input; Options; How to configure gdma for building Psi4. Interface to Libint by E. Valeev; Installation; How to configure Libint for building Psi4. Interface to Molden — molden(); Options. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Interface to PCMSolver by R. Di Remigio; Installati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/interfacing.html:1651,config,configure,1651,psi4manual/1.6.x/interfacing.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/interfacing.html,1,['config'],['configure']
Modifiability,"ribed as MP2 theory for the excited state and the relation; to such other response theories as CC2-LR, CIS(D) and CIS(D) has; been addressed [Haettig:2002] by Hattig et al. In the ADC theory,; the residue calculus of the propagator is translated into the eigenvalue; problem with respect to the correlated response matrix, also known as the; shifted-Hamiltonian. The σ-vectors (Hamiltonian-vector products); are constructed several times in the simultaneous expansion method (SEM); to solve the eigenvalue problem, and each σ-vector construction; has a computational cost that scales as . In addition,; the tensorial form of the σ-vector resembles to that of the; doubles correction in the CIS(D) energetic equation. As a consequence,; the pre-factor in the polynomial scaling becomes far larger than that; of the CIS(D) even though the quasi-degeneracy of the excited state is; properly accounted for in the ADC(2) model.; In Psi4 the quite efficient and flexible integral-transformation; library named libtrans is newly equipped and utilized in the; production level DCFT code. The ADC code is also based on; libtrans, and it is also based on libdpd, a library to; utilize molecular symmetry in the tensorial manipulations in framework; of the direct-product decomposition algorithm. By this feature, the Ritz; space and intermediate tensors are blocked according to the irreducible; representations of the point group, and the excited states that belong; to different symmetry are sought separately.; In the output of ADC, the ADC(2) results may look as follows:; -> 1 B1 state : 0.2565095 (a.u.), 6.9799824 (eV); Non-iterative: 0.2565636 (a.u.), 6.9814532 (eV); Occ Vir Coefficient; ---------------------------------------------; 3 0 -0.9017047264; 3 2 0.3038332241; 3 1 0.2907567119; 3 5 -0.0790167706; 3 4 -0.0425829926. Converged in 4 iteration.; Squared norm of the S component: 0.9315336; The S vector is rotated up to 8.102 (deg.). in which the ADC(2) excitation energy is indicated with arr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/adc-1.html:1896,flexible,flexible,1896,psi4manual/1.0.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/adc-1.html,2,['flexible'],['flexible']
Modifiability,"ribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with property-related helper functions."""""". import psi4. from . import optproc. __all__ = ['free_atom_volumes']. [docs]; def free_atom_volumes(wfn: psi4.core.Wavefunction, **kwargs):; """""" ; Computes free-atom volumes using MBIS density partitioning.; The free-atom volumes are computed for all unique (inc. basis set); atoms in a molecule and stored as wavefunction variables, :psivar:`MBIS FREE ATOM n VOLUME`.; Free-atom densities are computed at the same level of theory as the molecule, ; and we use unrestricted references as needed in computing the ground-state. . The free-atom volumes are used to compute volume ratios in routine MBIS computations. Parameters; ----------; wfn; The wave function associated with the molecule, method, and basis for ; atomic computations; """""". # If we're already a free atom, break to avoid recursion; # We don't ever need volume ratios for free atoms since they; # are by definition 1.0; natom = wfn.molecule().natom(); if natom == 1:; return 0 ; . # the level of theory; current_en = wfn.scalar_variable('CURRENT ENERGY'); total_energies = [k for k, v in wfn.scalar_variables().items() if abs(v - current_en) <= 1e-12]; theory = """"; for var in total_energies:; if 'TOTAL ENERGY' in var:; var = var.split(); if var[0] == 'SCF':; continue; elif var[0] == 'DFT':; theory = wfn.functional().name(); else:; theory = var[0]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/prop_util.html:1497,variab,variables,1497,psi4manual/1.9.x/_modules/psi4/driver/p4util/prop_util.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/prop_util.html,4,['variab'],['variables']
Modifiability,"ribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with property-related helper functions."""""". import psi4; from . import optproc. __all__ = ['free_atom_volumes']. [docs]; def free_atom_volumes(wfn: psi4.core.Wavefunction, **kwargs):; """""" ; Computes free-atom volumes using MBIS density partitioning.; The free-atom volumes are computed for all unique (inc. basis set); atoms in a molecule and stored as wavefunction variables, :psivar:`MBIS FREE ATOM n VOLUME`.; Free-atom densities are computed at the same level of theory as the molecule, ; and we use unrestricted references as needed in computing the ground-state. . The free-atom volumes are used to compute volume ratios in routine MBIS computations. Parameters; ----------; wfn; The wave function associated with the molecule, method, and basis for ; atomic computations; """""". # If we're already a free atom, break to avoid recursion; # We don't ever need volume ratios for free atoms since they; # are by definition 1.0; natom = wfn.molecule().natom(); if natom == 1:; return 0 ; . # the level of theory; current_en = wfn.scalar_variable('CURRENT ENERGY'); total_energies = [k for k, v in wfn.scalar_variables().items() if abs(v - current_en) <= 1e-12]; theory = """"; for var in total_energies:; if 'TOTAL ENERGY' in var:; var = var.split(); if var[0] == 'SCF':; continue; elif var[0] == 'DFT':; theory = wfn.functional().name(); else:; theory = var[0]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html:1497,variab,variables,1497,psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/prop_util.html,2,['variab'],['variables']
Modifiability,"rid -c psi4.; Then, hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gau2grid and activate dependent code. To remove a conda installation, conda remove gau2grid. Source. If using PSI4 built from source and you want gau2grid built from; from source also, let the build system fetch and build it and activate; dependent code. How to configure gau2gridfor building Psi4¶; Role and Dependencies. Role — In PSI4, gau2grid is a library that provides essential; grid operations for DFT.; Downstream Dependencies — PSI4 \(\Leftarrow\) gau2grid; Upstream Dependencies — gau2grid \(\Leftarrow\) None. CMake Variables. CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For gau2grid, set to an installation directory containing include/gau2grid/gau2grid.h; gau2grid_DIR — CMake variable to specify where pre-built gau2grid can be found. Set to installation directory containing share/cmake/gau2grid/gau2gridConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_gau2grid — CMake variable to force internal build of gau2grid instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_gau2grid — CMake variable to force detecting pre-built gau2grid and not falling back on internal build. Examples. Build bundled. >>> cmake. Link against pre-built. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/gau2grid/root. >>> cmake -Dgau2grid_DIR=/path/to/gau2grid/configdir. Build bundled despite pre-built being detectable. >>> cmake -DCMAKE_PREFIX_PATH=/path/to/unwanted/gau2grid/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_gau2grid=ON. table of contents. Interface to gau2grid by D. G. A. Smith; Installation; How to configure gau2gridfor building Psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to gau2grid by D. G. A. Smith. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/gau2grid.html:1887,variab,variable,1887,psi4manual/1.6.x/gau2grid.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/gau2grid.html,4,"['config', 'variab']","['configdir', 'configure', 'variable']"
Modifiability,"rides the value of; PSIDATADIR and specifies the path to the Psi data; library (ends in share/psi4). -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename with any; any “.in” or “.dat” extension replaced by “.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; 1; 2>>> psi4 --version; 0.4.262. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/external-1.html:17893,variab,variables,17893,psi4manual/1.2.1/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/external-1.html,4,['variab'],['variables']
Modifiability,"rides the value of; PSIDATADIR and specifies the path to the Psi data; library (ends in share/psi4). -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename with any; any ”.in” or ”.dat” extension replaced by ”.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; 1; 2>>> psi4 --version; 0.4.262. Environment Variables¶; These environment variables will influence PSI4‘s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:17782,variab,variables,17782,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,2,['variab'],['variables']
Modifiability,"riginal_coef(...); | original_coef( (GaussianShell)arg1, (int)arg2) -> float :; | docstring; | ; | C++ signature :; | d original_coef(N3psi13GaussianShellE {lvalue},i); | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | AMCHAR; | docstring; | ; | am; | docstring; | ; | amchar; | docstring; | ; | function_index; | Basis function index where this shell starts.; | ; | ncartesian; | docstring; | ; | ncenter; | docstring; | ; | nfunction; | docstring; | ; | nprimitive; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class GeometryUnits(Boost.Python.enum); | docstring; | ; | Method resolution order:; | GeometryUnits; | Boost.Python.enum; | __builtin__.int; | __builtin__.object; | ; | Data and other attributes defined here:; | ; | Angstrom = psi4.GeometryUnits.Angstrom; | ; | Bohr = psi4.GeometryUnits.Bohr; | ; | names = {'Angstrom': psi4.GeometryUnits.Angstrom, 'Bohr': psi4.Geometr...; | ; | values = {0: psi4.GeometryUnits.Angstrom, 1: psi4.GeometryUnits.Bohr}; | ; | ----------------------------------------------------------------------; | Methods inherited from Boost.Python.enum:; | ; | __repr__(...); | x.__repr__() <==> repr(x); | ; | __str__(...); | x.__str__() <==> str(x); | ; | ----------------------------------------------------------------------; | Data",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:473311,inherit,inherited,473311,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"ring starts at 1). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested configuration interaction level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:4394,variab,variable,4394,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,2,['variab'],['variable']
Modifiability,"ring; | ; | play(...); | play( (MintsHelper)arg1) -> None :; | docstring; | ; | so_angular_momentum(...); | so_angular_momentum( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_dipole(...); | so_dipole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_kinetic(...); | so_kinetic( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_nabla(...); | so_nabla( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_overlap(...); | so_overlap( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_potential(...); | so_potential( (MintsHelper)arg1) -> Matrix :; | docstring; | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inhe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:44554,inherit,inherited,44554,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,8,['inherit'],['inherited']
Modifiability,"ring; | ; | print_energy(...); | print_energy( (Dispersion)arg1, (Molecule)arg2) -> str :; | docstring; | ; | print_gradient(...); | print_gradient( (Dispersion)arg1, (Molecule)arg2) -> str :; | docstring; | ; | print_hessian(...); | print_hessian( (Dispersion)arg1, (Molecule)arg2) -> str :; | docstring; | ; | print_out(...); | print_out( (Dispersion)arg1) -> None :; | docstring; | ; | set_citation(...); | set_citation( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_description(...); | set_description( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | set_name(...); | set_name( (Dispersion)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (float)arg2) -> Dispersion :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:16079,inherit,inherited,16079,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"rint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs]; def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:45903,extend,extended,45903,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,6,['extend'],['extended']
Modifiability,"rint a lot of information. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4) or databases.; Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands. First line for C shell; second for bash.; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH; PYTHONPATH=/home/user/psiadditions:$PYTHONPATH; export PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every PSI4 instance.; sys.path.insert(0, '/home/user/psiadditions'). Place the path in the input file, either absolute or relative.; sys.path.insert(0, '../../psiadditions'); sys.path.insert(0, '/home/user/psiadditions'). Table Of Contents. Installation and Runtime Configuration; Obtaining PSI4; Compiling and Installing; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. Previous topic; Introduction; Next topic; A PSI4 Tutorial; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next   ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:10412,plugin,plugins,10412,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['plugin'],['plugins']
Modifiability,"rint the Psithon to Python translation of the input file. -V, --version¶; Print version information.; # stable release; >>> psi4 --version; 1.3.2. # development snapshot between 1.3 and 1.4; >>> psi4 --version; 1.4a2.dev525. Environment Variables¶; These environment variables will influence PSI4‘s behavior. CONDA_PREFIX¶; Set when a conda environment is activated. Note that if PSI4 has been; built against any library in CONDA_PREFIX, the path has been baked into the; program, so any available dependencies are liable to been loaded from the environment. HOST¶; Set when a conda environment with conda compilers is activated. Used; when compatibly building PSI4 from source against conda; dependencies. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; While once configuring PSI4 through PSIPATH was preferred; to modifying this environment variable, now PATH is preferred for; executables to accommodate QCEngine. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /scratch/user. # sh, bash: add to shell or ~/.bashrc (Li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:20820,variab,variable,20820,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['variab'],['variable']
Modifiability,"rint(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. to_file([filename]); Converts a Wavefunction object to a base class. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:11926,variab,variable,11926,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"rint(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. to_file([filename]); Converts a Wavefunction object to a base class. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; docstring. iteration_¶; docstring. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:11661,variab,variable,11661,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"rint; from typing import Any, Dict, Optional, Tuple, Union, TYPE_CHECKING. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; from qcelemental.models.results import AtomicResultProtocols; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, descrip",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:2213,Config,Config,2213,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html,1,['Config'],['Config']
Modifiability,"rint_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); optstash2.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs); ; core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper';",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:37961,variab,variable,37961,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['variab'],['variable']
Modifiability,"riptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Environment(Boost.Python.instance); | Method resolution order:; | Environment; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __getitem__(...); | __getitem__( (Environment)arg1, (str)arg2) -> str :; | docstring; | ; | C++ signature :; | Ss __getitem__(N3psi7Process11EnvironmentE {lvalue},Ss); | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 464; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ErfComplementERI(TwoElectronInt); | docstring; | ; | Method resolution order:; | ErfComplementERI; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ---------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:447701,inherit,inherited,447701,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"riptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ElectricFieldInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | ElectricFieldInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:29301,inherit,inherited,29301,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"riptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ElectricFieldInt(OneBodyAOInt); | docstring; | ; | Method resolution order:; | ElectricFieldInt; | OneBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from OneBodyAOInt:; | ; | compute_shell(...); | compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from OneBodyAOInt:; | ; | basis; | The basis set on center one; | ; | basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:443821,inherit,inherited,443821,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"riptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ErfERI(TwoElectronInt); | docstring; | ; | Method resolution order:; | ErfERI; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> None :; | docstring; | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:34881,inherit,inherited,34881,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"riptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ErfERI(TwoElectronInt); | docstring; | ; | Method resolution order:; | ErfERI; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | -----------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:450324,inherit,inherited,450324,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"riptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class F12G12(TwoElectronInt); | docstring; | ; | Method resolution order:; | F12G12; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> None :; | docstring; | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:40940,inherit,inherited,40940,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['inherit'],['inherited']
Modifiability,"riptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class F12G12(TwoElectronInt); | docstring; | ; | Method resolution order:; | F12G12; | TwoElectronInt; | TwoBodyAOInt; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from TwoBodyAOInt:; | ; | compute_shell(...); | compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; | docstring; | ; | C++ signature :; | m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); | ; | set_enable_pybuffer(...); | set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from TwoBodyAOInt:; | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | -----------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:457550,inherit,inherited,457550,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"rite_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:22677,flexible,flexible,22677,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,2,['flexible'],['flexible']
Modifiability,"rithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = core.get_variable('CURRENT ENERGY'). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():; core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = core.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * core.get_variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mean?; # 'MP2 TOTAL ENERGY',; # 'MP2 CORRELATION ENERGY',; # 'MP2 SAME-SPIN CORRELATION ENERGY']. core.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; core.set_variable('DFT TOTAL ENERGY', returnvalue); core.set_variable('CURRENT ENERGY', returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' -------------------------\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a referen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:61513,variab,variables,61513,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['variab'],['variables']
Modifiability,"rivate external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter, …); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self); docstring. diis_manager(self); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction’s temporary data. fin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:3713,variab,variable,3713,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,8,['variab'],['variable']
Modifiability,"rix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE so_potential(N3psi11MintsHelperE {lvalue},b); | ; | so_quadrupole(...); | so_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | C++ signature :; | St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE so_quadrupole(N3psi11MintsHelperE {lvalue}); | ; | so_traceless_quadrupole(...); | so_traceless_quadrupole( (MintsHelper)arg1) -> matrix_vector :; | docstring; | ; | C++ signature :; | St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE so_traceless_quadrupole(N3psi11MintsHelperE {lvalue}); | ; | sobasisset(...); | sobasisset( (MintsHelper)arg1) -> SOBasisSet :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi10SOBasisSetEEE sobasisset(N3psi11MintsHelperE {lvalue}); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class MoldenWriter(Boost.Python.instance); | docstring; | ; | Method resolution order:; | MoldenWriter; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | write(...); | write( (MoldenWriter)arg1, (str)arg2, (Matrix)arg3, (Matrix)arg4, (Vector)arg5, (Vector)arg6, (Vector)arg7, (Vector)arg8) -> None :; | docstring; | ; | C++ signature :; | void write(N3psi12MoldenWriterE {lvalue},Ss,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6VectorEEE,N5boo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:540635,inherit,inherited,540635,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['inherit'],['inherited']
Modifiability,"rix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_energies(self: psi4.core.HF, arg0: str, arg1: float) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix]) → None¶; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:29974,variab,variable,29974,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,28,['variab'],['variable']
Modifiability,"rix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self); docstring. cleanup_ci(self); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, …); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested exter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:2491,variab,variable,2491,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,1,['variab'],['variable']
Modifiability,"rix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:28557,variab,variable,28557,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,8,['variab'],['variable']
Modifiability,"rix. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on self. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self[, assume_socc_alpha]); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Serialize a Wavefunction object. variable(key); Return copy of scalar or array QCVariable key from self. variables([include_deprecated_keys]); Return all scalar or array QCVariables from self. write_molden([filename, do_virtual, use_natural]); Writes wavefunction information in wfn to filename in molden format. write_nbo(name); Write wavefunction information in wfn to name in NBO format. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha orbital subset. Parameters:. basis (str) – {‘SO’, AO’}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str) – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbitals should be returned?. Returns:; A Pitzer-ordered matrix of the orbitals, (# basis functions, # orbitals in the subset).; Pitzer-ordering is with respect to c1 symmetry if basis is AO. Return type:; Matrix. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:7728,variab,variables,7728,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,8,['variab'],['variables']
Modifiability,"rmat(evv10)); if core.get_option('SCF', 'PCM'):; core.print_out("" PCM Polarization Energy = {:24.16f}\n"".format(epcm)); if hasattr(self.molecule(), 'EFP'):; core.print_out("" EFP Energy = {:24.16f}\n"".format(eefp)); core.print_out("" Total Energy = {:24.16f}\n"".format(total_energy)). self.set_variable('NUCLEAR REPULSION ENERGY', enuc); self.set_variable('ONE-ELECTRON ENERGY', e1); self.set_variable('TWO-ELECTRON ENERGY', e2); if self.functional().needs_xc():; self.set_variable('DFT XC ENERGY', exc); self.set_variable('DFT VV10 ENERGY', evv10); self.set_variable('DFT FUNCTIONAL TOTAL ENERGY', hf_energy + exc + evv10); #self.set_variable(self.functional().name() + ' FUNCTIONAL TOTAL ENERGY', hf_energy + exc + evv10); self.set_variable('DFT TOTAL ENERGY', dft_energy) # overwritten later for DH; else:; self.set_variable('HF TOTAL ENERGY', hf_energy); if hasattr(self, ""_disp_functor""):; self.set_variable('DISPERSION CORRECTION ENERGY', ed); #if abs(ed) > 1.0e-14:; # for pv, pvv in self.variables().items():; # if abs(pvv - ed) < 1.0e-14:; # if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(self.functional().name()):; # fctl_plus_disp_name = pv.split()[0]; # self.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', dft_energy) # overwritten later for DH; #else:; # self.set_variable(self.functional().name() + ' TOTAL ENERGY', dft_energy) # overwritten later for DH. self.set_variable('SCF ITERATIONS', self.iteration_). # Bind functions to core.HF class; core.HF.initialize = scf_initialize; core.HF.initialize_jk = initialize_jk; core.HF.iterations = scf_iterate; core.HF.compute_energy = scf_compute_energy; core.HF.finalize_energy = scf_finalize_energy; core.HF.print_energies = scf_print_energies. def _converged(e_delta, d_rms, e_conv=None, d_conv=None):; if e_conv is None:; e_conv = core.get_option(""SCF"", ""E_CONVERGENCE""); if d_conv is None:; d_conv = core.get_option(""SCF"", ""D_CONVERGENCE""). return (abs(e_delta) < e_conv and d_rms < d_conv). def _validate_damping(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:21778,variab,variables,21778,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['variab'],['variables']
Modifiability,"rn copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:37766,variab,variable,37766,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"rn copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:35693,variab,variable,35693,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"rn fisapt_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = core.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level). # Load the fort.56 file; # and dump a copy int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:109220,variab,variables,109220,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,2,['variab'],['variables']
Modifiability,"rn mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). if 'comment' in molrec:; self.set_comment(molrec['comment']). self.set_provenance(copy.deepcopy(molrec['provenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.set_geometry_variable(var[0], var[1]). else:; geom = np.array(molrec['geom']).reshape((-1, 3)); nat = geom.shape[0]; unsettled = False. for iat in range(nat):; x, y, z = geom[iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_atom(Z, x, y, z, molrec['elem'][iat], molrec['mass'][iat], Z, label, molrec['elea'][iat]); # TODO charge and 2nd elez site; # TODO real back to type Ghost?. # apparently py- and c- sides settled on a diff convention of 2nd of pair in fragments_; fragment_separators = np.array(molrec['fragment_separators'], dtype=int); fragment_separators = np.insert(fragment_separators, 0, 0); fragment_separators = np.append(fragment_separators, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments, ['Real'] * len(fragments), [int(f) for f in molrec['fragment",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html:51939,variab,variables,51939,psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,14,['variab'],['variables']
Modifiability,"rn mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). if 'comment' in molrec:; self.set_comment(molrec['comment']). self.set_provenance(copy.deepcopy(molrec['provenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.set_geometry_variable(var[0], var[1]). else:; geom = np.array(molrec['geom']).reshape((-1, 3)); nat = geom.shape[0]; unsettled = False. for iat in range(nat):; x, y, z = geom[iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_atom(Z, x, y, z, molrec['elem'][iat], molrec['mass'][iat], Z, label, molrec['elea'][iat]); # TODO charge and 2nd elez site; # TODO real back to type Ghost?. # apparently py- and c- sides settled on a diff convention of 2nd of pair in fragments_; fragment_separators = np.array(molrec['fragment_separators'], dtype=np.int); fragment_separators = np.insert(fragment_separators, 0, 0); fragment_separators = np.append(fragment_separators, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments, ['Real'] * len(fragments), [int(f) for f in molrec['fragm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:48413,variab,variables,48413,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,1,['variab'],['variables']
Modifiability,"rn-and-forward. """"""; raise UpgradeHelper(""psi4.core.get_array_variables"", ""psi4.core.variables"", 1.9, f"" Replace `psi4.core.get_array_variables` with `psi4.core.variables` (or `psi4.core.array_variables` for array variables only).""). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_variable"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_variable` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only).""). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.get_array"", ""psi4.core.Wavefunction.variable"", 1.9, f"" Replace `psi4.core.Wavefunction.get_array` with `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only).""). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise UpgradeHelper(""psi4.core.Wavefunction.set_array"", ""psi4.core.Wavefunction.set_variable"", 1.9, f"" Replace `psi4.core.Wavefunction.set_array` with `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only).""). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead.; .. versionchanged:: 1.9; Errors rather than warn-and-forward. """"""; raise Up",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:47155,variab,variable,47155,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['variab'],['variable']
Modifiability,"rnal files (e.g., MOINTS and GAMLAM, default choice INTERNAL, =0) or on external files (EXTERNAL, =1). Type: string; Possible Values: INTERNAL, EXTERNAL; Default: INTERNAL. CFOUR_PROPS (CFOUR)¶CFOUR — Specifies whether and which molecular property is calculated. OFF (=0) means that no property is calculated, FIRST_ORDER (=1) requests computation of various one-electron first-order properties (e.g., dipole moment, quadrupole moment, electric field gradient, spin densities,etc.), SECOND_ORDER (=2, in the next release replaced by STAT_POL) computes static electric polarizabilities, DYNAMICAL (=7, in the next release replaced by DYN_POL) requests the calculation of frequency-dependent polarizabilities (note that here an additional input of the frequency is required), NMR (=5) requests the calculation of NMR chemical shifts/chemical shielding tensors (by default using GIAOs), J_FC requests the calculation of the Fermi-Contact contribution to indirect spin-spin coupling constants, J_SD the calculation of the corresponding spin-dipole contribution, and J_SO the calculation of the corresponding spin-orbit contribution to J; HYPERPOL (=22) invokes a calculation of static hyperpolarizabilities, DYN_HYP (=23) requests the calculation of frequency-dependent hyperpolarizabilities, SHG (=24) the calculation of hyperpolarizabilities related to the second-harmonic generation, OPT_REC (=25) the computation of hyperpolarizabilities related to optical rectification, VERDET (=26) the calculation of Verdet constants. Type: string; Possible Values: OFF, FIRST_ORDER, SECOND_ORDER, NMR, HYPERPOL, DYN_HYP, SHG, OPT_REC, VERDET; Default: OFF. CFOUR_QRHF_GENERAL (CFOUR)¶CFOUR — The presence of this keyword specifies that a QRHF based CC calculation, or alternatively, an SCF calculation that uses the CFOUR_QRHFGUES option, is to be performed. Type: array; Default: No Default. CFOUR_QRHF_ORBITAL (CFOUR)¶CFOUR — By default, in QRHF calculations, electrons are removed from the highest occupied orb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:66813,coupling,coupling,66813,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['coupling'],['coupling']
Modifiability,"rns the requested auxiliary basis. get_density(self, arg0); Experimental!. get_dimension(self, arg0); Returns the dimension of requested orbital subspace. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_opdm(self, Iroot, Jroot, spin, full_space); Returns the one-particle density or transition matrix. get_orbitals(self, arg0); docstring. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_tpdm(self, spin, symmetrize); Returns the two-particle density matrix. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. hamiltonian(self, arg0); docstring. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mcscf_object(self); docstring. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of be",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html:4925,variab,variable,4925,psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CIWavefunction.html,2,['variab'],['variable']
Modifiability,"rocess_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/psi4/share/psi4/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/psi4/share/psi4/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/quickadddatabase-1.html:3474,variab,variable,3474,psi4manual/1.4.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/quickadddatabase-1.html,2,['variab'],['variable']
Modifiability,"rocess_input line, then translated back in the GEOS section; see; NBC10.py for an example. The first line for each xyz file should be the number of atoms in the system.; The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment).; The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what’s the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. Run script psi4/psi4/share/psi4/scripts/ixyz2database.py. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into psi4/psi4/share/psi4/databases.; Alternately, append the directory containing your new database into; PSIPATH. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/quickadddatabase-1.html:3474,variab,variable,3474,psi4manual/1.5.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/quickadddatabase-1.html,2,['variab'],['variable']
Modifiability,"rogram will be the value of the keyword \(\times 10^{-6}\). This allows field strengths \(|\varepsilon| > 10^{-6}\) to be used. Type: integer; Default: 0. CFOUR_XFORM_TOL¶. The tolerance for storing transformed integrals. Integrals less than \(10^{-N}\) are neglected and not stored on disk. Type: integer; Default: 11. CFOUR_YFIELD¶. Specifies the Y-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword \(\times 10^{-6}\). This allows field strengths \(|\varepsilon| > 10^{-6}\) to be used. Type: integer; Default: 0. CFOUR_ZFIELD¶. Specifies the Z-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword \(\times 10^{-6}\). This allows field strengths \(|\varepsilon| > 10^{-6}\) to be used. Type: integer; Default: 0. Expert Psi4 Control of CFOUR¶. CFOUR_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect CFOUR. Type: integer; Default: 1. table of contents. CFOUR; Psi4 Control of CFOUR; TRANSLATE_PSI4. CFOUR Internal; CFOUR_ABCDTYPE; CFOUR_ACTIVE_ORBI; CFOUR_ANHARMONIC; CFOUR_ANH_ALGORITHM; CFOUR_ANH_DERIVATIVES; CFOUR_ANH_STEPSIZE; CFOUR_ANH_SYMMETRY; CFOUR_AO_LADDERS; CFOUR_AV_SCF; CFOUR_BASIS; CFOUR_BRUCK_CONV; CFOUR_BRUECKNER; CFOUR_CACHE_RECS; CFOUR_CALC_LEVEL; CFOUR_CC_CONV; CFOUR_CC_EXPORDER; CFOUR_CC_EXTRAPOLATION; CFOUR_CC_MAXCYC; CFOUR_CC_PROGRAM; CFOUR_CHARGE; CFOUR_CIS_CONV; CFOUR_CONTINUUM; CFOUR_CONTRACTION; CFOUR_CONVERGENCE; CFOUR_COORDINATES; CFOUR_CORE_ORBITALS; CFOUR_CPHF_CONVER; CFOUR_CPHF_MAXCYC; CFOUR_CURVILINEAR; CFOUR_DBOC; CFOUR_DCT; CFOUR_DERIV_LEVEL; CFOUR_DIFF_TYPE; CFOUR_DROPMO; CFOUR_ECP; CFOUR_EIGENVE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:65585,variab,variable,65585,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,24,['variab'],['variable']
Modifiability,"rojection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. ci_nat_orbs(self); docstring. cleanup_ci(self); docstring. cleanup_dpd(self); docstring. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. compute_state_transfer(self, arg0, arg1, ...); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diag_h(self, arg0, arg1); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_opdm(self); docstring. form_tpdm(self); docstring. freq",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html:2695,variab,variable,2695,psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ciwavefunction.html,2,['variab'],['variable']
Modifiability,"rom Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class vector_of_doubles(Boost.Python.instance); | docstring; | ; | Method resolution order:; | vector_of_doubles; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __contains__(...); | __contains__( (vector_of_doubles)arg1, (object)arg2) -> bool; | ; | __delitem__(...); | __delitem__( (vector_of_doubles)arg1, (object)arg2) -> None; | ; | __getitem__(...); | __getitem__( (object)arg1, (object)arg2) -> object; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __iter__(...); | __iter__( (object)arg1) -> object; | ; | __len__(...); | __len__( (vector_of_doubles)arg1) -> int; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setitem__(...); | __setitem__( (vector_of_doubles)arg1, (object)arg2, (object)arg3) -> None; | ; | append(...); | append( (vector_of_doubles)arg1, (object)arg2) -> None; | ; | extend(...); | extend( (vector_of_doubles)arg1, (object)arg2) -> None; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 40; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T. FUNCTIONS; DASUM(...); DASUM( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4) -> float :; docstring; ; DAXPY(...); DAXPY( (int)arg1, (int)arg2, (float)arg3, (Vector)arg4, (int)arg5, (Vector)arg6, (int)arg7) -> None :; docstring; ; DCOPY(...); DCOPY( (int)arg1, (int)arg2, (Vector)arg3, (int)arg4, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:147651,extend,extend,147651,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['extend'],['extend']
Modifiability,"rom Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class CdSalcList(Boost.Python.instance); | docstring; | ; | Method resolution order:; | CdSalcList; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | matrix(...); | matrix( (CdSalcList)arg1) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (CdSalcList)arg1) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Checkpoint(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Checkpoint; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (IO)arg2, (int)arg3) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | shared_object(...); | shared_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:5289,inherit,inherited,5289,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['inherit'],['inherited']
Modifiability,"rom data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. functional(self); Returns the internal DFT Superfunctional. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self, arg0); docstring. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self, arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self, arg0); Sets the guess Beta Orbital Matrix. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. initialize(); Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self); Sets up a GTFock JK object. initialize_jk(memory[, jk]). iterations([e_conv, d_conv]). jk(self); Returns the internal JK object. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory mod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html:6690,variab,variable,6690,psi4manual/1.5.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.hf.html,2,['variab'],['variable']
Modifiability,"rom data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. functional(self); Returns the internal DFT Superfunctional. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self, arg0); docstring. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the name so that files can be consistently written and read. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self, arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self, arg0); Sets the guess Beta Orbital Matrix. has_array_variable(self, arg0); Is the Matrix QC variable (case-insensitive) set?. has_potential_variable(self, arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self, arg0); Is the double QC variable (case-insensitive) set?. has_variable(key); Whether scalar or array QCVariable key has been set on self psi4.core.Wavefunction. hessian(self); Returns the Wavefunction's Hessian. initialize(); Specialized initialization, compute integrals and does everything to prepare for iterations. initialize_gtfock_jk(self); Sets up a GTFock JK object. initialize_jk(memory[, jk]). iterations([e_conv, d_conv]). jk(self); Returns the internal JK object. lagrangian(self); Returns the Lagrangian Matrix. legacy_frequencies(). Deprecated since version 1.4. mintshelper(self); The MintsHelper object. moFa(self); docstring. moFb(self); docstring. moFeff(self); docstring. mo_extents(self); returns the wavefunction's electronic orbital extents. mod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html:6749,variab,variable,6749,psi4manual/1.5.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html,2,['variab'],['variable']
