quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Availability," ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/o",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:2926,ERROR,ERROR,2926,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['ERROR'],['ERROR']
Availability," 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 2.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 2.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 2.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 2.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ```. This is because in broadcast assignment operations, such as `u[1][1:Nc, 1, k] .= u[5][2:Nc+1, 2, k]`, the data of the `WindowedField` is assigned. So, where's the issue? It's when we try any of the following operations:. 1. `u[1][1, 1:Nc, k] .= u[5][2:Nc+1, 2, k]`; 2. `view(u[1], 1, 1:Nc, k) .= u[5][2:Nc+1, 2, k]`; 3. `u[1][1, 1:Nc, k] .= u[5][2, 2:Nc+1, k]`; 4. `view(u[1], 1, 1:Nc, k) .= u[5][2, 2:Nc+1, k]`. Here the data extracted from the `WindowedField` on the RHS is always in the form of a column vector resulting in a dimension mismatch error. As a potential solution, we can consider assigning a `view` of the `WindowedField` as. 1. `u[1][1, 1:Nc, k] .= view(u[5], 2:Nc+1, 2, k)`; 2. `view(u[1], 1, 1:Nc, k) .= view(u[5], 2:Nc+1, 2, k)`; 3. `u[1][1, 1:Nc, k] .= view(u[5], 2, 2:Nc+1, k)`; 4. `view(u[1], 1, 1:Nc, k) .= view(u[5], 2, 2:Nc+1, k)`. or the transpose of the `WindowedField` as. 1. `u[1][1, 1:Nc, k] .= u[5][2:Nc+1, 2, k]'`; 2. `view(u[1], 1, 1:Nc, k) .= u[5][2:Nc+1, 2, k]'`; 3. `u[1][1, 1:Nc, k] .= u[5][2, 2:Nc+1, k]'`; 4. `view(u[1], 1, 1:Nc, k) .= u[5][2, 2:Nc+1, k]'`. It turns out only the second approach results in the correct solution. ```julia; julia> u[1][:, :, 1]; 12×12 OffsetArray(::Matrix{Float64}, -3:8, -3:8) with eltype Float64 with indices -3:8×-3:8:; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035885538:9459,error,error,9459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035885538,1,['error'],['error']
Availability," 1.0 1.0 1.0 1.0 1.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. ```. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow. grid = RegularRectilinearGrid(size=(8, 8),; x=(-10, 10), y=(0, 5),; topology=(Periodic, Bounded, Flat),; halo=(3,3)). bump(x, y, z) = y < exp(-x^2); grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). damping_rate = 1/100 # relax fields on a 100 second time-scale; const x0 = -10 # center point of sponge; const dx = 1.0 # sponge width; smoothed_step_mask(x, y, z) = 1/2 * (1 + tanh((x - x0) / dx)). uh_sponge = Relaxation(rate=damping_rate, mask=smoothed_step_mask, target=1); h_sponge = Relaxation(rate=damping_rate, mask=smoothed_step_mask, target=1). @inline inflow(j, k, grid, clock, model_fields) = @inbounds model_fields.h[1, j, 1]; @inline outflow(j, k, grid, clock, model_fields) = @inbounds model_fields.h[grid.Nx, j, 1]. uh_bcs = VVelocityBoundaryConditions(grid,; west = NormalFlowBoundaryCondition(inflow, discrete_form=true),; east = NormalFlowBoundaryCondition(outflow, discrete_form=true));. model = ShallowWaterModel(grid=grid_with_bump,; gravitational_acceleration=1,; boundary_conditions=(uh=uh_bcs,),; forcing = (uh=uh_sponge, h=h_sponge)). set!(model, h=1); simulation = Simulation(model, Δt=1.0, stop_iteration=1); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852958373:2428,mask,mask,2428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852958373,2,['mask'],['mask']
Availability," 1.99019 │ 1.38345 │; │ CPU │ (1, 0) │ 1.06409 │ 1.39873 │ 1.17271 │; │ CPU │ (2, 0) │ 1.17887 │ 1.99054 │ 1.38949 │; │ CPU │ (2, 3) │ 1.55493 │ 4.04677 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3) │ 1.47824 │ 3.50924 │ 1.45881 │; │ GPU │ (2, 5) │ 1.66293 │ 4.95474 │ 1.94286 │; │ GPU │ (2, 10) │ 2.13524 │ 9.47276 │ 2.52301 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘; ```; Some errors were encountered running the turbulence closure benchmark script with grid size 256 x 256 x 128.; There was an issue with the Nothing closure which was avoided by removing that type of closure from the closure array.; ```. Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ┌───────────────┬──────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Clo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:11532,error,errors,11532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['error'],['errors']
Availability," 3.244272524791092e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 1: 1.732365234564951e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 2: 1.7323652025336144e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 3: 0.05625027340835691; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 4: 1.7323652655498735e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 5: 1.7323652008460754e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 6: 0.0562502734083572; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 1: 1.570048120703993e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 2: 1.5700481280397916e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 3: 1.3603837144327004e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 4: 1.5700481343680627e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 5: 1.570048127987056e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 6: 1.360383713455704e-7; > > [ Info: φᶠᶠᵃ_difference_MITgcm panel 1: 1.478470279652168e-7; > > [ Info: φᶠᶠᵃ_difference_MITgcm panel 2: 1.4784702873954643e-7; > > [ Info: φᶠᶠᵃ_difference_MITgcm panel 3: 1.353035964424265e-7; > > [ Info: φᶠᶠᵃ_difference_MITgcm panel 4: 1.478470293751412e-7; > > [ Info: φᶠᶠᵃ_difference_MITgcm panel 5: 1.4784702869488048e-7; > > [ Info: φᶠᶠᵃ_difference_MITgcm panel 6: 1.3530359679547744e-7; > > ...; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > If we focus now on the λ and φ, it seems like the mean abs error is much bigger for λᶠᶠᵃ panels 3 and 6. Why is that? Could this be hinting a mistake?; > ; > OK, the differences for longitude panels 3 and 6 are the values of the Poles which are not uniquely defined. Glad we got that sorted out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2015620980:2449,error,error,2449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2015620980,1,['error'],['error']
Availability," <100%> (ø)` | :arrow_up: |; | [src/Simulations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zLmps) | `93.54% <100%> (-2.29%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `84% <0%> (-1.72%)` | :arrow_down: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `65% <0%> (-1.67%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.89% <0%> (+0.22%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `90% <0%> (+4.28%)` | :arrow_up: |; | [src/Models/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `80% <0%> (+30%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/cli",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/652#issuecomment-592508860:2318,checkpoint,checkpointer,2318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/652#issuecomment-592508860,1,['checkpoint'],['checkpointer']
Availability, = /glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig/lib/pkgconfig:2;/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib/pkgconfig:2;/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib/pkgconfig:2;/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/lib/pkgconfig:2;/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:1;/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:1;/glade/u/apps/casper/23.10/opt/view/lib/pkgconfig:1; __LMOD_REF_COUNT_DIAGUTIL_PATH = /glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/sys_check/sys_check.sh:1; NCAR_DEFAULT_MANPATH = /usr/local/share/man:/usr/share/man; __LMOD_REF_COUNT_MODULEPATH = /glade/u/apps/casper/modules/environment:1;/glade/work/knudsenl/spack-downstreams/casper/modules/23.10/Core:1;/glade/u/apps/casper/modules/23.10/Core:1;/glade/work/knudsenl/spack-downstreams/casper/modules/23.10/oneapi/2023.2.1:1;/glade/u/apps/casper/modules/23.10/oneapi/2023.2.1:1;/glade/work/knudsenl/spack-downstreams/casper/modules/23.10/openmpi/4.1.6/oneapi/2023.2.1:1;/glade/u/apps/casper/modules/23.10/openmpi/4.1.6/oneapi/2023.2.1:1; __LMOD_REF_COUNT_NCAR_LDFLAGS_INTEL_ONEAPI_COMPILERS = /glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/lib:1; HOME = /glade/u/home/knudsenl; CMAKE_PREFIX_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea:/glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig:/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2:/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv:/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1:/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6:/glade/u/apps/common/23.08/spack/opt,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:6753,down,downstreams,6753,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['down'],['downstreams']
Availability," @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5733,error,error,5733,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['error'],['error']
Availability," Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:2133,error,error,2133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability," Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:1851,error,error,1851,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability," BoundsError: attempt to access 0-element Vector{Ref{Union{Nothing, String}}} at index []; --;   | Stacktrace:;   | [1] throw_boundserror(A::Vector{Ref{Union{Nothing, String}}}, I::Tuple{});   | @ Base ./abstractarray.jl:651;   | [2] checkbounds;   | @ ./abstractarray.jl:616 [inlined];   | [3] _setindex!;   | @ ./abstractarray.jl:1289 [inlined];   | [4] setindex!(::Vector{Ref{Union{Nothing, String}}}, ::String);   | @ Base ./abstractarray.jl:1267;   | [5] find_local_cuda();   | @ CUDA.Deps ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:156;   | [6] macro expansion;   | @ ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:51 [inlined];   | [7] macro expansion;   | @ lock.jl:209 [inlined];   | [8] toolkit();   | @ CUDA.Deps ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:14;   | [9] toolkit_version();   | @ CUDA.Deps ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:209;   | [10] versioninfo(io::Base.TTY) (repeats 2 times);   | @ CUDA ~/.julia-3060/packages/CUDA/mVgLI/src/utilities.jl:35;   | [11] top-level scope;   | @ none:1; ```. On CUDA@3.3.0 this comes from a line that looks like. ```julia; __temp_libcusolver[] = ...; ```. I don't this this construct is valid in julia 1.6:. ```; julia> __temp_libcusolver = Ref{Union{Nothing,String}}[]; Ref{Union{Nothing, String}}[]. julia> __temp_libcusolver[] = nothing; ERROR: BoundsError: attempt to access 0-element Vector{Ref{Union{Nothing, String}}} at index []; Stacktrace:; [1] throw_boundserror(A::Vector{Ref{Union{Nothing, String}}}, I::Tuple{}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] _setindex!; @ ./abstractarray.jl:1289 [inlined]; [4] setindex!(::Vector{Ref{Union{Nothing, String}}}, ::Nothing); @ Base ./abstractarray.jl:1267; [5] top-level scope; @ REPL[4]:1; ```. But on CUDA#master the bug may have been fixed:. https://github.com/JuliaGPU/CUDA.jl/blob/3c251c1c210ff3fc75cef8dad688d170caadc275/deps/bindeps.jl#L180. So we might just need to update CUDA. Looking into it...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872246612:1390,ERROR,ERROR,1390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872246612,1,['ERROR'],['ERROR']
Availability, Coverage Diff @@; ## master #626 +/- ##; =========================================; + Coverage 70.47% 74.87% +4.4% ; =========================================; Files 118 118 ; Lines 2259 2277 +18 ; =========================================; + Hits 1592 1705 +113 ; + Misses 667 572 -95; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Utils/launch\_config.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `70.58% <0%> (-29.42%)` | :arrow_down: |; | [src/Solvers/pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcHJlc3N1cmVfc29sdmVyLmps) | `50% <0%> (-2.64%)` | :arrow_down: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `100% <0%> (ø)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `90.47% <0%> (+2.38%)` | :arrow_up: |; | [...nditions/solution\_and\_model\_boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zb2x1dGlvbl9hbmRfbW9kZWxfYm91bmRhcnlfY29uZGl0aW9ucy5qbA==) | `94.59% <0%> (+5.4%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `78.68% <0%> (+6.55%)` | :arrow_up: |; | [src/Architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `88.88% <0%> (+22.22%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=p,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/626#issuecomment-586645797:1705,checkpoint,checkpointer,1705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/626#issuecomment-586645797,1,['checkpoint'],['checkpointer']
Availability," I didn't know we had any `MPI` tests that used shallow water that were being run. Docs:; ```; ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; --; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: Failed to precompile PlotUtils [995b91a9-d308-5afd-9ec6-746e21dbc043] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/PlotUtils/YveHG_R3lk8.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] top-level scope at none:2; &nbsp; | [2] eval at ./boot.jl:347 [inlined]; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2556/packages/Plots/SjqWU/src/Plots.jl:20; &nbsp; | ERROR: LoadError: Failed to precompile Plots [91a5bcdd-55d7-5caf-9e0b-520d859cae80] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/Plots/ld3vC_R3lk8.ji.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-1/clima/oceananigans/docs/make.jl:6; &nbsp; | 🚨 Error: The command exited with status 1. ```. CPU test; ```; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; --; &nbsp; | [9] top-level scope at none:1; &nbsp; | Union{},Union{},Tuple{},NamedTuple{(test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2556/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2556/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141:1337,Error,Error,1337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141,1,['Error'],['Error']
Availability," I think we should require that. 1. The memory footprint of our model is no larger than it needs to be for a given problem (no 'extra' allocation of memory for unused tracers, for hydrostatic pressure when running in non hydrostatic mode, etc). 2. We do not perform unnecessary floating-point computations or indexing into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:1329,down,down,1329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['down'],['down']
Availability," Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}; indices=(Colon(), Colon(), 1)); Closest candidates are:; Field(::Field) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Fields/field.jl:160 got unsupported keyword argument ""indices""; Field(::Any, ::String, ::String, ::Any; grid, architecture, indices, boundary_conditions) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/OutputReaders/field_time_series.jl:150; Field(::Tuple, ::Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ, var""#s139""} where {FT, TX, TY, TZ, var""#s139""<:Oceananigans.Distributed.MultiArch}, ::Any, ::Any, ::Tuple, ::Any, ::Any) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Distributed/distributed_fields.jl:4 got unsupported keyword argument ""indices""; ...; Stacktrace:; [1] top-level scope; @ REPL[18]:1; ```. If I pass an abstract operation I get a different error:. ```julia; julia> Field(model.velocities.u^2; indices=(:,:,1)); ERROR: MethodError: no method matching offset_indices(::Type{Center}, ::Type{Bounded}, ::Int64, ::Int64, ::Int64); Closest candidates are:; offset_indices(::Any, ::Any, ::Any, ::Any, ::Colon) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:29; offset_indices(::Any, ::Any, ::Any, ::Any) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:16; offset_indices(::Any, ::Any, ::Any, ::Any, ::UnitRange) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:30; ...; Stacktrace:; [1] _broadcast_getindex_evalf(::typeof(Oceananigans.Grids.offset_indices), ::Type, ::Type, ::Int64, ::Int64, ::Int64); @ Base.Broadcast ./broadcast.jl:648; [2] _broadcast_getindex; @ ./broadcast.jl:621 [inlined]; [3] (::Base.Broadcast.var""#19#20""{Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple}, Nothing, typeof(Oceananigans.Grids.offset_indices), Tuple{Tuple{Dat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2391:2791,error,error,2791,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2391,1,['error'],['error']
Availability," Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: UndefVarError: NFBC not defined; Stacktrace:; [1] top-level scope; @ ~/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; [2] include(mod::Module, _path::String); @ Base ./Base.jl:386; [3] include(x::String); @ Oceananigans.BoundaryConditions ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; [4] top-level scope; @ ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:45; [5] include(mod::Module, _path::String); @ Base ./Base.jl:386; [6] include(x::String); @ Oceananigans ~/Research/OC/src/Oceananigans.jl:1; [7] top-level scope; @ ~/Research/OC/src/Oceananigans.jl:173; [8] include; @ ./Base.jl:386 [inlined]; [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [10] top-level scope; @ none:1; [11] eval; @ ./boot.jl:360 [inlined]; [12] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [13] top-level scope; @ none:1; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; in expression starting at /Users/navid/Research/OC/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_fSB7qw.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334:1529,ERROR,ERROR,1529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability," Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. julia> interior(model.tracers.t1); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:2438,checkpoint,checkpoint,2438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['checkpoint'],['checkpoint']
Availability," Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PATH::Bool, adjust_LIBPATH::Bool) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:78; &nbsp; | [9] mpiexec(::Function) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:61; &nbsp; | [10] mpiexec(::var""#1#2"") at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [11] top-level scope at none:4; &nbsp; | 🚨 Error: The command exited with status 1. </div></div><div class=""JobLogComponent__Footer pt2"" style=""box-sizing: border-box; display: flex; padding-top: 10px; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-size: 13px;""><br class=""Apple-interchange-newline""></div>; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:6439,Error,Error,6439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['Error'],['Error']
Availability, [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=h1) Report; > Merging [#797](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/162159d9ebc5b6b8a9accf84a598f4bfb43c1a37&el=desc) will **increase** coverage by `0.23%`.; > The diff coverage is `80.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #797 +/- ##; ==========================================; + Coverage 71.67% 71.91% +0.23% ; ==========================================; Files 184 124 -60 ; Lines 4781 2482 -2299 ; ==========================================; - Hits 3427 1785 -1642 ; + Misses 1354 697 -657 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.22% <66.66%> (+0.48%)` | :arrow_up: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `64.28% <100.00%> (+5.31%)` | :arrow_up: |; | [...ion/convergence\_tests/ConvergenceTests/analysis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvYW5hbHlzaXMuamw=) | | |; | [test/test\_verification.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ZlcmlmaWNhdGlvbi5qbA==) | | |; | [...nvergence\_tests/ConvergenceTests/file\_wrangling.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/797#issuecomment-657830968:1036,checkpoint,checkpointer,1036,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/797#issuecomment-657830968,1,['checkpoint'],['checkpointer']
Availability," [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5523,ERROR,ERROR,5523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['ERROR'],['ERROR']
Availability," `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI>; > .; > You are receiving this because you commented.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:1639,error,error,1639,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,2,['error'],['error']
Availability," ```; ERROR: LoadError: Enzyme cannot deduce type; Current scope:; ; Function Attrs: mustprogress nofree readonly willreturn; define ""enzyme_type""=""{[0]:Integer, [1]:Integer, [2]:Integer, [3]:Integer, [4]:Integer, [5]:Integer, [6]:Integer, [7]:Integer, [8]:Integer, [9]:Integer, [10]:Integer, [11]:Integer, [12]:Integer, [13]:Integer, [14]:Integer, [15]:Integer, [16]:Integer, [17]:Integer, [18]:Integer, [19]:Integer, [20]:Integer, [21]:Integer, [22]:Integer, [23]:Integer, [24]:Integer, [25]:Integer, [26]:Integer, [27]:Integer, [28]:Integer, [29]:Integer, [30]:Integer, [31]:Integer, [32]:Integer, [33]:Integer, [34]:Integer, [35]:Integer, [36]:Integer, [37]:Integer, [38]:Integer, [39]:Integer, [40]:Integer, [41]:Integer, [42]:Integer, [43]:Integer, [44]:Integer, [45]:Integer, [46]:Integer, [47]:Integer, [48]:Float@double, [56]:Float@double, [64]:Float@double, [72]:Float@double, [80]:Float@double, [88]:Float@double, [96]:Float@double, [104]:Float@double, [112]:Float@double, [120]:Integer, [121]:Integer, [122]:Integer, [123]:Integer, [124]:Integer, [125]:Integer, [126]:Integer, [127]:Integer, [128]:Integer, [129]:Integer, [130]:Integer, [131]:Integer, [132]:Integer, [133]:Integer, [134]:Integer, [135]:Integer, [136]:Integer, [137]:Integer, [138]:Integer, [139]:Integer, [140]:Integer, [141]:Integer, [142]:Integer, [143]:Integer, [144]:Float@double, [152]:Float@double, [160]:Float@double, [168]:Float@double, [176]:Integer, [177]:Integer, [178]:Integer, [179]:Integer, [180]:Integer, [181]:Integer, [182]:Integer, [183]:Integer, [184]:Integer, [185]:Integer, [186]:Integer, [187]:Integer, [188]:Integer, [189]:Integer, [190]:Integer, [191]:Integer, [192]:Integer, [193]:Integer, [194]:Integer, [195]:Integer, [196]:Integer, [197]:Integer, [198]:Integer, [199]:Integer, [200]:Float@double, [208]:Float@double, [216]:Float@double, [224]:Float@double, [232]:Float@double, [240]:Float@double, [248]:Integer, [249]:Integer, [2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140:71,ERROR,ERROR,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140,1,['ERROR'],['ERROR']
Availability," a file called `rigid_lid.jl` exists (https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/rigid_lid.jl) so I was curious whether `HydrostaticFreeSurfaceModel` can run with a free surface, presumably by passing `free_surface = nothing`. It does error (see MWE below) but with a couple of extra function definitions (see far below) it seems to time step. Are these fixes enough for a working rigid lid? If not, does it make sense to remove the `rigid_lid.jl` file?. Note: The documentation also mentions a rigid lid here: https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/elliptic_solvers/#Rigid-lid-pressure-operator. ---. Minimal working example to reproduce the error:. ```julia; using Oceananigans. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)); model = HydrostaticFreeSurfaceModel(; grid, free_surface=nothing); time_step!(model, 1); ```. Error:. ```; ERROR: MethodError: no method matching materialize_free_surface(::Nothing, ::@NamedTuple{…}, ::LatitudeLongitudeGrid{…}). Closest candidates are:; materialize_free_surface(::ExplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl:32; materialize_free_surface(::SplitExplicitFreeSurface, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:114; materialize_free_surface(::ImplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:93; ... Stacktrace:; [1] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::Nothing, tracers::Nothing, forcing::@NamedTup",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3735:1006,Error,Error,1006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735,1,['Error'],['Error']
Availability," a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isassigned(::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}, ::Int64, ::Int64); @ Base ./multidimensional.jl:1582; [10] alignment(io::IOContext{Base.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:1445,error,error,1445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,1,['error'],['error']
Availability," adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656:1075,ERROR,ERROR,1075,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656,1,['ERROR'],['ERROR']
Availability," and diagnostics. All callbacks are required to possess `callback.schedule`, and we can provide convenience objects for coupling simple callback functions to `AbstractSchedule`. 2. Within the time-stepping loop, execute `simulation.callbacks` prior to writing output. This ensures that data calculated in a callback can be output during the same time-step, such as `WindowedTimeAverage` and other non-local-in-time output. 3. Wrap the time-stepping loop inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedule` rather than chronically late as it is now. Since output is called after all the other callbacks, the output writers get the final say as to the next time-step. These changes will break the existing API. Notably, we'll use. ```julia; push!(simulation.callbacks, TimeStepWizard(cfl=1)); ```. rather than setting `simulation.Δt` to be a `TimeStepWizard`. This is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138:1369,checkpoint,checkpointer,1369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138,1,['checkpoint'],['checkpointer']
Availability," c1_forcing = Forcing(Fc1, field_dependencies=:c1); c2_forcing = Forcing(Fc2, field_dependencies=:c2). model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; tracers = (:c1, :c2),; forcing = (c1=c1_forcing, c2=c2_forcing)). set!(model, c1=1, c2=1); simulation = Simulation(model, Δt=Δt, stop_time=stop_time). ∫c1_dxdy = Field(Average(model.tracers.c1, dims=(1, 2))); ∫c2_dxdy = Field(Average(model.tracers.c2, dims=(1, 2))); ; nc_outputs = Dict(""c1"" => ∫c1_dxdy, ""c2"" => ∫c2_dxdy); nc_dimensions = Dict(""c1"" => (""zC"",), ""c2"" => (""zC"",)). single_time_average_nc_filepath = ""single_decay_windowed_time_average_test.nc""; ; window = window_nΔt*Δt; interval = interval_nΔt*Δt. single_nc_output = Dict(""c1"" => ∫c1_dxdy); single_nc_dimension = Dict(""c1"" => (""zC"",)). simulation.output_writers[:single_output_time_average] =; NetCDFOutputWriter(model, single_nc_output,; array_type = Array{Float64},; verbose = true,; filename = single_time_average_nc_filepath,; schedule = AveragedTimeInterval(interval, window = window, stride = stride),; dimensions = single_nc_dimension,; overwrite_existing = overwrite); checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation. end; ; Δt = .01 #1/64 # Nice floating-point number; T1 = 6Δt # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); window_nΔt = 2; interval_nΔt = 2; stride = 1; # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, window_nΔt, interval_nΔt, stride, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, window_nΔt, interval_nΔt, stride, false); run!(simulation, pickup=checkpoint). ##### For each λ, horizontal average should evaluate to; #####; ##### c̄(z, t) = ∫₀¹ ∫₀¹ exp{- λ(x, y, z) * t} dx dy; ##### = 1 /",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629:3276,checkpoint,checkpointer,3276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629,3,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpointer']"
Availability," data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0; ```; I am using ; ```; (Oceananigans) pkg> st; Project Oceananigans v0.77.4; Status `~/stable_oceananigans/Oceananigans.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.4.0; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.12.0; ⌃ [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; ⌅ [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; ⌃ [033835bb] JLD2 v0.4.22; ⌅ [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.7; [6fe1bfb0] OffsetArrays v1.12.7; [bac558e1] OrderedCollections v1.4.1; ⌃ [0e08944d] PencilArrays v0.17.6; [4a48f351] PencilFFTs v0.14.1; ⌃ [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.12; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated`; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:3786,avail,available,3786,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152,1,['avail'],['available']
Availability," errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | ERROR: ERROR: ERROR: ERROR: Package Oceananigans errored during testing; &nbsp; | Stacktrace:Package Oceananigans errored during testing; &nbsp; | Stacktrace:Package Oceananigans errored during testing; &nbsp; | Stacktrace:; &nbsp; | [1] pkgerrorPackage Oceananigans errored during testing; &nbsp; | Stacktrace:; &nbsp; | [1] (pkgerror; &nbsp; | [1] (pkgerror::(; &nbsp; | [1] ::pkgerrorString) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; &nbsp; | [2] (::test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; &nbsp; | [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; &nbsp; | [2] (),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; &nbsp; | [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:2345,ERROR,ERROR,2345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,8,"['ERROR', 'error']","['ERROR', 'errored']"
Availability," errors are present even in the initial velocities and the diagnosed initial vorticity. The vorticity error is significantly pronounced near the cubed sphere corners due to the deviation from orthogonality. For instance, in the domain's interior, the vorticity error norm is three orders of magnitude less than the vorticity norm, whereas at the corners, it is nearly the same order of magnitude.; - As the simulation progresses, the amplified error from the corners propagates into the interior as expected. After 500 time steps, the vorticity error in the interior increases from three orders of magnitude less to one order of magnitude less than the vorticity norm. I have attached panel-wise plots of the exact vorticity and the error of its numerical counterpart on the cubed sphere for the initial condition and after 500 time steps for reference. Given these circumstances, @navidcy and I are contemplating whether we should continue using the exact solution for verification in the test script or consider alternative verification methods, such as ensuring that the norm of the numerical solution of the Rossby-Haurwitz wave remains bounded within a specified range (as mentioned in the introduction to this PR). @glwagner, @simone-silvestri and @jm-c, let us know your thoughts. **Exact initial vorticity**. ![cubed_sphere_rossby_haurwitz_wave_ζ₀_exact](https://github.com/CliMA/Oceananigans.jl/assets/12926768/ec936d28-49e5-4da2-9f49-783e517b6f0c). **Error in initial vorticity**. ![cubed_sphere_rossby_haurwitz_wave_ζ₀_error](https://github.com/CliMA/Oceananigans.jl/assets/12926768/59374933-eeab-417b-adfe-56eb1e2e5673). **Exact vorticity after 500 time steps**. ![cubed_sphere_rossby_haurwitz_wave_ζ_exact](https://github.com/CliMA/Oceananigans.jl/assets/12926768/15c81d0c-239e-42ad-a740-8505bd3a4a35). **Error in vorticity after 500 time steps**. ![cubed_sphere_rossby_haurwitz_wave_ζ_error](https://github.com/CliMA/Oceananigans.jl/assets/12926768/9209cb44-860b-4a88-8d4a-946d1143da7c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2134152684:2210,Error,Error,2210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2134152684,2,['Error'],['Error']
Availability," fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype Float64 with indices 1:5×1:5×-2:-2; └── max=1.0, min=0.0, mean=0.04; ```. Meanwhile if I set the indices to `(1:5,1:5,2)` to access the supposedly `eta.indices`, I get:. ```; Field(eta, indices = (1:5,1:5,2)); ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 5:5]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] top-level scope; @ REPL[39]:1; Some type information was truncated. Use `show(err)` to see complete types.; ``` . > @josuemtzmo can you show the whole sta",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:2567,ERROR,ERROR,2567,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['ERROR'],['ERROR']
Availability," field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inlined]; > [13] macro expansion; > @ ./simdloop.jl:77 [inlined]; > [14] copyto!; > @ ./broadcast.jl:1003 [inlined]; > [15] copyto!; > @ ./bro",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:1137,error,error,1137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748,1,['error'],['error']
Availability," if we consider for now just a 1D problem with boundary point $\phi_b$ and interior points at $\phi_{b-1}$ etc. When we go to update the boundary point we have $\phi_b^n$ and $\phi_{b-1}^{n+1}$ and we want $\phi_b^{n+1}$. As per previous work we assume that the bulk speed is the same at both $b$ and $b-1$ but we don't have both the spatial and time derivatives of the $\phi$ interior at the same step so we first need to approximate the previous step as:. $\phi_{b-i}^n = \phi_{b-i}^{n+1}-\Delta t G^n_{b+1}$. We can then find the bulk velocity at timestep n as:. $U_b^n = -\frac{2\Delta x_{b-1}G^n_{b-1}}{\phi^n_b - \phi^{n+1}_{b-2} - \Delta t G^n _{b-2}}$. We then have all the information to step $\phi_b$ to:. $\phi_b^{n+1}=\phi_b^n-\frac{\Delta t}{\Delta x_b}U_b(\phi_b^n-\phi_{b-1}^{n+1} - \Delta t G^n_{b-1})$. This will require us to give the boundary condition both the tendencies and $\Delta t$, but this seems to be the easiest thing to change. I also think this is the only way we can get a physically sensible bulk speed where all of the components are calculated at the same timestep. I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a question for further down the line). We might also want to consider oblique waves but that shouldn't be too hard to extend to we might just have to calculate a lot of surrounding points which might motivate some other way to do it. Does this make sense to everyone? I also can't see an obvious way to get $\Delta t$ to the halo fill since it doesn't even make it into the `update_state!` so any suggestions would be appreciated. Update:. I'm not sure if",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810:2017,down,down,2017,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810,1,['down'],['down']
Availability," julia> set!(c,a); set!(d,b);. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.006219191907858468; 0.8963174540626572; 0.06824259256136866. julia> interior(c, 1, :, 1); 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; 0.45223462463057673; 0.18046843834182114; 0.9782543808912043. julia> view(d, :, 1, 1) .= view(c, 1, :, 1); 3×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 3×3×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, 1:1, 1:1); └── data: 9×1×1 OffsetArray(view(::Array{Float64, 3}, :, 4:4, 4:4), -2:6, 1:1, 1:1) with eltype Float64 with indices -2:6×1:1×1:1; └── max=0.697903, min=0.452235, mean=0.568357. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.45223462463057673; 0.6979033041564312; 0.5549323977919884; ```. However, the following works for the interior of the `Field`:; ```julia; julia> interior(d, :, 1, 1) .= interior(c, 1, :, 1);. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.45223462463057673; 0.18046843834182114; 0.9782543808912043; ```. Moreover, since `view(d, :, 1, 1).data` is a 9x1x1 OffsetArray and `view(c, 1, :, 1).data` is a 1x9x1 OffsetArray, ; `view(d, :, 1, 1).data .= view(c, 1, :, 1).data` leads to a dimension mismatch error. However, the following approach gives the correct result. . ```julia; julia> set!(c,a); set!(d,b);. julia> view(d, :, 1, 1).data .= reshape(view(c, 1, :, 1).data, -2:6, 1:1, 1:1); 9×1×1 OffsetArray(view(::Array{Float64, 3}, :, 4:4, 4:4), -2:6, 1:1, 1:1) with eltype Float64 with indices -2:6×1:1×1:1:; [:, :, 1] =; 0.0; 0.0; 0.0; 0.45223462463057673; 0.18046843834182114; 0.9782543808912043; 0.0; 0.0; 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038588542:2749,error,error,2749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038588542,1,['error'],['error']
Availability," makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots more fields, but I see now that this is much less of an issue. Sorry about making this much more complicated than it should have been!. Edit: updated the gist example with how this can be implemented (requires PR #2733 branch)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:1600,avail,available,1600,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312,1,['avail'],['available']
Availability," of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:3566,ERROR,ERROR,3566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['ERROR'],['ERROR']
Availability," one of its locations is `Nothing`, rather than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have a design problem on our hands to figure out how to represent these ideas i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:1086,mask,masking,1086,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044,2,['mask'],['masking']
Availability," precompile PlotUtils [995b91a9-d308-5afd-9ec6-746e21dbc043] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/PlotUtils/YveHG_R3lk8.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] top-level scope at none:2; &nbsp; | [2] eval at ./boot.jl:347 [inlined]; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2556/packages/Plots/SjqWU/src/Plots.jl:20; &nbsp; | ERROR: LoadError: Failed to precompile Plots [91a5bcdd-55d7-5caf-9e0b-520d859cae80] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/Plots/ld3vC_R3lk8.ji.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-1/clima/oceananigans/docs/make.jl:6; &nbsp; | 🚨 Error: The command exited with status 1. ```. CPU test; ```; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; --; &nbsp; | [9] top-level scope at none:1; &nbsp; | Union{},Union{},Tuple{},NamedTuple{(test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2556/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2556/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2556/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PAT",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141:1650,ERROR,ERROR,1650,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141,1,['ERROR'],['ERROR']
Availability," simulation which is failing now. This was working a few days ago.; ```; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC; xC, yC, zC = reshape(xC, (Nx, 1, 1)), reshape(yC, (1, Ny, 1)), reshape(zC, (1, 1, Nz)). # Set heating flux at the bottom.; Q = 9200 # W/m^2; Rp = 50 # plume radius [m]. r = @. sqrt((xC - Lx/2)^2 + (yC - Ly/2)^2). bottom_flux = zeros(Nx, Ny, 1); bottom_flux[r .< Rp] .= g * ɑ * Q / (ρ₀ * cₚ); bottom_flux = CuArray(bottom_flux). model.boundary_conditions.T.z.right = BoundaryCondition(Flux, bottom_flux); ```. This now fails with:; ```; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Flux,Int64}, got BoundaryCondition{Flux,CuArray{Float64,3}}; Stacktrace:; [1] setbc!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Val{:right}, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:81; [2] setproperty!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Symbol, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:80; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] include(::String) at ./client.jl:403; [8] top-level scope at none:0; in expression starting at /home/betaeffect/oceananigans/hydrothermal_plume/nukappa1em4/plume.jl:37; ```. I am not fully proficient in Julia yet, so wasn't able to figure out from the code how to fix this issue. Is there a simple fix?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314:1036,ERROR,ERROR,1036,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314,1,['ERROR'],['ERROR']
Availability," the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} += \Delta t^{n+1} (1.5 G^{n+1} - 0.5 G^{n}); ```; we remain with a spurious $G^n (1.5\Delta t^{n} - 0.5 \Delta t^{n-1}) - G^n$. . Given [this](https://homepages.m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738:1502,error,error,1502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738,1,['error'],['error']
Availability," to do IO in the long-term but will definitely want some way to output NetCDF. > Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project.; > ; > My last attempt at improving the NetCDF solved many of the issues with the package JuliaGeo/NetCDF.jl#61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite.; > ; > Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages.; > ; > I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https://github.com/JuliaGeo/NetCDF.jl/issues/87 fixed, I think we'll be happy for a long time. The `compress=9` bug explains why the IO was slow. @glwagner has suggested that for a project of our scale we'd want to help and contribute to the packages we use. We definitely want to stick with NetCDF as it's the _de facto_ standard in the climate, atmospheric, and ocean sciences. A discussion might be helpful down the line. With faster IO I think we're happy now and we're still figuring how to do IO long-term. > My feeling is that if you want to write Net",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:1561,robust,robustness,1561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['robust'],['robustness']
Availability," to have properties which can evolve with the model; - [x] Make the existing tests pass; - [x] and implements a zero gradient matching scheme. (Others please feel free to update this comment as necessary.). ------------------------------------------------------------------------; Hi all,. Following discussion with @glwagner, @simone-silvestri, and @jm-c this is a first attempt at implementing open boundary conditions. First I will try to get it working for the non-hydrostatic model which seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to be a topology because otherwise, users have to manually specify boundary conditions on everything? Then we can automatically set `OpenBoundaryCondition(nothing)` unless a user sets something else.; - Should we have an automatic way to setup a sponge layer?; - Do we think it is correct not to add a term to the pressure for time-varying inflow? I think we do not (see below",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:1410,down,downstream,1410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['down'],['downstream']
Availability," to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new features that help us build output in a sensible way. One idea is a macro that looks something like. ```julia; us, vs, ws, Ts = @indices (:, :, Nz) u v w T; ```. This would be equivalent to writing something like. ```julia; us = Field(u, indices=(:, :, Nz)); vs = Field(v, indices=(:, :, Nz)); ws = Field(w, indices=(:, :, Nz)); Ts = Field(T, indices=(:, :, Nz)); ```. Then, if users want to output surface fields _and_ the free surface, they should use this method rather than the `indices` kwarg.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520:1579,ERROR,ERROR,1579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520,1,['ERROR'],['ERROR']
Availability," underlying_grid = RectilinearGrid(CPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Flat y ; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> slope(x) = x; slope (generic function with 1 method). julia> grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)); 4×1×4 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo:; ├── immersed_boundary: PartialCellBottom(mean(z)=0.5, min(z)=0.125, max(z)=0.875, ϵ=0.2); ├── underlying_grid: 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Flat y ; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> model = HydrostaticFreeSurfaceModel(; grid); ERROR: BoundsError: attempt to access 10×1×1 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, 1:1) with eltype Float64 with indices -2:7×1:1×1:1 at index [1, 0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:422 [inlined]; [4] getindex; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:541 [inlined]; [5] Δzᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:115 [inlined]; [6] Δzᶜᶠᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:141 [inlined]; [7] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/grid_metrics.jl:138 [inlined]; [8] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/conditional_operations.jl:101 [inlined]; [9] _getindex; @ ./abstractarray.jl:1341 [inlined]; [10] getindex; @ ./abstractarray.jl:1291 [inlined]; [11] macro expansion; @ ./reducedim.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266:1181,ERROR,ERROR,1181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266,1,['ERROR'],['ERROR']
Availability, v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.14; [f5851436] FFTW_jll v3.3.9+7; [0234f1f7] HDF5_jll v1.12.0+1; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [856f044c] MKL_jll v2021.1.1+1; [7cb0a576] MPICH_jll v3.3.2+10; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [7243133f] NetCDF_jll v400.702.400+0; [fe0851c0] OpenMPI_jll v4.1.1+0; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.4+0; [0dad84c5] ArgTools; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8bb1440f] DelimitedFiles; [8ba89e20] Distributed; [f43a241f] Downloads; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions; [44cfe95a] Pkg; [de0858da] Printf; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA; [9e88b42a] Serialization; [1a1011a3] SharedArrays; [6462fe0b] Sockets; [2f01184e] SparseArrays; [10745b16] Statistics; [fa267f1f] TOML; [a4e569a6] Tar; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll; [deac9b47] LibCURL_jll; [29816b5a] LibSSH2_jll; [c8ffd9c3] MbedTLS_jll; [14a3606d] MozillaCACerts_jll; [83775a58] Zlib_jll; [8e850ede] nghttp2_jll; [3f19e933] p7zip_jll; ```. </details>,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684:14647,Down,Downloads,14647,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684,1,['Down'],['Downloads']
Availability," vertically irregular grid can be passed to a nonhydrostatic model and seems to run without a problem, but when the same formulation is applied to the horizontal, a method error is returned by the PressureSolver. The error persists if either the FFTBasedPoissonSolver or the FourierTridiagonalPoissonSolver are called. Is this a known issue?. A MWE follows. Notice the MWE is a reduction of the example given in the [grid documentation](https://clima.github.io/OceananigansDocumentation/stable/model_setup/grids/), which also gives back the same error when passed to a nonhydrostatic model.; ``` ; using Oceananigans. Lx, Ly, Lz = 1e4, 1e4, 1e3;; Nx, Ny, Nz = 64, 64, 32;; chebychev_spaced_y_faces(j) = - Ly/2 * cos(π * (j - 1) / Ny). grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = (-Lz,0); ). model = NonhydrostaticModel(; grid); ```. Gives:; ``` ; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, ; Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:23; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:24; PressureSolver(::Any, ::ImmersedBoundaryGrid) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\Nonhydros",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2940:958,ERROR,ERROR,958,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2940,1,['ERROR'],['ERROR']
Availability," with a `VerticallyStretchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574:1048,error,error,1048,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574,1,['error'],['error']
Availability,"   | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()';   | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()';   | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz;   | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561;   | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.;   | HTTP request sent, awaiting response... 304 Not Modified;   | File ‘/storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz’ not modified on server. Omitting download.;   |  ;   | Downloading artifact: MPICH;   | Downloading artifact: MPICH;   | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml';   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY);   | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443;   | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY);   | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508;   | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY);   | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706;   | [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; platform::Base.Bin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515:2541,error,error,2541,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515,1,['error'],['error']
Availability,"   | [12] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;   | [13] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [14] include(x::String);   | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;   | [15] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;   | [16] include;   | @ ./Base.jl:386 [inlined];   | [17] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing);   | @ Base ./loading.jl:1235;   | [18] top-level scope;   | @ none:1;   | [19] eval;   | @ ./boot.jl:360 [inlined];   | [20] eval(x::Expr);   | @ Base.MainInclude ./client.jl:446;   | [21] top-level scope;   | @ none:1;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;   | Stacktrace:;   | [1] pkgerror(msg::String);   | @ Pkg.Types /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:55;   | [2] precompile(ctx::Pkg.Types.Context; internal_call::Bool, strict::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});   | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1265;   | [3] precompile;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:921 [inlined];   | [4] #precompile#196;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:919 [inlined];   | [5] precompile();   | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:919;   | [6] top-level scope;   | @ none:1;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:3566,Error,Error,3566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134,1,['Error'],['Error']
Availability," Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² - 0.005027 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: SecondOrderSeawaterPolynomial{Float64}; ```. you get an error (or at least I did, attached at the bottom of this PR) when setting `model(; ... buoyancy)`. Instead if we have the `eos` set as a `RoquetEquationOfState`,. ```julia; julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; ├── seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; └── reference_density: 1024.6; ; julia> eos.seawater_polynomial # the density anomaly; ρ' = 0.7718 Sᴬ - 0.0491 Θ - 0.005027 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² + 0.0 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: BoussinesqEquationOfState{Float64}; ```. we can then set this as the `buoyancy` in the model, `model(; buoyancy)`, without an error. As of SeawaterPolynomials.jl v0.3.2 another idealised nonlinear eos has been added so the number available has been updated in `buoyancy models and equation of state.md`to reflect this and the compat entry has been updated. ## Error from setting `buoyancy = SeawaterBuoyancy(equation_of_state= RoquetSeawaterPolynomial(:Freezing))`. ```julia; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::SecondOrderSeawaterPolynomial{Float64}); Closest candidates are:; ρ′(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any) at ~/.julia/packages/Oceananigans/Zg9Bd/src/BuoyancyModels/nonlinear_equation_of_state.jl:27; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SecondOrderSeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/SecondOrderSeawaterPolynomials.jl:65; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.TEOS10.TEOS10Seawate",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3035:1494,error,error,1494,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035,1,['error'],['error']
Availability,"!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want to rerun the simulation from a checkpoint, 2 potential options would be available:. 1. The model runs from the latest checkpoint, and continues writing into the most recent output file once it catches up to the latest unsaved iteration. Note that since the model is running from the checkpoint the saved iterations which the model is running at could be in earlier parts than the most recent output. But the simulation should know that and only starts writing into the latest part once it catches up to the latest saved iteration.; 2. I specify a part number that is larger than all the previous output files, and the simulation picks up from the checkpoint and writes into the new part numbe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399:2380,ERROR,ERROR,2380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399,1,['ERROR'],['ERROR']
Availability,"""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:1344,ERROR,ERROR,1344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['ERROR'],['ERROR']
Availability,"""NaN error in u"" when trying to simulate open-ocean convection problem",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1289:5,error,error,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289,1,['error'],['error']
Availability,"""Serialization"" means ""saving to disk"":. https://en.wikipedia.org/wiki/Serialization. Functions can't be serialized by JLD2:. ```julia; julia> using JLD2. julia> file = jldopen(""test.jld2"", ""a+""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read/write); (no datasets). julia> f(x) = println(""Hello world!""); f (generic function with 1 method). julia> file[""f""] = f; f (generic function with 1 method). julia> close(file). julia> exit(). # Restart julia; $ julia ; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using JLD2. julia> file = jldopen(""test.jld2""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read-only); └─🔢 f. julia> f = file[""f""]; ┌ Warning: type Main.#f does not exist in workspace; reconstructing; └ @ JLD2 ~/.julia/packages/JLD2/b0tI9/src/data/reconstructing_datatypes.jl:364; JLD2.ReconstructedTypes.var""##Main.#f#257""(). julia> f(1); ERROR: MethodError: objects of type JLD2.ReconstructedTypes.var""##Main.#f#257"" are not callable; Stacktrace:; [1] top-level scope; @ REPL[5]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692:1174,ERROR,ERROR,1174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692,1,['ERROR'],['ERROR']
Availability,"""Why did you write such a bad callback?""), Base.StackTraces.StackFrame[top-level scope at REPL[2]:4, eval at boot.jl:360 [inlined], eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139, repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200, start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185, run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317, run_repl(repl::REPL.AbstractREPL, consumer::Any) at REPL.jl:305, (::Base.var""#875#877""{Bool, Bool, Bool})(REPL::Module) at client.jl:387, #invokelatest#2 at essentials.jl:708 [inlined], invokelatest at essentials.jl:706 [inlined], run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool) at client.jl:372, exec_options(opts::Base.JLOptions) at client.jl:302, _start() at client.jl:485]). julia> st; 13-element Vector{Base.StackTraces.StackFrame}:; top-level scope at REPL[2]:4; eval at boot.jl:360 [inlined]; eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139; repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200; start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185; run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317; run_repl(repl::REPL.AbstractREPL, consumer::Any) at REPL.jl:305; (::Base.var""#875#877""{Bool, Bool, Bool})(REPL::Module) at client.jl:387; #invokelatest#2 at essentials.jl:708 [inlined]; invokelatest at essentials.jl:706 [inlined]; run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool) at client.jl:372; exec_options(opts::Base.JLOptions) at client.jl:302; _start() at client.jl:485; ```. I'm not sure how this can be turned into something useful, but perhaps its a starting point. It may even be possible (though probably a bit futuristic) to implement a kwarg in `run!`, or to provide some debugging features for users that isolate errors due to user-defined functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614:5329,error,errors,5329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614,1,['error'],['errors']
Availability,"""show"" method throws an error for models with no tracers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/700:24,error,error,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/700,1,['error'],['error']
Availability,"# Benchmarks. ```; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; JULIA_NUM_THREADS = 24; JULIA_EDITOR = vim; GPU: NVIDIA TITAN V. CUDA toolkit 11.4, artifact installation; NVIDIA driver 470.86.0, for CUDA 11.4; CUDA driver 11.4. Libraries:; - CUBLAS: 11.5.4; - CURAND: 10.2.5; - CUFFT: 10.5.1; - CUSOLVER: 11.2.0; - CUSPARSE: 11.6.0; - CUPTI: 14.0.0; - NVML: 11.0.0+470.86; - CUDNN: 8.20.2 (for CUDA 11.4.0); - CUTENSOR: 1.3.0 (for CUDA 11.2.0). Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5, 7.0; - Device capability support: sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75, sm_80. 1 device:; 0: NVIDIA TITAN V (sm_70, 11.484 GiB / 11.784 GiB available); nothing; ```. ## `main`. ```; Nonhydrostatic model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float32 │ 32 │ 7.865 ms │ 8.157 ms │ 8.384 ms │ 9.923 ms │ 2.50 MiB │ 7004 │ 10 │; │ CPU │ Float32 │ 64 │ 13.237 ms │ 13.739 ms │ 14.162 ms │ 16.642 ms │ 3.20 MiB │ 12619 │ 10 │; │ CPU │ Float32 │ 128 │ 49.644 ms │ 53.133 ms │ 52.873 ms │ 56.953 ms │ 3.51 MiB │ 16344 │ 10 │; │ CPU │ Float32 │ 256 │ 338.545 ms │ 353.497 ms │ 353.048 ms │ 370.172 ms │ 3.81 MiB │ 35156 │ 10 │; │ CPU │ Float64 │ 32 │ 9.683 ms │ 10.028 ms │ 10.324 ms │ 12.479 ms │ 3.25 MiB │ 7003 │ 10 │; │ CPU │ Float64 │ 64 │ 14.979 ms │ 16.581 ms │ 17.035 ms │ 22.013 ms │ 4.07 MiB │ 12652 │ 10 │; │ CPU │ Float64 │ 128 │ 67.659 ms │ 68.736 ms │ 70.121 ms │ 84.62",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983874974:950,avail,available,950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983874974,1,['avail'],['available']
Availability,# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/977?src=pr&el=h1) Report; > Merging [#977](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/977?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4?el=desc) will **decrease** coverage by `0.01%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/977/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/977?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #977 +/- ##; ==========================================; - Coverage 72.54% 72.53% -0.02% ; ==========================================; Files 210 210 ; Lines 6076 6076 ; ==========================================; - Hits 4408 4407 -1 ; - Misses 1668 1669 +1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/977?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/977/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `88.88% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/977/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `75.00% <ø> (ø)` | |; | [src/TimeSteppers/runge\_kutta\_3.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/977/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9ydW5nZV9rdXR0YV8zLmps) | `85.07% <ø> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/977/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <100.00%> (ø)` | |; | [src/TimeSteppers/quasi\_adams\_bashforth\_2.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/977/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9xdWFzaV9hZGFtc19iYXNoZm9ydGhfMi5qbA==) | `84.84% <100.00%> (ø)` | |; | [src/Grids/Grids.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/977#issuecomment-699223879:1023,checkpoint,checkpointer,1023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/977#issuecomment-699223879,1,['checkpoint'],['checkpointer']
Availability,"# [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/233?src=pr&el=h1) Report; > :exclamation: No coverage uploaded for pull request base (`master@47d2abe`). [Click here to learn what that means](https://docs.codecov.io/docs/error-reference#section-missing-base-commit).; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/233/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/233?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #233 +/- ##; ========================================; Coverage ? 68.9% ; ========================================; Files ? 18 ; Lines ? 669 ; Branches ? 0 ; ========================================; Hits ? 461 ; Misses ? 208 ; Partials ? 0; ```. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/233?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/233?src=pr&el=footer). Last update [47d2abe...3a75da0](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/233?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/233#issuecomment-495452404:243,error,error-reference,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/233#issuecomment-495452404,2,['error'],['error-reference']
Availability,"# [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/243?src=pr&el=h1) Report; > :exclamation: No coverage uploaded for pull request base (`master@a099207`). [Click here to learn what that means](https://docs.codecov.io/docs/error-reference#section-missing-base-commit).; > The diff coverage is `0%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/243/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/243?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #243 +/- ##; =========================================; Coverage ? 74.59% ; =========================================; Files ? 23 ; Lines ? 866 ; Branches ? 0 ; =========================================; Hits ? 646 ; Misses ? 220 ; Partials ? 0; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/243?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/243/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `83.81% <0%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/243?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/243?src=pr&el=footer). Last update [a099207...53f26c5](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/243?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/243#issuecomment-496245199:243,error,error-reference,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/243#issuecomment-496245199,1,['error'],['error-reference']
Availability,# [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/546?src=pr&el=h1) Report; > :exclamation: No coverage uploaded for pull request base (`master@b1fe0ab`). [Click here to learn what that means](https://docs.codecov.io/docs/error-reference#section-missing-base-commit).; > The diff coverage is `53.57%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/546/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/546?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #546 +/- ##; =========================================; Coverage ? 69.91% ; =========================================; Files ? 69 ; Lines ? 2001 ; Branches ? 0 ; =========================================; Hits ? 1399 ; Misses ? 602 ; Partials ? 0; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/546?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/546/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `52.74% <0%> (ø)` | |; | [...ure\_implementations/leith\_enstrophy\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/546/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2xlaXRoX2Vuc3Ryb3BoeV9kaWZmdXNpdml0eS5qbA==) | `98.38% <100%> (ø)` | |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/546/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `76% <100%> (ø)` | |; | [...lence\_closure\_implementations/smagorinsky\_lilly.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/546/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3NtYWdvcmluc2t5X2xpbGx5Lmps) | `92.85% <100%> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oc,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/546#issuecomment-564303242:243,error,error-reference,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/546#issuecomment-564303242,1,['error'],['error-reference']
Availability,# [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627?src=pr&el=h1) Report; > :exclamation: No coverage uploaded for pull request base (`master@c417701`). [Click here to learn what that means](https://docs.codecov.io/docs/error-reference#section-missing-base-commit).; > The diff coverage is `84.84%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #627 +/- ##; =========================================; Coverage ? 75.13% ; =========================================; Files ? 118 ; Lines ? 2280 ; Branches ? 0 ; =========================================; Hits ? 1713 ; Misses ? 567 ; Partials ? 0; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | |; | [src/Models/show\_models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9zaG93X21vZGVscy5qbA==) | `0% <ø> (ø)` | |; | [src/Architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `88.88% <ø> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `100% <ø> (ø)` | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0% <0%> (ø)` | |; | [src/Simulations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zLmps) | `93.75% <100%> (ø)` | |; | [,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-586666059:243,error,error-reference,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-586666059,1,['error'],['error-reference']
Availability,# [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631?src=pr&el=h1) Report; > :exclamation: No coverage uploaded for pull request base (`master@0001584`). [Click here to learn what that means](https://docs.codecov.io/docs/error-reference#section-missing-base-commit).; > The diff coverage is `87.03%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #631 +/- ##; =========================================; Coverage ? 78.11% ; =========================================; Files ? 119 ; Lines ? 2326 ; Branches ? 0 ; =========================================; Hits ? 1817 ; Misses ? 509 ; Partials ? 0; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `85.71% <ø> (ø)` | |; | [src/BoundaryConditions/BoundaryConditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9Cb3VuZGFyeUNvbmRpdGlvbnMuamw=) | `100% <ø> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `100% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <100%> (ø)` | |; | [src/Fields/set!.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `67.64% <100%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589887431:243,error,error-reference,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589887431,1,['error'],['error-reference']
Availability,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:13,error,error,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,8,"['ERROR', 'checkpoint', 'error']","['ERROR', 'checkpoint', 'checkpointed', 'error']"
Availability,## [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1085?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=CliMA) Report; > :exclamation: No coverage uploaded for pull request base (`main@fad81b0`). [Click here to learn what that means](https://docs.codecov.io/docs/error-reference?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=CliMA#section-missing-base-commit).; > Patch has no changes to coverable lines. > :exclamation: Current head 32a06cb differs from pull request most recent head 94fdef6. Consider uploading reports for the commit 94fdef6 to get more accurate results. <details><summary>Additional details and impacted files</summary>. ```diff; @@ Coverage Diff @@; ## main #1085 +/- ##; =======================================; Coverage ? 57.31% ; =======================================; Files ? 162 ; Lines ? 3882 ; Branches ? 0 ; =======================================; Hits ? 2225 ; Misses ? 1657 ; Partials ? 0 ; ```. Help us with your feedback. Take ten seconds to tell us [how you rate us](https://about.codecov.io/nps?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=CliMA). Have a feature suggestion? [Share it here.](https://app.codecov.io/gh/feedback/?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=CliMA). </details>. [:umbrella: View full report in Codecov by Sentry](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1085?src=pr&el=continue&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=CliMA). ; :loudspeaker: Do you have feedback about the report comment? [Let us know in this issue](https://about.codecov.io/codecov-pr-comment-feedback/?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=CliMA).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-713171413:331,error,error-reference,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-713171413,1,['error'],['error-reference']
Availability,"############# 100.0%; &nbsp; | Downloading artifact: MbedTLS; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: Zlib; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenMPI; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: FFTW; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: HDF5; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibSSH2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: CompilerSupportLibraries; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:1708,Down,Downloading,1708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['Down'],['Downloading']
Availability,"############## 100.0%; &nbsp; | Downloading artifact: Zlib; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenMPI; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: FFTW; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: HDF5; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibSSH2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: CompilerSupportLibraries; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:1836,Down,Downloading,1836,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['Down'],['Downloading']
Availability,"################# 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_wri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:2623,Error,Error,2623,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,2,['Error'],['Error']
Availability,################## 100.0%; &nbsp; | Downloading artifact: IntelOpenMP; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: NetCDF; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenSpecFun; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: nghttp2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MbedTLS; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: Zlib; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenMPI; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: FFTW; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: HDF5; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibSSH2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: CompilerSupportLibraries; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:1177,Down,Downloading,1177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['Down'],['Downloading']
Availability,"##################### 100.0%; &nbsp; | Downloading artifact: nghttp2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MbedTLS; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: Zlib; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenMPI; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: FFTW; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: HDF5; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibSSH2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: CompilerSupportLibraries; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:1561,Down,Downloading,1561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['Down'],['Downloading']
Availability,"######################### 100.0%; &nbsp; | Downloading artifact: NetCDF; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenSpecFun; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: nghttp2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MbedTLS; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: Zlib; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenMPI; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: FFTW; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: HDF5; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibSSH2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: CompilerSupportLibraries; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nb",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:1304,Down,Downloading,1304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['Down'],['Downloading']
Availability,"######################### 100.0%; &nbsp; | Downloading artifact: OpenSpecFun; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: nghttp2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MbedTLS; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: Zlib; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenMPI; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: FFTW; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: HDF5; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibSSH2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: CompilerSupportLibraries; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &n",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:1431,Down,Downloading,1431,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['Down'],['Downloading']
Availability,#666 +/- ##; =========================================; + Coverage 78.28% 78.38% +0.1% ; =========================================; Files 118 119 +1 ; Lines 2390 2383 -7 ; =========================================; - Hits 1871 1868 -3 ; + Misses 519 515 -4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/666?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/666/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `100% <ø> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/666/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/666/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `100% <ø> (+3.7%)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/666/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.07% <ø> (ø)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/666/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <100%> (ø)` | :arrow_up: |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/666/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `100% <100%> (ø)` | |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/666/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `93.33% <100%> (ø)` | :arrow_up: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/666/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9h,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/666#issuecomment-595011047:1685,checkpoint,checkpointer,1685,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/666#issuecomment-595011047,1,['checkpoint'],['checkpointer']
Availability,"&quot;, Courier, monospace;"">; Oceananigans \| 818 12 830; --; &nbsp; | Distributed MPI Oceananigans \| 816 12 828; &nbsp; | Multi architectures rank connectivity \| 28 28; &nbsp; | Local grids for distributed models \| 24 24; &nbsp; | Injection of halo communication BCs \| 168 168; &nbsp; | Halo communication \| 588 12 600; &nbsp; | Time stepping IncompressibleModel \| 4 4; &nbsp; | Time stepping ShallowWaterModel \| 4 4; &nbsp; | Distributed FFT-based Poisson solver \| 2 2; &nbsp; | ERROR: ERROR: ERROR: ERROR: LoadError: LoadError: LoadError: LoadError: Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | ERROR: ERROR: ERROR: ERROR: Package Oceananigans errored during testing; &nbsp; | Stacktrace:Package Oceananigans errored during testing; &nbsp; | Stacktrace:Package Oceananigans errored during testing; &nbsp; | Stacktrace:; &nbsp; | [1] pkgerrorPackage Oceananigans errored during testing; &nbsp; | Stacktrace:; &nbsp; | [1] (pkgerror; &nbsp; | [1] (pkgerror::(; &nbsp; | [1] ::pkgerrorString) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; &nbsp; | [2] (::test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:1983,error,errored,1983,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['error'],['errored']
Availability,"' functionality to Oceananigans. With this PR, the user is now able to specify which tracers they would like to include in their simulation via the `Model` constructor:. ```julia; model = Model(..., tracers=(:b, :c1, :c2), ...); ```. ## User-facing considerations. 1. The specified tracers must be consistent with the specified buoyancy model. This consistency is ensured by `validate_buoyancy` in the `Model` constructor. For `BuoyancyTracer`, the user must specify a tracer named `:b`. For `SeawaterBuoyancy`, the user must specify tracers named `:T` and `:S`. (In the future, we could also allow the names of these buoyancy, temperature, and salinity tracers to be specified in the constructor for the respective buoyancy models, eg `SeawaterBuoyancy(temperature=:T, salinity=:S)`.). 2. The constructor for `ModelForcing` (which will have to be merged with #444 when it is approved) now allows the user to specify forcing for any of the tracer fields. If the user specifies a forcing for a tracer field that does not exist, an error is thrown. If a user does not specify a forcing for some tracer field, a default zero forcing is applied. 3. The same logic for `ModelForcing` applies to `BoundaryConditions` / `SolutionBoundaryConditions`. When boundary conditions for a tracer field are unspecified, a default tracer boundary condition is inferred from the x-velocity field: tracers either inherit `Periodic` boundary conditions, or are given a `Flux, Nothing` boundary condition for all other cases. 4. For closures, all tracer-diffusivity-related fields permit users to specify either:. * a constant (applied to all tracers), or ; * a `NamedTuple` with fields for *every* tracer. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, diff",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:1066,error,error,1066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,1,['error'],['error']
Availability,"'s my MWE which includes running the first simulation to generate the checkpoint file:. ```julia; using Oceananigans; using Printf. """""" Set up a simple simulation to test picking up from a checkpoint. """"""; function test_simulation(stop_time, Δt, δt); grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = false). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. rm(""test_iteration*.jld2"", force=true). Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); run!(simulation, pickup=checkpoint); ```. This reproduces the issue because I get. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds; [ Info: ... simulation initialization complete (2.697 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (5.721 seconds).; [ Info: Iter: 2, time: 2 seconds; [ Info: Simulation is stopping after running for 8.786 seconds.; [ Info: Simulation time 4 seconds equals or exceeds stop time 4 seconds.; [ Info: Iter: 4, time: 4 seconds; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (529.973 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (575.447 μs).; [ Info: Iter: 5, time: 5 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310:995,checkpoint,checkpoint,995,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310,2,['checkpoint'],['checkpoint']
Availability,"'ve figured out how to do the 3D pressure solve on a stretched grid following Chris' notes so I think we have all the pieces we need to implement vertically stretched grids, we just have to put it all together. I'm thinking about how to go about fully incorporating a vertically stretched grid, true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471:987,down,down,987,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471,1,['down'],['down']
Availability,"(!Matched::AbstractDict{K, T}; gitpath, force, source, storepatch) where {K, T} at ~/.julia/packages/DrWatson/I8SbQ/src/saving_tools.jl:200; ```. Do you have any recommendations for using DrWatson.jl with Oceananigans.JL? Maybe there's something basic I'm missing here about saving data files. Thanks!; Miles. <details><summary>Full script</summary>. ```julia; using DrWatson; @quickactivate ""Learning Oceananigans.jl"". using Oceananigans; using Statistics; using Random. function makesim(d::Dict); @unpack size,; extent,; topology,; architecture,; timestepper,; advection,; closure,; Δt,; stop_time,; Δx,; initial_condition,; seed = d. actual_size = (size..., 1). grid = RectilinearGrid(; size, extent, topology); model = NonhydrostaticModel(; grid, timestepper, advection, closure). # Initial conditions:; rng = MersenneTwister(seed); u, v = if initial_condition == ""random""; u = rand(rng, actual_size...); v = rand(rng, actual_size...); u .-= mean(u); v .-= mean(v); u, v; else; error(""Unknown initial condition: $initial_condition""); end. set!(model; u=u, v=v). sim = Simulation(model; Δt, stop_time); sim.callbacks[:progress] = Callback(; s -> @info ""Iteration $(iteration(s)) at time $(time(s))"", IterationInterval(100); ). ω, speed = begin; u, v, _ = model.velocities; ω = ∂x(v) - ∂y(u); speed = sqrt(u^2 + v^2); ω, speed; end. function init_jld2!(file, model); tag!(file) # Tag with git information; merge!(file, d) # Save parameters to model file; end; ; sim.output_writers[:fields] = JLD2OutputWriter(; model,; (; ω, speed);; filename=datadir(""simulations"", savename(d, ""jld2"")),; overwrite_existing=true,; schedule=TimeInterval(Δt * 3),; init=init_jld2!; ); return sim; end. Δt = 0.2; size = (128, 128); extent = (1, 1); Δx = extent[1] / size[1]; stop_time = 10.0; topology = (Periodic, Periodic, Flat); architecture = CPU(); timestepper = :RungeKutta3; advection = nothing; closure = nothing; initial_condition = ""random""; seed = 0. params = @strdict size extent topology architecture tim",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2829:2241,error,error,2241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2829,1,['error'],['error']
Availability,"(#1571) Greg, here we had left the discussion. In that code, I was getting ```Domain error``` after using Chebyshev spacing function or any cod function, and the rest was ok.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-826103367:85,error,error,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-826103367,1,['error'],['error']
Availability,"(0); CUDA.CuDevice(1); CUDA.CuDevice(2); CUDA.CuDevice(3); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ```. # Julia 1.5.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!), CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global}, Oceananigans.Solvers.HorizontallyPeriodic, GPU, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Int64, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:3037,ERROR,ERROR,3037,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['ERROR'],['ERROR']
Availability,(0.90.8) Fix a sign error in CATKE's implicit dissipative buoyancy flux,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3474:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3474,1,['error'],['error']
Availability,(0.90.9) Fix a sign error in CATKE's implicit dissipative buoyancy flux,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3484:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3484,1,['error'],['error']
Availability,(0.91.5) Tweak initialization procedure so that callback schedules work with checkpointed simulations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3660:77,checkpoint,checkpointed,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3660,1,['checkpoint'],['checkpointed']
Availability,"(:slice1,), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{UnitRange{Int64}, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float32, N} where N}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/MVUJA/src/OutputWriters/netcdf_output_writer.jl:324; [14] top-level scope; @ ~/Dropbox/tests/new_project/tilted.jl:24; [15] include(fname::String); @ Base.MainInclude ./client.jl:444; [16] top-level scope; @ REPL[2]:1; ```. Am I missing something or is this a bug?. PS: I had to exclude a big chunk of the error because the output was too long and github wouldn't let me post it...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497:42813,error,error,42813,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497,1,['error'],['error']
Availability,"(as discussed with @simone-silvestri); I encountered this bug when trying to upgrade to julia 1.10.0. What happens is `maximum(abs, v)` doesn't work for grids larger than (10, 10, 10). However `maximum(abs, u)`, `maximum(abs, w)`, `maximum(abs, b)`, `maximum(u)`, `maximum(v)`, `maximum(w)`, and `maximum(b)` work just fine. Here's a MWE tested on Supercloud and Tartarus:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid). u, v, w = model.velocities. maximum(u); maximum(w); maximum(v). maximum(abs, u); maximum(abs, w); maximum(abs, v); ```. ```; ERROR: LoadError: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#863#864""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#863#864""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream::CUDA.CuStream) where N; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:62 [inlined]; [9] #868; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:136 [inlined]; [10] macro expansion; @ CUDA ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427:702,ERROR,ERROR,702,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"(model; Δt=0.01, stop_time=60). function progress(sim); model = sim.model; @printf(; ""iteration: %d, time: %.4f, U_max=(%.2e, %.2e, %.2e)\n"",; iteration(sim),; time(sim),; maximum(abs, model.velocities.u),; maximum(abs, model.velocities.v),; maximum(abs, model.velocities.w); ). @printf(; "" reltol=%.2e, abstol=%.2e, solver iterations: %d, residual: (mean=%.2e, abs(max)=%.2e)\n"",; model.pressure_solver.conjugate_gradient_solver.reltol,; model.pressure_solver.conjugate_gradient_solver.abstol,; iteration(model.pressure_solver),; mean(model.pressure_solver.conjugate_gradient_solver.residual),; maximum(abs, model.pressure_solver.conjugate_gradient_solver.residual); ); end. simulation.callbacks[:progress] = Callback(progress, IterationInterval(1)). nan_checker = NaNChecker(fields=model.velocities, erroring=true); simulation.callbacks[:nan_checker] = Callback(nan_checker, IterationInterval(1)). run!(simulation); ```. Now I'm seeing that it's maxing out the solver iterations at 4096 and the residual (mean and max) is still like 5 orders of magnitude higher than tolerance. ```; [ Info: Initializing simulation...; iteration: 0, time: 0.0000, U_max=(0.00e+00, 0.00e+00, 0.00e+00); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 0, residual: (mean=0.00e+00, abs(max)=0.00e+00); [ Info: ... simulation initialization complete (109.482 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.840 seconds).; iteration: 1, time: 0.1000, U_max=(1.19e-02, 5.23e-03, 5.19e-03); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-1.78e-03, abs(max)=1.06e-02); iteration: 2, time: 0.2000, U_max=(1.21e-02, 4.93e-03, 5.20e-03); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-9.30e-04, abs(max)=5.56e-03); iteration: 3, time: 0.3000, U_max=(1.25e-02, 5.02e-03, 5.32e-03); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-4.85e-04, abs(max)=2.74e-03); iteration: 4, time: 0.4000, U_max=(6.2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412573112:2269,toler,tolerance,2269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412573112,1,['toler'],['tolerance']
Availability,(v0.83.0) Fix error interpolating field on irregularly spaced grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912:14,error,error,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912,1,['error'],['error']
Availability,"(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [9] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:46; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/tomas/repos/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:1950,error,error,1950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['error'],['error']
Availability,")(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:846; [27] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [28] invokelatest; @ ./essentials.jl:714 [inlined]; [29] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/LineEdit.jl:2493; [30] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:1232; [31] (::REPL.var""#49#54""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:423. julia> grid.Δzᵃᵃᶜ.parent; 4-element CuArray{Float64, 1}:; Error showing value of type CuArray{Float64, 1}:; ERROR: CUDA error: invalid argument (code 1, ERROR_INVALID_VALUE); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] ada",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:6152,error,error,6152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685,1,['error'],['error']
Availability,"),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; │ [6] macro expansion; │ @ ./none:0 [inlined]; │ [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CuStream, CuFunction, CuDim3, CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CuDeviceArray{Float64, 4, 1}, ::Oceananigans.AbstractOperations.ConditionalOperation{Face,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:1646,error,error,1646,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['error'],['error']
Availability,"); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:643; [2] sum(c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:condition, :mask, :dims), Tuple{Array{Bool, 3}, Int64, Tuple{Int64, Int64, Int64}}}}); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:654; [3] Reduction(avg::Average, field::Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:4761,mask,mask,4761,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['mask'],['mask']
Availability,"); dz = 1 .+ 5000 ./ (1 .+ exp.(- (k .- 100)/10 )); zf = [0; -cumsum(dz)]; zf = reverse(zf); Lz = zf[1]; #; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = zf). # Turbulence closures; kappaV = 1e-5; kappaH = 5e5; turb_leith = TwoDimensionalLeith(;C=0.3, C_Redi=1, C_GM=1,isopycnal_model=SmallSlopeIsopycnalTensor()); vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = turb_leith; closures = (vertical_closure, horizontal_closure). # Setting up model; model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; buoyancy = SeawaterBuoyancy(equation_of_state=TEOS10EquationOfState()),; closure = closures,; ). # Setting up simulation; Δt = 5.; stop_time = 20.; simulation = Simulation(model, Δt=Δt, stop_time=stop_time). # Running model; run!(simulation). ```. but get the following error. . ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gc!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 42)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(8, 8, 42)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, Val{1}, CenteredFourthOrder, Tuple{TwoDimensionalLeith{Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2660:1650,ERROR,ERROR,1650,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2660,1,['ERROR'],['ERROR']
Availability,"**TL;DR: We can compress 18GB of Oceananigans simulation checkpoints into 350MB with bitrounding and lossless compression.**. #### Problem; Output is currently uncompressed in Float64 which contains; - redundancies: zeros for immersed boundaries, halos; similar/identical exponent bits; - false information: tailing mantissa bits with no mutual information to neighbouring grid points. #### Proposed solution; Bitrounding to remove false information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599:57,checkpoint,checkpoints,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599,2,['checkpoint'],"['checkpoint', 'checkpoints']"
Availability,", -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Gradient,Int64},BoundaryCondition{Gradient,Int64}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}(Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (5, 1028, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=ZeroFlux, north=ZeroFlux), z=(bottom=Gradient, top=Gradient), FieldSlicer{Colon,UnitRange{Int64},Colon}(Colon(), 3:7, Colon(), false), (1, 2)). julia> bwind(model); 1×1×16 Array{Float64,3}:; [:, :, 1] =; 3.3804104762232327e-9. [:, :, 2] =; -3.3870178841474065e-9. [:, :, 3] =; -5.033240008504092e-9. ... [:, :, 14] =; 4.520675322973764e-9. [:, :, 15] =; 1.7337945671947679e-9. [:, :, 16] =; -6.1358421780537424e-9; ```. PS: this is quite abstract so I'll try to come up with an example that reproduces the error when I have time",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559:3005,error,error,3005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559,2,['error'],['error']
Availability,", BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:2039,error,error,2039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,", Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); > @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; > [6] top-level scope; > @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > ```. Huh, that error seems unrelated but I'm not sure. In particular, it looks like you cannot create a netcdf file in the first place (this takes place before any code is executed that has to do specifically with this PR). Does your code work on `main`? You could also try using `JLD2OutputWriter` to see if you still get an error. It also could help to see what code you're running. PS I changed you single ticks ""`"" to block ticks ""```"" to make your message more readable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:31572,error,error,31572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839,2,['error'],['error']
Availability,", Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:condition, :mask, :dims), Tuple{KernelFunctionOperation{Center, Center, Face, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64, typeof(boundary_node), Tuple{Center, Center, Face}}, Int64, Tuple{Int64, Int64, Int64}}}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/field.jl:657; [4] Reduction(avg::Average, field::Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1907385408:5798,mask,mask,5798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1907385408,1,['mask'],['mask']
Availability,", NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Tuple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359:3704,down,download,3704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359,1,['down'],['download']
Availability,", but here are the first few lines:. ```; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.AbstractOperations.gpu__compute!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Float64, typeof(W), Tuple{}}, ::Tuple{Colon, Colon, Colon}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to julia.get_pgcstack); Stacktrace:; [1] multiple call sites; @ unknown:0; Reason: unsupported call through a literal pointer (call to jl_gc_run_pending_finalizers); Stacktrace:; [1] enable_finalizers; @ ./gcutils.jl:126; [2] _trylock; @ ./lock.jl:133; [3] multiple call sites; @ unknown:0; Reason: unsupported dynamic function invocation (call to kwcall(::Any, ::typeof(sprint), f::Function, args...) @ Base strings/io.jl:107); ```. I imagine `lambertw` isn't implemented by CUDA, but that doesn't seem to be what the error says, so I wonder if there's something else going on here. I also saw that [ClimaAtmos seems to be one of the packages that use `LambertW.jl`](https://juliapackages.com/p/lambertw), so maybe the Clima people have encountered (and hopefully solved) this before?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438:2516,error,error,2516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438,1,['error'],['error']
Availability,", they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worke",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:1195,Error,Error,1195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,2,['Error'],['Error']
Availability,", y, z) = U∞ + 1e-5 * Ξ(z). ## Vertical velocity initial condition: random noise scaled by the friction velocity.; wᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z). Tᵢ(x, y, z) = T0(z) + dTdz * model.grid.Lz * 1e-6 * Ξ(z). ## `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=S₀); ```; When I tried to output `model.pressures.prapid`, I got:. ```julia; 100×100×48 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 100×100×48 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 106×106×54 OffsetArray(::Array{Float64, 3}, -2:103, -2:103, -2:51) with eltype Float64 with indices -2:103×-2:103×-2:51; └── max=NaN, min=NaN, mean=NaN; ```; The NaN value appears. But for $p_{NHS}$ and $p_{HY'}$, the results are reasonable. So any comments or ideas about this error? . Another issue is about the calculation of the pressure terms for which the boundary conditions are inhomogeneous Neumann boundary conditions ($p_b'$, $p_{st}'$ and $p_{sg}'$, see Appendix A for details in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). For this issue, I have checked the related issue #1232. I wanna ask do I need to subtly update the boundary values of $p_b'$, $p_{st}'$ and $p_{sg}'$ to convert the inhomogeneous Neumann problem to the homogeneous Neumann problem? If so, how do I determine the values the boundary should update?. I hope I've described this issue clearly, but please let me know if anything confuse you. In addition, this is my first attempt to make a possible contribution to an open source project, and I would like to ask what is the most efficient way to conduct the discussion? Should we talk about this he",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3459:9001,error,error,9001,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459,1,['error'],['error']
Availability,", Δt=25, stop_time=1e4,). using Statistics: std; using Printf; progress_message(sim) = @printf(""Iteration: %04d, time: %s, iteration×Δt: %s, std(pNHS) = %.2e\n"",; iteration(sim), sim.model.clock.time, iteration(sim) * sim.Δt, std(model.pressures.pNHS)); add_callback!(simulation, progress_message, IterationInterval(1)). simulation.output_writers[:snaps] = NetCDFOutputWriter(model, (; model.pressures.pNHS,),; filename = ""test_pressure.nc"",; schedule = TimeInterval(100),; overwrite_existing = true,); run!(simulation); ```. On main this produces stuff like:. ```; Iteration: 0001, time: 25.0, iteration×Δt: 25.0, std(pNHS) = 6.02e-03; Iteration: 0002, time: 50.0, iteration×Δt: 50.0, std(pNHS) = 6.02e-03; Iteration: 0003, time: 75.0, iteration×Δt: 75.0, std(pNHS) = 6.02e-03; Iteration: 0004, time: 99.99999999999999, iteration×Δt: 100.0, std(pNHS) = 6.02e-03; Iteration: 0005, time: 100.0, iteration×Δt: 125.0, std(pNHS) = 2.72e+10; ```. The last two lines are of note where we went from `time: 99.99999999999999` to `time: 100.0`, implying a very tiny time-step, which results in a weird pressure field, as quantified by the last output of the last line: `std(pNHS) = 2.72e+10`. Note that because of this, `time` and `iteration×Δt` don't match up anymore in the last line. Namely `time: 100.0, iteration×Δt: 125.0`. This ""misstep"" happens many times throughout the run on `main`. On this branch this doesn't happen anymore, and even after many time-steps things remain aligned (albeit with a very small round-off error):. ```; Iteration: 0396, time: 9900.0, iteration×Δt: 9900.0, std(pNHS) = 5.99e-03; Iteration: 0397, time: 9925.000000000002, iteration×Δt: 9925.0, std(pNHS) = 5.99e-03; Iteration: 0398, time: 9950.000000000004, iteration×Δt: 9950.0, std(pNHS) = 5.99e-03; Iteration: 0399, time: 9975.000000000005, iteration×Δt: 9975.0, std(pNHS) = 5.99e-03; ```. Ideally the way to really fix this would be to figure out a way to avoid round-off errors, but I haven't been able to do that yet.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606:2302,error,error,2302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606,2,['error'],"['error', 'errors']"
Availability,",; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which gives an error output of. ```julia; ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base .\tuple.jl:31; [2] fractional_z_index; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:110 [inlined]; [3] fractional_indices; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:133 [inlined]; [4] advect_particle; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:75 [inlined]; [5] macro expansion; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:145 [inlined]; [6] cpu__advect_particles!; @ C:\Users\xinle\.julia\packages\KernelAbstractions\WoCk1\src\macros.jl:276 [inlined]; [7] cpu__advect_particles!(__ctx__::KernelAbstractions.CompilerMetadata{…}, particles::StructVector{…}, restitution::Float64, grid::RectilinearGrid{…}, Δt::Float64, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3632:1686,ERROR,ERROR,1686,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632,1,['ERROR'],['ERROR']
Availability,",Int64,Periodic,Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},Oceananigans.Solvers.Backward,GPU,VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},Int64,Bounded,Int64,NamedTuple{(:forward, :backward),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}},Tuple{Int64,Int64,Int64}}}}}},Tuple{Nothing,Nothing},NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},Int64,Array{Any,1},Int64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}) at /home/guptam/.julia/packages/Oceananigans/wJDxT/src/Simulations/run.jl:127; [8] top-level scope at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:80; [9] include(::Function, ::Module, ::String) at ./Base.jl:380; [10] include(::Module, ::String) at ./Base.jl:368; [11] exec_options(::Base.JLOptions) at ./client.jl:296; [12] _start() at ./client.jl:506; in expression starting at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:76; ```. I believe this is caused by the `AnisotropicBiharmonicDiffusivity` component of the turbulence closure, since using a simple `AnisotropicDiffusivity` works fine. Also note that the above setup works on a `RegularRectilinearGrid`. Any ideas? . I am working on the `ali/unclog-docs` branch to avoid the error reported here #1571, using Julia v1.5.4 and Oceananigans v0.54.0 + GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574:93778,error,error,93778,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574,1,['error'],['error']
Availability,"-2b89c7a130ca]; ERROR: LoadError: UndefVarError: `IntervalBox` not defined; Stacktrace:; [1] top-level scope; @ ~/.julia/packages/TaylorSeries/2qRvJ/ext/TaylorSeriesIAExt.jl:182; [2] include; @ ./Base.jl:495 [inlined]; [3] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2222; [4] top-level scope; @ stdin:3; in expression starting at /Users/navid/.julia/packages/TaylorSeries/2qRvJ/ext/TaylorSeriesIAExt.jl:1; in expression starting at stdin:3; ┌ Error: Error during loading of extension TaylorSeriesIAExt of TaylorSeries, use `Base.retry_load_extensions()` to retry.; │ exception =; │ 1-element ExceptionStack:; │ Failed to precompile TaylorSeriesIAExt [ed7ef945-33a4-511e-97fe-2b89c7a130ca] to ""/Users/navid/.julia/compiled/v1.10/TaylorSeriesIAExt/jl_TNauRw"".; │ Stacktrace:; │ [1] error(s::String); │ @ Base ./error.jl:35; │ [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); │ @ Base ./loading.jl:2468; │ [3] compilecache; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::Str",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:1148,error,error,1148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['error'],['error']
Availability,". But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with the pressure correction. But as noted in this PR, this is not enough to fix issues with the immersed boundary MWE... but whether or not that is because of problems with the setup itself, I'm not sure... - All of that said, taking @tomchor suggestion to be more careful in updating the clock for RK3 actually does solve the MWE here. Obviously, this is again addressing the (in principle not entirely solvable) issue of error accumulation in `clock.time`, rather than addressing the other issue with very small time-steps producing an ill-posed pressure correction. I think we should fix RK3 separately, basically because we cannot completely avoid accumulating error in `clock.time`, every little thing we do to make it more accurate is a good idea.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136:1894,reliab,reliably,1894,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136,6,"['error', 'reliab']","['error', 'reliably']"
Availability,". In order to organize the community's work (and also to support some work at Clima on biogeochemistry in Oceananigans), I propose that we create a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I thi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512:1248,down,down,1248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512,1,['down'],['down']
Availability,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly appreciated. Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:5764,ERROR,ERROR,5764,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,".DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.On",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:2727,error,error,2727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['error'],['error']
Availability,".Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, a::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Float64, typeof(Oceananigans.Grids.zspacing), Tuple{Center, Center, Center}}; condition::Nothing, mask::Float64, kwargs::Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:init,), Tuple{Bool}}}); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Fields/field.jl:619; [24] minimum(f::Function, c::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Float64, typeof(Oceananigans.Grids.zspacing), Tuple{Center, Center, Center}}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Field",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457:10421,mask,mask,10421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457,1,['mask'],['mask']
Availability,".Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64...; ```. I'm not really sure what to make of this error. Because the simulation I need to run is necessarily complex, it's been hard to get rid of this error in my main simulation. Any ideas?. PS.: I ran this MWE in particular on an NVIDIA Quadro GP100 GPU, but I have gotten the same error (albeit with a longer MWE) on Tesla V100s. ```julia; julia> versioninfo(); Julia Version 1.8.3; Commit 0434deb161e (2022-11-14 20:14 UTC); Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 72 × Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-13.0.1 (ORCJIT, skylake-avx512); Threads: 1 on 72 virtual cores; Environment:; JULIA_DEPOT_PATH = /glade/work/tomasc/.julia; LD_LIBRARY_PATH = /glade/u/apps/dav/opt/cuda/11.4.0/extras/CUPTI/lib64:/glade/u/apps/dav/opt/cuda/11.4.0/lib64:/glade/u/apps/dav/opt/julia/1.8.3/lib:/glade/u/apps/dav/opt/julia/1.8.3/lib/julia:/glade/u/apps/dav/opt/openmpi/4.1.1/gnu/10.1.0/lib:/glade/u/apps/dav/opt/ucx/1.11.0/lib:/glade/u/apps/dav/opt/gnu/10.1.0/lib64:/glade/u/ap",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869:23025,error,error,23025,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869,1,['error'],['error']
Availability,".ScaledPlan{ComplexF64, FFTW.cFFTWPlan{ComplexF64, 1, true, 3, Vector{Int64}}, Float64}, Oceananigans.Solvers.Backward, CPU, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}}}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, String})(file::JLD2.JLDFile{JLD2.MmapIO}); @ Oceananigans.OutputWriters /glade/work/tomasc/.julia_bkp/packages/Oceananigans/52CTk/src/OutputWriters/checkpointer.jl:197; [3] jldopen(::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:14880,checkpoint,checkpointer,14880,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['checkpoint'],['checkpointer']
Availability,".jl/pull/632?src=pr&el=h1) Report; > Merging [#632](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/632?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/2ae1cbb86f484420dd2233745a5928a00bf6f77d&el=desc) will **increase** coverage by `0.12%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/632/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/632?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #632 +/- ##; ==========================================; + Coverage 78.03% 78.16% +0.12% ; ==========================================; Files 118 118 ; Lines 2363 2395 +32 ; ==========================================; + Hits 1844 1872 +28 ; - Misses 519 523 +4 ; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/632?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Simulations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/632/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zLmps) | `93.10% <0.00%> (-2.73%)` | :arrow_down: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/632/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `92.00% <0.00%> (+0.33%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/632?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/632?src=pr&el=footer). Last update [2ae1cbb...396d43d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/632?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/632#issuecomment-592961053:1265,checkpoint,checkpointer,1265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/632#issuecomment-592961053,1,['checkpoint'],['checkpointer']
Availability,".jl:211; [5] view(f::Field{…}, i::CartesianIndices{…}, j::Function, k::Function); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Fields/field.jl:308; [6] view(f::Field{…}, i::CartesianIndices{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Fields/field.jl:339; [7] _reverse!(A::Field{…}, dims::Tuple{…}); @ Base ./arraymath.jl:95; [8] _reverse!; @ ./arraymath.jl:71 [inlined]; [9] #reverse!#274; @ ./arraymath.jl:70 [inlined]; [10] _reverse(A::Field{…}, dims::Function); @ Base ./arraymath.jl:60; [11] reverse(A::Field{Face, Center, Center, Nothing, ZRegOrthogonalSphericalShellGrid{…}, Tuple{…}, OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}); @ Base ./arraymath.jl:59; [12] top-level scope; @ REPL[199]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; If the vector is formed by extracting multiple elements from the first dimension of the field on the RHS (as opposed to the second dimension as above), e.g.,; ```julia; julia> u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; no error message pops up but `u[region][Nc+1, 1-Hc:0, k]` is filled with junk values as shown below:; ```julia; 1×4×1 Field{Face, Center, Center} on OrthogonalSphericalShellGrid on CPU; ├── grid: 4×4×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 4×4×1 halo and with precomputed metrics; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (5:5, -3:0, 1:1); └── data: 1×4×1 OffsetArray(view(::Array{Float64, 3}, 9:9, 1:4, 2:2), 5:5, -3:0, 1:1) with eltype Float64 with indices 5:5×-3:0×1:1; └── max=2.1234e-314, min=5.0e-324, mean=5.30853e-315; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721:3207,error,error,3207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2030829721,1,['error'],['error']
Availability,".jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:5216,ERROR,ERROR,5216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['ERROR'],['ERROR']
Availability,".u; > interpolate!(u_subsampled, u); > return u_subsampled; > end; > ; > outputs = (; u=subsample_u); > ```. I tried. ```julia; subset_grid = RectilinearGrid(arch,; size = (grid.Nx, grid.Ny, div(grid.Nz, 20)),; extent = (grid.Lx, grid.Ly, grid.Lz); ). u_subsampled = XFaceField(subset_grid); v_subsampled = YFaceField(subset_grid); w_subsampled = ZFaceField(subset_grid). function subsample_u(model); u = model.velocities.u; interpolate!(u_subsampled, u); return u_subsampled; end. function subsample_v(model); v = model.velocities.v; interpolate!(v_subsampled, v); return v_subsampled; end. function subsample_w(model); w = model.velocities.w; interpolate!(w_subsampled, w); return w_subsampled; end. subset_outputs = (; u = subsample_u, v = subsample_v, w = subsample_w); ```. and. ```julia; simulation.output_writers[:xyz] = NetCDFOutputWriter(model, subset_outputs,; schedule = TimeInterval(300),; filename = ""test.nc"",; with_halos = false,; array_type = Array{Float32},; ); ```. is returning the following error. ```julia; Custom output v needs dimensions!. Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] define_output_variable!(dataset::NCDatasets.NCDataset{Nothing}, output::Function, name::String, array_type::Type, deflatelevel::Int64, output_attributes::Dict{String, String}, dimensions::Dict{Any, Any}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/3LHMs/src/OutputWriters/netcdf_output_writer.jl:448; [3] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594:1190,error,error,1190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594,1,['error'],['error']
Availability,"/3VnCC/src/device/intrinsics.jl:22; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [9] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:46; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:1797,ERROR,ERROR,1797,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['ERROR'],['ERROR']
Availability,"/4352 matching grid points);   | [2023/05/22 15:07:12.176] INFO ΔT: min=-1.303846e-12, max=+1.495692e-12, mean=-4.293441e-17, absmean=+1.875657e-13, std=+2.728047e-13 (4096/4096 matching grid points);   | [2023/05/22 15:07:12.177] INFO ΔS: min=-4.632739e-12, max=+5.300649e-12, mean=-1.405126e-16, absmean=+6.662951e-13, std=+9.690186e-13 (4096/4096 matching grid points);   | Thermal bubble [CPU, vertically_unstretched grid]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:76;   | Expression: all(test_fields.u .≈ correct_fields.u);   | Stacktrace:;   | [1] macro expansion;   | @ /storage5/buildkite-agent/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_thermal_bubble_regression_test(arch::CPU, grid_type::Symbol);   | @ Main ~/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:76;   | Thermal bubble [CPU, vertically_unstretched grid]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:77;   | Expression: all(test_fields.v .≈ correct_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /storage5/buildkite-agent/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_thermal_bubble_regression_test(arch::CPU, grid_type::Symbol);   | @ Main ~/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:77;   | Thermal bubble [CPU, vertically_unstretched grid]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:78;   | Expression: all(test_fields.w .≈ correct_fields.w); ```. You can see that u, v, and w fail, but the errors are really small and most points are a match. As far as I can tell, for other regression simulations only `w` fails and the results seem to be the same both on the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1559671586:2676,error,errors,2676,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1559671586,1,['error'],['errors']
Availability,"/4814f95eb9d7b57f1db8dc6e793bf1c2c5e80a5a/src/Models/ShallowWaterModels/shallow_water_model.jl#L38-L54. The constructor below assumes that clock's parameter is Number. But if we use a clock with `DateTime` then the shallow water model cannot be constructed. ```Julia; julia> using Oceananigans; [ Info: Oceananigans will use 6 threads. julia> grid = RectilinearGrid(size=(4, 8), extent=(1000, 1000), topology=(Periodic, Periodic, Flat));. julia> gravitational_acceleration = 9.81;. julia> ShallowWaterModel(; grid, gravitational_acceleration); ShallowWaterModel{typename(CPU), Float64}(time = 0 seconds, iteration = 0); ├── grid: 4×8×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── tracers: (); └── coriolis: Nothing. julia> using Dates. julia> clock = Clock(time=DateTime(2021, 1, 1)); Clock{DateTime}: time = 2021-01-01T00:00:00, iteration = 0, stage = 1. julia> ShallowWaterModel(; grid, gravitational_acceleration, clock); ERROR: MethodError: no method matching ShallowWaterModel(::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, ::CPU, ::Clock{DateTime}, ::Float64, ::NamedTuple{(:momentum, :mass), Tuple{UpwindBiased{3, Float64, Nothing, Nothing, Nothing, UpwindBiased{2, Float64, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, WENO{3, Float64, Nothing, Nothing, Nothing, true, Nothing, WENO{2, Float64, Nothing, Not",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2954#issuecomment-1452778143:1038,ERROR,ERROR,1038,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2954#issuecomment-1452778143,1,['ERROR'],['ERROR']
Availability,"/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:6342,ERROR,ERROR,6342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,5,"['ERROR', 'Error']","['ERROR', 'Error']"
Availability,"/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, CenteredSecondOrder, Nothing, Nothing, VerstappenAnisotropicMinimumDissipation{Float64,NamedTuple{(:T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1059:1087,Error,Error,1087,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059,1,['Error'],['Error']
Availability,"/src/REPL.jl:229; [15] (::REPL.var""#do_respond#61""{Bool, Bool, REPL.var""#72#82""{REPL.LineEditREPL, REPL.REPLHistoryProvider}, REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:798; [16] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [17] invokelatest; @ ./essentials.jl:706 [inlined]; [18] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441; [19] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126; [20] (::REPL.var""#44#49""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:411; ```. But the object seem to have been created. Weirdly enough I also get errors using the object, even though it exists:. ```julia; julia> ε = ComputedField(ε_operation); Error showing value of type ComputedField{Center, Center, Center, Oceananigans.Fields.FieldStatus{Float64}, KernelFunctionOperation{Center, Center, Center, Nothing, CPU, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, typeof(isotropic_viscous_dissipation_rate_ccc), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundary",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1758#issuecomment-866917397:20617,error,errors,20617,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1758#issuecomment-866917397,1,['error'],['errors']
Availability,"/tartarus-3/clima/oceananigans/src/Architectures.jl:60; ...; Stacktrace:; [1] condition_operand; @ ~/builds/tartarus-3/clima/oceananigans/src/ImmersedBoundaries/immersed_reductions.jl:26 [inlined]; [2] sum(f::Function, c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Vᶜᶜᶜ)}; condition::BitArray{3}, mask::Int64, dims::Tuple{Int64, Int64, Int64}); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3440#issuecomment-1915984001:2596,mask,mask,2596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3440#issuecomment-1915984001,1,['mask'],['mask']
Availability,"0/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `27.02% <ø> (ø)` | |; | [src/Diagnostics/Diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/980/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL0RpYWdub3N0aWNzLmps) | `100.00% <ø> (ø)` | |; | [src/Diagnostics/nan\_checker.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/980/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL25hbl9jaGVja2VyLmps) | `33.33% <ø> (ø)` | |; | [src/Diagnostics/time\_series.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/980/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL3RpbWVfc2VyaWVzLmps) | `78.26% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/980/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/980/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <ø> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/980/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `88.88% <ø> (ø)` | |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/980/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `93.87% <ø> (ø)` | |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/980/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `77.63% <ø> (ø)` | |; | ... and [8 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/980/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/980?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Cod",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/980#issuecomment-699496171:2326,checkpoint,checkpointer,2326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/980#issuecomment-699496171,1,['checkpoint'],['checkpointer']
Availability,"01 # timestep; T1 = 6Δt # first simulation stop time; T2 = 2T1 # second simulation stop time; window_nΔt = 2 # window interval: 2Δt; interval_nΔt = 2 # time average saving interval: 2Δt; stride = 1; ```; The averaged values are clearly off after the checkpoint (t>6Δt):; <img width=""587"" alt=""image"" src=""https://github.com/user-attachments/assets/24c0238d-3723-435d-bca2-4b4a2be83e71"">. This issue does not only occur in the existing MWE (decaying function); it also occurs in our [MWE](https://github.com/liuchihl/Oceananigans.jl/pull/1#issuecomment-2295343588) using the exact same parameters mentioned above. The dashed curve and steps indicate `TimeInterval` and `AveragedTimeInterval` outputs, respectively, shown in the figure below. It is unclear to me as to why spurious zero appears in this case.; <img width=""892"" alt=""image"" src=""https://github.com/user-attachments/assets/5e78add8-7b29-45f3-8123-156cf6ae38d3"">. The point of these tests is to show that even when the checkpoint interval is an integer multiple of the `AveragedTimeInterval`, issues can still arise. . Here is the MWE with the decaying function for reference: ; ```julia; using Oceananigans; using Plots; using NCDatasets; using Test; if isfile(""single_decay_windowed_time_average_test.nc""); rm(""single_decay_windowed_time_average_test.nc""); end; run(`sh -c ""rm test_iteration*.jld2""`). function test_simulation(stop_time, Δt, window_nΔt, interval_nΔt, stride, overwrite). arch = CPU(); topo = (Periodic, Periodic, Periodic); domain = (x=(0, 1), y=(0, 1), z=(0, 1)); grid = RectilinearGrid(arch, topology=topo, size=(4, 4, 4); domain...). λ1(x, y, z) = x + (1 - y)^2 + tanh(z); λ2(x, y, z) = x + (1 - y)^2 + tanh(4z). Fc1(x, y, z, t, c1) = - λ1(x, y, z) * c1; Fc2(x, y, z, t, c2) = - λ2(x, y, z) * c2; ; c1_forcing = Forcing(Fc1, field_dependencies=:c1); c2_forcing = Forcing(Fc2, field_dependencies=:c2). model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; tracers = (:c1, :c2),; forcing = (c1=c1_forcing, c2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629:1363,checkpoint,checkpoint,1363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629,2,['checkpoint'],['checkpoint']
Availability,"09""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; [14] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; [15] _require(::Base.PkgId) at ./loading.jl:1007; [16] require(::Base.PkgId) at ./loading.jl:928; [17] require(::Module, ::Symbol) at ./loading.jl:923; during initialization of module Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:4364,error,error,4364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['error'],['error']
Availability,"0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, -2, :]; 6×8 OffsetArray(::Matrix{Float64}, -1:4, -1:6) with eltype Float64 with indices -1:4×-1:6:; 4.06893e233 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 7.49511e247 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 3.83945e151 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 5.33788e223 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, :, -2]; 6×7 OffsetArray(::Matrix{Float64}, -1:4, -1:5) with eltype Float64 with indices -1:4×-1:5:; 0.0 NaN 0.0 2.42941e-314 5.13924e151 3.5e-323 4.06893e233; 0.0 0.0 0.0 2.66157e-314 5.6593e-314 4.0e-323 7.49511e247; NaN 0.0 NaN 1.4545e-320 2.98408e-314 6.09933e6 2.09002e-95; 0.0 0.0 0.0 8.46763e165 1.66e-321 4.06893e233 3.83945e151; 0.0 NaN 0.0 6.09933e6 2.75228e-318 7.49089e247 5.33788e223; 0.0 0.0 0.0 9.85509e165 3.0e-323 6.09933e6 2.09002e-95; ```. Even by accessing array elements indices outside the interior and halo ranges, we don’t get out-of-bounds errors. Instead, we obtain junk values for these indices. This behavior applies to windowed fields as well. But why is that the case? What is the reasoning behind this design choice, since I am assuming it’s on purpose?. Secondly, when accessing the interior elements of a windowed field, the indices in the windowed dimension must start from 1 instead of their actual values, which also results in junk values for these elements. Is this also intentional, or should I create a pull request to address it?. ```julia; julia> my_windowed_field = CenterField(grid, indices=(:, :, 5:6)); 2×3×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, :, 5:6); └── data: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615:2008,error,errors,2008,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615,1,['error'],['errors']
Availability,"0_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_E5FieldIvvS14_vvvS22_IS7_Li3ES9_IS7_Li3ELi1EEES7_vvvES31_S32_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_ES_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvE11NotImmersedI8truefuncES4_S7_E' uses too much parameter space (0x11f0 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:125; [7] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140:4459,error,error,4459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140,1,['error'],['error']
Availability,"1 2.5e-11 2.5e-11 … 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11. ... [:, :, 15] =; 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 … 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11. [:, :, 16] =; 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 … 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11 2.5e-11. [:, :, 17] =; -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 … -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10 -2.875e-10. julia> interior(PV_kern_notint); 1×64×17 view(OffsetArray(::Array{Float64,3}, 0:2, 0:65, 0:18), 1:1, 1:64, 1:17) with eltype Float64:; [:, :, 1] =; 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 … 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10. [:, :, 2] =; 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 … 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10. [:, :, 3] =; 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 … 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10. ... [:, :, 15] =; 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 … 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10. [:, :, 16] =; 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 … 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10 6.5e-10. [:, :, 17] =; -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 … -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10 -6.0e-10. julia> PV_true; 6.500000000000004e-10; ```. So as you can see this doesn't look like a numerical error. I feel like I'm missing something kinda obvious here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1324#issuecomment-769920640:2692,error,error,2692,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1324#issuecomment-769920640,1,['error'],['error']
Availability,"1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> u, v, w = model.velocities; NamedTuple with 3 Fields on 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo:; ├── u: 16×16×16 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── v: 16×16×16 Field{Center, Face, Center} on RectilinearGrid on GPU; └── w: 16×16×17 Field{Center, Center, Face} on RectilinearGrid on GPU. julia> maximum(u); 0.0. julia> maximum(w); 0.0. julia> maximum(v); 0.0. julia> maximum(abs, u); 0.0. julia> maximum(abs, w); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/nbRJk/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#867#868""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#867#868""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:2244,ERROR,ERROR,2244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"1.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:1284,error,error,1284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,1,['error'],['error']
Availability,10-100x slowdown on CPU after upgrade to KernelAbstractions 0.8 (due to type inference failure?),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996:87,failure,failure,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996,1,['failure'],['failure']
Availability,"19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _Li3ES5_IS4_Li3ELi1EEEEE12_DOM_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:16985,error,error,16985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['error'],['error']
Availability,"19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _w_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEES18_I57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEEvS18_I69__u___v___w___b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_I12_zeroforcingS26_S26_S26_17ContinuousForcingI6CenterS28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:9792,error,error,9792,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['error'],['error']
Availability,"1bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl) you pointed out the tracer-`CenterField` had its values filled via `set!` with an anonymous function:. https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L152. The above does not fill any values in the halo regions! On the other hand, you were filling values for the `XFaceField` using a `for`-loop that was looping in the halo regions as well... https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L193-L198. So this might be one reason for why the plots look different? I am not quite sure because the plots also don't include color bars so I'm not sure if the disagreement is a plotting issue or a combination of plotting + a bug. But let's strip down the script to the bare minimum showcasing the problem -- at the moment the script has a lot of if statements and seems to be used for many things, not just to showcase the issue discussed here. For example, running this ; ```julia; using Oceananigans; using Oceananigans.MultiRegion: getregion. grid = ConformalCubedSphereGrid(panel_size=(4 ,4, 1), z=(-1, 0), radius=1). u = XFaceField(grid); v = YFaceField(grid); c = CenterField(grid). set!(c, (λ, φ, z) -> φ); set!(u, (λ, φ, z) -> φ); set!(v, (λ, φ, z) -> φ). @info ""u values""; display(rotl90(view(getregion(u, 1).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, 1).data, :, :, 1))). @info ""c values""; display(rotl90(view(getregion(c, 1).data, :, :, 1))); ```. gives. ```Julia; [ Info: u values; 6×6 OffsetArray(::Matrix{Float64}, 0:5, 0:5) with eltype Float64 with indices 0:5×0:5:; 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 29.5018 32.0568 34.1162 32.0568 0.0; 0.0 10.7341 11.1836 11.6116 11.1836 0.0; 0.0 -10.7341 -11.1836 -11.6116 -11.1836 0.0; 0.0 -29.5018 -32.0568 -34.1162 -32.0568 0.0; 0.0 0.0 0.0 0.0 0.0 0.0; [ Info:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856:1168,down,down,1168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856,1,['down'],['down']
Availability,"2 to remove filling halo regions and buffering between ranks.; This gave perfect efficiency up to 3 ranks. This was mainly done to locate where possible bottlenecks are and not a legitimate change to the code. It was expected that buffering is what's causing efficiency decreases, and this confirms that there are no other additional undetected causes for efficiency drops.; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 0.988079 | 1.01206 | 1.06328 | 1.0406; (4096, 768) | (1, 3) | 0.992832 | 1.00722 | 1.06328 | 1.0406. <!--EndFragment-->; </body>; </html>. system environment and CUDA.versioninfo():; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/.julia; GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0; Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing; Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75; Environment:; - JULIA_CUDA_USE_BINARYBUILDER: false; 3 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 2: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846:2032,avail,available,2032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846,3,['avail'],['available']
Availability,"2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; coarse_u,), coarse_grid;; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. Throws the following error:. ```; ERROR: LoadError: DimensionMismatch: new dimensions (1, 1, 8, 1) must be consistent with array size 4; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing, Missing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] save_output!(ds::NCDatasets.NCDataset{…}, output::Field{…}, model::NonhydrostaticModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters ~/repos/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:1196,error,error,1196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['error'],['error']
Availability,"2.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:1798,ERROR,ERROR,1798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,2,['ERROR'],['ERROR']
Availability,23.2.1/compiler/2023.2.1/linux/compiler/lib/intel64_lin:1;/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib:1; __LMOD_REF_COUNT_PKG_CONFIG_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig/lib/pkgconfig:2;/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib/pkgconfig:2;/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib/pkgconfig:2;/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/lib/pkgconfig:2;/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:1;/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:1;/glade/u/apps/casper/23.10/opt/view/lib/pkgconfig:1; __LMOD_REF_COUNT_DIAGUTIL_PATH = /glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/sys_check/sys_check.sh:1; NCAR_DEFAULT_MANPATH = /usr/local/share/man:/usr/share/man; __LMOD_REF_COUNT_MODULEPATH = /glade/u/apps/casper/modules/environment:1;/glade/work/knudsenl/spack-downstreams/casper/modules/23.10/Core:1;/glade/u/apps/casper/modules/23.10/Core:1;/glade/work/knudsenl/spack-downstreams/casper/modules/23.10/oneapi/2023.2.1:1;/glade/u/apps/casper/modules/23.10/oneapi/2023.2.1:1;/glade/work/knudsenl/spack-downstreams/casper/modules/23.10/openmpi/4.1.6/oneapi/2023.2.1:1;/glade/u/apps/casper/modules/23.10/openmpi/4.1.6/oneapi/2023.2.1:1; __LMOD_REF_COUNT_NCAR_LDFLAGS_INTEL_ONEAPI_COMPILERS = /glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/lib:1; HOME = /glade/u/home/knudsenl; CMAKE_PREFIX_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea:/glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig:/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2:/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv:/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h:/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:6644,down,downstreams,6644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['down'],['downstreams']
Availability,"341a] Lz4_jll v1.9.4+0; [856f044c] MKL_jll v2024.2.0+0; [7cb0a576] MPICH_jll v4.2.1+1; [f1f71cc9] MPItrampoline_jll v5.4.0+0; [9237b28f] MicrosoftMPI_jll v10.1.4+2; [e98f9f5b] NVTX_jll v3.1.0+2; ⌃ [7243133f] NetCDF_jll v400.902.209+0; ⌅ [4c82536e] Nettle_jll v3.7.2+0; [fe0851c0] OpenMPI_jll v5.0.3+0; [458c3c95] OpenSSL_jll v3.0.14+0; [efe28fd5] OpenSpecFun_jll v0.5.5+0; [c2071276] P11Kit_jll v0.24.1+0; [02c8fc9c] XML2_jll v2.13.1+0; [ffd25f8a] XZ_jll v5.4.6+0; [3161d3a3] Zstd_jll v1.5.6+0; [477f73a3] libaec_jll v1.1.2+0; [337d8026] libzip_jll v1.10.1+0; [1317d2d5] oneTBB_jll v2021.12.0+0; [0dad84c5] ArgTools v1.1.1; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8ba89e20] Distributed; [f43a241f] Downloads v1.6.0; [7b1f6079] FileWatching; [9fa8497b] Future; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL v0.6.3; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions v1.2.0; [44cfe95a] Pkg v1.9.2; [de0858da] Printf; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays; [10745b16] Statistics v1.9.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.0.5+0; [781609d7] GMP_jll v6.2.1+2; [deac9b47] LibCURL_jll v7.84.0+0; [29816b5a] LibSSH2_jll v1.10.2+0; [c8ffd9c3] MbedTLS_jll v2.28.2+0; [14a3606d] MozillaCACerts_jll v2022.10.11; [4536629a] OpenBLAS_jll v0.3.21+4; [05823500] OpenLibm_jll v0.8.1+0; [bea87d4a] SuiteSparse_jll v5.10.1+6; [83775a58] Zlib_jll v1.2.13+0; [8e850b90] libblastrampoline_jll v5.8.0+0; [8e850ede] nghttp2_jll v1.48.0+0; [3f19e933] p7zip_jll v17.4.0+0; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated -m`; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:21641,avail,available,21641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['avail'],['available']
Availability,3bb67fe8] + TranscodingStreams v0.9.13; [9d95972d] + TupleTools v1.3.0; [013be700] + UnsafeAtomics v0.2.1; [d80eeb9a] + UnsafeAtomicsLLVM v0.1.3; [81def892] + VersionParsing v1.3.0; [6e34b625] + Bzip2_jll v1.0.8+0; [4ee394cb] + CUDA_Driver_jll v0.5.0+1; [76a88914] + CUDA_Runtime_jll v0.6.0+0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.14.0+0; [1d5cc7b8] + IntelOpenMP_jll v2023.1.0+0; [dad2f222] + LLVMExtra_jll v0.0.23+0; [1d63c593] + LLVMOpenMP_jll v15.0.4+0; [94ce4f54] + Libiconv_jll v1.16.1+2; [856f044c] + MKL_jll v2023.1.0+0; [7cb0a576] + MPICH_jll v4.1.2+0; [f1f71cc9] + MPItrampoline_jll v5.3.1+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+4; [7243133f] + NetCDF_jll v400.902.208+0; [fe0851c0] + OpenMPI_jll v4.1.5+0; [458c3c95] + OpenSSL_jll v3.0.9+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [02c8fc9c] + XML2_jll v2.10.3+0; [3161d3a3] + Zstd_jll v1.5.5+0; [477f73a3] + libaec_jll v1.0.6+1; [0dad84c5] + ArgTools v1.1.1; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8ba89e20] + Distributed; [f43a241f] + Downloads v1.6.0; [7b1f6079] + FileWatching; [b77e0a4c] + InteractiveUtils; [4af54fe1] + LazyArtifacts; [b27032c2] + LibCURL v0.6.3; [76f85450] + LibGit2; [8f399da3] + Libdl; [37e2e46d] + LinearAlgebra; [56ddb016] + Logging; [d6f4376e] + Markdown; [a63ad114] + Mmap; [ca575930] + NetworkOptions v1.2.0; [44cfe95a] + Pkg v1.8.0; [de0858da] + Printf; [3fa0cd96] + REPL; [9a3f8284] + Random; [ea8e919c] + SHA v0.7.0; [9e88b42a] + Serialization; [6462fe0b] + Sockets; [2f01184e] + SparseArrays; [10745b16] + Statistics; [4607b0f0] + SuiteSparse; [fa267f1f] + TOML v1.0.0; [a4e569a6] + Tar v1.10.1; [8dfed614] + Test; [cf7118a7] + UUIDs; [4ec0a83e] + Unicode; [e66e0078] + CompilerSupportLibraries_jll v1.0.1+0; [deac9b47] + LibCURL_jll v7.84.0+0; [29816b5a] + LibSSH2_jll v1.10.2+0; [c8ffd9c3] + MbedTLS_jll v2.28.0+0; [14a3606d] + MozillaCACerts_jll v2022.2.1; [4536629a] + OpenBLAS_jll v0.3.20+0; [05823500] + OpenLibm_jll v0.8.1+0; [83775a58] + Zlib_jll ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:4610,Down,Downloads,4610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['Down'],['Downloads']
Availability,"4, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:1484,ERROR,ERROR,1484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['ERROR'],['ERROR']
Availability,"40 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:1028,Checkpoint,Checkpointing,1028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,2,"['Checkpoint', 'Error']","['Checkpointing', 'Error']"
Availability,"4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA. ```. (Apologies this error message is a bit mangled because I use `InteractiveErrors`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:19182,error,errors,19182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,4,['error'],"['error', 'errors']"
Availability,"4x 64x 64 static ocean (CPU, Float64) 10 635ms 0.19% 63.5ms 13.5KiB 0.49% 1.35KiB; 128x128x128 static ocean (GPU, Float64) 10 80.2ms 0.02% 8.02ms 332KiB 12.0% 33.2KiB; 128x128x128 static ocean (GPU, Float32) 10 77.0ms 0.02% 7.70ms 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (CPU, Float32) 10 72.3ms 0.02% 7.23ms 13.1KiB 0.47% 1.31KiB; 32x 32x 32 static ocean (CPU, Float64) 10 45.1ms 0.01% 4.51ms 13.5KiB 0.49% 1.35KiB; 64x 64x 64 static ocean (GPU, Float64) 10 8.30ms 0.00% 830μs 332KiB 12.0% 33.2KiB; 64x 64x 64 static ocean (GPU, Float32) 10 8.05ms 0.00% 805μs 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (GPU, Float64) 10 3.63ms 0.00% 363μs 332KiB 12.0% 33.2KiB; 32x 32x 32 static ocean (GPU, Float32) 10 3.45ms 0.00% 345μs 329KiB 11.9% 32.9KiB; ──────────────────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 0.623; 64x 64x 64 static ocean: 0.614; 128x128x128 static ocean: 0.723; 256x256x256 static ocean: 0.841. GPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 1.052; 64x 64x 64 static ocean: 1.031; 128x128x128 static ocean: 1.042; 256x256x256 static ocean: 1.038. CPU -> GPU speedsup:; 32x 32x 32 static ocean (Float32): 20.923; 32x 32x 32 static ocean (Float64): 12.402; 64x 64x 64 static ocean (Float32): 128.536; 64x 64x 64 static ocean (Float64): 76.582; 128x128x128 static ocean (Float32): 161.689; 128x128x128 static ocean (Float64): 112.144; 256x256x256 static ocean (Float32): 195.877; 256x256x256 static ocean (Float64): 158.772; ```. Some comments:; * Switching to `Float32` actually slowed things down on my CPU (and on the cluster).; * No surprise: GPU does better with bigger problems. Running another benchmark with 512x512x512 to see if we can break 200x!; * When I did this kind of timing a couple of weeks ago I only saw CPU->GPU speedups of ~90x but now we're getting ~195x for the largest model with `Float32`. We've improved performance without even knowing it!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:3636,down,down,3636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,1,['down'],['down']
Availability,"517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able to create a MWE this time:. ```julia; using Printf; using Oceananigans; using Oceananigans: Utils, Units; using Oceananigans.OutputWriters; using Oceanostics: SingleLineProgressMessenger. grid = RegularRectilinearGrid(size=(4, 4, 4), extent=(1,1,1)); model = IncompressibleModel(architecture = CPU(), grid = grid). start_time = 1e-9*time_ns(); simulation = Simulation(model, Δt=1, stop_time=50, iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; ); println(""\n"", simulation,""\n"",). @info ""Setting up chk writer""; simulation.output_writers[:chk_writer] = Checkpointer(model; dir=""."",; prefix = ""chk.test"",; schedule = TimeInterval(5),; force = true, cleanup = true,; ); ; println(""\n"", simulation,""\n"",) . @printf(""---> Starting run!\n""); run!(simulation, pickup=true); ```. This results in the following output:. ```julia. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. [ Info: Setting up chk writer. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Ne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:2614,Checkpoint,Checkpointer,2614,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260,1,['Checkpoint'],['Checkpointer']
Availability,"5; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x00000",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:1381,error,error,1381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"631/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `85.71% <ø> (ø)` | |; | [src/BoundaryConditions/BoundaryConditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9Cb3VuZGFyeUNvbmRpdGlvbnMuamw=) | `100% <ø> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `100% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <100%> (ø)` | |; | [src/Fields/set!.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `67.64% <100%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `76.19% <62.5%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.52% <87.5%> (ø)` | |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `62.16% <90%> (ø)` | |; | [...rc/BoundaryConditions/field\_boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `92% <93.75%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/631?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589887431:2093,checkpoint,checkpointer,2093,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589887431,1,['checkpoint'],['checkpointer']
Availability,"64, 3}, ::BatchedTridiagonalSolver{Vector{Float64}, Vector{Float64}, Vector{Float64}, Array{Float64, 3}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Nothing, ZDirection}, ::Vector{Float64}); > @ Oceananigans.Solvers ~/repos/Oceananigans.jl3/src/Solvers/batched_tridiagonal_solver.jl:83; > [4] can_solve_single_tridiagonal_system(arch::CPU, N::Int64; tridiagonal_direction::ZDirection); > @ Main ~/repos/Oceananigans.jl3/test/test_batched_tridiagonal_solver.jl:39; > [5] macro expansion; > @ ~/bin/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; > [6] macro expansion; > @ ~/repos/Oceananigans.jl3/test/test_batched_tridiagonal_solver.jl:169 [inlined]; > [7] macro expansion; > @ ~/bin/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:1363 [inlined]; > [8] macro expansion; > @ ~/repos/Oceananigans.jl3/test/test_batched_tridiagonal_solver.jl:167 [inlined]; > [9] macro expansion; > @ ~/bin/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:1363 [inlined]; > [10] top-level scope; > @ ~/repos/Oceananigans.jl3/test/test_batched_tridiagonal_solver.jl:163; > ```; > ; > I'm not very familiar with `KernelAbsractions` so I don't really understand what's happening, but my guess is that I need to define `work_layout` for `ZDirection`. Problem is I have no idea what it should be.; > ; > Let me know if you want me to push the code I have with `ZDirection` and this error to the branch. I don't know what you did but note that for `tridiagonal_direction isa ZDirection`, then `work_layout = :xy`. We don't need to define the work layout for `ZDirection` (I don't know what that would mean either)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1564940399:4490,error,error,4490,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1564940399,1,['error'],['error']
Availability,"64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Tuple{Int64, Int64}}(Statistics.mean!, 4×4×5 Field{Face, Face, Face} on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=Nothing, top=Nothing, immersed=ZeroFlux; └── data: 6×6×7 OffsetArray(::Array{Float64, 3}, 0:5, 0:5, 0:6) with eltype Float64 with indices 0:5×0:5×0:6; └── max=0.0, min=0.0, mean=0.0, (1, 2)). julia> Average(field, dims=(1,3)); ERROR: UndefVarError: Ayᶠᶠᶠ not defined; Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:360 [inlined]; [3] eval; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/Bks9B/src/AbstractOperations/AbstractOperations.jl:1 [inlined]; [4] metric_function; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/Bks9B/src/AbstractOperations/grid_metrics.jl:139 [inlined]; [5] Oceananigans.AbstractOperations.GridMetricOperation(L::Tuple{DataType, DataType, DataType}, metric::Oceananigans.AbstractOperations.YAreaMetric, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ Oceananigans.AbstractOperations /glade/work/tomasc/.julia_bkp/packag",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2189:2426,ERROR,ERROR,2426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2189,1,['ERROR'],['ERROR']
Availability,"762989865623905; 0.006762989865623905; 2.673025080318251e-8; 2.673025080318251e-8; 0.006762989865623905; 0.006762989865623905; 2.673025080318251e-8; 2.673025080318251e-8; 0.006762989865623905; 0.006762989865623905. GPU; 10-element OffsetArray(::CuArray{Float64,1}, -2:7) with eltype Float64 with indices -2:7:; 0.006762989865623905; 0.006762989865623905; 2.673025080318251e-8; 2.673025080318251e-8; 0.006762989865623905; 0.006762989865623905; 2.673025080318251e-8; 2.673025080318251e-8; 0.006762989865623905; 0.006762989865623905; ```. However, when I use `RungeKutta3` I get that the results are different.; ```; CPU; 10-element OffsetArray(::Array{Float64,1}, -2:7) with eltype Float64 with indices -2:7:; 0.00676299502124483; 0.00676299502124483; 1.696248222222971e-8; 1.696248222222971e-8; 0.00676299502124483; 0.00676299502124483; 1.6962482222229713e-8; 1.6962482222229713e-8; 0.00676299502124483; 0.00676299502124483. GPU; 10-element OffsetArray(::CuArray{Float64,1}, -2:7) with eltype Float64 with indices -2:7:; 0.006762989865623905; 0.006762989865623905; 2.673025080318251e-8; 2.673025080318251e-8; 0.006762989865623905; 0.006762989865623905; 2.673025080318251e-8; 2.673025080318251e-8; 0.006762989865623905; 0.006762989865623905; ```; I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. I observed that QAB2 then starts to differ at the next time step. I suppose the differences in the `RK3` method appear sooner because it is a multistep method, so three steps in one?. I know that the pressure solve is what differs significantly between the `CPU` and `GPU` approaches but are these reasonable errors or do these seem too big?. I can say that the errors at the boundary happen with both time stepping methods. So I cannot run this example on a GPU because of this numerical instability that develops. I know that many other examples run successfully, but not sure what I am doing differently compared other codes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815174351:2045,error,errors,2045,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815174351,2,['error'],['errors']
Availability,"76f85450] + LibGit2; [8f399da3] + Libdl; [37e2e46d] + LinearAlgebra; [56ddb016] + Logging; [d6f4376e] + Markdown; [a63ad114] + Mmap; [ca575930] + NetworkOptions v1.2.0; [44cfe95a] + Pkg v1.8.0; [de0858da] + Printf; [3fa0cd96] + REPL; [9a3f8284] + Random; [ea8e919c] + SHA v0.7.0; [9e88b42a] + Serialization; [6462fe0b] + Sockets; [2f01184e] + SparseArrays; [10745b16] + Statistics; [4607b0f0] + SuiteSparse; [fa267f1f] + TOML v1.0.0; [a4e569a6] + Tar v1.10.1; [8dfed614] + Test; [cf7118a7] + UUIDs; [4ec0a83e] + Unicode; [e66e0078] + CompilerSupportLibraries_jll v1.0.1+0; [deac9b47] + LibCURL_jll v7.84.0+0; [29816b5a] + LibSSH2_jll v1.10.2+0; [c8ffd9c3] + MbedTLS_jll v2.28.0+0; [14a3606d] + MozillaCACerts_jll v2022.2.1; [4536629a] + OpenBLAS_jll v0.3.20+0; [05823500] + OpenLibm_jll v0.8.1+0; [83775a58] + Zlib_jll v1.2.12+3; [8e850b90] + libblastrampoline_jll v5.1.1+0; [8e850ede] + nghttp2_jll v1.48.0+0; [3f19e933] + p7zip_jll v17.4.0+0; Info Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated -m`. julia> using Oceananigans. julia> grid = RectilinearGrid(size=(5, 4, 3), extent=(1, 2, 3));. julia> model = HydrostaticFreeSurfaceModel(; grid); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 5×4×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (T, S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with ĝ = NegativeZDirection(); ├── free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²; │ └── solver: FFTImplicitFreeSurfaceSolver; └── coriolis: Nothing. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface = ImplicitFreeSurface(; solver_method=:HeptadiagonalIterativeSolver)); ERROR: MethodError: no method matching",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:5735,avail,available,5735,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['avail'],['available']
Availability,"803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:89",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5706,error,error,5706,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['error'],['error']
Availability,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:13212,ERROR,ERROR,13212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,"['ERROR', 'error']","['ERROR', 'errored']"
Availability,"8;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing);   | @ Base ./loading.jl:1554;   | [10] top-level scope;   | @ stdin:1;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:1;   | in expression starting at stdin:1;   | Stacktrace:;   | [1] pkgerror(msg::String);   | @ Pkg.Types /storage5/buildkite-agent/julia-1.8.2/share/julia/stdlib/v1.8/Pkg/src/Types.jl:67;   | [2] precompile(ctx::Pkg.Types.Context, pkgs::Vector{String}; internal_call::Bool, strict::Bool, warn_loaded::Bool, already_instantiated::Bool, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});   | @ Pkg.API /storage5/buildkite-agent/julia-1.8.2/share/julia/stdlib/v1.8/Pkg/src/API.jl:1432;   | [3] precompile;   | @ /storage5/buildkite-agent/julia-1.8.2/share/julia/stdlib/v1.8/Pkg/src/API.jl:1063 [inlined];   | [4] #precompile#225;   | @ /storage5/buildkite-agent/julia-1.8.2/share/julia/stdlib/v1.8/Pkg/src/API.jl:1062 [inlined];   | [5] precompile (repeats 2 times);   | @ /storage5/buildkite-agent/julia-1.8.2/share/julia/stdlib/v1.8/Pkg/src/API.jl:1062 [inlined];   | [6] top-level scope;   | @ none:1;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:3545,Error,Error,3545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,2,"['Error', 'error']","['Error', 'error']"
Availability,"8_S31_S8_IS9_Li3ES10_IS9_Li3ELi1EEES9_S32_S33_S11_IS9_S12_S12_S13_S9_S9_S8_IS9_Li1ES10_IS9_Li1ELi1EEES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES10_IS9_Li1ELi1EEEvES9_ES30_IS28_S28_S28_S31_S8_IS9_Li3ES10_IS9_Li3ELi1EEES9_S34_S35_S11_IS9_S12_S12_S13_S9_S9_S8_IS9_Li1ES10_IS9_Li1ELi1EEES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES10_IS9_Li1ELi1EEEvES9_EEEEES23_I46__u___v___w___b____1____2____3____4____5____6_S18_I15DiscreteForcingIS23_I13______u______S18_IS16_S16_S9_EE9_sponge_uES37_IS23_I13______u______S18_IS16_S16_S9_EE9_sponge_vES37_IS23_I13______u______S18_IS16_S16_S9_EE9_sponge_wES37_IS23_I13______u______S18_IS16_S16_S9_EE9_sponge_bE12_zeroforcingS42_S42_S42_S42_S42_EES8_IS9_Li3ES10_IS9_Li3ELi1EEES23_I27__time___iteration___stage_S18_IS9_S16_S16_EE' uses too much parameter space (0x1a10 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_XSJ4P4z47a.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:428; [3] #224; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:347 [inlined]; [4] JuliaContext(f::CUDA.var""#224#225""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Cassette.overdub), Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(8, 8, 6)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112:5057,error,errors,5057,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112,1,['error'],['errors']
Availability,"94736842105263; 0.13157894736842105; 0.18421052631578946; 0.23684210526315788; 0.2894736842105263; 0.3421052631578947. julia> collect(grid.xᶜᵃᵃ); 10-element Vector{Float64}:; -0.625; -0.375; -0.125; 0.125; 0.375; 0.625; 0.875; 1.125; 1.375; 1.625; ```. After this PR:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 6 threads. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = (0,1), y=(0,1),; z = LinRange(0,1,20), ; halo=(3,3,3),; ); ERROR: ArgumentError: `length(z)` must be equal to size passed to `size` argument.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::LinRange{Float64}, dir::Symbol, size_dir::Int64, FT::Type); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:108; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Tuple{Int64, Int64, Int64}, FT::Type, extent::Nothing, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/rectilinear_grid.jl:284; [4] RectilinearGrid(architecture::CPU, FT::Type; size::Tuple{Int64, Int64, Int64}, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}, halo::Tuple{Int64, Int64, Int64}, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/rectilinear_grid.jl:259; [5] top-level scope; @ REPL[2]:1; [6] top-level scope; @ ~/.julia/packages/CUDA/Uurn4/src/initialization.jl:52; ```. I decided to throw an error instead of a warning because I don't think we want the user be able to proceed in a situation like this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550:2606,error,error,2606,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550,1,['error'],['error']
Availability,"9_Li3ES10_IS9_Li3ELi1EEE10_identity1S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S25_S26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES27_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S29_S18_S25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S27_S29_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S28_S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S26_S27_S29_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S25_S26_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. We haven't discussed the problem with `AveragedField` on this thread. I think we need a new issue for that (can't remember if there already is one). It actually looks like some, but not all of the issue there have been solved. A minimal example is:. ```julia; julia> U = AveragedField(u, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (1, 1, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── dims: (1, 2); ├── operand: Field located at (Face, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(u - U)). julia> compute!(ComputedField((u - U)^2)). julia> V = AveragedField(v, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338:4150,error,errors,4150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338,1,['error'],['errors']
Availability,"9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1152,ERROR,ERROR,1152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['ERROR'],['ERROR']
Availability,": "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(2)). # Run a simulation that saves data to a checkpoint; model.clock.iteration = 1 # we want to start here for some reason; run!(simulation); ```. which produces. ```julia; julia> include(""test2.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (383.622 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (620.680 μs).; [ Info: Iter: 2, time: 1 second; [ Info: Iter: 3, time: 2 seconds; [ Info: Iter: 5, time: 4 seconds; [ Info: Iter: 7, time: 6 seconds; [ Info: Simulation is stopping after running for 25.701 ms.; [ Info: Simulation time 8 seconds equals or exceeds stop time 8 seconds.; [ Info: Iter: 9, time: 8 seconds; ```. Basically here there is a ""spurious actuation"" at the first iteration (here iteration 2, because we started from iteration 1). This fixes the issue:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1, stop_time=6). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); progress_cb = Callback(progress_message, TimeInterval(2)); simulation.callbacks[:progress] = progress_cb. # Run a simulation that saves data to a checkpoint; model.clock.iteration = 1 # we want to start here for some reason; progress_cb.schedule.actuations = 1; run!(simulation); ```. producing. ```julia; julia> include(""test2.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (595.408 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (876.240 μs).; [ Info: Iter: 3, time: 2 seconds; [ Info: Iter: 5, time: 4 seconds; [ Info: Simulation is stopping after running for 51.452 ms.; [ Info: Simulation time 6 seconds equals or exceeds stop time 6 seconds.; [ Info: Iter: 7, time: 6 seconds; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246123947:1713,checkpoint,checkpoint,1713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246123947,2,['checkpoint'],['checkpoint']
Availability,": x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 32, 32); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.03125f0, 0.03125f0, 0.03125f0). julia> model = IncompressibleModel(architecture=GPU(), float_type=Float32, advection=WENO5(), grid=grid); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid.; └ @ Oceananigans.Grids /g/data/v45/nc3020/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; IncompressibleModel{GPU, Float32}(time = 0 seconds, iteration = 0); ├── grid: RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}(Nx=32, Ny=32, Nz=32); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}; └── coriolis: Nothing. julia> time_step!(model, 1); ERROR: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, WENO5, Nothing, Nothing, Nothing, Buoyancy{SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}, Oceananigans.BuoyancyModels.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:1562,ERROR,ERROR,1562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['ERROR'],['ERROR']
Availability,"::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:89",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:3093,error,error,3093,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['error'],['error']
Availability,"::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Vector{Float64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[13]:1; ```. ```; julia> grid = LatitudeLongitudeGrid(size=(2, 2, 2), longitude=(-20, 20), latitude=(10, 20), z=[0, -0.5, -1], topology=(Bounded, Bounded, Bounded)). ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:109; [2] validate_lat_lon_grid_args(FT::Type, latitude::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, z::Vector{Float64}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/latitude_longitude_grid.jl:272; [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Vector{Float64}, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/latitude_longitude_grid.jl:189; [4] LatitudeLongitudeGrid; @ ~/Research/OC6.jl/sr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319:1758,ERROR,ERROR,1758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319,1,['ERROR'],['ERROR']
Availability,":Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/compiler/execution.jl:340; [19] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:637; [27] top-level scope; @ ~/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; [28] include(fname::String); @ Base.MainInclude ./client.jl:489; [29] top-level scope; @ REPL[19]:1; [30] top-level scope; @ ~/.julia/packages/CUDA/35NC6/src/initialization.jl:190; in expression starting at /home/xinkai/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```; Note that line 20 is the last line of the code snippet above (`maximum(abs, v)`). Here's the Julia version info:; ```; Julia Version 1.10.0; Commit 3120989f39b (2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427:3790,mask,mask,3790,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427,1,['mask'],['mask']
Availability,":Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[9]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types. julia> maximum(abs, v); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/nbRJk/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/nbRJk/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#867#868""{Bool, Int64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:5321,mask,mask,5321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372,1,['mask'],['mask']
Availability,"; >   | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY); >   | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443; >   | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY); >   | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508; >   | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY); >   | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706; >   | [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; platform::Base.BinaryPlatforms.Platform, julia_version::VersionNumber, verbose::Bool, io::Base.TTY); >   | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:683; >   | [6] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); >   | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1391; >   | [7] instantiate(; kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Bool}}}); >   | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1300; >   | [8] top-level scope; >   | @ none:1; >   | 🚨 Error: The command exited with status 1; >   | user command error: exit status 1; > ```. The reason for the failure eludes me. But I will try something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628:4456,Error,Error,4456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628,3,"['Error', 'error', 'failure']","['Error', 'error', 'failure']"
Availability,"; ```. Solution: ??????. ### 3. ""Entry function uses too much parameter space"". ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. Solution: probably som",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:856,ERROR,ERROR,856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:4483,ERROR,ERROR,4483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,2,"['ERROR', 'error']","['ERROR', 'errored']"
Availability,"; u=subsample_u); > ```. I tried. ```julia; subset_grid = RectilinearGrid(arch,; size = (grid.Nx, grid.Ny, div(grid.Nz, 20)),; extent = (grid.Lx, grid.Ly, grid.Lz); ). u_subsampled = XFaceField(subset_grid); v_subsampled = YFaceField(subset_grid); w_subsampled = ZFaceField(subset_grid). function subsample_u(model); u = model.velocities.u; interpolate!(u_subsampled, u); return u_subsampled; end. function subsample_v(model); v = model.velocities.v; interpolate!(v_subsampled, v); return v_subsampled; end. function subsample_w(model); w = model.velocities.w; interpolate!(w_subsampled, w); return w_subsampled; end. subset_outputs = (; u = subsample_u, v = subsample_v, w = subsample_w); ```. and. ```julia; simulation.output_writers[:xyz] = NetCDFOutputWriter(model, subset_outputs,; schedule = TimeInterval(300),; filename = ""test.nc"",; with_halos = false,; array_type = Array{Float32},; ); ```. is returning the following error. ```julia; Custom output v needs dimensions!. Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] define_output_variable!(dataset::NCDatasets.NCDataset{Nothing}, output::Function, name::String, array_type::Type, deflatelevel::Int64, output_attributes::Dict{String, String}, dimensions::Dict{Any, Any}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/3LHMs/src/OutputWriters/netcdf_output_writer.jl:448; [3] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594:1259,error,error,1259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594,1,['error'],['error']
Availability,"; using Printf. """""" Set up a simple simulation to test picking up from a checkpoint. """"""; function test_simulation(stop_time, Δt, δt); grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = false). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. rm(""test_iteration*.jld2"", force=true). Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); run!(simulation, pickup=checkpoint); ```. This reproduces the issue because I get. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds; [ Info: ... simulation initialization complete (2.697 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (5.721 seconds).; [ Info: Iter: 2, time: 2 seconds; [ Info: Simulation is stopping after running for 8.786 seconds.; [ Info: Simulation time 4 seconds equals or exceeds stop time 4 seconds.; [ Info: Iter: 4, time: 4 seconds; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (529.973 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (575.447 μs).; [ Info: Iter: 5, time: 5 seconds; [ Info: Iter: 6, time: 6 seconds; [ Info: Iter: 7, time: 7 seconds; [ Info: Simulation is stopping after run",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310:1117,checkpoint,checkpoint,1117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310,4,['checkpoint'],['checkpoint']
Availability,"; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilA",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:3468,error,error,3468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['error'],['error']
Availability,"<a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/f2258781c657ad9b4b88072c5eeaf9ec8c370874""><code>f225878</code></a> Add production dependenc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:5946,mainten,maintenance,5946,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['mainten'],['maintenance']
Availability,"= 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; #; k = collect(1:Nz); dz = 1 .+ 5000 ./ (1 .+ exp.(- (k .- 100)/10 )); zf = [0; -cumsum(dz)]; zf = reverse(zf); Lz = zf[1]; #; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = zf). # Turbulence closures; kappaV = 1e-5; kappaH = 5e5; turb_leith = TwoDimensionalLeith(;C=0.3, C_Redi=1, C_GM=1,isopycnal_model=SmallSlopeIsopycnalTensor()); vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = turb_leith; closures = (vertical_closure, horizontal_closure). # Setting up model; model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; buoyancy = SeawaterBuoyancy(equation_of_state=TEOS10EquationOfState()),; closure = closures,; ). # Setting up simulation; Δt = 5.; stop_time = 20.; simulation = Simulation(model, Δt=Δt, stop_time=stop_time). # Running model; run!(simulation). ```. but get the following error. . ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gc!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 42)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(8, 8, 42)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, Val{1}, CenteredFourthOrder, Tuple{TwoDimension",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2660:1636,error,error,1636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2660,1,['error'],['error']
Availability,"= 80; topology = (Periodic, Bounded, Bounded); grid = RegularRectilinearGrid(size=(1, 512, 8), x=(0, Lx), y=(0, Ly), z=(-Lz, 0),; topology=(Periodic, Bounded, Bounded)). model = IncompressibleModel(architecture = GPU(),; grid = grid,; ). w_ic(x, y, z) = 0.01*y; v_ic(x, y, z) = 0.01*x; set!(model, w=w_ic, v=v_ic). import Oceananigans.Fields: ComputedField, KernelComputedField; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.Grids: Center, Face. u, v, w = model.velocities. function naive_calc(); p = sum(model.pressures); wp = @at (Center, Center, Face) w*p; dwpdz = (1/1024) * ∂z(wp); println(dwpdz); return ComputedField(dwpdz); end. function nested_calc(); p = ComputedField(sum(model.pressures)); wp = ComputedField(@at (Center, Center, Face) w*p); dwpdz = (1/1024) * ∂z(wp); println(dwpdz); return ComputedField(dwpdz); end; ```. I can include this script in the REPL after which I get the following results. First, when trying to compute the naive calculation using a GPU I get an error, which is expected at this point:. ```julia; julia> dwpdz_naive = naive_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── * at (Center, Center, Face) via identity;          ├── Field located at (Center, Center, Face);          └── + at (Center, Center, Center) via identity;             ├── Field located at (Center, Center, Center);             └── Field located at (Center, Center, Center); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8);",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:1299,error,error,1299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,2,['error'],['error']
Availability,"=== true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:1300,ERROR,ERROR,1300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['ERROR'],['ERROR']
Availability,=========; + Hits 4596 4619 +23 ; + Misses 1783 1666 -117 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `58.33% <ø> (+1.19%)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `100.00% <ø> (+63.15%)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX3R1cGxlcy5qbA==) | `33.33% <33.33%> (ø)` | |; | [src/Fields/new\_data.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9uZXdfZGF0YS5qbA==) | `76.92% <50.00%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.80% <100.00%> (+2.91%)` | :arrow_up: |; | [src/TurbulenceClosures/diffusion\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9kaWZmdXNpb25fb3BlcmF0b3JzLmps) | `100.00% <100.00%> (ø)` | |; | [...e\_closure\_implementations/isotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2lzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `100.00% <100.00%> (ø)` | |; | [src/TurbulenceClosures/turbulence\_closure\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfdXRpbHMuamw=) | `75.00% <100.00%> (ø)` | |; | [...urbulenceClosures/viscous\_dissipation\_operators.jl](h,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/999#issuecomment-700403403:1834,checkpoint,checkpointer,1834,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999#issuecomment-700403403,1,['checkpoint'],['checkpointer']
Availability,"============; Files 189 189 ; Lines 5210 5299 +89 ; =======================================; + Hits 3778 3843 +65 ; - Misses 1432 1456 +24 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <ø> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `85.71% <ø> (ø)` | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `91.78% <69.23%> (-6.70%)` | :arrow_down: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `92.06% <85.71%> (+0.99%)` | :arrow_up: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `89.18% <100.00%> (ø)` | |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `64.28% <100.00%> (+5.31%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=footer). Last",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/839#issuecomment-670153251:1738,checkpoint,checkpointer,1738,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839#issuecomment-670153251,1,['checkpoint'],['checkpointer']
Availability,"> * But when Documenter.jl run is it fails!. How does it fail? Does it emit an error? What is the error?. > Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related... What warnings are you getting?. > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid ≈ RegularGrid. That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. > How do I setup the Poisson solver to obtain solution of ∇²b=0 with b(x, t) = cos(πx) and no flux boundary condition at all other walls. Let's zoom. To clarify, we have a `PreconditionedConjugateGradientSolver` that I think would work well for this. This solver is a generic linear algebra solve that works with Oceananigans fields; it is not limited to solving the Poisson equation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877740920:79,error,error,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877740920,2,['error'],['error']
Availability,"> * Implementation of zero laplacians on the immersed boundaries to allow a biharmonic closure with immersed boundaries. Do we also need to zero the Laplacian on _non-immersed_ (ie ordinary) boundaries?. Relatedly, I don't think we need to `@unroll` when we fill halos for `FluxBoundaryCondition`:. https://github.com/CliMA/Oceananigans.jl/blob/adffd0cb67373da364a54d7f300d1f33817539bd/src/BoundaryConditions/fill_halo_regions_flux.jl#L33. The only point of filling points _beyond_ the first halo point is for `AnisotropicBiharmonicDiffusivity`. So if we aren't using it we can get rid of `@unroll` and just fill the first halo point, I think. I think we also need to throw an error if the _only_ closure if `ScalarBiharmonicDiffusivity` and the boundary condition is anything _but_ `FluxBoundaryCondition`. It's kind of complex because it's still ok to have biharmonic and non-flux, provided that there's _another_ closure (in a closure tuple) present. Maybe we can just open an issue about validating boundary conditions + closures and figure out an algorithm there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039857134:677,error,error,677,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039857134,1,['error'],['error']
Availability,"> * Should we create an issue about this on CUDA.jl? Seems unnecessary or, if necessary, at least a warning should be in place, no?. It might be worth raising an issue. I don't think it makes sense for `CUDA.jl` to throw a warning when people use `Int64`; since this is the julia default integer representation such a warning would be thrown 99.9% of cases. And we can't ""always convert"" `Int64` to `Int32` because this sometimes errors:. ```julia; julia> Int32(2^33); ERROR: InexactError: trunc(Int32, 8589934592); ```. One solution is for `CUDA.jl` to provide a custom type to express ""intentional"" usage of `Int64` (or maybe there is a better solution). I was thinking about raising an issue (just thinking about exactly what to say) and I'm happy to do that if that's ok with you @tomchor .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869779611:430,error,errors,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869779611,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,"> * Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES). I think it's a nice idea to illustrate using `Oceanostics` for something that would be challenging for a user to implement themselves, like calculating viscous dissipation. Can we visualize dissipation and buoyancy flux, and then illustrate closing the domain-integrated TKE budget using domain-averages of those quantities?. (Note that we do illustrate interfacing with other packages like `Random`, `JLD2`, `NCDatasets`, `Plots`, etc --- but showcasing packages in our ""ecosystem"" specifically is certainly in our interest.). > * Use Python/xarrray to read and plot the data. To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain. I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953867263:1280,mainten,maintenance,1280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953867263,1,['mainten'],['maintenance']
Availability,"> 1. Modify the CG method to make it numerically stably for positive semi-definite matrices. Right, although I am not sure that this is done correctly in this PR. There may be more work to do... > My method belongs to the second category. I create a new matrix. > $$\tilde{A} = A + cv_0v_0^\dagger$$. > where $c$ is a positive real number and $v_0$ is the basis of the null space of $A$. I was a bit confused about the motivation for defining a new matrix, but with some help from @amontoison I feel I understand this better. The basic idea applies to any semi-definite system; the idea is to ""shift"" an operator by the identity:. $$ \tilde A = A + \epsilon I $$. Where $\epsilon$ is a constant. The key to this method is the smallness of $\epsilon$. Note that we are solving a different system: if the original system is $A x = b$, then the new system is. $$ \left (A + \epsilon I \right ) y = b $$. We do not automatically have $y=x$ or even $y \approx x$. However, we may have $y \approx x$ when $\epsilon$ is smaller than the tolerance of the underlying CG algorithm, for example. In addition to making $\epsilon$ small, another strategy to recover $x$ from $y$ is to solve a new system:. $$ A z = b - A y $$. which, we can show, allows us to recover $x$ via $x = y + z$. For the purpose of implementing shifted operators, some methods in Krylov.jl support provision of a ""shift"" as an argument to the solver, eg the argument `λ` here: https://jso.dev/Krylov.jl/dev/solvers/sid/#Krylov.symmlq. It'd be easy to support a shift of the Poisson operator, the caveat being that the problem being solved is no longer exact. We could additionally support finding the exact solution through a second CG iteration via the method described above, but this would be a bit more work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2415277183:1030,toler,tolerance,1030,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2415277183,3,"['recover', 'toler']","['recover', 'tolerance']"
Availability,"> 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). One way to do it would be to leave most of the heavy work for the user, which would have to specify fluxes in each of the immersed solid's interfaces separately. The user's script would look like what I did here:; https://github.com/CliMA/Oceananigans.jl/blob/faed0c4ac85409cb94811b0bdba2bbb7becf330a/sandbox/drag_test.jl#L25-L41. The downside is that this won't work for non-grid-fitted boundaries and requires more user-written code. The upside is that could (I think) re-use much of the inner-workings of the current BC implementation. > We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs. Not sure I understand this point. Do you mind clarifying @glwagner? By ""overhang"" do you mean that there's no fluid-to-the-bottom-immersed-boundary-to-the-top interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975:1087,down,downside,1087,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975,2,['down'],['downside']
Availability,"> 2\. It would be a good idea in my opinion to support either options of passing the prefix or the filename (as many softwares do) so that we always preservw the extension which I believe is our priority. (Just implement a check on the last relevant characters, if there is a correct extension leave it as is otherwise append it). I think this is an excellent suggestion!. We can do. ```julia; dotindex = findlast('.', filename); possible_ext = isnothing(dotindex) ? """" : filename[dotindex+1:end]; possible_ext == "".nc"" || filename *= "".nc""; ```. We can put similar logic into `FieldTimeSeries`. I was stuck on trying to throw an error if the ext is wrong, which has the major downside that we can't use `.` in filenames anymore. But this is a pretty nice solution I think. The main downside is that if you accidentally call your file `.jld2` for netcdf then you'll end up with a file `.jld2.nc`. But I think we can just _recommend_ that `filename` has no extension and we figure it out. And we also support explicit extensions for users that want that interface, with the caveat that if they screw up they'll have funny filenames. I'll make the changes to the output writers here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345:630,error,error,630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1099095345,3,"['down', 'error']","['downside', 'error']"
Availability,"> ; > https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130; > ; > I tried `arch_array` but seems like we need to write some more methods for it?; > ; > ```julia; > julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); > ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[6]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ; > julia> r_array = arch_array(arch, interior(r)); > ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[7]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```. Why do you need to convert to architecture? Is it enough to use. ```julia; r_reshaped = reshape(interior(r), Nx * Ny * Nz); ```. ?. If you can't use that then I think you have to preallocate a temporary array probably.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492:1215,ERROR,ERROR,1215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492,1,['ERROR'],['ERROR']
Availability,"> > * But when Documenter.jl run is it fails!; > ; > How does it fail? Does it emit an error? What is the error?. I'll rerun it now and post the error. Let's see what [this log](https://buildkite.com/clima/oceananigans/builds/3269#3fdc21e3-4269-4134-af7b-87b99576aec3) gives. > > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid ≈ RegularGrid.; > ; > That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. Would this create a vertically stretched grid with example the same spacing as the regular one?. ```Julia; grid = RegularRectilinearGrid(size = (Nx, Nz),; x = (-Lx/2, Lx/2),; z = (-H, 0),; halo = (3, 3),; topology = (Bounded, Flat, Bounded)). grid_stretched = VerticallyStretchedRectilinearGrid(size = (Nx, Nz),; topology = (Bounded, Flat, Bounded),; x = (-Lx/2, Lx/2),; halo = (3, 3),; z_faces = grid.zF); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159:87,error,error,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159,3,['error'],['error']
Availability,"> > 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.); > ; > I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). Also making this change would mean that a bunch of scripts would fail silently. Meaning that, depending on what/where fluxes are prescribed, the fluxes would flip, producing a completely different result, without Oceananigans throwing an error (since I think we wouldn't change the interface). So if we do go that way I think we'd need to be really careful about it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086349867:998,error,error,998,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086349867,2,['error'],['error']
Availability,"> > ; > > ; > > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > > ```julia; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > > ```; > ; > But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function. Okay, thanks for the clarification! So you're proposing something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. But in my opinion something closer to the previous alternative is already good enough, no? Since you can infer `z=(0, Lz)` from `z_stretch=function_or_array`:. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z_stretch=collect(0:Δz:Lz)); ```. One can envision a general form of this where the following alternatives are all valid and the rest is inferred from the constructor:. ```julia; z_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z_stretch=collect(0:Δz:Lz)); y_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), z=(0, 1), y_stretch=collect(0:Δz:Lz)); x_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), y=(0, 1), z=(0, 1), x_stretch=collect(0:Δz:Lz)); ```. In my opinion this is better since it's a little cleaner (although it may require some more programming on the background). Also, I think `z_stretch` is less clear than `zF`, no? At least to me it's not clear what I'm supposed to provide as the `z_stretch` argument.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813457987:552,down,down,552,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813457987,2,['down'],['down']
Availability,"> > > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > > ; > > ; > > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there.; > ; > Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. Good point. > > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?; > ; > I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure. Yeah I see your point. I'll check `model.last_Δt` and report soon. I think it'll be good news if this is the culprit because it seems like we'd have fairly simple options to fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352:178,error,error,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352,4,['error'],['error']
Availability,"> > > Is this something that is handled on the MIT side ?; > > ; > > ; > > Yeah, it’s something the Oceananigans dev team should sort out! :); > ; > Curious to know if there's any movement on getting this resolved. I can offer some help in getting an allocation request in to Pawsey Supercomputing Centre - I mentioned to @navidcy that I have a solution for doing CI on systems with job schedulers (like Pawsey's Setonix).; > ; > If existing hardware systems at MIT are not available for this, I can also help with procurement, if needed. If you go this route, I can look into providing some time on our systems to get testing rolling. @simone-silvestri can you please help with this? I agree its critical to get this PR merged ASAP, it's already getting stale. I think we should contact Satori folks first directly or via @christophernhill . @Sbozzolo might be able to help if there are AMD machines on the caltech cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997634181:474,avail,available,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997634181,1,['avail'],['available']
Availability,"> > > There is something fishy with MPI.jl..; > > ; > > ; > > CPU or GPU (or both!) ?; > ; > There are only `CPU distributed tests` and they are failing before they even start:; > https://buildkite.com/clima/oceananigans/builds/3587#c5384940-778a-42c1-842b-c57c1209b786; > ; > This error beats me. :(. I think it's a problem (bug?) with `MPI.jl` or something else outside Oceananigans. The error seems to suggest that some package associated with MPICH_jll thinks we are on MacOS. It's surprising because we didn't upgrade packages. However, we are running on a new system (shiny Ubuntu 20.04) and that may be the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891780863:282,error,error,282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891780863,2,['error'],['error']
Availability,"> > > This is looking great!; > > > Also, I see you're using MPI. Does this mean that we're not limited by the CUDA multi-GPU requirements? (I don't remember details, but I believe you can use only CUDA software and run multi-GPU, but only up to 8 GPUs and all on the same node or something...?); > > ; > > ; > > Yes this uses MPI which means that it should scale up to whatever number of GPUs you can get your hands on. There is no restriction in terms of infra or intra-node computations. The only restriction is that you need to user a number of tasks per node which are smaller or equal than the number of GPUs per node because there is a one-to-one mapping between a MPI rank and a GPU in the node.; > ; > Should we include something in the docs about this functionality? Or is it still considered experimental?. This is a bit hidden in the docstring here; https://github.com/CliMA/Oceananigans.jl/blob/7eeb9a064f884402afb3bc697ba8c8c8c9c773ee/src/DistributedComputations/distributed_architectures.jl#L200; but anyways when bulding the architecture this step will spit out an error if you are trying to set a device which does not exist on the node; https://github.com/CliMA/Oceananigans.jl/blob/7eeb9a064f884402afb3bc697ba8c8c8c9c773ee/src/DistributedComputations/distributed_architectures.jl#L236-L241. The change of the docstring is being addressed here #3673",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2267582185:1081,error,error,1081,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2267582185,1,['error'],['error']
Availability,"> > > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > > ; > > ; > > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.; > ; > Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?. Sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422:965,error,error,965,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422,2,['error'],['error']
Availability,"> > > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > > ; > > ; > > @glwagner that sounds OK.; > > the include(""dependencies_for_runtests.jl"") breaks; > > ```; > > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > workflow because of; > > ```; > > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > in; > > ```; > > utils_for_runtests.jl; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which can't be redeclared since its const? Is there a trick to fix that?; > ; > It should be ok to redeclare a `const` as something identical:; > ; > ```julia; > julia> const a = 1; > 1; > ; > julia> const a = 1; > 1; > ; > julia> const a = ""hi""; > ERROR: invalid redefinition of constant a; > Stacktrace:; > [1] top-level scope; > @ REPL[3]:1; > ```; > ; > So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it.; > ; > PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly. Just a note that the reported error by @christophernhill was with Julia v1.7. I think there were some differences with consts? Not quite sure….",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829:1267,ERROR,ERROR,1267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1003869829,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"> > > Why here we have `FT` as independent input and don't use `eltype(grid)`?; > > > https://github.com/CliMA/Oceananigans.jl/blob/afb46612df31dc7e841114b7f09229a2aca2a150/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L276; > > > ; > > > Can't this result to type instabilities?; > > ; > > ; > > I think the positional argument should be `grid` rather than `FT`.; > ; > I think so too. @simone-silvestri is there any reason it was done this way?. It's following the pattern for other constructors (but in those other cases, `grid` is not available). . We haven't written these conventions out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3311#issuecomment-1748921269:564,avail,available,564,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3311#issuecomment-1748921269,1,['avail'],['available']
Availability,"> > @fluidnumerics-joe the CI doesn't work... something's wrong with the Manifest you pushed.; > > It would be easier if you somehow allow maintainers to push. There is an option ""Allow edits and access to secrets by maintainers"" when you open a PR. Perhaps you disabled that?; > > Personally if I don't see the CI working (at least starting) then I feel it's a bit futile to comment on code that might be outdate or deprecated.; > ; > I'll check settings. Have you noticed your main branch fails CI?. Main branch doesn’t fail. It starts. Just the GPU server that we run CI was down yesterday. . The CI on this branch doesn’t even start. Not even the CPU CI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936971094:578,down,down,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936971094,1,['down'],['down']
Availability,"> > @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?; > > If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up.; > > The motvation is to assess how much of this is due to pressure errors versus other stuff.; > ; > I'm looking at the time-series of total momentum --- the line goes down, but also _up_! So momentum is _increasing_ inside the domain, transiently.; > ; > I didn't try to connect this with the vorticity field but maybe you can draw some conclusions!. Does the total energy do the same thing or is it just the momentum?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101522533:339,error,errors,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101522533,3,"['down', 'error']","['down', 'errors']"
Availability,"> > @tomchor I think I know what I need to do to resolve the issues. Do you mind if I send commits to this PR?; > > Basically we have built models in a way that would not withstand time stepping (but the tests passed because we never tried to time step). We just need to stop running those tests. Also `restore_from_checkpoint` should be skipped (and the whole feature deprecated).; > ; > Please, commit away! And thanks. Gonna resolve the restore from checkpoint thing in a separate PR once and for all rather than fiddle around with it here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885660090:453,checkpoint,checkpoint,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885660090,1,['checkpoint'],['checkpoint']
Availability,"> > @tomchor can you do another one; > > ; > > * Using Julia 1.8 and Oceanigans#main; > > ?; > ; > Wasn't #2778 closed without merging?; > ; > Do you mean for me to run that branch?. @navidcy I ran it using Julia 1.8 and the branch in #2778 and indeed the memory consumption goes down. Using 80 million points (what I've been using for version 0.78) I have:. - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 21714MiB / 32768MiB. So the memory usage after adding diagnostics decrease significantly (from 31 to 21 GB), while the memory usage before looks like it's exactly the same. With branch #2778 I can then go back to running simulations at least of the same size as I did in 0.77.5.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300864095:280,down,down,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300864095,1,['down'],['down']
Availability,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:522,error,error,522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586,6,['error'],['error']
Availability,"> > @tomchor the description of this issue is a little vague. The dynamics weren't ""weird"" --- the problem was a bug in reconstructing buoyancy in the momentum equations, right? It'd be nice to add a little more explicit description of the original issue. I think there is a PR that fixed the bug that we can point to as well.; > ; > The issue is that the videos aren't available anymore and, apart from the internal wave packet example, I don't really remember what was happening well enough to be able describe it objectively.; > ; > That said, I did my best to make the description more clear and linked the PR that solved the bug. The issue was that buoyancy was not reconstructed properly in the vertical. (There was also a problem with reconstructing buoyancy in the horizontal, but this only affects tilted domains.) So there was a bug and the discretization was incorrect.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1621989632:370,avail,available,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1621989632,2,['avail'],['available']
Availability,"> > A test would be nice to come along with this PR. I can help out with that if you want.; > ; > Thanks! I'll take you up on that if you don't mind. Given that you said that other grids also have arrays, it might be best to expand checkpoint testing for all grids?. Yeap. But first we need to sort the GPU/CPU issue. For example, two grids that are identical but the arrays of one live on CPU but the other on GPU should they be considered equal? I believe in that case we should add methods so that:; ```julia; julia> grid1 == grid2; true. julia> grid1 === grid2; false; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219663:232,checkpoint,checkpoint,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219663,1,['checkpoint'],['checkpoint']
Availability,"> > AUUUGHHH that was hard but finally found the source of the type instability:; > ; > which type instability; is this related to discussion in #3750?. Yes. That issue documents slow reductions for windowed fields on immersed boundary grids. I hypothesized that it was due to a failure of type inference. Looking into it further I see that `axes(op::AbstractOperation)` cannot be type inferred when indices is not `(:, :, :)` because of the tuple generator. We found the same problem with `axes` for `Field` and fixed it but didn't fix it for AbstractOperations. Reducing windowed fields on immersed boundary grids requires this because they are wrapped in `ConditionalOperation` in order to mask the immersed regions during the reduction. This PR extends the fix we implemented for `Field` to also encompass `AbstractOperation`. It also cleans up conditional operations quite a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380361438:279,failure,failure,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380361438,2,"['failure', 'mask']","['failure', 'mask']"
Availability,"> > Ah interesting, why do you create `coarse_model`? Is that so `coarse_model.grid` gets saved down? I think we can make it so that isn't needed probably...; > ; > Right now it's needed solely because `NetCDFWriter` needs a `model` to get the grid from (and maybe other stuff). I think it would be pretty easy to modify `NetCDFWriter` so that it only needs a `grid` passed, but I haven't looked into that. I think just modifying the constructor for the output writer to. ```julia; NetCDFOutputWriter(model, outputs, grid=model.grid; kw...); ```. would do it. The next level would be to look at the grid for the outputs and automagically build interpolated outputs if the grids are different (but that could be added separately from the above change)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091033197:96,down,down,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091033197,1,['down'],['down']
Availability,"> > Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?; > ; > The idea is that we will eventually support general regridding. In this PR, we only implement vertical regridding as a start. The next case to support would be regridding for Cartesian grids; after that, for curvilinear grids. We've attempted to write an informative error:; > ; > ```julia; > msg = """"""Regridding; > $(short_show(v)) on $(short_show(source_grid)); > to $(short_show(u)) on $(short_show(target_grid)); > is not supported.""""""; > ```. I see! I got a bit confused about this error because I'm not familiar with `SingleColumnGrid`, but it makes more sense now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923045151:465,error,error,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923045151,4,['error'],['error']
Availability,"> > As a sanity you could try removing `interior(r)` and just pass `r` instead... :-O; > ; > Ah unfortunately same error and `typeof(R)` with; > ; > ```diff; > diff --git a/src/Fields/mapreduce_abstract_fields.jl b/src/Fields/mapreduce_abstract_fields.jl; > index 6ce35031..21237fa2 100644; > --- a/src/Fields/mapreduce_abstract_fields.jl; > +++ b/src/Fields/mapreduce_abstract_fields.jl; > @@ -11,6 +11,6 @@ for function_name in (:sum, :prod, :maximum, :minimum, :all, :any); > # Unwrap ReducedField to a view over interior nodes:; > @eval begin; > Base.$(function_name!)(f::Function, r::AbstractReducedField, a::AbstractArray; kwargs...) = Base.$(function_name!)(f, interior(r), a; kwargs...); > - Base.$(function_name!)(r::AbstractReducedField, a::AbstractArray; kwargs...) = Base.$(function_name!)(identity, interior(r), a; kwargs...); > + Base.$(function_name!)(r::AbstractReducedField, a::AbstractArray; kwargs...) = Base.$(function_name!)(identity, r, a; kwargs...); > end; > end; > ```. _Same_ error? Whoa.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845614201:115,error,error,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845614201,2,['error'],['error']
Availability,"> > As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).; > ; > I agree, but this patch-up will not work for immersed boundaries anyway. What do you mean? What patch-up?. > I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. I agree I think that would be nice. It means that operators need to know about boundary conditions though, which is a major refactor... > As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries. We support values and gradients on non-immersed boundaries, but we do _not_ support evaluating them across immersed boundaries. We have to support what we claim / say that we support, that is the only issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786:643,down,down,643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786,1,['down'],['down']
Availability,> > Can you add tests?; > ; > New tests passed. Thanks! Some of the tests segfaulted so I restarted them. I'll approve it once tests pass and then we should be ready to go! Feel free to ping me if I'm taking too long ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3567#issuecomment-2087368347:186,ping,ping,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3567#issuecomment-2087368347,1,['ping'],['ping']
Availability,"> > Can't we just plot a fixed-color shape on top on the mount on all panels? [`Makie.poly`](https://docs.makie.org/stable/reference/plots/poly/) seems to be able to do that.; > ; > We can.; > ; > We can also mask the output after we load it, e.g, via; > ; > using something like; > ; > ```julia; > using Oceananigans.ImmersedBoundaries: mask_immersed_field!; > ; > function mask_and_get_interior(φ_t, n; value=NaN); > mask_immersed_field!(φ_t[n], value); > return interior(φ_t[n], :, 1, :); > end; > ; > u′ₙ = @lift mask_and_get_interior(u′_t, $n); > ```; > ; > which gives; > ; > internal_tide.mp4 ; > But either of these solutions complicate the example a bit. Ideally, `mask_immersed_field!` should not be user-facing. And plotting a mountain on top of the mountain is a bit of a hack and would require a bit of explaining and justifying why we do that. I think we should mask the solution during visualization in the script. This is actually what users will need to do currently to make decent visualizations, so it is good to illustrate how to do it --- even if, hopefully, we will eventually have a better solution. As for plotting a shape on top, I'm inclined to encourage visualization that directly represents the domain / data for the purposes of an Oceananigans example. I think its ok if people want to incorporate visualizations like that in their own work but we may not want to promote it as ""the best"" way to visualize complex domains in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358:209,mask,mask,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358,2,['mask'],['mask']
Availability,"> > Docs should show up at https://clima.github.io/OceananigansDocumentation/previews/PR1543/ once a commit has been made after the PR has been opened.; > ; > This gives me a 404 error!. I believe you have to open the PR (not have it as ""Draft"") and then it'll push the preview....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-813713965:179,error,error,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-813713965,1,['error'],['error']
Availability,"> > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `bu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:176,error,error,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,4,['error'],['error']
Availability,"> > Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?; > > If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`).; > > A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).; > ; > Good points. Based on these points I'd argue for us to keep things as it is but include a comment about this in the docstring / docs.; > ; > Agreed?. Fine by me. I also think `Cb=1/Pr` would be a good choice and retains current defaults.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336992:608,error,error,608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336992,1,['error'],['error']
Availability,"> > Either way, I don't think that's important. A preconditioner should be some kind of approximate inverse for A, where we are solving for x in Ax = b --- or in other words, an approximate solver. The preconditioner does not have to be ""exact"" or ""error free"", since it's really the CG iteration that solves the problem. The idea is that the FFT-based solver yields a pressure field that is _almost_ correct.; > ; > Ah, I see, so the idea behind using the FFT-based solver specifically as a preconditioner is because it's probably faster than other combination (if I understand correctly).; > ; > Thanks!. For sure, and we could use other preconditioners. But I suspect the FFT will be _much_ faster than any other preconditioner, which is why I think it's so interesting (and somewhat novel --- though similar approaches have been used for other problems).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284558702:249,error,error,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284558702,1,['error'],['error']
Availability,"> > Hmm, it should not be a tolerance issue. To debug this I would probably suggest Tartarus since it has at least 2 GPUs (I am not sure your laptop has 2 gpus 😄 ); > ; > I checked and tests were failing because values of order 1e-19 or less were not agreeing... see https://buildkite.com/clima/oceananigans-distributed/builds/1131#018d7a2d-f6c5-4e22-8006-3e2d318465d1/170-5060; > ; > I replaced `a ≈ b` (which defaults to `atol=0` with `isapprox(a, b, atol=eps(eltype(grid)))`; see [385a05d](https://github.com/CliMA/Oceananigans.jl/pull/3403/commits/385a05d55dfe189eb0734c9120d0f9604eb070f7). Makes sense. Are the differences associated with some of the unrolling that we added (eg to fill halo regions)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1930124210:28,toler,tolerance,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1930124210,1,['toler'],['tolerance']
Availability,"> > How about a test? If it's not trivial then don't worry.; > ; > I like the idea of a test.; > ; > One example could be the following:; > ; > 1. define the horizontal compoments of velocity to be random fields,; > 2. use this function is used to compute the vertical velocity,; > 3. compute the divergnece of the resulting three-dimensional field and compute its norm (which should be zero).; > ; > If you do this for two different resolutions you should find that the error decreases with higher resolution.; > ; > Do you think this would be of interest?. @francispoulin a test like that would be good. Sometimes things that are fixed have subsequently been re-broken - because they don't have unit test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896868081:471,error,error,471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896868081,1,['error'],['error']
Availability,"> > I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:463,error,error,463,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457,1,['error'],['error']
Availability,"> > I don't know exactly what it means for a gradient to be applied to the field. Can you please clarify?; > ; > I just meant where in the code the gradient boundary conditions get imposed, which you've shown us is in the calculation of the gradients that feed into the downgradient diffusive fluxes that are used in the diffusive flux divergence contribution to the tracer tendencies. Thanks!. Okay great. I would only add, I think it's clearer to think of the gradient as being _used_ to diagnose the cross-boundary flux (rather than imposed). I guess the point here is that there is actually an apparent flux of tracer into the perturbation field because of the presence of the background. So we are imagining that the background is being maintained by some large scale circulation which is ultimately the source of this apparent flux. `FluxBoundaryCondition` can be used if you know the diffusivity a priori but otherwise it does look like it will be simpler to use `GradientBoundaryCondition` to add this apparent flux contribution to the evolution of the perturbation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2212615516:270,down,downgradient,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2212615516,2,['down'],['downgradient']
Availability,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884:154,error,error,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884,6,['error'],['error']
Availability,"> > I guess I just read the first part ""no method matching PressureSolver"" and that made sense to me: there's no pressure solver for my input!; > ; > Fair enough! But perhaps not what would come in mind to everyone ;). I tend to agree with @navidcy. For that error to be clear a user would have to be familiar with Julia's multiple dispatch feature and what ""method"" means. Clear for us, but not super clear for a new Julia user. > @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in i, j and solve in k. Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022800912:259,error,error,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022800912,2,['error'],['error']
Availability,> > I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.; > ; > That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not). I guess this would be a bug in that scenario,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023:60,error,errors,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023,2,['error'],"['error', 'errors']"
Availability,"> > I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?; > ; > @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on.; > ; > I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation. Thanks @christophernhill for all this information. This will be most helpful. Unfortunately, tomorrow I am busy from 9am to 5pm so I don't think I can zoom, but maybe on Monday? I'll try and look into these resources before hand.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570:397,down,downloaded,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570,2,['down'],['downloaded']
Availability,"> > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code.; > ; > I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. I just noticed that a lot of errors from new users that I've helped come from having the wrong function signatures, either when imposing initial or boundary conditions or forcings. With standardized ""3D"" function calls it makes it easier to catch. My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. But I guess your hope is that this will decrease the number of mistakes in the first place since the signatures hopefully will become more intuitive?. > I think the scripts read better with this change. Agreed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777364648:419,error,errors,419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777364648,2,['error'],['errors']
Availability,"> > I started by updating all the examples for the new syntax that I thought would work, and then went on to other stuff to let the CI do its thing. Now that I see one of them failed I went back and focused on that one specifically. I think its an ok workflow since regardless I would have to wait for compilation / setup, so its not a bad strategy to let CI find the errors for you, at least at first; > ; > It is, if it works for you! Sometimes I personally have a larger adjustment time to get back to a problem when I move to a different one so the workflow you seem to follow doesn't work for me that well.; > ; > Merge?. True... I'm working on 30 things at once usually...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2273505540:368,error,errors,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2273505540,1,['error'],['errors']
Availability,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:219,mainten,maintenance,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247,2,['mainten'],['maintenance']
Availability,"> > I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit.; > ; > To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU?. If the precomputation is storing values in an `Array` or `CuArray` (which is already mutable) then no. If you need to precompute a number for every boundary, then yes you need something mutable. But it looks like this would not involve the `BoundaryCondition` itself but rather a component of the boundary condition (eg the `condition` or the `classification`). None of this is hard though. I think we need to write down the use cases we want to support (explicitly, as detailed as possible), then we can design the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979244558:679,down,down,679,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979244558,1,['down'],['down']
Availability,"> > I think the majority of simulations do not use a Checkpointer so the warning would be irrelevant in most cases.; > ; > I don't get this. How are people not using a Checkpointer? Is no one else limited by HPC wall times or running long simulations? It seems like one of the most fundamental capabilities of any time-stepped numerical model.; > ; > But yes, this warning should only be issued if a Checkpointer is used (and maybe also when a simulation picks up from an existing Checkpoint). I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient. Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon. @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. I'm not saying we don't want to develop this, I'm just providing some context about why this hasn't been resolved / developed yet. In an ideal world the simulations would run fast enough that we wouldn't need checkpointing, after all 😄",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305131230:53,Checkpoint,Checkpointer,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305131230,17,"['Checkpoint', 'checkpoint']","['Checkpoint', 'Checkpointer', 'Checkpointing', 'checkpointer', 'checkpointing']"
Availability,"> > I think to preserve the work in this PR, we should add a `Float32` test which will fail if a spurious promotion undermines performance; > ; > Agreed. I'll revisit this PR later to see if I can find where the conversion happens. The test I added only checks to see if we can take a time step. But I should be able to also add a test to ensure no spurious promotion occurred. Ah, that will work as a test if we remove the `convert`. The `convert` is a good sanity check to find where the problem is, but its not a solution since it merely allows the code to run without error --- it doesn't actually allow us to realize the benefits of using `Float32`. Arguably with this it is actually worse to use `Float32`, since the numerics are degraded bbut the perfrmance benefit is not fully realized",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445330720:572,error,error,572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445330720,2,"['degraded', 'error']","['degraded', 'error']"
Availability,"> > I tried to do that but couldn't make it work in Julia.; > ; > How do you do it in python? We can use python here so if there's a python solution, it's good enough. It's a bit obscure, but you can find an example [here](https://matplotlib.org/stable/gallery/axisartist/demo_floating_axes.html#sphx-glr-gallery-axisartist-demo-floating-axes-py). Is it worth using Python here though? I feel like we'd need to have a whole conda environment set-up just for that. . > I'm re-running the script, keeping the REPL open (so I don't have to precompile, that's the whole point). But there is a line close(ds). Is close(ds) not enough?. The issue happens when Julia tries to open a file that's already in use by another process. So if you're using only the one Julia REPL over and over with this script (and you're closing the dataset afterwards), I think this error shouldn't be happening. Unless the script is crashing before teaching the `close(ds)` statement, which has happened with me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065348138:855,error,error,855,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065348138,1,['error'],['error']
Availability,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822:1063,redundant,redundant,1063,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822,4,"['down', 'redundant']","['down', 'redundant']"
Availability,"> > I'm getting this error when trying to run my code on multiple GPUs (it works fine on CPUs):; > ; > Hmmmm it has to do with switching `stream` from your stream pool in the GPU you are in. That always worked for the clusters I tried. Any instance of `@apply_regionally` should fail for you. If you can give me a MWE I can take a look at it. Here's a MWE:. ```julia; using Oceananigans; using CUDA. if CUDA.has_cuda_gpu(); arch = GPU(); n_partitions = CUDA.ndevices(); else; arch = CPU(); n_partitions = 2; end . grid_base = RectilinearGrid(arch, size=(4, 4, 4), extent = (1,1,1)); grid = MultiRegionGrid(grid_base, partition = XPartition(n_partitions), devices = n_partitions). model = NonhydrostaticModel(grid = grid); ```. Running this on a CPU works, but on a GPU is throws me this error:. ```; ERROR: TaskFailedException. nested task error: BoundsError: attempt to access Tuple{Vector{CuStream}} at index [2]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] (::Oceananigans.Architectures.var""#3#6"")(); @ Oceananigans.Architectures /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:26; [3] lock(f::Oceananigans.Architectures.var""#3#6"", l::ReentrantLock); @ Base ./lock.jl:185; [4] next_stream; @ /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:24 [inlined]; [5] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(2, 4)}, typeof(Oceananigans.BoundaryConditions.gpu__fill_bottom_and_top_halo!)})(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Flo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261:21,error,error,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"> > I'm ok with exporting `KernelFunctionOperation` from the submodule `AbstractOperations`. But do we also want to export it from the top-level so it's available when we write `using Oceananigans`?; > ; > I'm okay with not exporting it to the top level, but then I guess we also wanna stop exporting `KernelComputedField` to the top level for consistency, no?. I don't understand what you're saying, can you say it again a bit differently? My suggestion is to add `KernelFunctionOperation` to this line: https://github.com/CliMA/Oceananigans.jl/blob/22bcf3adc2fad0fda6b474aa08a84acd6c461478/src/Oceananigans.jl#L88. and therefore export it when users write `using Oceananigans`. EDIT: looks like you've done just that. @tomchor are you suggesting that we _not_ export it from `Oceananigans.AbstractOperations`? I'm agnostic on that point. We export many things from submodules, primarily as a convenience for developers. For example, both `Oceananigans` and `Oceananigans.Fields` exports `Field`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1939#issuecomment-901395047:153,avail,available,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1939#issuecomment-901395047,1,['avail'],['available']
Availability,"> > I'm still sort of worried that we shouldn't have `BasicBiogeochemistry` at all because I'm worried that will tempt child packages into using it... (the double-edged sword of convenience); > ; > It is also going to be an extra thing to maintain that probably isn't that useful?. That's my main concern. It's basically a convenience thing for model developers who are just getting started. So it is slightly friendly, but it's not a good idea if it slows everyone down...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335297027:466,down,down,466,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335297027,1,['down'],['down']
Availability,"> > I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors.; > ; > That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed. 🤦 there's already Using GPUs of course, silly me...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200:222,error,errors,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200,1,['error'],['errors']
Availability,"> > Interesting! Which version were you before updating?; > ; > I used v0.88.0 before. But even if I pin Oceananigans to v0.88.0, the issue still occurs, and the contents of `Manifest.toml` are not the same as before. That suggests that this could be an issue with your environment... What other packages are you using?. What can happen is that a package got upgraded when you bumped up to 0.90.0, but then because compat was satisfied with that upgraded package, it did _not_ get changed when you subsequently bumped down to 0.88.0. Upgrading is conservative, it doesn't happen unless you ask for it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1799252941:518,down,down,518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1799252941,1,['down'],['down']
Availability,"> > Is it possible to get julia to ignore the manifest (i.e. specify that we want to ignore it in the CI), so that when a user downloads it they can still use the manifest?; > > Having asked that I don't actually know what the manifest does that isn't already taken care of by the Project?; > ; > The Project compat is supposed to take care of everything. It's just that subtle bugs can creep into packages that might cause things to fail for us (for example something subtle can break type inference, causing everything to fail on the GPU). So using the Manifest is a bit more conservative, because we fix all of the packages that don't _need_ to be upgraded. On the other hand, we are better community members by deleting the Manifest because catching those bugs is important for everyone. To be more specific, with Project.toml we specify compat on packages we depend on, but we do not have compat on packages that our dependencies depend on. The Manifest tracks all packages including dependencies of dependencies (and dependencies of those). We've caught issues in the past by comparing the committed Manifest to another Manifest with different packages. Some issues include, a version of MPI_jll that doesn't work on Mac, or some weird bug in ChainRulesCore... things that we don't have explicit compat for...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361792025:127,down,downloads,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361792025,1,['down'],['downloads']
Availability,"> > Is this for ShallowWaterModel?; > ; > Yes, the closure terrm for tracers was not done correctly and gave an error in the previous form. This fixes it for the `VectorInvariantForm`, but more work needs to be done for the `ConservativeForm`. I plan to talk to @simone-silvestri on Monday about this and other things. Sounds good, I updated the PR title so no one gets alarmed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157765920:112,error,error,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157765920,1,['error'],['error']
Availability,"> > Is this something that is handled on the MIT side ?; > ; > Yeah, it’s something the Oceananigans dev team should sort out! :). Curious to know if there's any movement on getting this resolved. I can offer some help in getting an allocation request in to Pawsey Supercomputing Centre - I mentioned to @navidcy that I have a solution for doing CI on systems with job schedulers (like Pawsey's Setonix). . If existing hardware systems at MIT are not available for this, I can also help with procurement, if needed. If you go this route, I can look into providing some time on our systems to get testing rolling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1995881191:451,avail,available,451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1995881191,1,['avail'],['available']
Availability,"> > It's something to do with GPU, maybe GPU reductions?; > > ```; > > [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; > > --; > >   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199; > >   | Expression: minimum_xspacing(grid) ≈ FT(π / 3); > >   | Evaluated: 0.0 ≈ 1.0471975511965976; > > ```; > ; > I see this error. But I can't reproduce it. On tartarus it's not happening and I don't have access to Svedrup. So I don't know what to do... :(. I guess its a CUDA version issue or something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567729329:445,error,error,445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567729329,1,['error'],['error']
Availability,> > Likely this function is the problem:; > > https://github.com/CliMA/Oceananigans.jl/blob/775d1544610d5af6f602254ec5dff3dec7f18480/src/BoundaryConditions/update_boundary_conditions.jl#L15-L16; > ; > Yeah I saw that this was where some of the errors were coming from but I don't really understand what is going on with Enzyme that this causes problems?. It could be that this function is recursive coupled with the fact that `boundary_conditions` is not type-inferrable. So we may want to rewrite both of those functions. Luckily typically the changes we make to improve type inferrence (making it easier for the compiler to understand) also make it easier for humans to understand. As a starting point I don't think we can use the `Tuple` generator...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263694349:244,error,errors,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263694349,1,['error'],['errors']
Availability,> > No stretched mesh is supported at the moment (that will come in a later PR); > ; > Will an info/error been thrown in this case?. It does now!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2259299531:100,error,error,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2259299531,1,['error'],['error']
Availability,"> > Not sure I understand this. Is this trying to check whether a location is adjacent to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?; > ; > Are you confused by the _definition_, or the way it's used? `peripheral_node` and `immersed_peripheral_node` are needed to condition fluxes. `external_node` is needed for masking. For example, vorticity is valid _on_ the boundary, and thus peripheral values of vorticity should not be masked (I don't think...). But we do need to condition fluxes on peripheral nodes. I was a bit confused as to both. But your comments clarified quite a bit, thanks! I think the rest of my doubts will be answered once I have time to read the code more carefully...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101510306:362,mask,masking,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101510306,2,['mask'],"['masked', 'masking']"
Availability,"> > OK, this is now ready to review.; > > I have hardcoded the boundary condition parameters! Any attempt to include them via parameters failed. Please help by showing me how (try building the docs though first before you claim success :) --- I tried a million times!); > > Also, I get a lot of these warnings:; > > ```; > > ┌ Warning: type FieldBoundaryConditions{BoundaryCondition{Flux, Nothing},BoundaryCondition{Flux, Nothing},Nothing,Nothing,BoundaryCondition{Flux, Nothing},BoundaryCondition{Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.__atexample__named__horizontal_convection.#bˢ,Nothing,Tuple{},Tuple{},Tuple{}}},BoundaryCondition{Flux, Nothing}} does not exist in workspace; reconstructing; > > └ @ JLD2 ~/.julia/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:358; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Any idea why? My instinct says that these issues are intertwined but I can't figure out why...; > ; > What's the error?; > ; > I believe that warning comes from `FieldTimeSeries`. But that's a warning, not an error, so its ok. when I did; ```; const b★ = 1.0; const k = 2π / Lx. @inline bˢ(x, y, t, p) = - p.b★ * cos(p.k * x). b_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(bˢ, parameters = (b★ = b★, k = k))); ```; and try to build the docs I get:; ```; ┌ Debug: Running ExpanderPipeline on generated/horizontal_convection.md; └ @ Documenter.Expanders ~/.julia/packages/Documenter/4JDQo/src/Expanders.jl:39; ┌ Warning: failed to run `@example` block in src/generated/horizontal_convection.md:221-223; │ ```@example horizontal_convection; │ run!(simulation); │ ```; │ c.value = TypeError: in <:, expected Type, got a value of type JLD2.OnDiskRepresentation{(0,), Tuple{NamedTuple{(:b★, :k), Tuple{Float64, Float64}}}, Tuple{NamedTuple{(:b★, :k), Tuple{Float64, Float64}}}}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881794493:1028,error,error,1028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881794493,2,['error'],['error']
Availability,"> > Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?; > ; > Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid.; > ; > I agree that we should have a test for that and maybe something in the docs, sometime?. Added a note in docstring + an `@assert` check. See [43cfed7](https://github.com/CliMA/Oceananigans.jl/pull/2522/commits/43cfed75cf5601f543f91eef8cdd3c29d90fa05e)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451:126,error,error,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451,1,['error'],['error']
Availability,"> > Should we remove the warning when constructing `FourierTridiagonalPoissonSolver`?; > ; > Are you talking about this one?; > ; > https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L31-L34; > ; > If so, I think we can remove it after the tests pass, no? Unless you think there might be more issues lurking. Yes, that warning. I realized that the Poisson solver tests (not withstanding the bizarre aspects pointed out in #1867) don't test Flat topologies for the vertically stretched grid. So I've added those. If those pass we can certainly take down the warning. I guess the internal wave test is also a good indication that the solver is working. Either way the warning was a bit misleading since no calculations using the vertically stretched grid were likely to work without correct metrics --- not just calculations involving the Poisson solver.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949550:634,down,down,634,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949550,1,['down'],['down']
Availability,"> > Some good news is that more tests seem to be passing compared to the prevoius PR.; > > One of the messages I saw was there was a cancellation signal, see below. Lots of the tests just cancelled, and I'm not sure why.; > > ```; > > Testing Oceananigans; > > # Received cancellation signal, interrupting; > > ```; > ; > I don't know what you saw. But what I see here:; > ; > https://buildkite.com/clima/oceananigans/builds/14750; > ; > is that almost all tests pass. Thanks @navidcy , that does look very promising!. The error that I saw is copied below. I am not quite sure where this comes from though.; ```; [8dfed614] Test; Status `/tmp/jl_pRHyI0/Manifest.toml`; [403513] signal (11.1): Segmentation fault; in expression starting at /storage5/buildkite-agent/.julia-14750/packages/CUDA_Runtime_jll/rcOoh/.pkg/platform_augmentation.jl:102; Allocations: 2907 (Pool: 2899; Big: 8); GC: 0; ERROR: failed process: Process(`/storage5/buildkite-agent/julia-1.10.2/bin/julia -C native -J/storage5/buildkite-agent/julia-1.10.2/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_pRHyI0/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/storage5/buildkite-agent/.julia-14750""]); append!(empty!(Base.DL_LOAD_PATH), String[]); cd(""/storage5/buildkite-agent/.julia-14750/packages/CUDA_Runtime_jll/rcOoh/.pkg""); include(""/storage5/buildkite-agent/.julia-14750/packages/CUDA_Runtime_jll/rcOoh/.pkg/select_artifacts.jl""); ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-libstdcxx30-julia_version+1.10.2`, ProcessSignaled(11)) [0]; Stacktrace:; [1] pipeline_error; @ ./process.jl:565 [inlined]; [2] read(cmd::Cmd); @ Base ./process.jl:449; [3] collect_artifacts(pkg_root::String; platform::Base.BinaryPlatforms.Platform); @ Pkg.Operations /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:720; [4] collect_artifacts; @ /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988500458:523,error,error,523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988500458,3,"['ERROR', 'error', 'fault']","['ERROR', 'error', 'fault']"
Availability,"> > Something changed and there is an [error](https://buildkite.com/clima/oceananigans/builds/6799#086c56e0-6bf7-4373-8f4f-9b9e3da07b05/19-2421) at; > > https://github.com/CliMA/Oceananigans.jl/blob/2a9f9dd2ff156ef54f9cc4e8ec662d272afee573/examples/tilted_bottom_boundary_layer.jl#L179-L182; > > ; > > Can anyone help me here? @glwagner, @tomchor?; > ; > Shouldn't `fields` be `outputs` in the call to NetCDFWriter? I don't see `fields` defined in this version so I'm guessing someone changed the name at some point. Yeap. But still I get an error... ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs,; filename = joinpath(@__DIR__, ""tilted_bottom_boundary_layer.nc""),; schedule = TimeInterval(20minutes),; overwrite_existing = true); ERROR: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/eX5vA/src/netcdf_c.jl:255; [2] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/eX5vA/src/dataset.jl:201; [3] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508:39,error,error,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103318508,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"> > Thanks @navidcy for pointing this out.; > > I can see that now we loop over `float_types`, but I don't see where this is set to `[Float32, Float64]`, as it is in other tests. Maybe I'm missing something?; > ; > https://github.com/CliMA/Oceananigans.jl/blob/0ddffe59457ece2b07452a421a8125abf4f4820f/test/runtests.jl#L54. Ah, thanks, I was looking in the script that was modified. It makes sense that it's specified in `'runtests.jl`. Thanks @navidcy for the clarification. I am happy to see this change and that the tests all pass. I'm confused about the error that we're getting in #1780 .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1782#issuecomment-870171220:558,error,error,558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1782#issuecomment-870171220,1,['error'],['error']
Availability,"> > Thanks @tomchor , and very nice.; > > What would the difference of those two curves look like in the region where there is no masking? Are they identicial or just similar?; > ; > In the simulations without the IBM that region does't exist! The domain in those cases starts at `z=0`. And in the simulation with IBM that region exists, but lies inside the immersed solid. I meant in the physical region. The curves look like they overlap but if you plotted the difference you could see how much they differ in the physical domain. Just an idea.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074479039:130,mask,masking,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074479039,1,['mask'],['masking']
Availability,"> > The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates.; > ; > You mean the convention not only specifies what you have to output but also disallows _additional_ information?. I had interpreted something as saying that it puts limits on the metadata in files, but it turns out I misinterpreted. So no, it doesn't disallow anything afaik. I amended my previous statement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516716556:8,down,downside,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516716556,1,['down'],['downside']
Availability,"> > The plume emerging from the tracer is due to leakage right? It's a nice way to visualize it quickly.; > ; > Yes. Without the masking, the 0 concentration in the cylinder just leaks out until it's replaced by the fluid concentration. You can see it in this one:; > ; > contours_tracer_Nh_1000_5thOrder.mp4. Hmm, that's another way to visualize the leakage.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1888#issuecomment-885164695:129,mask,masking,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888#issuecomment-885164695,1,['mask'],['masking']
Availability,"> > The way it's written though is not ready to go into the literated examples list.; > ; > Can you elaborate? What isn't ready about it? If there are ways to make it shorter or better, we should definitely do that in this PR rather than later!. I can elaborate. What I meant is that this example, although it's Literate-ready, it does not provide any explanation to the reader about what's coming. All other examples come with remarks of the sort ""we now build the grid""... ""Next, let's form a model with two tracers..."", ""now all what's left to do is to run the simulation""... On the other hand, this example just list down the commands without any explanation. I'm not saying that's bad. It's just different from the rest of the examples. I think it's perfect for the README file but. in my opinion, you don't wanna see this as your first example if you are reading the docs because it doesn't really take you from the hand and guide you to feel welcome in all this new Oceananigans.jl terminology. To conclude: I think we should add it to the Literate examples list, e.g., in `docs/make.jl`. ```julia; examples = [; ""hello_ocean.jl"",; ""one_dimensional_diffusion.jl"",; ""two_dimensional_turbulence.jl"",; ""internal_wave.jl"",; ""convecting_plankton.jl"",; ""ocean_wind_mixing_and_convection.jl"",; ""langmuir_turbulence.jl"",; ""eady_turbulence.jl"",; ""kelvin_helmholtz_instability.jl""; ]. for example in examples; example_filepath = joinpath(EXAMPLES_DIR, example); Literate.markdown(example_filepath, OUTPUT_DIR, documenter=true); end; ```. This way, docs will fail if the code cannot run the `hello_ocean.jl`. But we shouldn't add it in th e; but don't in the `example_pages` list. Rather, we should include this as part of the README. That's all what I meant. My 2 cents have been now deposited in this PR. :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727728558:621,down,down,621,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727728558,1,['down'],['down']
Availability,"> > There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl; > ; > @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_. Looks like that validation experiment is missing . ```julia; pushfirst!(LOAD_PATH, joinpath(@__DIR__, "".."", "".."")); ```. ~~so it may have been using an old version of Oceananigans in your global environment!~~ EDIT: even if this were the case, I still get the error after adding an appropriate `pushfirst!`. I'll try to fix this separate from this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685:305,error,error,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685,2,['error'],['error']
Availability,> > There is something fishy with MPI.jl..; > ; > CPU or GPU (or both!) ?. There are only `CPU distributed tests` and they are failing before they even start:; https://buildkite.com/clima/oceananigans/builds/3587#c5384940-778a-42c1-842b-c57c1209b786. This error beats me. :(,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891514571:256,error,error,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891514571,1,['error'],['error']
Availability,"> > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > ; > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`. Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540:946,error,error,946,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540,2,['error'],['error']
Availability,"> > This is the issue that described what I was seeing: #3290; > > @johnryantaylor does that looks like what you're seeing?; > > If so, the two workarounds that I have come up with are; > > ; > > * to run on branch [Don't separate the pressure into hydrostatic and nonhydrostatic in `NonhydrostaticModel` #3080](https://github.com/CliMA/Oceananigans.jl/pull/3080) like @glwagner suggested (downside here is that this branch is kinda out-of-date and apparently stale); > > * Make the `x` (or `y`) directions periodic (seems like `x`already is in your case) and tilt the domain accordingly. (The second video in [Having a domain that's periodic in the ""gravity"" direction doesn't work for `gravity_unit_vector = NegativeZDirection()` #3290](https://github.com/CliMA/Oceananigans.jl/issues/3290) illustrates that); > > ; > > If that's not your issue, do you mind posting the animatino you're generating?; > ; > And just to confirm @tomchor those issues are not associated with BackgroundField, right?. If it's the same issue as the one I pointed out in #3290 (which is not 100% clear atm), then you're right, they're not associated with `BackgroundField`. They have to do with trying to enforce a periodic pressure when the hydrostatic pressure is aperiodic on `z` due to the fact that it comes from a `b` integral in `z`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782233834:390,down,downside,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782233834,2,['down'],['downside']
Availability,"> > This update just fixes a trivial problem with the test though, which we need so that tests pass on `main` (we can't merge any PRs until we fix this urgent issue).; > > I suggest that we fix more substantial issues with the test in a future PR? It might be helpful to open an issue with some of your comments too @christophernhill; > ; > @glwagner that sounds OK.; > ; > the include(""dependencies_for_runtests.jl"") breaks; > ; > ```; > export TEST_FILE=test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl; > /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; > ```; > ; > workflow because of; > ; > ```; > const AB2Model = NonhydrostaticModel{<:QuasiAdamsBashforth2TimeStepper}; > ```; > ; > in; > ; > ```; > utils_for_runtests.jl; > ```; > ; > which can't be redeclared since its const? Is there a trick to fix that?. It should be ok to redeclare a `const` as something identical:. ```julia; julia> const a = 1; 1. julia> const a = 1; 1. julia> const a = ""hi""; ERROR: invalid redefinition of constant a; Stacktrace:; [1] top-level scope; @ REPL[3]:1; ```. So it's not re-including the file that's a problem, but rather conflicting definitions of `AB2Model`. But I don't know why this issue wouldn't also arise if `dependencies_for_runtests.jl` is included even just once. I'll look into it. PS I recommend using `include` rather than running a single-file test because if any debugging needs to be done, the test will run again on the second `include` very quickly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384:1023,ERROR,ERROR,1023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002699384,1,['ERROR'],['ERROR']
Availability,"> > To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain.; > > I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance...; > ; > Yes I think we'd need to use `Pycall`. I agree that's hard to maintain so let's not pursue that now.; > ; > I still think it'd be good to show one example with `NetCDF` writer though. Here's a question: is post-processing results directly in julia (making animations, plots, etc.) using the `NetCDF` output as easy as with the `jld2` output?. There's currently one example with NetCDF: https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/. I'm not totally sure what's meant by easy. If plotting arrays, then the tasks are identical. If using `FieldTimeSeries` (to perform non-trivial finite volume calculations in post-processing for example) then that isn't supported with `NetCDFOutputWriter` (this is possible, but requires someone passionate about NetCDF to put in the effort there).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-954122449:433,mainten,maintenance,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-954122449,1,['mainten'],['maintenance']
Availability,> > Usually restarting the test works for me to clear that error; > ; > Good to know. How can I do that?. I don't think you can because you need access to the Clima buildkite. But @simone-silvestri can do it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180:59,error,error,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180,2,['error'],['error']
Availability,"> > We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI.; > > You mind if I revamp this PR and try to see what we need to do to update CUDA? I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0); > > Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3; > ; > That is very exciting! Do you know of any scaling results that people have done using this multiGPU approach? I'd be keen to try this with Oceananigans when it's working. I know that we tried using MPI and GPU last summer and had some problems. One, getting it to work was a pain. Two, the effiicency dropped down to 60% when going fro 1 to 2 GPUs. I now we can do better, and maybe this is a way of doing that. One key problem to solve is that we cannot pass non-contiguous data between GPUs without scalar operations. This affects both ""direct"" communication via the CUDA.jl API and cuda-aware MPI. As a result passing non-continuous data is _extremely_ slow and is probably the primary reason for the abysmal multi-GPU scaling we saw. I believe @simone-silvestri is going to use a single layer buffer to pass halo data (copy halo to buffer, pass to buffer on remote device, then copy from remote buffer to remote halo). Once that's implemented we can potentially use the same code for a multi-node implementation via CUDA-aware MPI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044990716:731,down,down,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044990716,1,['down'],['down']
Availability,"> > We'll be looking here for previews: https://clima.github.io/OceananigansDocumentation/previews/PR3673; > ; > I tried this link but received a 404 error. Does it work for others?. It errors for me too! Nothing will come up until the docs build passes, looks like it is still failing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2260849231:150,error,error,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2260849231,2,['error'],"['error', 'errors']"
Availability,"> > What's the error with `TimeInterval`?; > ; > I think the issue was the interval being stored as a Float64, but I'm not sure why that would ever endup in a kernel. (copy-pasting from #2618). One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698:15,error,error,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698,1,['error'],['error']
Availability,"> > When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > > ```julia; > > ERROR: LoadError: UndefVarError: `settings` not defined; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > > ```julia; > > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > > ```; > ; > Do you need help fixing these?. @glwagner thanks for your help on Zoom yesterday. @navidcy thanks for creating a new PR #3305 to fix the second issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712:61,error,errors,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712,4,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,"> > With this last commit the bottom drag should be working for `u` at least, which shows that the function calls are working. Expanding it to other components and directions is now straightforward.; > > Here's a video comparing this IBM with drag BC with two non IBM models (one with no-slip BC, and another with drag BC):; > > u_drag.mp4; > ; > So the blue and dashed green curves should coincide, which they do for most of the domain, but there's the begging part of the dashed curve that doesn't seem to have blue. Is that a plotting issue or is there something I'm missing?. That's the immersed solid, where the velocities are masked to zero :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074209813:632,mask,masked,632,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074209813,1,['mask'],['masked']
Availability,"> > You're gonna want to implement a struct that's someting like; > > ```julia; > > struct HaloFillingEvent; > > location; > > z_indices; > > from_side; > > to_side; > > field_id; > > end; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > and then a function; > > ```julia; > > mpi_tag(hfe::HaloFillingEvent) = # number; > > ```; > ; > I am not sure about this solution. The tag is used immediately (and only) where created, not recorded, and automatically destroyed by MPI after the communication is complete, so I do not immediately see the immediate utility of extra steps, or to save something in memory. A function that, given architecture, location, and side, spits out a unique tag seems sufficient for interpretability without having to record the output somewhere (it's a bit like a hash function, if you have function and inputs you have everything you need). There are a few purposes:. - Make it easier for a future developer to understand the code by using words rather than a digit code; - Make debugging possible; - Replace this:. ```; arch.active_requests[] += 1; ```. with an actual list of the active requests (rather than simply counting them --- eg `push!(active_events, new_event)`, and `pop!(active_events, finished_event)`. The objective is not to write the minimal code that will work, but to create a system that is human understandable. While a minimal functionality can be debugged and made to work once, it will be very brittle because if it breaks, it could shut down the whole system and prevent future development. Also `active_requests` used to be called `mpi_tag` and I don't understand the relationship between those two concepts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298985401:1520,down,down,1520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298985401,2,['down'],['down']
Availability,"> > `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.; > ; > Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?). It's possible to do anything really, the `.toml` files are ordinary text files. The second question is the important one --- what's the best way to do this that causes least headaches.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039:186,down,downgrades,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090381039,1,['down'],['downgrades']
Availability,"> > `test_dynamics.jl` fail.; > > Is this correct here?; > > https://github.com/CliMA/Oceananigans.jl/blob/ad110ecdc635192c110e229df4fbfa04fc7a2266/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L39-L41; > > ; > > I guess it should be `if formulation == VerticallFormulation() and ...`?; > ; > No that's correct --- we can't use vertically implicit time-stepping with `HorizontalFormulation`.; > ; > The reason is that `HorizontalFormulation` has no vertical terms. Then the error message should be `only supported for `VerticalFormulation or ThreeDimensionalFormulation""`, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2288#issuecomment-1059284185:508,error,error,508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2288#issuecomment-1059284185,1,['error'],['error']
Availability,"> > but this errors with Reason: unsupported call to an unknown function (call to jl_f_getfield), so I'm not sure its going to be straight forward or worthwhile trying to make the high level version work on GPU.; > ; > I think that's because within a kernal on the GPU, `field` in; > ; > ```julia; > @inline function interpolate(field, x, y, z); > LX, LY, LZ = location(field); > grid = field.grid; > return interpolate(field, LX(), LY(), LZ(), grid, x, y, z); > end; > ```; > ; > is an OffsetArray and has no property `grid` (or a location). Ah this makes sense, thank you",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370811046:13,error,errors,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370811046,1,['error'],['errors']
Availability,"> > might either throw an error or fill the LHS with junk or incorrect values; > ; > I'm not that happy mostly because it seems we don't understand? Why ""might""?. I guess I used ""might"" because I don't fully understand it either. What I meant to say is that the line; ```julia; u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn; ```; throws an error due to a dimension mismatch and the line; ```julia; u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; fills the LHS with junk values. Hence the workaround I proposed above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2034626926:26,error,error,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2034626926,2,['error'],['error']
Availability,"> > potentially with a default value of overwrite_existing = false.; > ; > Do you run with `overwrite_existing=false`? (Outside the context of restoring from a checkpoint.). I agree, that is not a common use case scenario. I have only used `overwrite_existing=false` without a checkpoint for short tests within the same Julia instance to extend the model output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391892045:160,checkpoint,checkpoint,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391892045,2,['checkpoint'],['checkpoint']
Availability,"> @Sbozzolo might be able to help because I believe they do something special to avoid round off issues in `ClimaAtmos`. With regards to floating point instabilities due to arithmetic with time and time intervals, ultimately, we will be solving this issue (and others) by moving away from a floating point time in favor of an integer one (e.g., milliseconds from a start date). As a fun fact, if you are using Float32 and keep track of your time in seconds, `t + dt` is going to have numerical error after approximately one year of simulated time (which is not that much).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153112248:494,error,error,494,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153112248,1,['error'],['error']
Availability,"> @christophernhill do you think you could produce a script with non-trivial dynamics involving the `HydrostaticFreeSurfaceModel` and the implicit solver?; > ; > We should also come up with something that exercises the tridiagonal solver on a vertically-stretched grid. @glwagner @francispoulin and @hennyg888, we could start from https://github.com/CliMA/Oceananigans.jl/blob/master/validation/barotropic_gyre/barotropic_gyre.jl ? I'll check that it is still healthy. We can make the number of points bigger or smaller to look at problem size. Do we want to also try `RegularLatitudeLongitudeGrid` or should we do a box first . This also has an `ImmersedBoundaryGrid` bump in the domain - we can get rid of that for now, but could include that too down the road. . We should be able to add some vertical levels to this and turn on some implicit vertical diffusion - which is another tridiagonal solve?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894291059:749,down,down,749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894291059,1,['down'],['down']
Availability,"> @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?; > ; > If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up.; > ; > The motvation is to assess how much of this is due to pressure errors versus other stuff. I think it would work flawlessly in that case!. This PR is all about viscous fluxes across immersed boundaries, so when we implement a viscous closure for `ShallowWaterModel` we can try to setup flow around islands or something and do a similar analysis as we've done here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101515457:339,error,errors,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101515457,2,['error'],['errors']
Availability,"> @glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?; > ; > If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up.; > ; > The motvation is to assess how much of this is due to pressure errors versus other stuff. I'm looking at the time-series of total momentum --- the line goes down, but also _up_! So momentum is _increasing_ inside the domain, transiently. I didn't try to connect this with the vorticity field but maybe you can draw some conclusions!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101514179:339,error,errors,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101514179,3,"['down', 'error']","['down', 'errors']"
Availability,"> @glwagner CUDA aware MPI is supported for 11.2 but it is only built against OpenMPI 4.1.0 and 4.1.1, I think we had previously 4.0.4. Also julia 1.6.2 is available. good beta, I'll upgrade, thanks!. > looks like maybe some more race conditions on different hardware?. Heh yeah, pretty interesting. sverdrup is running on Quadro P6000 with CUDA 11; tartarus (where we sometimes run tests for development) has a Titan V, also I think with CUDA 11. These are running on a P100? With this new CI I'll need to make sure I can log in to central to debug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484:156,avail,available,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484,1,['avail'],['available']
Availability,"> @glwagner I am running into issues when setting up a 3D simulation. I am not sure where the error is coming from but I suspect it comes from a typo in `/Oceananigans/MuMNB/src/Operators/divergence_operators.jl` line 62, where `Ayᵂ ` is defined but not used. Should it be `Ayˢ`?. Nice catch! Thank you!!! Indeed, all the cases I was running were `Flat` in `y` and so I didn't catch that bug. The issue is clear:. https://github.com/CliMA/Oceananigans.jl/blob/22286264ced8707fcdcb3d983b0b53e7f73907d2/src/Operators/divergence_operators.jl#L62-L68. PS you might already know but just in case, here's some tips for github: you can generate a link by browsing the code and clicking on the line number to bring up a prompt:. <img width=""473"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/164772983-7776dd60-7da0-4371-88b7-0475156f35fb.png"">. when you paste the link in a PR like this one it will show the line:. https://github.com/CliMA/Oceananigans.jl/blob/22286264ced8707fcdcb3d983b0b53e7f73907d2/src/Operators/divergence_operators.jl#L67. In addition, you can actually go into ""Files changed"" on this PR and _suggest_ the change directly: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/incorporating-feedback-in-your-pull-request",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106758714:94,error,error,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106758714,2,['error'],['error']
Availability,"> @glwagner I might need help with this one. When I try to use `ZDirection` I keep getting this KA-related error:; > ; > ```julia; > Batched tridiagonal solver [CPU()]: Error During Test at /home/tomas/repos/Oceananigans.jl3/test/test_batched_tridiagonal_solver.jl:169; > Test threw exception; > Expression: can_solve_single_tridiagonal_system(arch, Nz; tridiagonal_direction); > MethodError: no method matching work_layout(::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ::Nothing; include_right_boundaries=false, reduced_dimensions=(), location=nothing, only_active_cells=false); > Closest candidates are:; > work_layout(::Any, ::Tuple; kwargs...) at ~/repos/Oceananigans.jl3/src/Utils/kernel_launching.jl:33; > work_layout(::Any, ::Symbol; include_right_boundaries, location, reduced_dimensions, only_active_cells) at ~/repos/Oceananigans.jl3/src/Utils/kernel_launching.jl:51; > Stacktrace:; > [1] launch!(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ::Nothing, ::typeof(Oceananigans.Solvers.solve_batched_tridiagonal_system_kernel!), ::Array{Float64, 3}, ::Vararg{Any}; include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, only_active_cells::Bool, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1564940399:107,error,error,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1564940399,2,"['Error', 'error']","['Error', 'error']"
Availability,"> @glwagner I remember now why the right-hand side `b` is an `AbstractVector{FC}`: I use the type `FC` for type stability with the keyword arguments (tolerances, etc.) as well as default values (`sqrt(eps(real(FC)))`). True but then you could use `AbstractArray{FT}` similarly right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415654627:150,toler,tolerances,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415654627,1,['toler'],['tolerances']
Availability,"> @glwagner I tested the fix locally, seems to fix the issue. I was also catching up with a past discussion on turbulence closure (#1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Ah, a closure tuple! We might need to add more code to support that. Can you paste the whole error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106756075:265,error,errors,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106756075,2,['error'],"['error', 'errors']"
Availability,"> @glwagner I tested the fix locally, seems to fix the issue. I was also catching up with a past discussion on turbulence closure (#1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Here's a question. Doing wall-resolved LES is a bit tricky here. In the way the code is written, the diffusivity for wall fluxes with value or gradient boundary condition is derived from the model closure. For closure tuples, the logical thing to do is to add all the diffusivities together to come up with the immersed flux. However, this means that to do wall resolved LES we have to solve a tricky problem which is how to specify that the LES diffusivity has a value of 0 on the boundary. The interface implemented here doesn't support that; when we write `ValueBoundaryCondition(0)` what that means is that we add fluxes to a tendency consistent with `ValueBoundaryCondition(0)`. (The alternative, which would essentially mean ""return `0` when the field is reconstructed on boundary faces"" requires feeding boundary conditions into the reconstruction operator used by the closure. Doing that would substantially complicate the code.) This means effectively that there's no way to set the LES diffusivity to 0 on an immersed boundary. Even if there were a way to ensure this, it's also inconvenient to have to specify boundary conditions on the LES diffusivities... An alternative approach might attach a diffusivity / viscosity to the immersed boundary condition. Then the closure is ignored when calculating the immersed flux and the ""boundary diffusivity"" is used instead. This has some convenience downsides (ie diffusivity values have to be passed both to the closure _and_ the boundary condition), but would a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166:265,error,errors,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166,1,['error'],['errors']
Availability,"> @glwagner I'm not sure whats causing these tests to fail now?. @jagoosw afaik sometimes we get errors of the kind. `ERROR: LoadError: SystemError: opening file ""/data5/glwagner/.julia-10703/compiled/v1.8/Oceananigans/hU93i_Y0P9A.ji"": No such file or directory`. on the gpu tests. Which is what's hapenning now. It's now clear to me at least what the cause is, but restarting the tests generally makes them pass. I just restarted them so it be fine. I should note that we got an error of the kind. `Expression: all(test_fields.v .≈ truth_fields.v)`. in the GPU shallow water tests, which I thought were corrected. Is this something we need to worry about?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1481364658:97,error,errors,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1481364658,5,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,"> @glwagner Yes you are right. I tried restarting Julia, and it worked without the error message. Sorry!. no worries!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386940947:83,error,error,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386940947,1,['error'],['error']
Availability,"> @glwagner, I tried to add a test but look,; > ; > ```julia; > julia> using Oceananigans; > ; > julia> grid = RectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1)); > 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.5; > └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.5; > ; > julia> Fu = ones(size(grid)); > 2×2×2 Array{Float64, 3}:; > [:, :, 1] =; > 1.0 1.0; > 1.0 1.0; > ; > [:, :, 2] =; > 1.0 1.0; > 1.0 1.0; > ; > julia> model = NonhydrostaticModel(; grid, forcing=(u=Fu,)); > ERROR: TaskFailedException; > ; > nested task error: MethodError: objects of type Array{Float64, 3} are not callable; > Use square brackets [] for indexing an Array.; > Stacktrace:; > [1] u_velocity_tendency; > @ ~/Research/OC10.jl/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:71 [inlined]; > [2] cpu_compute_Gu!; > @ ~/.julia/packages/KernelAbstractions/Zcyra/src/macros.jl:287 [inlined]; > [3] cpu_compute_Gu!(__ctx__::KernelAbstractions.CompilerMetadata{…}, Gu::Field{…}, grid::RectilinearGrid{…}, interior_map::Nothing, args::Tuple{…}); > @ Oceananigans.Models.NonhydrostaticModels ./none:0; > [4] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); > @ KernelAbstractions ~/.julia/packages/KernelAbstractions/Zcyra/src/cpu.jl:115; > [5] (::KernelAbstractions.var""#18#21""{…})(); > @ KernelAbstractions ~/.julia/packages/KernelAbstractions/Zcyra/src/cpu.jl:90; > ; > ...and 1 more exception.; > ; > Stacktrace:; > [1] sync_end(c::Channel{Any}); > @ Base ./task.jl:448; > [2] macro expansion; > @ ./task.jl:480 [inlined]; > [3] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1986430708:639,ERROR,ERROR,639,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1986430708,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"> @glwagner, am I correct that this warning is only needed when 1) `hydrostatic_pressure_anomaly = nothing` and 2) immersed boundaries are being used?. The pressure solver is incorrect even with `hydrostatic_pressure_anomaly = CenterField(grid)`, just that apparently only the nonhydrostatic part is incorrect so the error is smaller than with `hydrostatic_pressure_anomaly = nothing`.; #3188 should solve this issue",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2271774772:317,error,error,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2271774772,1,['error'],['error']
Availability,"> @glwagner, how can we avoid `collect`? E.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130; > ; > I tried `arch_array` but seems like we need to write some more methods for it?; > ; > ```julia; > julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); > ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[6]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ; > julia> r_array = arch_array(arch, interior(r)); > ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[7]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```. Why do you need to convert to architecture? Is it enough to use. ```julia; r_reshaped = reshape(interior(r), Nx * Ny * Nz); ```. ?. If you can't use that then I think y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492:381,ERROR,ERROR,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492,1,['ERROR'],['ERROR']
Availability,"> @glwagner, regarding the; > ; > ```julia; > ERROR: LoadError: UndefVarError: bc not defined; > ```; > ; > in the Docs, is it related to; > [JuliaDocs/Documenter.jl#228](https://github.com/JuliaDocs/Documenter.jl/issues/228); > perhaps?. Nice find!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879849296:46,ERROR,ERROR,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879849296,1,['ERROR'],['ERROR']
Availability,"> @liuchihl Have you tried running on the CPU to see if you get a more useful error message?. Thanks, I'll give that a try. I could be wrong, but my guess is that the issue might be related to the use of GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429704389:78,error,error,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429704389,1,['error'],['error']
Availability,"> @liuchihl I think the best way forward is to write a simple test that illustrates the error. Then I can help fix the error to make the test pass. Once that is done, we may be ready to merge this PR. What do you think?. Sure, I agree with that! I will work on that and let you know how it goes. . > PS it is always best to work with minimal examples, and to paste code directly into a discussion stream (rather than providing links). This will help us keep up an efficient workflow. For sure, sorry about that, I haven't been able to create an MWE for this specific issue because I don't understand the problem yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433226812:88,error,error,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433226812,4,['error'],['error']
Availability,"> @navidcy Due to #1995 is it worth pinning CUDA.jl to the current version? Might also _magically_ fix some GPU issues although I see that `cpu-time-stepping-tests-2` is also failing. I'll try this. However, these GPU-related error started appearing in #1994 as well...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-930528128:226,error,error,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-930528128,1,['error'],['error']
Availability,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:204,error,error,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155,5,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,> @siddharthabishnu there are errors on the tests on GPUs:; > ; > https://buildkite.com/clima/oceananigans/builds/15275#018e8708-1af0-41a5-9a4a-e9d5e2bc223c/24-757. Maybe due to the absence of `@CUDA.allowscalar` in the `fill_cubed_sphere_halo_regions!` methods?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2033411187:30,error,errors,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2033411187,1,['error'],['errors']
Availability,"> @simone-silvestri, seems like the output writer is trying to save with halos despite `with_halos = false`. https://buildkite.com/clima/oceananigans/builds/8658#018376f6-45e7-4a9b-a40f-c9d5c76d5517/27-398; > ; > Is this a clue?. I tried to trace it down. What's happening is that . https://github.com/CliMA/Oceananigans.jl/blob/c08e3d8c1b2e6639a2726bc544885ebf8853e504/src/OutputWriters/netcdf_output_writer.jl#L423. returns a `data` as an array **with the halos** (wrongly probably) and then. https://github.com/CliMA/Oceananigans.jl/blob/c08e3d8c1b2e6639a2726bc544885ebf8853e504/src/OutputWriters/netcdf_output_writer.jl#L424. fallsback to . https://github.com/CliMA/Oceananigans.jl/blob/c08e3d8c1b2e6639a2726bc544885ebf8853e504/src/OutputWriters/netcdf_output_writer.jl#L489",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1257482155:250,down,down,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1257482155,1,['down'],['down']
Availability,"> @tomchor @whitleyv what's the ultimate vision for this PR. I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. So I'd prefer something a little more exact.) Hard coding this option in is mostly a test to see how it would go while using the available framework, before creating a full method that users would be able to implement nicely. . Implementing immersed boundary conditions as a separate term would work, I believe! A `value` immersed option wouldn't involve as much effort (as we've previously worked out for no slip), besides getting the direction correct. I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953:593,avail,available,593,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953,1,['avail'],['available']
Availability,> @tomchor Not sure if this is the issue but have you tried adapting `ScaleInvariantSmagorinsky` for the GPU?; > ; > Looks like `ScalarBiharmonicDiffusivity` needed it here:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L109-L113; > ; > Not sure why `update_frequency` is coming up as an `Integer` (which is an abstract supertype) instead of `Int` (which is a concrete type and an alias for `Int64`) but maybe adapting will fix this?. I tried that and got a different error. But now looking at `ScalarBiharmonicDiffusivity` I think I probably did something wrong. I'll try again soon!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313450686:607,error,error,607,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313450686,1,['error'],['error']
Availability,"> @tomchor Which version of GPUCompiler are you trying to pin to? It's not listed in `Project.toml` and so the pin is not effective. @vchuravy Maybe pinning wasn't the right word to use. I'm doing `]add GPUCompiler@0.16.4` and then `]rm GPUCompiler`, which ensures that Manifest.toml retains version 0.16.4 even though GPUCompiler doesn't appear in `Project.toml`. That's probably not the best-practices way to do things, but afaik it works. That was the only way I could get tests passing in https://github.com/CliMA/Oceananigans.jl/pull/2865. The issues I was seeing there were very similar to the issues that appeared in https://github.com/CliMA/Oceananigans.jl/pull/2782 and to some degree in https://github.com/CliMA/Oceananigans.jl/pull/2899, so I suspect keeping `GPUCompiler.jl` will help make those tests pass (or least narrow down what the issues are). The reason tests didn't pass here here is because there's an error related to the `always_inline=true` flag, which (based on your comment [here](https://github.com/CliMA/Oceananigans.jl/pull/2899#issuecomment-1416876175), hasn't made it into the `main` channel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2900#issuecomment-1418258822:836,down,down,836,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2900#issuecomment-1418258822,2,"['down', 'error']","['down', 'error']"
Availability,"> @tomchor can you clarify what you mean when you say you expected the ""gaussian function to be set-up with a sharp cut-off""? Do you mean you expected the width of the Gaussian to be narrower?. No, I mean I expected the sponge layer to be confined to a finite part of the domain. That is, I expected the sponge layer to be _identically_ zero for most of the domain. Us not ""being on the same page"" here (for the lack of a better description! haha) may be due to different philosophies of what a sponge layer should be. So, due to my background, a sponge layer should be a function that _only_ acts in a _finite_ part of the domain. So, for example, in my code I set-up the sponge layer mask as. ```; mask = H(-(z-z₀)) ⋅ (z - z₀)² / (z₁ - z₀)²; ```; with H(z) being the Heaviside function. Comparing this to the Gaussian mask, this has a disadvantage of not being as smooth (although it should be smooth enough because of the (z - z₀)² / (z₁ - z₀)² term, and we can always increase the order of the exponents). However it has a very important advantage: I know _exactly_ when it stops influencing my solution. So I know that in the range `(z₀, max(z)]` my solver is solving the NS equations (plus or minus some approximations) without any added nonphysical term. I was always taught (and I still agree) that setting up a sponge layer mask as something that only reaches zero at infinity (like a Gaussian) is not recommended since you don't know when do start believing your solution. In practice if you're 4σs away from the center of the Gaussian you're pretty sure that the sponge layer influences are minimal (but they're not exactly zero!). But a harder question is: how far away is far enough?. A note here should be that if my mask was simply `mask = H(-(z-z₀))` it would probably fail as a sponge layer because, as @navidcy and @glwagner have pointed out, it would reflect a ton of waves. So the transition should be done with care. So, again, I think it boils down to your background and modelin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-734431314:686,mask,mask,686,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-734431314,3,['mask'],['mask']
Availability,"> @tomchor did you try the MWE in #2018 with this fix and it's all good?. It fixes it for CPUs, but I get an error for GPU architecture. It's likely that we need to allow scalar operations due to `==`. I'm planning on trying that tomorrow and I won't merge before it also works for GPUs. (I was wondering if we should add this as a test...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945212788:109,error,error,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945212788,1,['error'],['error']
Availability,"> @tomchor not sure this helps... Thanks for answer! I understand that apparently the issue is having a function in an `AbstractOperation`, right? I'm confused as to why this wasn't a problem in your example though (boundaries aside, of course). My main question is: if this is indeed a limitation, is there any interest in improving/changing this in any way? From the point of view of a naive user like myself, it's odd that I can add two things without any error/warning, they get calculated normally, and then in the end the result is wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768780674:459,error,error,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768780674,1,['error'],['error']
Availability,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:513,error,error,513,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769,4,['error'],['error']
Availability,"> @tomchor the description of this issue is a little vague. The dynamics weren't ""weird"" --- the problem was a bug in reconstructing buoyancy in the momentum equations, right? It'd be nice to add a little more explicit description of the original issue. I think there is a PR that fixed the bug that we can point to as well. The issue is that the videos aren't available anymore and, apart from the internal wave packet example, I don't really remember what was happening well enough to be able describe it objectively. That said, I did my best to make the description more clear and linked the PR that solved the bug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1616803081:361,avail,available,361,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1616803081,2,['avail'],['available']
Availability,"> @tomchor this may affect your results. Suprisingly, with this change the velocity field appears to _both_ divergence free _and_ satisfies impenetrability. Prior to this PR, the velocity was not divergence free. Thus I think this is important for correctness. Do you want to evaluate it?. Wow that's interesting. I don't know if I have the time to evaluate this right now, so feel free to move forward without me. But if you observe that the velocity retains impenetrability and is now divergence-free then there are no downsides to this PR!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2892#issuecomment-1414102299:521,down,downsides,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2892#issuecomment-1414102299,1,['down'],['downsides']
Availability,"> @weymouth Is iterating between the application of the boundary conditions and the pressure correction what you would recommend if we determine the errors are unacceptably large?. In my work, we adjust the matrix. However, I think the iteration approach might be sufficient. I'm sure I've seen it used before on other people's work. Fadlun, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-859073668:149,error,errors,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-859073668,1,['error'],['errors']
Availability,"> A centered second order advection should be okay but you have to pair it with some diffusion otherwise oscillatory errors will break your solution. True! At least we know what's going on. Thanks @simone-silvestri!. Here it is without any diffusion:. https://github.com/CliMA/Oceananigans.jl/assets/7112768/626e976e-2a75-4b66-ba7d-8a8614ad4ef8. And here it is with `ScalarDiffusivity(; κ=1e-2)`:. https://github.com/CliMA/Oceananigans.jl/assets/7112768/8e3d924c-1165-49fa-a047-786d1d287479. You can still ""see"" the corner.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3266#issuecomment-1723549969:117,error,errors,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3266#issuecomment-1723549969,1,['error'],['errors']
Availability,"> A more hierarchical organization of the docs is; > ; > 1. Introduction; > ; > * What's Oceananigans?; > * Installation; > * Writing your first script; > 2. Examples; > 3. Model setup; > ; > * Fields, BoundaryCondition, and AbstractOperations; > * IncompressibleModel; > * HydrostaticFreeSurfaceModel; > * ShallowWaterModel; > * Setting initial conditions; > * Diffusion, viscosity, and TurbulenceClosures; > * Forcing functions; > * Coriolis forces; > * Buoyancy forces; > 4. Simulations and post processing; > ; > * Simulation; > * OutputWriters; > * OutputReaders, post-processing, and plotting; > 5. Useful tips; > ; > * Using Graphics Processing Units (GPUs); > * Common errors and performance pitfalls; > 6. Contributor's guide; > 7. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); > 8. Physics and numerical implementation; > 9. Appendix. I wholeheartedly agree with this structure :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116:677,error,errors,677,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116,2,['error'],['errors']
Availability,"> A short summary of the physics of this example and what we expect to see would be useful for helping debug issues with the setup. @wenegrat Feel free to correct / chime-in here. But here's a short summary from what I understand:. This script simulates a bottom boundary layer developing over a sloping bottom. This is simulated in a horizontally-periodic set-up (horizontally meaning parallel to the bathymetry) starting from rest with a uniform flow in the y-direction that is immediately subject to bottom drag. The interaction between flow and topography creates a bottom Ekman layer with downslope Ekman transport that crosses isobaths and advects lighter fluid under dense fluid, creating convective mixing. Furthermore, when this BBL reaches thermal wind balance (or possibly even earlier than that I guess) it also creates a region of negative potential vorticity, which is unstable to symmetric/centrifugal instabilities. So basically we expect turbulence at the bottom due to gravitational and symmetric/centrifugal instabilities (in addition to the some shear instabilities I guess).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885211037:594,down,downslope,594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885211037,1,['down'],['downslope']
Availability,"> A test would be nice to come along with this PR. I can help out with that if you want. Thanks! I'll take you up on that if you don't mind. Given that you said that other grids also have arrays, it might be best to expand checkpoint testing for all grids?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219284:223,checkpoint,checkpoint,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219284,1,['checkpoint'],['checkpoint']
Availability,"> Actually, I get NaNs in the `h` field after just one time step... It must be an implementation error. A great thing to observe! I am happy to chat if you wanted to discuss what's going on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129129182:97,error,error,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129129182,1,['error'],['error']
Availability,"> Actually, it is curious that for some reason things do work out correctly if setting to a `Field`:; > ; > ```julia; > julia> d = CenterField(grid);; > ; > julia> view(d, :, 1, 1) .= view(c, 1, :, 1);; > ; > julia> interior(d, :, 1, 1); > 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; > 0.06779701769558852; > -1.1932513091536738; > -1.1239966299690682; > ; > julia> interior(c, 1, :, 1); > 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; > 0.06779701769558852; > -0.5935171905074843; > 1.399692772040493; > ```; > ; > No idea why that works... @glwagner, Thanks for creating the MWE without the complication of a multiregion grid and boiling down the issue. However, I disagree on your last point. Things do not work correctly in case of a `Field`. Yes, it doesn't throw an error, but the data of `interior(c, 1, :, 1)` is not assigned to `interior(d, :, 1, 1)` except for the **first** element (as seen in your MWE and mine below). ```julia; julia> a = rand(3, 3, 3); b = rand(3, 3, 3);. julia> grid = RectilinearGrid(size=(3, 3, 3), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid); d = CenterField(grid);. julia> set!(c,a); set!(d,b);. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.006219191907858468; 0.8963174540626572; 0.06824259256136866. julia> interior(c, 1, :, 1); 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; 0.45223462463057673; 0.18046843834182114; 0.9782543808912043. julia> view(d, :, 1, 1) .= view(c, 1, :, 1); 3×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 3×3×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, 1:1, 1:1); └── data: 9×1×1 OffsetArray(view(::Array{Float64, 3}, :, 4:4, 4:4), -2:6, 1:1, 1:1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038588542:688,down,down,688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038588542,2,"['down', 'error']","['down', 'error']"
Availability,"> Add some warnings to let users know that TimeInterval and AveragedTimeInterval (and probably other diagnostic schedules) are currently broken and give incorrect results after picking up from a checkpoint whenever the checkpoint interval is not an integer multiple of the scheduled time interval. Can we make it so this warning gets thrown only if one is using a Checkpointer? I think the majority of simulations do not use a Checkpointer so the warning would be irrelevant in most cases. Maybe we should put the warning within the checkpointer constructor. Checkpointing certainly needs love. I think it's only used for barebones stuff right now, not complicated simulations. To be fully featured we have to somehow have a system for checkpointing all callbacks. It's not just `AveragedTimeInterval` that would have a problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305045146:195,checkpoint,checkpoint,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305045146,7,"['Checkpoint', 'checkpoint']","['Checkpointer', 'Checkpointing', 'checkpoint', 'checkpointer', 'checkpointing']"
Availability,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:385,toler,tolerance,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957,4,['toler'],['tolerance']
Availability,"> After this passes, would we want to include this in the docs somewhere? If yes do you have an example in mind?. This PR updates the docs for recommended checkpointer usage!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1893#issuecomment-886143177:155,checkpoint,checkpointer,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893#issuecomment-886143177,1,['checkpoint'],['checkpointer']
Availability,"> Ah CI doesn't even initialize on the CPU now...; > ; > Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):; > ; > ```julia; > shell> hostname; > tartarus; > ; > julia> ENV[""CUDA_VISIBLE_DEVICES""]; > ""-1""; > ; > julia> using CUDA; > ; > julia> CUDA.has_cuda(); > false; > ; > julia> CUDA.has_cuda_gpu(); > ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); > Stacktrace:; > [1] throw_api_error(res::CUDA.cudaError_enum); > @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; > [2] macro expansion; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; > [3] cuDeviceGetCount; > @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; > [4] ndevices; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; > [5] length; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; > [6] has_cuda_gpu (repeats 2 times); > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; > [7] top-level scope; > @ REPL[5]:1; > [8] top-level scope; > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; > ```. err, is this a bug in `CUDA.jl`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440:185,error,errors,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440,6,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,"> Ah interesting, why do you create `coarse_model`? Is that so `coarse_model.grid` gets saved down? I think we can make it so that isn't needed probably... Right now it's needed solely because `NetCDFWriter` needs a `model` to get the grid from (and maybe other stuff). I think it would be pretty easy to modify `NetCDFWriter` so that it only needs a `grid` passed, but I haven't looked into that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091027995:94,down,down,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091027995,1,['down'],['down']
Availability,"> Ah yeah this makes sense.; > ; > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > So in this case all that we should change is returning the exact same model but with a list of symbols changed to indices. Would this not be an issue if users have to explicitly declare the list of tracers?. Working on some biogeochemistry stuff with @seamanticscience, I came to the conclusion that the ""auto-adding"" of tracers has some definite downsides, like you easily forget what the tracer names are. The fact is that you have to know what the tracer names are anyways to set initial conditions. So I'm leaning towards requiring that users add tracers explicitly. It's also nice to get the error message that tells you what tracers you need, reminding you of their names. Not sure if that would help, but we may want to make that usability improvement first if its a related issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319:913,down,downsides,913,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319,4,"['down', 'error']","['downsides', 'error']"
Availability,"> Ah, I see. Sounds like it wouldn't be trivial to add that support.; > ; > I guess a workaround to avoid partially-averaged results when picking up would be to set the `Checkpointer` to only write checkpoints when the `TimeAveraged` results are also written. I'm not sure what that would do to other (more frequent) outputs though, since it'd potentially try to write some time steps twice (and not in monotonic ordering)... There are two things. One is to fix the flow of information... that's probably pretty easy because we can either 1) make `Checkpointer` a callback or 2) change `write_output!` to have the syntax `write_output(writer, simulation)` here:. https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/Simulations/run.jl#L147. then with a fallback `write_output!(writer, sim) = write_output!(writer, sim.model)`, very little has to change... The other task is to figure out how to save down the ""state"" of the time-averaging apparatus so that it can be restored correctly. That's maybe the harder part but of course unavoidable to make checkpointing work with it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1969272305:170,Checkpoint,Checkpointer,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1969272305,5,"['Checkpoint', 'checkpoint', 'down']","['Checkpointer', 'checkpointing', 'checkpoints', 'down']"
Availability,"> Ah, I see...; > ; > ```; > @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); > ```; > ; > that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree. So I pushed fd3a456.; Is there a test for that? Do we need to test that this expression is actually correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171:183,robust,robust,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171,1,['robust'],['robust']
Availability,"> All the tests seem to pass but I get two errors.; > ; > The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:43,error,errors,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748,4,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,"> Alright, thanks, that makes a lot of sense! Very nice explanation.; > ; > So, if I understand correctly, in practical terms the result of this PR is that _some_ abstract operations that didn't compile before (the ones where recursive calls to `identity` were a problem and that don't have averaged fields embedded) now compile and can be used. Right? That's a nice improvement!. Yes, I think so. I didn't test many, but I did confirm that `u - v + w` will compile (where it did not previously). The error we were previously receiving was ""dynamic function invocation error"". This is often a type inference problem: if the julia compiler cannot infer types probably, then the resulting julia code cannot be translated into CUDA. Thus the kernel still contains ""dynamic julia functions"". This is the same error we get when trying to compile operations containing `AveragedField`. But apparently the compilation issues for those kernels are different and not resolved by this PR sadly. I think there is a very specific issue associated with `AveragedField`. . We received _other_ independent errors from seemingly more complicated operations such as ""device kernel image is invalid"", and ""entry function uses too much parameter space"". I think solving these might require contributions / modifications to `CUDA.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821856913:501,error,error,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821856913,4,['error'],"['error', 'errors']"
Availability,> Also the docs seem to fail because it can't find the docs for `ShallowWatermodel`?; > ; > ```; > ┌ Error: no docs found for 'ShallowWaterModel' in `@docs` block in src/model_setup/overview.md:26-28; > --; >   | │ ```@docs; >   | │ ShallowWaterModel; >   | │; > ```. I can have a look laters,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126829436:101,Error,Error,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126829436,1,['Error'],['Error']
Availability,> Also the docs seem to fail because it can't find the docs for `ShallowWatermodel`?; > ; > ```; > ┌ Error: no docs found for 'ShallowWaterModel' in `@docs` block in src/model_setup/overview.md:26-28; > --; >   | │ ```@docs; >   | │ ShallowWaterModel; >   | │; > ```. [4d6cda6](https://github.com/CliMA/Oceananigans.jl/pull/2522/commits/4d6cda6f51e2739312ac971c459686b47618232f) should fix it! The docstring had moved away from its function :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127725566:101,Error,Error,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127725566,1,['Error'],['Error']
Availability,"> Also, did you really wanted to include `RafsPlots.jl` in the PR? :); > ; > @sandreza, I'm adding [WIP] in the PR's title to denote ""Work in Progress"". Please remove it and ping us when you feel this PR is ready to be reviewed. Thanks Navid! I think @ali-ramadhan is planning on making this branch legit and up-to-date with the latest changes",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-818259201:174,ping,ping,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-818259201,1,['ping'],['ping']
Availability,"> Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?. The idea is that we will eventually support general regridding. In this PR, we only implement vertical regridding as a start. The next case to support would be regridding for Cartesian grids; after that, for curvilinear grids. We've attempted to write an informative error:. ```julia; msg = """"""Regridding; $(short_show(v)) on $(short_show(source_grid)); to $(short_show(u)) on $(short_show(target_grid)); is not supported.""""""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923014008:457,error,error,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923014008,2,['error'],['error']
Availability,"> Also, why is dot(interior(a), interior(b)) not correct?. Won't this be incorrect if the fields are not masked? We have to explicitly exclude immersed regions when computing `dot` if masking is not guaranteed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2725#issuecomment-1260787498:105,mask,masked,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2725#issuecomment-1260787498,2,['mask'],"['masked', 'masking']"
Availability,"> Also, you don't need the `field_dependencies` argument with `discrete_form=true` (but I think that has no effect, so just a side comment, maybe we should throw an error for that). Ah yeah, I forgot to change that when I adapted it to discrete form. Thanks for catching that and for the other tips!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401359397:165,error,error,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401359397,1,['error'],['error']
Availability,"> Although I have tried non-exponential masks in the past with a similar slowdown, so I'm not sure if that's the issue. I guess the key here is something that doesn't have a transcendental function. I'd be surprised if its the issue but it's possible so worth testing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875678777:40,mask,masks,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875678777,1,['mask'],['masks']
Availability,"> Although the new `test_netcdf_file_splitting` is working, I'm currently having issues in with the `test_netcdf_time_averaging`, where this test fails.; > ; > https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/test_netcdf_output_writer.jl#L683; > ; > ; > I've tested the PR & the `main` upstream branch in my computer and I have the same error:; > ```; > Stacktrace:; > [1] macro expansion; > @ ~/.julia/juliaup/julia-1.10.2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/Test/src/Test.jl:672 [inlined]; > [2] test_netcdf_time_averaging(arch::CPU); > @ Main ~/github/Oceananigans.jl/test/test_netcdf_output_writer.jl:727; > [3] macro expansion; > @ ~/github/Oceananigans.jl/test/test_netcdf_output_writer.jl:889 [inlined]; > [4] macro expansion; > @ ~/.julia/juliaup/julia-1.10.2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/Test/src/Test.jl:1577 [inlined]; > [5] top-level scope; > @ ~/github/Oceananigans.jl/test/test_netcdf_output_writer.jl:880; > NetCDF output writer [CPU]: Test Failed at /Users/jmtzmo/github/Oceananigans.jl/test/test_netcdf_output_writer.jl:727; > Expression: all(isapprox.((ds[""c2""])[:, n + 1], c̄2(averaging_times), rtol = rtol)); > ```. me and @josuemtzmo sorted this out; things should be OK now!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3506#issuecomment-1994626027:380,error,error,380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3506#issuecomment-1994626027,1,['error'],['error']
Availability,> And if I modify the default free surface model to `free_surface = ImplicitFreeSurface(gravitational_acceleration=eltype(grid)(g_Earth))` I also get the same error (the docstring is also wrong for what the default free surface model is). Can you raise this in a separate issue?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732648650:159,error,error,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732648650,1,['error'],['error']
Availability,"> And with quite a small sponge (red lines in top plot) this is pretty much resolved:; > ; > internal_wave_sponge.mp4 ; > Note/update:; > ; > Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution. @jagoosw sorry to be dropping into this discussion a bit late, but I don't quite understand why the sponge is needed at the inflow in the example above. Shouldn't the prescribed inflow BC be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336:542,error,error,542,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336,4,['error'],['error']
Availability,> Another issue to add into this discussion is the fact of how to handle output (e.g. file.nc) with checkpoints and file_splitting. I propose handling this by initializing output files within `run!` rather than during instantiation of the output writer. This is separate from the interface discussion here though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391721684:100,checkpoint,checkpoints,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391721684,1,['checkpoint'],['checkpoints']
Availability,"> Another option is to pass FT=Float32 to the model and then let the constructor convert related components to Float32 (or Float64 if FT=Float64 is passed). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement. This could work but I'm wary of converting in general. When we convert, then identity is lost between whatever the `component` in the user script and `model.component`. This is an especially major problem for `grid`. But even if we implement this feature via the grid, there would be many other types like `FPlane(f=1)` for example which have the incorrect type. We can tell users that this is possible so they always need to use `model.coriolis`. But broadly I think this kind of design is a bit brittle; too easy for things to go wrong. > Actually, I think it would be better to define a function Oceananigans.set_default_number_type(FT) for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. I think that's a nice idea. It's also maybe more sensible syntax right now since there is only one default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263:970,error,error,970,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263,2,['error'],['error']
Availability,> Any idea why docs fails? https://buildkite.com/clima/oceananigans/builds/8381#0182beb4-dc53-4ca9-9d6c-76d43f05f6b6; > ; > ```; > /bin/bash: line 2: 815367 Segmentation fault (core dumped) /storage5/buildkite-agent/julia-1.6.7/bin/julia --color=yes --project=docs/ docs/make.jl; > --; >   | 🚨 Error: The command exited with status 139; >   | user command error: exit status 139; > ```. No idea. Can you reproduce the error locally?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1222426434:170,fault,fault,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1222426434,4,"['Error', 'error', 'fault']","['Error', 'error', 'fault']"
Availability,"> Anyone has any idea why all the errors with `all` or `interior` or `parent`? E.g.,; > ; > https://buildkite.com/clima/oceananigans/builds/11267#0187fd3b-6ccf-4f23-be19-445f384d6722/35-377. I did a bit of investigating locally but couldn't figure it out. It would be really nice to have 1.9 going sometime soon since it apparently significantly decreases the TTFX.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1542475873:34,error,errors,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1542475873,1,['error'],['errors']
Availability,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:157,error,error,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839,5,"['ERROR', 'error']","['ERROR', 'error', 'errorhandling']"
Availability,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:96,down,download,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152,2,"['avail', 'down']","['available', 'download']"
Availability,> Are the artifacts downloaded even if we don't use them?. Yeah apparently so. I think for some reason CUDA artifacts are downloaded first but certain calls like `CUDA.versioninfo()` can trigger further artifact downloads of CUDNN and CUTENSOR. > I think the disadvantage of using artifacts is that we are a bit more exposed to bugs and I think that's the cause of at least some of our pain here. The advantage is that it's less work to maintain our local CUDA software and our test environment might be more realistic / relevant since users typically use artifacts (I think). The CUDA.jl docs recommend using artifacts (https://cuda.juliagpu.org/dev/installation/overview/#CUDA-toolkit) but this may be because new users are less likely to encounter issues if they use the artifacts (which usually work out of the box) instead of fidgeting with local installs especially on servers without root access. For CI maintaining a local toolkit installation may be better?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872401461:20,down,downloaded,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872401461,3,['down'],"['downloaded', 'downloads']"
Availability,"> Are you sure this is exactly the same code that you ran?; > ; > I tried executing it as is and found an error on this line; > ; > ```; > T_bcs = FieldBoundaryConditions( top = FluxBoundaryCondition(heatflux(t)),; > bottom = GradientBoundaryCondition(dTdz)); > ```; > ; > The error is the following:; > ; > ```; > ERROR: UndefVarError: t not defined; > Stacktrace:; > [1] top-level scope; > @ REPL[38]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52; > ```. @francispoulin sorry, I did one mistake there. Though I am pasting a short code here which can produce the same error -; ```; using Printf; using Oceananigans; using Oceananigans.Units: minutes, hour, hours, day. const Nx=256; const Ny=256; const Nz=64. #Length of grid in south, north and vertical direction; const Lx=4; const Ly=4; const Lz=0.1. const S = 1.6 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-Nz-1) ) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; architecture = CPU(),; x = (0,Lx),; y = (0,Ly),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m⁻¹; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Qᵘ=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(α=alpha, β=beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timesteppe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:106,error,error,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274:463,down,down,463,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274,2,['down'],['down']
Availability,"> As a historical note, we have resisted adding diagnostics to the code base so far because we believed that a more generic solution would make it ""easy"" for users to define their own diagnostics (eg, as simple as writing the mathematical expression), and because long lists of diagnostics impose a maintenance burden. I agree that some diagnostics would be important, but I also agree with the above philosophy of Oceananigans. In cases like this wouldn't it be good to consider adding a companion repo to oceananigas that has all these diagnostics rather than putting them in Oceananigans by default? Much like LESbrary.jl does, it would be someting that (hopefully) can use `KernelComputedFields`, but it wouldn't be dedicated only to LES (so I guess it can't be LESbrary.jl).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758899177:299,mainten,maintenance,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758899177,2,['mainten'],['maintenance']
Availability,"> As a sanity you could try removing `interior(r)` and just pass `r` instead... :-O. Ah unfortunately same error and `typeof(R)` with. ```diff; diff --git a/src/Fields/mapreduce_abstract_fields.jl b/src/Fields/mapreduce_abstract_fields.jl; index 6ce35031..21237fa2 100644; --- a/src/Fields/mapreduce_abstract_fields.jl; +++ b/src/Fields/mapreduce_abstract_fields.jl; @@ -11,6 +11,6 @@ for function_name in (:sum, :prod, :maximum, :minimum, :all, :any); # Unwrap ReducedField to a view over interior nodes:; @eval begin; Base.$(function_name!)(f::Function, r::AbstractReducedField, a::AbstractArray; kwargs...) = Base.$(function_name!)(f, interior(r), a; kwargs...); - Base.$(function_name!)(r::AbstractReducedField, a::AbstractArray; kwargs...) = Base.$(function_name!)(identity, interior(r), a; kwargs...); + Base.$(function_name!)(r::AbstractReducedField, a::AbstractArray; kwargs...) = Base.$(function_name!)(identity, r, a; kwargs...); end; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845613014:107,error,error,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845613014,1,['error'],['error']
Availability,"> As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models). I agree, but this patch-up will not work for immersed boundaries anyway. I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113:598,down,down,598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113,1,['down'],['down']
Availability,"> As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like. The only change to existing code you need is a new property in `GridFittedBottom`. Then the current methods are the fallback (default), and we extend behavior by defining new functions for specific cases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044750063:129,toler,tolerance,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044750063,1,['toler'],['tolerance']
Availability,"> BTW, in the next release of `NCDatasets.jl`,`defVar` will throw an error if there is an unrecognized keyword (See this [change](https://github.com/Alexander-Barth/NCDatasets.jl/issues/212)).; > ; > That means that older versions of `Oceananigans.jl` (< 0.84) will not work with newer versions of `NCDatasets.jl` (>0.12.17). Sounds that NCDatasets is gonna have a breaking change but _not_ a minor release?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608576153:69,error,error,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608576153,1,['error'],['error']
Availability,"> BTW, in the next release of `NCDatasets.jl`,`defVar` will throw an error if there is an unrecognized keyword (See this [change](https://github.com/Alexander-Barth/NCDatasets.jl/issues/212)).; > ; > That means that older versions of `Oceananigans.jl` (< 0.84) will not work with newer versions of `NCDatasets.jl` (>0.12.17). That's good to know, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608761156:69,error,error,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608761156,1,['error'],['error']
Availability,"> But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. That's something very important to consider, I think, and I totally agree. It seems like we're converging to the ""no code is better than broken code"" perspective. Here's my pitch for this PR:. - Remove the Lid-drive cavity and Couette flow from the docs; - Keep the Convergence tests (maybe move it to the Appendix to make for a cleaner left menu); - Remove the `validation` directory from the master branch as well (that's broken code for now and it prompts users to test them and get errors); - Open another issue/PR to discuss what we'll do with the validation scripts (maybe another repo is a good idea). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873153475:77,down,download,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873153475,4,"['down', 'error']","['download', 'errors']"
Availability,"> By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection. I just tried with the latest commit and got this error:. ```julia; ERROR: LoadError: TaskFailedException. nested task error: UndefVarError: coeff_β_2_0 not defined; Stacktrace:; [1] left_biased_β(::Tuple{Float64, Float64}, ::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Val{0}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [2] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [3] beta_loop(::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, ::typeof(Oceananigans.Advection.left_biased_β)); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; [4] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:240,error,error,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"> Can we update the PR description to state this goal? ""This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers..."". Done!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938#issuecomment-1440573098:94,checkpoint,checkpoint,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938#issuecomment-1440573098,1,['checkpoint'],['checkpoint']
Availability,"> Can you paste the code snippet that produces the warning here?. I'm not exactly sure which part of this code is producing it but as an MWE, this produces the same error:; ```julia; grid = RectilinearGrid(size=(10, 10, 20), extent=(1, 1, 2)); model = NonhydrostaticModel(;grid, tracers=TracerFields((:A, :B), grid)); ```. If I specify a boundary condition then it doesn't give this error:; ```julia; model = NonhydrostaticModel(;grid, tracers=TracerFields((:A, :B), grid), boundary_conditions = (A = FieldBoundaryConditions(top = FluxBoundaryCondition(1.0)), )); ```; Which gives this instead:; ```julia; ┌ Warning: B was assigned an immersed FluxBoundaryCondition: Nothing, but this is not supported on; │ 10×10×20 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; │ The immersed boundary condition on B will have no effect.; └ @ Oceananigans.BoundaryConditions ~/.julia/packages/Oceananigans/jMMeT/src/BoundaryConditions/field_boundary_conditions.jl:160; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 10×10×20 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (A, B); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1324269751:165,error,error,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1324269751,2,['error'],['error']
Availability,> Can you point me to where in the code this goes down?. It happens in this halo fill:. https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Models/NonhydrostaticModels/pressure_correction.jl#L8-L20. after the tendency integration but before the pressure correction,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389132522:50,down,down,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389132522,1,['down'],['down']
Availability,"> Can you tell me if you still get the same error in the latest tagged release or on master?. Yeap @Sumanshekhar17, I also suggest you go to the latest tagged release and try again. :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-826249256:44,error,error,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-826249256,1,['error'],['error']
Availability,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:128,error,error,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"> Can't we just plot a fixed-color shape on top on the mount on all panels? [`Makie.poly`](https://docs.makie.org/stable/reference/plots/poly/) seems to be able to do that. We can. We can also mask the output after we load it, e.g, via. using something like. ```Julia; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. function mask_and_get_interior(φ_t, n; value=NaN); mask_immersed_field!(φ_t[n], value); return interior(φ_t[n], :, 1, :); end. u′ₙ = @lift mask_and_get_interior(u′_t, $n); ```. which gives. https://github.com/CliMA/Oceananigans.jl/assets/7112768/a402bfcd-ef72-42d8-bbb9-97fb98be4fe3. But either of these solutions complicate the example a bit. Ideally, `mask_immersed_field!` should not be user-facing. And plotting a mountain on top of the mountain is a bit of a hack and would require a bit of explaining and justifying why we do that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983782339:193,mask,mask,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983782339,1,['mask'],['mask']
Availability,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:152,error,error,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027,1,['error'],['error']
Availability,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >   | Stacktrace:; >   | [1] error(s::String); >   | @ Base ./error.jl:33; >   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >   | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >   | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >   | [4] #2; >   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >   | @ Base.Filesystem ./file.jl:106; >   | [6] #makedocs#1; >   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >   | [7] top-level scope; >   | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >   | 🚨 Error: The command exited with status 1; >   | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```; ┌ Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;   | │ ```@example shallow_water_Bickley_jet;   | │ model = ShallowWaterModel(architecture = GPU(),;   | │ timestepper = :RungeKutta3,;   | │ advection = WENO5(),;   | │ grid = grid,;   | │ gravitational_acceleration = g,;   | │ coriolis = FPlane(f=f));   | │ ```;   | │ c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);   | └ @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:30,ERROR,ERROR,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390,9,"['ERROR', 'Error', 'down', 'error']","['ERROR', 'Error', 'down', 'error']"
Availability,"> Could you explain why using ifelse has better performance?; Is this because the ternary ? : is an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:577,ERROR,ERROR,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['ERROR'],['ERROR']
Availability,"> Did you encounter the same issue whereby the simulation would _immediately_ NaN (rather than intermittently)? I'd be curious to see your setup in order to have more than one working example to test with. In my original simulations, I encountered NaNs usually after several hours in wall time, so it was bad for debugging. Luckily, I found a reliable way to get NaNs immediately is to set both `reltol` and `abstol` to zero and `maxiter` to more than a thousand. The purpose is to test the numerical stability of the iteration method. My theory is that the current CG iteration solver is numerically unstable. The residual usually decreases quickly for the first several iterations but may increase after that. That is why using a larger `reltol` or `abstol` or a lower `maxiter` makes it more ""stable"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420337695:343,reliab,reliable,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420337695,1,['reliab'],['reliable']
Availability,> Do we then want to have the conservative form of ShallowWaterModel be available only for bathymetry == nothing?. That seems like a good starting point to me. Do the easy thing and start running simulations!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1120403902:72,avail,available,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1120403902,1,['avail'],['available']
Availability,> Do you mean when we're computing a diagnostic like vorticity should the kernel include the boundary point?. > > Can you point me to where in the code this goes down?; > ; > It happens in this halo fill:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Models/NonhydrostaticModels/pressure_correction.jl#L8-L20; > ; > after the tendency integration but before the pressure correction. Where is the halo filling code?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389163421:162,down,down,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389163421,1,['down'],['down']
Availability,"> Do you reckon the problems stem from https://github.com/CliMA/Oceananigans.jl/pull/2890?. Oh well, that could be... but probably it would error on CPUs as well? I can test it out",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430388903:140,error,error,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430388903,1,['error'],['error']
Availability,> Do you think that we should allow people to plan multithreaded FFTs on the CPU? There's no reason not to use multithreading if its available.; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/116#issuecomment-470798886_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119:133,avail,available,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119,1,['avail'],['available']
Availability,> Docs should show up at https://clima.github.io/OceananigansDocumentation/previews/PR1543/ once a commit has been made after the PR has been opened. This gives me a 404 error!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-813527300:170,error,error,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-813527300,1,['error'],['error']
Availability,"> Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact. Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103004854:174,error,error,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103004854,1,['error'],['error']
Availability,"> Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?; > ; > If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`).; > ; > A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case). Good points. Based on these points I'd argue for us to keep things as it is but include a comment about this in the docstring / docs. Agreed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889335843:610,error,error,610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889335843,1,['error'],['error']
Availability,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:571,error,error,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878,6,"['down', 'error']","['down', 'error']"
Availability,"> Either way, I don't think that's important. A preconditioner should be some kind of approximate inverse for A, where we are solving for x in Ax = b --- or in other words, an approximate solver. The preconditioner does not have to be ""exact"" or ""error free"", since it's really the CG iteration that solves the problem. The idea is that the FFT-based solver yields a pressure field that is _almost_ correct. Ah, I see, so the idea behind using the FFT-based solver specifically as a preconditioner is because it's probably faster than other combination (if I understand correctly). Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284450132:247,error,error,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284450132,1,['error'],['error']
Availability,> Error message:. Huh. What's the type of `vz_op`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098671996:2,Error,Error,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098671996,1,['Error'],['Error']
Availability,"> Except we currently have to manually adjust the actuation to match the correct value based on the pre-pickup simulation during setup. @liuchihl this is outside the scope of this PR, isn't it? This PR says nothing about checkpointing, the issue is `AveragedTimeInterval`. The checkpointing stuff is separate and orthogonal to this. It's best to keep PRs limited in scope as much as possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433144787:221,checkpoint,checkpointing,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433144787,2,['checkpoint'],['checkpointing']
Availability,"> FATAL ERROR: Symbol ""__nv_llabs""not found. I should be able to reduce it down to a minimal working example (guessing it's a CUDA.jl issue). I have seen this error when working with `KernelAbstractions` without any CUDA dependency.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010:8,ERROR,ERROR,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832223010,3,"['ERROR', 'down', 'error']","['ERROR', 'down', 'error']"
Availability,"> For example, I need to downgrade the ""ArrayInterface"" to v2.14.17. I think to achieve this you should create a new environment by creating a new directory with a file called `Project.toml`. You can then use julia's package manager (or edit `Project.toml` directly) to add `ArrayInterface` to the environment, and to ""pin"" it or limit its version to 2.14.17. Here's julia's documentation for their package manager:. https://docs.julialang.org/en/v1/stdlib/Pkg/. Let us know if that helps or if you need more help setting up an environment! Figuring out the minimal package limitations that are needed to get Oceananigans to compile would be a huge step forward toward solving this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824921744:25,down,downgrade,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824921744,1,['down'],['downgrade']
Availability,> For hydrostatic models I get errors about trying to pass double precision numbers to a kernel. The Metal examples don't say anything about this btw. Can you please paste the error that you find into this issue?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731460376:31,error,errors,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731460376,2,['error'],"['error', 'errors']"
Availability,"> For reducing any `AbstractField` over ""windows"", `ConditionalOperation` is sufficient. The task there is to define `condition` appropriately (`mask` is chosen as the ""neutral"" value for the particular reduction). I guess there isn't an ordinary constructor for `ConditionalOperand`, but there is a function `condition_operand`...; > ; > https://github.com/CliMA/Oceananigans.jl/blob/b5bf45ed51587954f61ca7492e946fef69ff72ee/src/AbstractOperations/conditional_operations.jl#L23. Is there an example of how to do that? If not, do you mind writing a quick example? I saw that Oceananigans gained this `ConditionalOperation` lately, but the code has been growing so fast lately that it's hard to keep track, so I really don't know how I'd do it. Also I couldn't find `ConditionalOperation` on the docs or in the PRs (although I know it's in one of the PRs).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022242069:145,mask,mask,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022242069,1,['mask'],['mask']
Availability,> Glad you could figure it out.; > ; > Did you want me to test if this change removes the error?. It would be great to put a test of this on ClimaOcean. We also need to test it here (but that's more work because we cano't use your MWE).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3790#issuecomment-2374831899:90,error,error,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3790#issuecomment-2374831899,1,['error'],['error']
Availability,> Happy to say it is true!. I'm totally perplexed why dispatch seems to be failing silently. Often in these cases we get an error that a method is ambiguous. I'm stumped.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805147225:124,error,error,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805147225,1,['error'],['error']
Availability,> Here's the first offending function:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/775d1544610d5af6f602254ec5dff3dec7f18480/src/Fields/field.jl#L353-L359; > ; > did this code or something down the line change in this PR?. I don't think anything changed here?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263597746:197,down,down,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263597746,1,['down'],['down']
Availability,"> Hm haven't seen that error before. In any case this PR should resolve: [EnzymeAD/Enzyme.jl#1297](https://github.com/EnzymeAD/Enzyme.jl/pull/1297). Okay, let's see if we can test whether that fixes it before merging in changes from #3477, just so we can test one thing at a time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1948851940:23,error,error,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1948851940,1,['error'],['error']
Availability,"> Hmm ok somehow changes I made were lost, but I can't figure out how. Anyways I have tried to put them back in. I was wondering the same. I noticed the error was the same we had before.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2101268806:153,error,error,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2101268806,1,['error'],['error']
Availability,"> Hmm, docs still seem to fail. What's the error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884362524:43,error,error,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884362524,1,['error'],['error']
Availability,"> Hmm, it should not be a tolerance issue. To debug this I would probably suggest Tartarus since it has at least 2 GPUs (I am not sure your laptop has 2 gpus 😄 ). I checked and tests were failing because values of order 1e-19 or less were not agreeing... see https://buildkite.com/clima/oceananigans-distributed/builds/1131#018d7a2d-f6c5-4e22-8006-3e2d318465d1/170-5060. I replaced `a ≈ b` (which defaults to `atol=0` with `isapprox(a, b, atol=eps(eltype(grid)))`; see [385a05d](https://github.com/CliMA/Oceananigans.jl/pull/3403/commits/385a05d55dfe189eb0734c9120d0f9604eb070f7)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1928865390:26,toler,tolerance,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1928865390,1,['toler'],['tolerance']
Availability,"> Hmm, it should not be a tolerance issue. To debug this I would probably suggest Tartarus since it has at least 2 GPUs (I am not sure your laptop has 2 gpus 😄 ); > ; > By the way, for unrolling loops we can look at this package which might be very useful to us https://github.com/cstjean/Unrolled.jl. What's the difference between that and what we are using from `KernelAbstractions.jl`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1930121202:26,toler,tolerance,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1930121202,1,['toler'],['tolerance']
Availability,"> Hmm, now I'm getting a ""no space on device error"":; > ; > ![image](https://private-user-images.githubusercontent.com/13205162/382723979-6a328f01-1e93-413c-9414-2e0eba6ef6c3.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzA3Mzc3NDEsIm5iZiI6MTczMDczNzQ0MSwicGF0aCI6Ii8xMzIwNTE2Mi8zODI3MjM5NzktNmEzMjhmMDEtMWU5My00MTNjLTk0MTQtMmUwZWJhNmVmNmMzLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDExMDQlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQxMTA0VDE2MjQwMVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWNmYmQxNThlOGFlYTM5ZTUxYWVmZWM4OTU2Y2FkMjEzMTMzY2E4YWQ5YWU0NjE2ZDc1MzY2N2RmZmY3M2E4NDgmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.bNKx7tQeuOuUHiNoHap1rJmGXuoJ77l0DNwuxZRkEfc). gotta delete somem stuff",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2455153749:45,error,error,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2455153749,1,['error'],['error']
Availability,"> Hmm. What is; > ; > ```julia; > view(u[region_W], 1, Nc+1-Hc:Nc, k); > ```; > ; > is this a `Field`? Next question, what is; > ; > ```julia; > reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k)); > ```; > ; > If the former is a `Field` I don't think we've defined `reverse` on `Field`. But you could do that... @glwagner, yes, `view(u[region_W], 1, Nc+1-Hc:Nc, k)` is a `WindowedField`, on which `reverse` is not defined yet. But `reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data)` is a valid operation. However, simply typing ; ```julia; u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn; u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; might throw the above-mentioned error due to a dimension mismatch or fill the LHS with junk or incorrect values. So, a safe solution is ; ```julia; view(u[region], 1, Nc+1:Nc+Hc, k).data .= reshape(reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn, 1:1, Nc+1:Nc+Hc, k:k); view(u[region], Nc+1, 1-Hc:0, k).data .= reshape(reverse(view(u[region_E], 2:Hc+1, 1, k).data), Nc+1:Nc+1, 1-Hc:0, k:k); ```; @glwagner, @navidcy, if you guys are fine with this fix, I will close the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769:732,error,error,732,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769,2,['error'],['error']
Availability,"> Hmmm, I can appreciate that if we set the topology in the `z` direction to be `Flat`, then we have one layer. I presume that if we set it to be something else, say `Layered`, then we will have layered?; > ; > I like that idea a lot, however, I think we still need to throw an error if the user sets the topography to be `Bounded` or `Periodic`. Do you agree @navidcy ?. I suggest that `Flat` means single layer algorithm, `Bounded` means multi layer algorithm",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147860430:278,error,error,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147860430,1,['error'],['error']
Availability,"> Hmmm, doesn't rectilinear imply orthogonal?; > ; > `RegularRectilinearOrthogonalGrid` might be a little redundant?. No. Rectilinear just means that the axis are straight lines... But the axis could intercept in angles other than 90 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295927:106,redundant,redundant,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295927,1,['redundant'],['redundant']
Availability,"> Hmmm, maybe more of a question for @glwagner but can you nest ComputedFields (is it tested?)?. It appears you're right, that at least some of the problem comes from nested `ComputedField`s. (I need to run more tests later to be sure). If nesting `ComputedField`s isn't allowed and can't be made to work, I'd suggest throwing an error if possible. However, nesting `ComputedField`s seems like a pretty useful feature to have. My talks with @glwagner over `KernelComputedField` lead me to believe that it's possible to make that work, no?. > Otherwise might help to describe how compute!(Ri_abs) and compute!(Ri_abs2) are different from Ri_cons, e.g. is it completely wrong, factor of 2, only wrong at the boundary, etc. @ali-ramadhan I provided my full example in the last sentence of my question!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768639056:330,error,error,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-768639056,1,['error'],['error']
Availability,"> Hmmm, might have to default to `NamedTuple` as `nothing` cannot be splatted.; > ; > ```julia; > julia> f(x, y; kwargs...) = @show kwargs; > f (generic function with 1 method); > ; > julia> N = nothing; > ; > julia> f(1, 2; N...); > ERROR: MethodError: no method matching iterate(::Nothing); > ; > Closest candidates are:; > iterate(::Base.AsyncGenerator, ::Base.AsyncGeneratorState); > @ Base asyncmap.jl:362; > iterate(::Base.AsyncGenerator); > @ Base asyncmap.jl:362; > iterate(::Core.MethodMatch, ::Int64); > @ Base deprecated.jl:265; > ...; > ; > Stacktrace:; > [1] merge(a::@NamedTuple{}, itr::Nothing); > @ Base ./namedtuple.jl:361; > [2] top-level scope; > @ REPL[12]:1; > ```. That works. I think they are sort of identical in the end",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3898#issuecomment-2456112210:234,ERROR,ERROR,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3898#issuecomment-2456112210,1,['ERROR'],['ERROR']
Availability,"> How about a test? If it's not trivial then don't worry. I like the idea of a test. . One example could be the following:. 1. define the horizontal compoments of velocity to be random fields, ; 2. use this function is used to compute the vertical velocity,; 3. compute the divergnece of the resulting three-dimensional field and compute its norm (which should be zero). . If you do this for two different resolutions you should find that the error decreases with higher resolution. Do you think this would be of interest?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896762413:443,error,error,443,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896762413,1,['error'],['error']
Availability,"> How do we deal with errors of this kind in the doctests?:; > ; > ```; >   | │; >   | │ diff =; >   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.; >   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.; >   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration; >   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44; >   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; > ...; > ```; > ; > i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different.; > ; > I remember there was a relatively simple way to deal with this, but I can't find it. Damn... I remember the issue... Something with filter doctests. I can try to sort it out. Ignore it for now :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200:22,error,errors,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200,2,['error'],['errors']
Availability,"> How does that work for Julia?; > For Python, if the user gives both `max_change<1` and `min_change>1`, this is going to give the `max_change` error only. Is it the same for Julia? If so, should we keep like this?. Sorry that was my bad for the error. . This. ```; a==b && foo; ```. means that `foo` will be executed only if `a==b`. See:. https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation. But to answer your question: yes lets keep it like that. User will get another error next time :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705753655:144,error,error,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705753655,3,['error'],['error']
Availability,"> How sure are you about the precise version? Is `GPUCompiler@0.16.5` the breaking release for you?. I haven't tried to find the precise version, but `GPUCompiler@0.16.7` already creates the errors, so the breaking release is either 0.16.7 or 0.16.6.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2900#issuecomment-1418274125:191,error,errors,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2900#issuecomment-1418274125,1,['error'],['errors']
Availability,"> However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. I don't have much experience with solid wall boundary layers. A quick search returns this review:. https://journals.aps.org/prfluids/pdf/10.1103/PhysRevFluids.2.104601?casa_token=VBO0hrNqp-cAAAAA%3A3XEKZfLTdhiVluwRl8sCQCkOK44GoGUX-546uFtqQjSWAUIDQpKyyQsA4lQd65Oz6Kw5ClWias_CVQ0. suggesting that correct flux predictions in wall-modeled LES is unsolved. For example:. <img width=""616"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/a6ffe67e-2009-441a-a440-80afe0dc4a70"">. shows a mismatch between DNS and wall-modeled LES for a few standard codes. Based on the literature, a failure to reproduce the log-law is expected?. It might help if you provide more background on what exactly you're trying to achieve, and why you believe the current approach will achieve that objective. For example, are we attempting to reproduce a known result?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364:744,failure,failure,744,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364,1,['failure'],['failure']
Availability,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:29,error,error,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538,20,"['checkpoint', 'error']","['checkpoint', 'checkpointer', 'error', 'errors']"
Availability,"> I added a `ParticleAdvectionForcing` that behaves similarly to `dynamics(particles, model, Δt)` which allows user to specify any velocities it wishes to add to the model by passing in `NonHydrostaticModel(..., advective_forcing = ParticleAdvectiveForcing(u=some_u, v=some_v, w=some_w))` . The arguments are functions that take `(particles, model, Δt)` as inputs.; > ; > When I am trying to test my code I ran into a problem:; > ; > ```; > ERROR: UndefVarError: `flattened_node` not defined; > ```; > ; > https://github.com/CliMA/Oceananigans.jl/blob/a73e845a7a7bce8e22e9453670c1c20b67dbfc3a/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L92; > ; > @simone-silvestri I see that you added this and I couldn't find anywhere in the code where `flattened_node` is defined. What is it supposed to be?. This is from #3395. We should wait for that PR to be merged before merging this one",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837242844:441,ERROR,ERROR,441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837242844,1,['ERROR'],['ERROR']
Availability,"> I admit that I don't understand the symmetric interpolant stuff that is done, which is perhaps why I can't see the error. This distinction only matters for momentum advection. For tracer advection, the velocity field does not have to be interpolated to the location of the tracer fluxes, since it's already located there due to the staggered arrangement of velocity fields and tracer fields. For tracer advection, all that matters are the definition of the left-biased and right-biased functions for interpolating cell-averaged tracer values to cell faces. These are the functions `left_biased_interpolate_xᶠᵃᵃ`, etc. This might be made clear by the operators for `advective_tracer_flux_*` when using an upwind-biased scheme:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Advection/upwind_biased_advective_fluxes.jl#L103-L110",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747713133:117,error,error,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747713133,2,['error'],['error']
Availability,> I agree that `HydrostaticLinearFreeSurfaceModel' does not. But should it in case the user specifies the wrong halos?. In that case users will get a segmentation fault. We've introduced a lot of new grids to be used with `HydrostaticFreeSurfaceModel` so I think this is just a matter of convenience for developers. We don't have any real validation experiments for `HydrostaticFreeSurfaceModel` so it's not really ready for general use yet... If people are using `HydrostaticFreeSurfaceModel` they should be setting up validation experiments!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844532819:163,fault,fault,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844532819,1,['fault'],['fault']
Availability,"> I agree with docs changes. But it would disrupt a lot of important ongoing work to remove the `validation` directory from the repo without providing an alternative place / way to collaborate on new features. So I think we should leave the `validation` scripts in the repo and discuss what to do next before removing them. Is there ongoing work there? I thought all ongoing work was supposed to be confined to PRs. That's what I've been doing. If that's true and we need to keep the `validation` dir, then at the very least we should make it obvious that those scripts aren't ready for users. The name ""validation"" kinda implies that users can use those scripts to validate their installation, so it's not a surprise that a lot of newcomers try those scripts out and get error. Maybe rename that dir to `work_in_progress`? And then put a `README.md` file in it explaining that most of the scripts are out-of-date?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873213393:772,error,error,772,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873213393,1,['error'],['error']
Availability,"> I am in favor of not doing [979c2a7](https://github.com/CliMA/Oceananigans.jl/commit/979c2a7cd10c1f2054cad996622cafd2e3fb3ffa). It hardcodes a change in the source code that is only required for aesthetic reasons. I would wait for #3092 and in the meantime mask the output in the example. Deal, done",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983852170:259,mask,mask,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983852170,1,['mask'],['mask']
Availability,"> I am in favor of not doing [979c2a7](https://github.com/CliMA/Oceananigans.jl/commit/979c2a7cd10c1f2054cad996622cafd2e3fb3ffa). It hardcodes a change in the source code that is only required for aesthetic reasons. I would wait for #3092 and in the meantime mask the output in the example. I agree with @simone-silvestri that we want this feature, but that it should be done properly",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986373058:259,mask,mask,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986373058,1,['mask'],['mask']
Availability,"> I attempted to reproduce the issue using the 1D diffusion example in the same environment, but I was unable to do so. . Ok, after changing from `IterationInterval` to `TimeInterval` in the 1D diffusion example ([source](https://github.com/liuchihl/internal-tide-mixing/blob/3D-realtopo-delta-glw-background-flux-div/oneD_diffusion_checkpoint_test.jl)), I am able to reproduce the same problem now. . Here is the progress message after picking up the checkpoint:; <img width=""580"" alt=""image"" src=""https://github.com/user-attachments/assets/9ef385f4-b53d-4954-97f9-54656420c232"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244270596:452,checkpoint,checkpoint,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244270596,1,['checkpoint'],['checkpoint']
Availability,"> I believe for your implementation, since the tracer values are not corrected for pressure, any leakage will be due to the advection of tracer by momentum that _is_ impacted by the pressure correction. This advection should be less with a smaller spacial step if I remember correctly. Well, I agree that less leakage implies that less tracer is advected across the boundary. But why is less tracer advected across the boundary?. It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. Another question might be whether the leakage / error depends on the extent of the masked region (holding resolution constant). I'm not sure whether its worth looking into all this stuff though --- it might be better simply to work on implementing an accurate pressure solver, since I don't think it would be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142:720,mask,masking,720,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142,8,"['error', 'mask']","['error', 'masked', 'masking']"
Availability,"> I believe to support concrete `BackgroundField` we need to add a method to `regularize_background_field` defined here:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/7501c5325a0f7c77a89316d23ee7a56a3877dad9/src/Fields/background_fields.jl#L59-L63; > ; > that looks like; > ; > ```julia; > regularize_background_field(X, Y, Z, field::Field, grid, clock) = field; > ```; > ; > If you want to be super friendly you could also check that `location(field) == (X, Y, Z)` and `grid == field.grid` and throw an error if not so users don't get wrong results. That sounds pretty easy and would happily help work on this during a pair programming session but don't think I understand it well enough to tackle it myself. But thanks a lot for explaining the nuances.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816790661:511,error,error,511,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816790661,1,['error'],['error']
Availability,"> I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?. Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg. ```; ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; ```. > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though. As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685:427,error,error,427,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685,1,['error'],['error']
Availability,"> I can work on this. We can build; > ; > ```julia; > function finalize!(sim::Simulation); > # Finalize callbacks; > [cb.finalize(cb, sim) for cb in sim.callbacks]; > ; > # Finalize model; > finalize!(sim.model); > ; > return nothing; > end; > ```; > ; > Models can then define appropriate finalizations. One layer down, we can have; > ; > ```julia; > function finalize!(model::HydrostaticFreeSurfaceModel); > finalize!(model.free_surface); > return nothing; > end; > ```. Let's do this! :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1243043352:315,down,down,315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1243043352,1,['down'],['down']
Availability,> I can't say I have any idea why this error occurs. Do we do something special in this doc that we don't do in others?. Got it. It was not exported in the main Oceananigans.jl file. Fixed via 52a394a.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1711#issuecomment-849943434:39,error,error,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1711#issuecomment-849943434,1,['error'],['error']
Availability,"> I changed `∂xᶠᵃᵃ` to use `Δxᶠᵃᵃ` and when I try and compute the `x` derivative of the free surface in the `x` momentum equation I get the following error. It seems to me like we need to generalize this function, and others, to work on immersed grids. You'll have to revert that change. We want to deprecate `∂xᶠᵃᵃ` so that all the operators we use are valid on curvilinear grids where two horizontal location specifications are required.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-849805174:150,error,error,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-849805174,1,['error'],['error']
Availability,> I clicked on `this code` but then obtained a 404 error. Could the link not be quite right?. Sorry that was because I had linked to a branch that got merged and doesn't exist anymore. I updated the original issue with a working link,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101591884:51,error,error,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101591884,1,['error'],['error']
Availability,"> I did a few tests with some criteria for timestep-skipping with a couple of my own simulations in addition to the MWE included here. In summary:; > ; > 1. Criterion `sim.Δt / 1e10`: successfully gets rids of the problem in both the MWE and in my simulations; > 2. Criterion `10 * eps(sim.Δt) * sim.Δt`: doesn't get rid of the problem in any simulation; > 3. `100 * eps(sim.Δt) * sim.Δt`: fixes the problem in the MWE but not in my simulations, although it does decrease its frequency of occurrence a good amount.; > 4. `1000 * eps(sim.Δt) * sim.Δt`: fixes everything in all simulations I've tried.; > ; > So only options 1 and 4 fully fix the problem (at least in the simulations I've tried so far). For me both those options rely on pretty arbitrary numbers though, so I'm not very happy with neither. From the point of view seeing the timestep-skipping as an approximation (un+1≈un), then maybe criterion 1 makes more sense, although I'm not sure how it'd behave for Float32 simulations.; > ; > I see three possible ways to go about it right now:; > ; > 1. Do what this PR is doing, and manually set the criterion to either option 1 or 4 above. If it turns out that some simulations still have issues, we revisit.; > 2. We add `min_Δt` as a property of `NonhydrostaticModel` (or maybe `Simulation`?). I think the minimum `Δt` for which time skipping will be necessary will vary significantly between simulations, so this solution deals with that by leaving the decision up to the user if they are interested in the pressure output.; > 3. We try something that actually prevents these round-off errors instead of dealing with them. @glwagner suggested an `Integer`-based model clock, but there might be other options. Note that `eps(sim.Δt)` is similar to `sim.Δt * eps(typeof(Δt))`. So `Δt / 1e10` is pretty similar to `100000 * eps(sim.Δt)`. The only point of using `eps` is to avoid hard coding `Float64`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2136281567:1598,error,errors,1598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2136281567,1,['error'],['errors']
Availability,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:354,toler,tolerance,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451,1,['toler'],['tolerance']
Availability,"> I don't know exactly what it means for a gradient to be applied to the field. Can you please clarify?. I just meant where in the code the gradient boundary conditions get imposed, which you've shown us is in the calculation of the gradients that feed into the downgradient diffusive fluxes that are used in the diffusive flux divergence contribution to the tracer tendencies. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211480361:262,down,downgradient,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211480361,1,['down'],['downgradient']
Availability,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:145,error,error,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683,4,['error'],['error']
Availability,"> I don't think we should pin a indirect dependency. Using Julia 1.7 with Mac M1 is decidedly unsupported and the user can do the pinning in their `Project.toml`. Ah, I didn't realize this was specifically a Mac M1 issue. I think we'll continue to get issues and questions about this error if we don't do something about it (and its very inconvenient for this important subset of users). What's the best way to solve this problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112118418:284,error,error,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112118418,1,['error'],['error']
Availability,> I don't understand what is going on with my two PRs that are not passing the tests. Should I close and create them again from the latest master?. Nope. It's not your fault. We are having issues with the CI.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013533717:168,fault,fault,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013533717,1,['fault'],['fault']
Availability,"> I don't understand why this is failing (it also fails locally).; > ; > It is only:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/4d30ed8bf093b6b7894677ef33c2c0b1cf3e1487/test/test_field.jl#L126; > ; > ; > that fails for Float32 on the grid points, and the error is ~4.6f-6 vs eps which is ~3.8f-6. It is also weird that this fails on regular grids where I haven't changed anything.; > Also, the maximum error for each interpolation is:; > ; > ```; > u -> 1.9073486e-6; > v -> 4.7683716e-6; > w -> 3.8146973e-6; > c -> 3.8146973e-6; > ```; > ; > with ϵmax= 3.8146973f-6 and I don't know why they wouldn't all be the same?. I'm not sure what you mean by ""they"", but with different nodes, ie different `nodes(v, reshape=true)`, then shouldn't they be different (to within machine precision)?. The function involves a few arithmetic operations:. https://github.com/CliMA/Oceananigans.jl/blob/4d30ed8bf093b6b7894677ef33c2c0b1cf3e1487/test/test_field.jl#L109. and round off error accumulates. Therefore you may want to increase the tolerance to `10*e_max` or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1492713386:265,error,error,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1492713386,4,"['error', 'toler']","['error', 'tolerance']"
Availability,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038:140,error,errors,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038,2,['error'],['errors']
Availability,"> I found that using --check-bounds=yes or running the code on a CPU cannot reproduce the error in the original script posted by me. Interesting --- does that mean that this is not an out-of-bounds issue?. > I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Are the NaNs appearing in the particle coordinates, or in the model velocity fields? The _default_ `NaNChecker` only checks the first entry in the model's prognostic field:. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Simulations/simulation.jl#L71. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Models/Models.jl#L163-L169. Note also that by default, the `NaNChecker` is only actuated every 100 iterations. You are free to use a different NaNChecker, however. The balance between the computational cost of checking NaNs / frequency of NaN checking and the cost of a time-step is use-case-specific. Can you clarify why you expect the model to abort itself when NaNs appear? Are you suggesting that we can improve the default NaN checker?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783:90,error,error,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783,2,['error'],['error']
Availability,"> I guess if we run this on different nodes the efficiency is bound to go down, but that's a problem with the architecture I guess and not something we can change with software. Unless there is something I don't know about?. Yeah I don't have much experience with scaling MPI but I'm guessing single-node scaling depends on your software while multi-node scaling depends more on the cluster/hardware?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413:74,down,down,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805929413,1,['down'],['down']
Availability,"> I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a question for further down the line). We might also want to consider oblique waves but that shouldn't be too hard to extend to we might just have to calculate a lot of surrounding points which might motivate some other way to do it.; > ; > Does this make sense to everyone? I also can't see an obvious way to get Δt to the halo fill since it doesn't even make it into the `update_state!` so any suggestions would be appreciated. To clarify, the statement ""when U_b is negative"" means more generally ""when U_b implies inflow into the domain"". It makes sense to me that inflow is prescribed, whereas outflow is a little tricker, requiring us to smoothly advect information out of the domain. Having the boundary condition depend on the previous time-step does seem to break assumptions we have made about how information flows. For example, we call `update_state!` during model construction. How does the first time-step / initialization work with this kind of outflow model? It might help to consider that. Practically speaking it would not be hard to pass the time-step to update state. But it might be nice to understand the implications before committing, because a different design / redesign could make sense. For example I supposed we would need to have a default ""time step"" that is 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289:469,down,down,469,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289,1,['down'],['down']
Availability,"> I have only used overwrite_existing=false without a checkpoint for short tests within the same Julia instance to extend the model output. Thank you for pointing out this use case. I think this is another situation that could be solved by waiting until `run!` for initialization. We can analyze an existing file and determine whether or not any data within the file will be overwritten based on the simulation parameters (current time, stop time). Another idea by the way would be to move the concept of ""overwriting"" to `run!`, as well. Then the single keyword can apply to all output, or not, which presumably more aligned with what a user would want (rather than toggling `overwrite_existing` for each writer individually).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2392171348:54,checkpoint,checkpoint,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2392171348,1,['checkpoint'],['checkpoint']
Availability,> I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error. That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980:58,error,errors,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980,2,['error'],"['error', 'errors']"
Availability,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on. I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918:391,down,downloaded,391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918,2,['down'],['downloaded']
Availability,"> I hope this description of the workflow is clearer. It's clear!. > I thought the optimal implementation is to append to the previous existing file when using checkpoints. Of course I agree with this. I think our basic principle should be that there is no difference in workflow, either for running or analysis, between scripts for checkpointing or not. Also, I think that `overwrite_existing` should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. > If I don't change the name each time I pickup, with the overwrite_existing=false it crashes, and with overwrite_existing=true it rewrites all the files. If we have a system that does not overwrite files when picking up from a checkpoint, do you think that it will be necessary to have `overwrite_existing=false` by default? In this case, the only time we risk overwriting files is when we _re-run_ a simulation from the beginning. Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:. In my experience, I typically set up a script with `overwrite_existing=true` from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed `overwrite_existing=false` because of some concern about overwriting data. It's inconvenient, in fact, to set `overwrite_existing=false`. My thought is that it makes more sense to ask people to intentionally request `overwrite_existing=false` in the _rare_ case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Also, even for this purpose I don't really want a ""non-overwriting guarantee"" as a feature. I would prefer something like ""unique_filenames = true"" or something, which I could then ""turn on"" if I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201:160,checkpoint,checkpoints,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201,10,['checkpoint'],"['checkpoint', 'checkpointing', 'checkpoints']"
Availability,"> I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:; > ; > `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`; > ; > Then it returns the following error:; > ; > Error output:; > Any idea what it could be, @simone-silvestri ?. That's related with #3374 and the warning comes from Julia v1.10 (wasn't there with Julia v1.9).; The PR #3403 will deal with these warnings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561:435,error,error,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561,2,"['Error', 'error']","['Error', 'error']"
Availability,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:1234,avail,available,1234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462,1,['avail'],['available']
Availability,"> I looked at the error and see this but don't pretend to know why this has happened.; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19; >   | Expression: all(test_model.timestepper.G⁻.w.data .≈ true_model.timestepper.G⁻.w.data); >  ```; > ```. Hmm yeah, the model output changed. Not sure what's causing this since I've never investigated the checkpointer. But the fact that the regression tests work points towards it being the checkpointer itself that changed, and not simulation results, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534:18,error,error,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534,4,"['Checkpoint', 'checkpoint', 'error']","['Checkpointer', 'checkpointer', 'error']"
Availability,"> I m wondering if this issue is solved in the new version. It is! Although I'll move the masking from the model update to the output construction since it doesn't change model runs and it saves time. Tests should be passing, although apparently the GPU runs aren't running currently",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1218827709:90,mask,masking,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1218827709,1,['mask'],['masking']
Availability,"> I mean using no immersed boundary but a topography that does not reach the ocean surface. You can do that by including in the model a bathymetry that is limited to a certain negative value.; > ; > The immersed boundary and topography are two different things in the `SahllowWaterModel`. The immersed boundary is a mask of zeros and ones located in the grid, while the topography is an array (or function) passed to the model that enters the tendency calculation. But @francispoulin is using _flat_ topography --- this doesn't reach the surface, its flat.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2073292988:316,mask,mask,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2073292988,1,['mask'],['mask']
Availability,"> I really would rather emit a warning here rather than an error because I don't think an error is appropriate when input is legitimate (which was the case for what `FieldTimeSeries` did, prior to this PR). @tomchor @simone-silvestri is that ok with you two?. Sure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2589#issuecomment-1142619937:59,error,error,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2589#issuecomment-1142619937,2,['error'],['error']
Availability,"> I see that one of the errors is `UndefVarError: device_event not defined`, which I suppose means we need to load it?. Indeed, I'll fix that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890028428:24,error,errors,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890028428,1,['error'],['errors']
Availability,"> I seem to have a problem with the GPU cubed sphere tests; > ; > ```; > ERROR: Out-of-bounds array access.; > ERROR: a exception was thrown during kernel execution.; >   | Run Julia on debug level 2 for device stack traces.; > ```; > ; > When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error. We've seen this issue before where sverdrup tests fail but tartarus passes. Can anyone remember where we saw that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071:73,ERROR,ERROR,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"> I started by updating all the examples for the new syntax that I thought would work, and then went on to other stuff to let the CI do its thing. Now that I see one of them failed I went back and focused on that one specifically. I think its an ok workflow since regardless I would have to wait for compilation / setup, so its not a bad strategy to let CI find the errors for you, at least at first. It is, if it works for you!; Sometimes I personally have a larger adjustment time to get back to a problem when I move to a different one so the workflow you seem to follow doesn't work for me that well. Merge?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2273274742:366,error,errors,366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2273274742,1,['error'],['errors']
Availability,"> I suggest that the grid constructor does not restrict the `z` topology then but instead the `HydrostaticFreeSurface` does so. Right?. That's fine with me, perhaps the error message will be clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255:169,error,error,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255,2,['error'],['error']
Availability,> I suggested a syntax change that could help. You're right it does help. I'll try replacing these one by one and see if that helps with the error on buildkite. Although if would be useful to figure out why I'm not getting the same errors locally.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411432495:141,error,error,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411432495,2,['error'],"['error', 'errors']"
Availability,"> I suspect is that is the grid inflation which happens in the nonhydrostatic model. You need 4 halos because it's an immersed boundary so the model inflates the grid automatically and apparently that gives out of boundaries with the advection. If you build the model from correct sized halos thus bypassing inflation the problem disappears. You're right! Increasing the halo to 4 makes all simulations run. > I ll put a little more effort in the inflation. We can also just think about spitting an error as we do for the `HydrostaticFreeSurfaceModel`. I think either way is good. But I think one of them need to be done before merging because the error I get from CUDA is really not helpful. Also, can you briefly explain why an extra node is needed when using IBM?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1180977749:499,error,error,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1180977749,2,['error'],['error']
Availability,"> I think I'm envisioning somehow a split in subsections where the equations solved by each model (`IncompressibleModels`, `HydrostaticFreeSurfaceModels`, and `ShallowWaterModels`) are written down. What do you think?; > ; > @glwagner, @ali-ramadhan, @francispoulin. Agree with this. > My main question is: from all doc pages under ""Physics"", which are model independent and which are only relevant to IncompressibleModels? Is the following correct?. It's mixed. The LES closures are not supported by anything but `IncompressibleModel`. Some of the `TurbulenceClosures` are only supported by `HydrostaticFreeSurfaceModel`. Some are supported by all (like `IsotropicDiffusivity`). Probably we don't want to organize the ""equation terms"" docs by model type. We could include a comment at the end of each turbulence closure description that's something like. > Supported by:; > * `IncompressibleModel`; > * `HydrostaticFreeSurfaceModel`; > * `ShallowWaterModel`. Such a structure might be feasible to maintain moving forwards.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1690#issuecomment-847445638:193,down,down,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1690#issuecomment-847445638,1,['down'],['down']
Availability,"> I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). Agreed!. > I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient.; > ; > Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon.; > ; > @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. For context, 100% of my simulations have used checkpoints. As far as I know, 100% of the simulations from others in my group also use checkpoints. The only exceptions for my case are very early scripts still in the development phase, and still with very coarse grids. As soon as I try to get more serious with it, I need checkpoints. So this a PR I'm very much looking forward to seeing merged ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720:37,Checkpoint,Checkpointing,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720,17,"['Checkpoint', 'checkpoint']","['Checkpointing', 'checkpointer', 'checkpointing', 'checkpoints']"
Availability,"> I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > ; > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful. I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025972971:219,mainten,maintenance,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025972971,1,['mainten'],['maintenance']
Availability,> I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit. To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU? That's why I didn't originally go down the route of making the velocity explicitly part of the boundary condition.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869:287,down,down,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869,1,['down'],['down']
Availability,"> I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. I agree! Just to makes sure we're on the same page, it seems we need two separate functions to calculate both the Stokes velocity and Stokes shear averaged over a finite volume cell:. 1. The finite-volume-averaged Stokes _shear_ is the difference between a continuous expression for the Stokes velocity evaluated at the top and bottom of a cell; 2. The finite-volume-averaged Stokes velocity is the difference between a continuous expression for the total-depth-averaged Stokes velocity at the top and bottom of a cell. > In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". Very useful information, thank you!. > I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia?. That depends strongly on my fortran-reading skills but yes, I think so! We still need to write down a continuous expression for the Stokes velocity though, I think. There's some difficulties because the Stokes velocity diverges near the surface? We can perhaps make some approximation there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887:60,avail,available,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347887,2,"['avail', 'down']","['available', 'down']"
Availability,"> I think providing a string as a closure doesn't even make it to the new error message you added so you get a MethodError from `with_tracers`!; > ; > ```julia; > julia> using Oceananigans, Test; > Precompiling Oceananigans; > 1 dependency successfully precompiled in 11 seconds. 129 already precompiled.; > ; > julia> grid = RectilinearGrid(CPU(), size=(2, 2, 2), extent=(1, 2, 3)); > 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; > ├── Periodic y ∈ [0.0, 2.0) regularly spaced with Δy=1.0; > └── Bounded z ∈ [-3.0, 0.0] regularly spaced with Δz=1.5; > ; > julia> closure = ""not a closure""; > ""not a closure""; > ; > julia> NonhydrostaticModel(; grid, closure); > ERROR: MethodError: no method matching with_tracers(::Tuple{}, ::String); > ; > Closest candidates are:; > with_tracers(::Any, ::Nothing, Any...; kwargs...); > @ Oceananigans ~/Research/OC11.jl/src/Utils/with_tracers.jl:44; > with_tracers(::Any, ::Oceananigans.TurbulenceClosures.TwoDimensionalLeith{FT}) where FT; > @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl:61; > with_tracers(::Any, ::ScalarBiharmonicDiffusivity{F, N}) where {F, N}; > @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl:85; > ...; > ; > Stacktrace:; > [1] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{}, closure::String, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, hydrostatic_pressure_anomaly::Oceananigans.Models.NonhydrostaticModels.DefaultHydrostaticPressureAnomaly, nonhydrostatic_pressure::Field{…}, diffusivity_fields::Nothing, pressure_solver::Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325346266:74,error,error,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325346266,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"> I think that should be revisited when we decide to take on the more challenging issue of checkpointing partially-accumulated time-averages so that windowed_time_average always works as intended when picking up from checkpoints. good point!. There is a possibility that it is not very hard. It will require reshuffling code (which I can do), but with Julia we can serialize objects to disk and then load them back seamlessly in a single line... which might be all we need. The only limitation of serialization is that we haven't yet figured out how to serialize _methods_ (eg functions) which prevents us from serializing entire models. When functions are not involved things can be pretty simple.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956:91,checkpoint,checkpointing,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956,4,['checkpoint'],"['checkpointing', 'checkpoints']"
Availability,"> I think the e could be ""effective"" rather than ""eddy"". I'm not sure it makes sense to refer to the molecular diffusivity as ""sub-grid scale"". Shouldn't we refer to the molecular contribution to the flux as ""resolved"" physics?. I come from an engineering background, so my views might be different, but I don't remember ever seeing something called ""effective"" diffusivity. Also, to me at least it's kind of ambiguous what process go into some ""effective"" diffusivity, which I think can confuse users (I certainly would be confused). . Plus, one could argue that molecular diffusivity itself isn't technically ""resolved physics"", since we're not resolving the molecules! It's just the same down-gradient closure as the eddy diffusivity. It works really well in this case because there's a huge scale separation between the molecule size and the smallest motion size, which is the Kolmogorov scale. While this scale separation is natural for molecular diffusivity, it's completely artificial (non-existent really) for the eddies, which is why it doesn't work nearly as well. (Corrsin published a really nice paper about this in 1976.). So I still think that `ν_sgs = ν_eddy + ν_molec` makes sense and is unambiguous. I think being unambiguous is the most important part here, though, since we want people to understand the code easy to be able to contribute, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775252780:691,down,down-gradient,691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775252780,1,['down'],['down-gradient']
Availability,"> I think the majority of simulations do not use a Checkpointer so the warning would be irrelevant in most cases. I don't get this. How are people not using a Checkpointer? Is no one else limited by HPC wall times or running long simulations? It seems like one of the most fundamental capabilities of any time-stepped numerical model. But yes, this warning should only be issued if both OutputWriter *and* Checkpointers are being used *and* if the checkpointer interval is not an integer multiple of the OutputWriter interval.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305122481:51,Checkpoint,Checkpointer,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305122481,4,"['Checkpoint', 'checkpoint']","['Checkpointer', 'Checkpointers', 'checkpointer']"
Availability,"> I think this bug allows the option to restructure the code differently and implement the `ValueBoundaryCondition` like the immersed boundary. In that way, we can get rid of the fill halo regions for value, gradient, and flux boundary conditions.; > I know this might be a bit more tedious, but I think it might pay off later. @simone-silvestri how about merging this now and restructuring the code in a future PR? I think we also have to decide whether we want to accept the downsides of the restructuring, so we may not be ready to implement it yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3209#issuecomment-1665678824:477,down,downsides,477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3209#issuecomment-1665678824,1,['down'],['downsides']
Availability,"> I think this bug allows the option to restructure the code differently and implement the `ValueBoundaryCondition` like the immersed boundary. In that way, we can get rid of the fill halo regions for value, gradient, and flux boundary conditions.; > I know this might be a bit more tedious, but I think it might pay off later. I agree that's interesting. However, there are downsides for diagnostics since you can no longer evaluate gradients on the boundary. This means, for example, that we couldn't calculate the viscous momentum flux on a no-slip boundary in a straightforward manner (though it's still possible to figure it out).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3209#issuecomment-1662919220:375,down,downsides,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3209#issuecomment-1662919220,1,['down'],['downsides']
Availability,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708:62,down,downsides,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708,4,['down'],"['downside', 'downsides']"
Availability,"> I think we need to write down the use cases we want to support (explicitly, as detailed as possible), then we can design the code. I will try (feel free to edit):. The use cases we want to add support for is advection of user specified values into the domain (in a ""soft"" way, i.e. not directly specifying incase the interior solution has diverged from the boundary specified solution), we also want to be able to advect information out of the interior domain. . We want to be able todo this with both user specified bulk velocities as well as velocities that depend on the wall normal velocity and possibly wall normal acceleration (some also consider oblique waves but from what I have read it doesn't help that much). The calculated bulk velocities might be the different at every point (i.e. computed within the fill kernel), but may also (often) be the same at every point on the boundary so should be computed before the fill kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979835760:27,down,down,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979835760,1,['down'],['down']
Availability,"> I think we should distinguish between output we need when we run the model, and output we may eventually provide to the broader community. Ideally, formats for both would be the same, but this may not be the best solution. E.g., netCDF has obvious disadvantages but is still widely used. That does not mean it should be the output format we use by default (although we may want to provide model statistics in netCDF in the end, if a few years from now this is still what everyone uses). So: separate the discussion of what is best for us now from what we should provide (e.g., in any CMIPx archive down the line). Zarr and HDF both seem worth discussing.; > ; > Also important to keep in mind in this discussion: Our workflow will be different from most standard models, which write out instantaneous output that then is post-processed to get statistics etc. We will have to accumulate statistics on the fly, and we can (and should) forgo most instantaneous output, at least for the atmosphere. The model will learn from the accumulated statistics. Otherwise, with instantaneous output, the data volume, especially with embedded LES, will create an I/O and data transfer bottleneck that will limit us, and, e.g., will limit our ability to use distributed computing platforms. I agree. Ideally we'd support different formats (e.g. NetCDF, JLD2, HDF, Zarr, etc.) and have the option to use the best format for your application. We can already switch between output writers and choose which field(s)/diagnostics to output but we only do binary, NetCDF, and JLD for now. We were just focusing on NetCDF for our short-term needs, but this will definitely be a challenge for large problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476303978:600,down,down,600,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476303978,1,['down'],['down']
Availability,> I think we should fix the problem once. Otherwise we'll end up with unnecessary code somewhere that has to be deleted. @glwagner Can you please be clearer? Does that mean adding `min_Δt` to `Simulation` is an acceptable solution? Or should we try to avoid these round-off errors to even happen in the first place?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2150576412:274,error,errors,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2150576412,2,['error'],['errors']
Availability,"> I think what I'm asking is what you envision using this vector for. I don't see the purpose of it. One could just as easily inspect each closure in the tuple individually to see what the viscosity for each closure type is. This method is unambiguous and far more general than developing a ""vector abstraction"" for the diagonal components of a viscosity tensor.; > ; > That said, I agree that the output of `viscosity` for a closure tuple isn't useful. It's summing the viscosities together. This makes sense when the formulations are the same for each component, but not when they are different. So we should change that.; > ; > The main use case envisioned is when you have two `ScalarDiffusivity` with `ThreeDimensionalFormulation`. In that case, `viscosity` returns an object (a `BinaryOperation`) representing the sum of a the nonlinear diffusivity (a field) and the background molecular component (a number). This can then be used in subsequent `AbstractOperations` for calculations.; > ; > When the closure tuple involves multiple `ScalarDiffusivity` with heterogeneous formulations, we need a different abstraction.; > ; > We also need to deal with the case where the closure tuple contains non-scalar-diffusivity closures.; > ; > To design an abstraction, I think we should start with a use case, which can help us develop requirements for the abstraction. Once we have requirements, we can implement something minimal and simple that's easy to reason with and that will generalize to more complicated use cases we may want to consider in the future (hopefully). I agree with this. I'll revert `viscosity()` to its original formulation for now. My only question/suggestion is: should we check in `viscosity(::Tuple)` that the all the elements have the same formulation? That way we can throw a warning (or maybe even an error) when trying to add different formulation closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1272625541:1830,error,error,1830,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1272625541,2,['error'],['error']
Availability,"> I think you may need @inline in front of most of those functions (only matters for CPU). ~That was my first attempt, but I get an error saying `ERROR: LoadError: LoadError: -(grid.Lz) + grid.Δz * (k - 1 / 2) is not a function expression`. I guess I need to choose between `@inline` or `@inbounds`?~. Nevermind, I was doing something very dumb. Inlining gives me exact same performance as not inlining (0.20% of the simulation). I guess the compiler is getting smarter about inlining. > If the slow down is the same for DiscreteForcing then the problem may really just be evaluating exp, sadly... You could try @inline bottom_mask(k) = 1 to test... I'll try that. Although I have tried non-exponential masks in the past with a similar slowdown, so I'm not sure if that's the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875673783:132,error,error,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875673783,4,"['ERROR', 'down', 'error', 'mask']","['ERROR', 'down', 'error', 'masks']"
Availability,> I think you might be able to derive the fifth order scheme from Wicker and Skamarock (2002):; > ; > https://palm.muk.uni-hannover.de/trac/wiki/doc/tec/discret; > ; > http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.119.8289&rep=rep1&type=pdf; > ; > But I'm not 100% sure... Very helpful.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747127872:205,down,download,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747127872,1,['down'],['download']
Availability,"> I thought this was answered quite clearly, albeit for a very idealized case, here: https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692706814 Is AB2 still technically only first-order accurate?. True, that PR does demonstrate convergence with time step! However we seem to rarely concern ourselves with time-stepping errors (apart from catastrophic instability), which I think is justified since spatial errors dominate in our simulations that are typically marginally-resolved in space by design. The stickier and harder question regards _time to solution_, which is what we really care about. It's stickier because it is fundamentally heuristic. For example since RK3 is a 3-stage time-stepper and AB2 is 1-stage, we need to be able to take time-steps that are 3 times longer with RK3. Theoretically, [AB2 is stable up to CFL=0.5](https://mitgcm.org/public/r2_manual/final/online_documents/node310.html) while RK3 is stable up to CFL=sqrt(3)=1.7 --- just barely achieving the ""3x"" needed for RK3 to be superior. But that's just in theory. In practice we find that solutions become unstable at lower CFL, and caution warrants a bit of buffer. It seems like we usually use CFL=0.1-0.2 for AB2 but CFL=0.5-1 for RK3. So at the lower end for AB2, RK3 is indeed providing a decent speed up for time to solution. And I agree with you @ali-ramadhan that I have found in practice that I prefer RK3 for LES. There is more to the story --- RK3 also has superior stability properties for diffusion. Where there is some interesting room for further research is also to understand how much more stable RK3 might make a turbulence closure scheme like CATKE or k-epsilon. We do find that these can impose stricter time-step restrictions than advection, especially on grids with very fine vertical resolution near the surface. RK3 also has the crucial advantage that it is self-starting. This means we can change the time-step at will (without resolving this issue I guess) and we don't need tendenc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394:333,error,errors,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394,4,['error'],['errors']
Availability,"> I thought we'd made this change a while ago, but users should probably just be able to specify tracked fields by name and then we could just change:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/9b67d4d106c905918866e0edb527def0edcc367f/src/Models/LagrangianParticleTracking/update_lagrangian_particle_properties.jl#L24-L33; > ; > to e.g.:; > ; > ```; > for name in particles.tracked_fields; > field = getproperty(fields(model), name); > ...; > ```; > ; > or if we still want the particles to be able to have their own externally defined fields (I'm not sure why we would?), then we could do something a bit more complicated.; > ; > I remember having similar issues when I started using particles too. This seems much better. Aren't there plenty of applications for tracking fields that aren't in `fields(model)`? For example, density, buoyancy, vorticity, speed, light availability. Supporting those cases may require a little redesign of the particles functionality though, so I think the change @jagoosw suggests is still moving in a good direction. It's pretty primitive and hasn't seen a whole lot of love since it was first hastily thrown together many years ago. One way to keep the current functionality (though syntax would change) is to allow a tuple of `tracked_fields`, which can either be `Symbol` (which must be a name in `fields(model)`) or a `Symbol => Field` pair. It's still annoying to build those `Field` prior to model construction but at least it leaves open the possibility.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609#issuecomment-2141330978:878,avail,availability,878,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609#issuecomment-2141330978,1,['avail'],['availability']
Availability,> I tried running it with a NamedTuple and it gave me getindex() errors. What do you mean?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1456822250:65,error,errors,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1456822250,1,['error'],['errors']
Availability,"> I tried to create a lat-lon grid that is flat in `z` but got this...; > ; > ```julia; > julia> grid = LatitudeLongitudeGrid(size=(36, 34), longitude = (-180, 180), latitude = (-85, 85), topology = (Bounded, Bounded, Flat)); > ERROR: BoundsError: attempt to access 0-element Vector{Any} at index [1]; > Stacktrace:; > [1] getindex(A::Vector{Any}, i1::Int64); > @ Base ./array.jl:805; > [2] generate_coordinate(FT::Type, topology::Type, N::Int64, H::Int64, coord::Nothing, arch::CPU); > @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/grid_generation.jl:60; > [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Nothing, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); > @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/latitude_longitude_grid.jl:195; > [4] top-level scope; > @ REPL[5]:1; > [5] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```; > ; > @francispoulin, given that 3rd dimension needs to be flat, how were you running the SWE simulations on lat-lon grid?. Hmm, I have done this with help from @simone-silvestri . I'll go look at our example and get back with some details in a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143548669:228,ERROR,ERROR,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143548669,1,['ERROR'],['ERROR']
Availability,"> I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. I believe my suggestion regarding `default_dimensions` will solve one of the errors encountered in this issue, but I'm not sure about other similar errors.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799808900:287,error,errors,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799808900,2,['error'],['errors']
Availability,"> I was thinking of putting a test saying if not flat in the vertical then stop, but wasn't sure if this is okay. I think you should either error or forcibly remake the grid with `Flat` in the vertical and throw a warning.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1649#issuecomment-839402869:140,error,error,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1649#issuecomment-839402869,1,['error'],['error']
Availability,"> I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. We have an implementation like that for `fill_halo_regions!` here; > ; > https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78; > ; > What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields.; > ; > On the other hand, if defining a new type is useful for OutputWriters I am ok with it. The new commit follows the suggestion of overloading the `compute!` method to apply it on a tuple of `ComputedField`. I also added a check to make sure that all these fields are `FullField`. However, I wonder whether we should throw an error when any of these fields is not a ""full field"" or we should follow the implementation of `fill_halo_regions!` to fill these regions using different methods?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036:1015,error,error,1015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036,1,['error'],['error']
Availability,"> I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work. Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :). > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that. Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443:1021,redundant,redundant,1021,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443,2,['redundant'],['redundant']
Availability,"> I'll leave this here for the record. I'm currently experiencing the first significant dynamical difference I've seen so far between the model with and without the pressure separation.; > ; > In a simulation where I'm studying flow past an obstacle (therefore with immersed boundaries) the simulation runs fine on this branch, but (everything else being the same) doesn't finish running on `main`. On `main` the velocities keep increasing, leading to a progressive decrease in Δt to satisfy CFL condition, but the velocities keep increasing despite that, with smaller and smaller Δts. (I believe that's called a slow blow-up?); > ; > So this is a case where the simulation _fails_ on `main`, but is successful in this branch.; > ; > The simulation is far too complex to post here, but I'll try to come up with a MWE that reproduces it. Interesting that is with immersed boundaries. The pressure solver isn't correct in that case so I'm not sure how to interpret that. The error should be smaller on `main` (because it's only the correction to the hydrostatic anomaly that is wrong on `main`). The main uncertainty is how this PR will interact with #3188. We could explore using the new immersed pressure solver on this branch to test that out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1682026102:973,error,error,973,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1682026102,1,['error'],['error']
Availability,"> I'm a bit stumped. The error is; > ; > ```; > Test threw exception; > --; >   | Expression: advective_and_multiple_forcing(arch); >   | TaskFailedException; >   |  ; >   | nested task error: BoundsError; > ```; > ; > But I can't reproduce this locally.; > ; > I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115; > ; > On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy... I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547:25,error,error,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547,6,['error'],['error']
Availability,"> I'm assuming this is a relatively simple issue to resolve?. Unfortunately not due to our current algorithm that we inherited from MITgcm, but which we hope to change pretty soon. Right now Oceananigans splits up the pressure into the hydrostatic pressure anomaly and the non-hydrostatic pressure (see https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/pressure_decomposition/). MITgcm did this to facilitate easy switching between a hydrostatic mode and a non-hydrostatic mode: to turn a non-hydrostatic model into a hydrostatic one, just don't compute the non-hydrostatic pressure and recompute w from the continuity equation. But we feel we can use multiple dispatch to implement a hydrostatic model in Julia. This algorithm also requires extra memory (2 pressure fields instead of just 1). So we're hoping to change the algorithm to only use 1 pressure field and get rid of this pressure decomposition. The algorithm also makes it difficult to implement tilted gravity because the hydrostatic pressure anomaly is computed as. ```; pHY′ = ∫ buoyancy_perturbation dz from z=0 down to z=-Lz; ```. where `buoyancy_perturbation = g * (αT - βS)` if you're using a linear equation of state. So now if gravity is tilted it's not just a vertical integral. I'm actually not sure how to modify the vertical integral if gravity is tilted... Seemed easier to move away from this vertical integral by not decomposing pressure then we should be able to easily add in support for tilted gravity via a `bg⃗` term in the momentum equation where `g⃗ = g⃗(x, y, z)` can be whatever the user wants. Not sure if we have an issue discussing this change to the pressure decomposition, but if it doesn't exist then I can open one to track progress on it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732369605:1110,down,down,1110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732369605,1,['down'],['down']
Availability,"> I'm getting this error when trying to run my code on multiple GPUs (it works fine on CPUs):. Hmmmm it has to do with switching `stream` from your stream pool in the GPU you are in. That always worked for the clusters I tried. Any instance of `@apply_regionally` should fail for you. If you can give me a MWE I can take a look at it. In particular, it looks like you are specifying 2 GPUs but your system only sees 1 on them. What is your output of `CUDA.devices()`?. > Also, is there any reason why only `XPartition` is exported?. No particular reason, actually. That is the first partitioning I started working on. `YPartition` came later and apparently, I forgot to export it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310758094:19,error,error,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310758094,1,['error'],['error']
Availability,"> I'm guessing it's slower because it's masking out the immersed values but I don't know if we expect it to be ~2000x slower than without an immersed boundary. It's those memory allocations... But why are there memory allocations when calling `minimum(u2)`? This is a type inference problem I think. The problem is actually computing reductions of _windowed_ immersed fields. `u2` is _windowed_ because halos were excluded from the output. If we write `with_halos = true` and re-run everything, there is no issue:. ```julia; julia> @time minimum(u2); 0.031018 seconds (366 allocations: 33.102 KiB, 6.05% compilation time); 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3750#issuecomment-2377505117:40,mask,masking,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750#issuecomment-2377505117,1,['mask'],['masking']
Availability,"> I'm not really sure how to fix this one... Not sure if I completely understand what's happening since I am not super familiar with the `NetCDFOutputWriter`, but it looks to me like an implementation of `define_output_variable` has been provided for `WindowedSpatialAverage`, but not for the case when `WindowedSpatialAverage` is wrapped inside a `WindowedTimeAverage` (in which case the type of the output is `::WindowedTimeAverage{<:WindowedSpatialAverage}` as written in the error message above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525:479,error,error,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784265525,1,['error'],['error']
Availability,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:67,error,error,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869,4,['error'],['error']
Availability,"> I'm not sure there is any way that the pressure separation could directly impact the conservation of tracer, so I'm hypothesizing that the effect is indirect and occurs through the differences in the emergent dynamics. Yes, I think the tracer errors must be arising due to differences in the emergent dynamics. Isn't there something about the errors in the pressure solver meaning that the velocity field is partially divergent and that the no-normal-flow boundary condition is not perfectly satisfied?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2265952102:245,error,errors,245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2265952102,2,['error'],['errors']
Availability,"> I'm ok with exporting `KernelFunctionOperation` from the submodule `AbstractOperations`. But do we also want to export it from the top-level so it's available when we write `using Oceananigans`?. I'm okay with not exporting it to the top level, but then I guess we also wanna stop exporting `KernelComputedField` to the top level for consistency, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1939#issuecomment-901387255:151,avail,available,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1939#issuecomment-901387255,1,['avail'],['available']
Availability,"> I'm up to add such a feature but to combat disinformation, we must note that it is possible to run without `const`ants:; > ; > ```julia; > using Oceananigans; > ; > grid = RectilinearGrid(GPU(), size=(4, 4, 4), extent=(1, 1, 1)); > ; > Base.@kwdef struct MonochromaticStokesShear; > Us :: Float64 = 0.05; > wave_vertical_scale :: Float64 = 5.0; > end; > ; > @inline (mss::MonochromaticStokesShear)(z, t) = mss.Us * exp(z / mss.wave_vertical_scale) / mss.wave_vertical_scale; > ; > model = NonhydrostaticModel(; grid, stokes_drift=UniformStokesDrift(∂z_uˢ=MonochromaticStokesShear())); > ; > time_step!(model, 10); > ```. Interesting, I didn't know one could use `@kwdef` to make this work so thanks for correcting me. I tried running it with a `NamedTuple` and it gave me `getindex()` errors so I assumed `const` was the only way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1456769440:787,error,errors,787,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1456769440,1,['error'],['errors']
Availability,"> I'm wondering if it might be a bit much to put docstrings on every single AbstractGridMetric for this experimental feature? They aren't exported so not user-facing (I think we may end up using this internally only for things like IntegratedField down the line). Fair point. But internal docstrings also help I think. It's way easier for me to contribute, for example, when the internal functions are well-documented. I think the more we add these, the more likely we are to get contributions from people outside of the regular group, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826008043:248,down,down,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826008043,1,['down'],['down']
Availability,"> I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275:220,error,errors,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275,1,['error'],['errors']
Availability,"> I've got the mode-1 internal wave case working now. Axes are in units of depth (h) and k is set to π/h, top panel is `u`, middle is `w`, and bottom is `b`.; > ; > First the periodic case:; > ; > internal_wave_sponge_pp.mp4 ; > As expected numerical error reflects off the boundary if we just prescribe the boundary values:; > ; > internal_wave.mp4 ; > And with quite a small sponge (red lines in top plot) this is pretty much resolved:; > ; > internal_wave_sponge.mp4. So the cases that ""work"" just use a sponge, but no matching scheme?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004536722:251,error,error,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004536722,1,['error'],['error']
Availability,> I've made this mistake many times haha. Seems like it might be good to add a warning telling users they probably meant to pass in a ComputedField since the error isn't super useful and only shows up when you call run!. We could limit the type of the elements of `values(outputs)` to callable objects and `AbstractField` ?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762957312:158,error,error,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762957312,1,['error'],['error']
Availability,"> If a user makes a mistake and provides a matrix with one column instead of a vector, it will fail internally with an unfriendly error message. Ah for sure. I was just remarking that if you need the eltype, you can use `AbstractArray{FT}` (or you can simply call `eltype`, which is preferred by [YASGuide](https://github.com/jrevels/YASGuide) --- type parameters should be used for dispatch only). I think it's ok if you keep `AbstractVector`. We can create a wrapper for Krylov.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962:130,error,error,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962,2,['error'],['error']
Availability,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092:149,mask,masking,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092,2,['mask'],['masking']
Availability,"> If we change the name and that's a breaking change we will bump the version and all users will be happy or keep working with the Oceananigans version they want to. I understand that it'll just be a breaking release. My concern is that a user that has a tilted-domain simulation with `gravity_unit_vector=g` will update their Oceananigans version, the code will run possibly without any errors, give a completely different result since gravity just flipped, and they won't know that it's because now they should have `gravity_unit_vector=-g`. But if we think that's an acceptable price (I don't know how many people use this feature) and that keeping the name while changing the code is the way to go, then I'm fine moving forward with that. I do think we should decide this and resolve this though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455154184:388,error,errors,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455154184,1,['error'],['errors']
Availability,"> If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. Close! But we failed to mention that this damps the _horizontal_ divergence, not the 3D divergence... So it's not damping error; it's damping physical flows with non-small `dw/dz`. And you're right, we haven't implemented a separate ""rotational damping"" closure. But we could. And yeah, you can exchange those operators in continuous space, but not the discrete analogs. So the order of operators matters discretely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112563320:118,error,error,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112563320,2,['error'],['error']
Availability,"> If we have fluid falling down the slope, to the left, I think it's reasoanble to expect it to start to the right. Because it's periodic that makes things a little complicated because the fluid falls out through the left and then enters in on the right. Keep in mind though that this isn't a gravity current, but rather Ekman transport down the slope due to a uniform along-slope velocity. My expectation would be that the downslope Ekman flow should start uniformly across the slope (not at a boundary). . > Out of curiosity, would it be possible to try this with Bounded in x? I wonder what that would look like. Here you would develop an overturning circulation up through the water column (upward branch at the left boundary, descending at the right boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885050727:27,down,down,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885050727,3,['down'],"['down', 'downslope']"
Availability,"> If you wanna ensure that you are doing exactly what the docs built will be doing then do the above. Otherwise, yes just running the example is easier. I thought you'd run it already so I was trying to find the culprit :). I started by updating all the examples for the new syntax that I thought would work, and then went on to other stuff to let the CI do its thing. Now that I see one of them failed I went back and focused on that one specifically. I think its an ok workflow since regardless I would have to wait for compilation / setup, so its not a bad strategy to let CI find the errors for you, at least at first",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272659233:588,error,errors,588,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272659233,1,['error'],['errors']
Availability,"> In the Docs, should we write `𝐟` or `f𝐤` for the Coriolis term? Does the shallow water model only supports Coriolis aligned in the vertical?. Yes, for shallow water we can only have the Coriolis vector in the vertical direction. Otherwise, we will have 3D motion and the basic assumption of columnar motion breaks down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142151054:316,down,down,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142151054,1,['down'],['down']
Availability,> Increasing the precision of the output to Float64 eliminates the initial error seen at the first few frames of the animation. I'm not sure I understand. The error is only associated with post-processing and not with the actual simulation?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712197575:75,error,error,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712197575,2,['error'],['error']
Availability,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440:356,down,downstream,356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440,4,"['down', 'error']","['downstream', 'error']"
Availability,"> Is energy increasing? If so that might be a time stepping error and you need to reduce your time step. Yes, and the issue does seem to decrease with a time step but not nearly fast enough (at least for this specific setup). Here are some results with the MWE above using 1e-6 m/s initial noise amplitude and running the simulation for 10 days. . In all cases the initial KE is ~5e-14 m2/s2. | Target CFL | KE final / KE initial |; | ------------- | ------------- |; | 5e-1 | 1e7 |; | 5e-2 | 1e5 |; | 5e-3 | 1e3 |; | 5e-4 | 16 |. So even running with a 5e-4 cfl there's still an order of magnitude increase in the KE after 10 days. To me this is totally unexpected for the setup in question.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442082140:60,error,error,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442082140,1,['error'],['error']
Availability,"> Is it possible to get julia to ignore the manifest (i.e. specify that we want to ignore it in the CI), so that when a user downloads it they can still use the manifest?; > ; > Having asked that I don't actually know what the manifest does that isn't already taken care of by the Project?. The Project compat is supposed to take care of everything. It's just that subtle bugs can creep into packages that might cause things to fail for us (for example something subtle can break type inference, causing everything to fail on the GPU). So using the Manifest is a bit more conservative, because we fix all of the packages that don't _need_ to be upgraded. On the other hand, we are better community members by deleting the Manifest because catching those bugs is important for everyone.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361571344:125,down,downloads,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361571344,1,['down'],['downloads']
Availability,"> Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU. I think it might be more fruitful to generalize `BatchedTridiagonalSolver`. It's a little annoying (our fault for using `i, j, k` rather than `CartesianIndex`...) --- but we can probably figure out how to rotate indices in https://github.com/CliMA/Oceananigans.jl/blob/a314f1f64e80181ecff84d6bab1e5182644d95cc/src/Solvers/batched_tridiagonal_solver.jl#L91. Not a small refactor, so I'd argue not priority 1 right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023499655:318,fault,fault,318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023499655,1,['fault'],['fault']
Availability,"> Is this bad? Sorry but I'm not sure what the problem is. It's not a major problem, just misleading since we can indeed write this function and don't need to throw an error. > I thought we wanted a stretched domain to be bounded?. Only for `IncompressibleModel` with currently available Poisson solvers: `FourierTridiagonalPoissonSolver` can only solve the Poisson equation in domains that are vertically-bounded. But with other solvers (or problems that don't need Poisson solvers), its fine to have a vertically-periodic domain with a vertically-stretched grid, as far as I can tell.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1605#issuecomment-825685613:168,error,error,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1605#issuecomment-825685613,2,"['avail', 'error']","['available', 'error']"
Availability,"> Is this for ShallowWaterModel?. Yes, the closure terrm for tracers was not done correctly and gave an error in the previous form. This fixes it for the `VectorInvariantForm`, but more work needs to be done for the `ConservativeForm`. I plan to talk to @simone-silvestri on Monday about this and other things.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157760136:104,error,error,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157760136,1,['error'],['error']
Availability,"> Is this for examples and docs? It does obviously read better; I'm not sure about the downside of name proliferation. Maybe we can stew on it and update in a future PR?. I was thinking both, i.e. encourage their use to improve script readability. Yeah we can just update things as we go along. I guess the downside is that new users may not immediately notice that these common words, e.g. `minutes`, are actually being exported by `Oceananigans.Utils`. Perhaps if they were exported by a submodule like `Oceananigans.Units` that would be clearer. Also, newcomers to Julia may not realize that you can write things like `2π` or `3hours` but this should not stop us from using this nice language feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555:87,down,downside,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555,2,['down'],['downside']
Availability,"> Is this for examples and docs? It does obviously read better; I'm not sure about the downside of name proliferation. Maybe we can stew on it and update in a future PR?. I was thinking both, i.e. encourage their use to improve script readability. Yeah we can just update things as we go along. I guess the downside is that new users may not immediately notice that these common words, e.g. `minutes`, are actually being exported by `Oceananigans.Utils`. Perhaps if they were exported by a submodule like `Oceananigans.Units` that would be clearer. Also, newcomers to Julia may not realize that you can write things like `2π` or `3hours` but this should not stop us from using this nice language feature. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1075:87,down,downside,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1075,2,['down'],['downside']
Availability,"> It doesn't give any errors but seems to freeze when running the simulation. In the case of a 16x16 grid my student waited 4 hours and nothing. Are you trying to initialize a flow, or implement a geostrophic solution as a background flow / basic state?. I think if you're trying to use `BackgroundFields` the function `b(x, y, z, t, p)` is called at every grid point and time step. So I think you want to precalculate a background `Field` rather than provide a function that's recomputed every time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-874992659:22,error,errors,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-874992659,1,['error'],['errors']
Availability,"> It fixes it for CPUs, but I get an error for GPU architecture. It's likely that we need to allow scalar operations due to `==`. I'm planning on trying that tomorrow and I won't merge before it also works for GPUs. (I was wondering if we should add this as a test...). Hm... Whatever we do should work for both CPUs and GPUs. @glwagner and I were thinking about equality between grids at some point. Probably (I'm not sure -- you can double check that), the fix in this PR fails for GPUs, because when in that case when the checkpointer tries to compare the two grids, the one saved on disk has `Arrays` while the other one has `CuArrays`. If that's the case, we need a solution that remedy this and call two grids ""equal"" despite the device they live on. Some of these issue are related or discussed within #1825 and #1998.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945215869:37,error,error,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945215869,2,"['checkpoint', 'error']","['checkpointer', 'error']"
Availability,"> It looks like the function `calculate_Gu!` is passing too many parameters to the GPU. there is a limit to the number of parameters you can pass. Can you show the functions you are using?. Also just to clarify for @tomchor note that `Entry function... uses too much parameter space (0x1a10 bytes, 0x1100 max)` in the PTX compilation error refers to parameters in the sense of https://github.com/JuliaGPU/CUDA.jl/issues/267 (not the ""parameters"" of `Forcing`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401328595:334,error,error,334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401328595,1,['error'],['error']
Availability,"> It looks like the function `calculate_Gu!` is passing too many parameters to the GPU. there is a limit to the number of parameters you can pass. Can you show the functions you are using?. The example below can reproduce the error pretty well for me (it's basically the same as the one above but with discrete forcing and a few more tracers). So if you're trying to debug it, this is probably the way to go. ```julia; using Oceananigans; arch = GPU(). z_faces = collect(0:1:6); grid = RectilinearGrid(arch, size=(8, 8, 6),; x=(0, 1), y=(0, 1), z=z_faces). @inline b_bg(x, y, z, t) = x; B_field = BackgroundField(b_bg). @inline sponge_u(i, j, k, grid, clock, model_fields, p) = -p.σ * (model_fields.u[i,j,k] - p.α*p.u₀); @inline sponge_v(i, j, k, grid, clock, model_fields, p) = -p.σ * (model_fields.v[i,j,k] - p.α*p.u₀); @inline sponge_w(i, j, k, grid, clock, model_fields, p) = -p.σ * (model_fields.w[i,j,k] - p.α*p.u₀); @inline sponge_b(i, j, k, grid, clock, model_fields, p) = -p.σ * (model_fields.b[i,j,k] - p.α*p.u₀). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; σ=1, u₀=1, α=4e-5), discrete_form=true); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; σ=1, u₀=1, α=4e-5), discrete_form=true); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; σ=1, u₀=1, α=4e-5), discrete_form=true); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; σ=1, u₀=1, α=4e-5), discrete_form=true). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2, :τ3), # This runs fine with one fewer tracer now; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. My actual production code is far too complicated to paste here, but the relevant forcings I'm using there are:. ```julia; const z₀ = -100; const z₂ = -120; const z₁ = -grid.Lz. @inline function bottom_m",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401329050:226,error,error,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401329050,1,['error'],['error']
Availability,"> It looks like the problem is because NCDatasets needs NetCDF_jll, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. You may need to raise an issue with `NetCDF_jll.jl`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2840#issuecomment-1327966801:81,avail,available,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840#issuecomment-1327966801,1,['avail'],['available']
Availability,"> It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. This is likely to help since the velocity is small in the boundary layer, and so will reduce the magnitude of the local correction in a step. > We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. I would be interested in such an argument. Other than zooming in on the slowest part of the BL, I'm not sure if/why increasing resolution would reduce the total flux over a fixed interval of time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-868299100:436,mask,masking,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-868299100,2,"['error', 'mask']","['error', 'masking']"
Availability,"> It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78; > ; > ~If I followed the code correctly, the LES models are looped through here: ~; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8; > ; > ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~. True, we have to regenerate the test data to make this change to the default if we want to continue using the default in the regression test. As a quick fix we could change the regression test to use `C=0.23`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946:780,down,downside,780,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946,1,['down'],['downside']
Availability,"> It seems to me that both methods are trying to do the same thing.; > ; > They both identify a cell that the topopgraphy passes through and picks a height to represent the topogrpahy, and it should be the same cell. In the partial cell method we find the height to be something between the bottom and the top of that cell. The grid fitted boundary used the bottom (or the top, if I'm mistaken).; > ; > If they are both doing the same thing and the only differences is the particular height we assign, then do we want to have two completely different methods? Instead we could have one general method that allows for the two (or more) options.; > ; > We might want to have different options on how to pick the height of the topography.; > ; > 1. Bottom of the cell (GridFittedBoundary); > 2. Top of the cell; > 3. Midpoint rule (2nd order approximation, and what I am currently playing with); > 4. Simpsons rule (4th order approxiamtion, and not that much harder to do).; > ; > If it's not that much more effort then why wouldn't we want to give the user a choice in how to represent the topogrpahy?; > ; > Also, one method would be less to maintain, I would think, when we decide what that method should be and code it up.; > ; > This is just a suggestion and I am of course happy to follow whatever people decide is best moving forward. I think generalizing `GridFittedBottom` so that we have different methods available to identify the ""height of a cell"" is a nice idea. Using `bottom_height` evaluated at cell centers is a low-order method in a sense. So we can have higher-order methods available. You can add a property to `GridFittedBottom` that allows the user to control that behavior, something like `height_model` (although I hate the word ""model"" so maybe there's a better name).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044501306:1413,avail,available,1413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044501306,2,['avail'],['available']
Availability,"> It's because there is no method for `arch_array(arch, ::BitArray)`. I ll add it. Thanks @simone-silvestri. I wonder why I wasn't able to reproduce the error locally though. I even tested it on the GPU but everything passed somehow. Seems like tests pass. I just need an approval and I'll merge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3440#issuecomment-1917231125:153,error,error,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3440#issuecomment-1917231125,1,['error'],['error']
Availability,"> It's coming from the hydrostatic pressure integral. Does CATKE modify the hydrostatic pressure integral? Seeing that made me think that it wasn't the integral and that the illegal memory access happened elsewhere but was ""caught"" in the hydrostatic pressure integral kernel. Not sure if it'll be useful but I'll try prodding around the `model` to see if there's a `Float64` somewhere as a hint. > but you can confirm that it doesn't happen with `closure=nothing`?. I can confirm that this MWE works and does not produce an error:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; longitude = (0, 1),; latitude = (0, 1),; z = (-100, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = BuoyancyTracer(),; tracers = (:b, :e),; closure = nothing; ); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439675501:525,error,error,525,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439675501,1,['error'],['error']
Availability,"> It's just a small detail...; > ; > if you had an `ImmersedBoundary` on the `GPU` and wanted to move it on the `CPU` (in case the immersed boundary was an abstractarray) the `immersed_boundary` would remain a `CuArray` even after calling `on_architecture(CPU(), ibg)`.; > ; > This was a small bug which never really affected us (you never really need to shift a grid from the `GPU` to the `CPU` in practice and most of the time that bottom is a function, not an array). On the other hand I needed this because when I do a `MultiRegionGrid` of a `ImmersedBoundary` and split the `bottom` in different `GPU`s, I need to pass that bottom correctly to the `CPU` otherwise we have `CUDA illegal access` problems (i.e. you cannot just split an array from one GPU to others without taking care of it adequately); > ; > So I was getting an error related to this when I wanted to split a simulation with ""realistic"" bathymetry onto 2 GPUs. Makes sense. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084722001:833,error,error,833,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084722001,1,['error'],['error']
Availability,"> It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance. Good point. Adding 3 separate constant diffusivities is a good idea, but it wouldn't test any LES closures (where the fields have to actually be computed). Do you think that'd be necessary?. Another possibility is to compare a model with `closure=SmagorisnkyLilly(ν=1e-6, κ=1e-7)` against a model with `closure=(SmagorisnkyLilly(ν=0, κ=0), IsotropicDiffusivity(ν=1e-6, κ=1e-7)`. Those should be equivalent, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883734013:185,toler,tolerance,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883734013,1,['toler'],['tolerance']
Availability,"> It's something to do with GPU, maybe GPU reductions?; > ; > ```; > [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; > --; >   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199; >   | Expression: minimum_xspacing(grid) ≈ FT(π / 3); >   | Evaluated: 0.0 ≈ 1.0471975511965976; > ```. I see this error. But I can't reproduce it. On tartarus it's not happening and I don't have access to Svedrup. So I don't know what to do... :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566845080:427,error,error,427,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566845080,1,['error'],['error']
Availability,"> Just added BitInformation to the Project.toml, due to dependency on `StatsBase` and `Distributions` this also adds; > ; > ```; > Updating `~/git/Oceananigans.jl/Project.toml`; > [de688a37] + BitInformation v0.6.1; > Updating `~/git/Oceananigans.jl/Manifest.toml`; > [66dad0bd] + AliasTables v1.1.2; > [de688a37] + BitInformation v0.6.1; > [49dc2e85] + Calculus v0.5.1; > [31c24e10] + Distributions v0.25.108; > [fa6b7ba4] + DualNumbers v0.6.8; > [1a297f60] + FillArrays v1.11.0; > [34004b35] + HypergeometricFunctions v0.3.23; > [77ba4419] + NaNMath v1.0.2; > [90014a1f] + PDMats v0.11.31; > [1fd47b50] + QuadGK v2.9.4; > [79098fc4] + Rmath v0.7.1; > [2913bbd2] + StatsBase v0.34.3; > [4c63d2b9] + StatsFuns v1.3.1; > [f50d1b31] + Rmath_jll v0.4.0+0; > ```; > ; > also why is the Manifest.toml committed?. Through past experience we found that we needed the Manifest committed to make sense of the errors we encounter during CI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109117793:900,error,errors,900,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109117793,1,['error'],['errors']
Availability,"> Just do the datadep like the tests do it and do delete anything downloaded to retrigger downloading. Let me know if that helps. @navidcy, you were right. Manually deleting the dowloaded .jld2 file at `~/.julia/scratchspaces/124859b0-ceae-595e-8997-d05f6a7a8dfe/datadeps/cubed_sphere_32_grid_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2` and forcing DataDeps to download it again solved the issue! Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023746490:66,down,downloaded,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023746490,3,['down'],"['download', 'downloaded', 'downloading']"
Availability,"> Keep in mind though that this isn't a gravity current, but rather Ekman transport down the slope due to a uniform along-slope velocity. My expectation would be that the downslope Ekman flow should start uniformly across the slope (not at a boundary). Yes, that was my thinking too. Plus, the set-up is homogeneous and periodic in the horizontal directions, so really there should be no preference in `x` for motion to start. I also can't find anything in the code that would introduce an asymmetry so I need to investigate this further in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885166453:84,down,down,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885166453,2,['down'],"['down', 'downslope']"
Availability,> Likely this function is the problem:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/775d1544610d5af6f602254ec5dff3dec7f18480/src/BoundaryConditions/update_boundary_conditions.jl#L15-L16. Yeah I saw that this was where some of the errors were coming from but I don't really understand what is going on with Enzyme that this causes problems?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263597330:238,error,errors,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263597330,1,['error'],['errors']
Availability,"> Locally I am seeing:; > ; > ```; > Binary operations [GPU]: Error During Test at /home/vchuravy/src/Oceananigans/test/test_abstract_operations.jl:121; > Test threw exception; > Expression: ZeroField() - u == -u; > Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/B3xv7/src/GPUArraysCore.jl:100; > [3] getindex(::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Int64, ::Int64, ::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/g2pOV/src/host/indexing.jl:9; > [4] getindex; > ```. Ok, I'll take a look",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2899#issuecomment-1418343631:62,Error,Error,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2899#issuecomment-1418343631,3,"['Error', 'error']","['Error', 'error']"
Availability,> Looks good and hope the tests all pass.; > ; > Should any new tests be added?. I think we should test that we can use `ContinuousBoundaryFunction` on an auxiliary field and run `fill_halo_regions!` without error. Or better yet show that it produces the right thing.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1859#issuecomment-880639149:208,error,error,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859#issuecomment-880639149,1,['error'],['error']
Availability,"> Luckily, I found a reliable way to get NaNs immediately is to set both reltol and abstol to zero and maxiter to more than a thousand. The purpose is to test the numerical stability of the iteration method. I think this makes sense. When the residual is reduced to near machine precision then I think this is when the present instability is exposed, which occurs when the search direction is essentially a constant. I wonder if its possible that the instability was observed in the original simulations when, for some random reason of the flow configuration, the CG solution converged especially fast (thereby exposing the instability).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420734546:21,reliab,reliable,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420734546,1,['reliab'],['reliable']
Availability,> Masking is done:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/ca437145013e82380bbbc8b1d700656eeba78607/examples/internal_tide.jl#L213-L217. That's great.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986919343:2,Mask,Masking,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986919343,1,['Mask'],['Masking']
Availability,"> Maybe another doubt, what do we do if the α is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?. We don't mask the partial cells at all. We only mask cells that are fully immersed. There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683:102,mask,masking,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683,4,['mask'],"['mask', 'masking']"
Availability,"> Maybe just; > ; > ```julia; > const WindowedData = OffsetArray{<:Any, <:Any, <:SubArray}; > const WindowedField = Field{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:WindowedData}; > construct_output(user_windowed_field::WindowedField, indices) = user_windowed_field # don't re-index a windowed field; > ```; > ; > `WindowedField` is defined in #2502, but its ok to redefine it here and we can consolidate later. This indeed appears to work, thanks for the suggestion. A quick note here is that by not reindexing, the output writer's keyword `with_halos` has not effect. Ideally we want `with_halos` to trim down the halos even in windowed fields, no? Any thoughts? (Or maybe we can add `with_halos` option to `Field`?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1115525480:608,down,down,608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1115525480,1,['down'],['down']
Availability,"> Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error.; > ; > Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?. Mm yeah I can extend the existing test to pass only if the tracer distribution changes after that time-step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234:82,error,error,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234,2,['error'],['error']
Availability,"> My end goal here is to recreate the set-up in [this paper](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/frontogenesis-and-frontal-arrest-of-a-dense-filament-in-the-oceanic-surface-boundary-layer/2FFBE4503C590CE7BDB1B8BAA236C387) and see if I can see some submesoscale activity. This is just a proof (or disproof I guess) of concept, so I'm aiming for a coarser resolution and other simplifications. Any tips are greatly appreciated. If you're mostly interested in the oceanic boundary layer and don't need topography or a free surface, then Oceananigans probably has most of what you need. (See #443 if you're interested in surface physics.). 8192×3072×256 ~ 10¹⁰ grid points is out of our reach for the moment although our plan is to be able to run these super large simulations one day!. We're still limited to 1 GPU (with 16 or 32GB RAM) which lets us go up to ~5×10⁷ grid point. We could probably extend that to ~10⁸ grid points if we implement #98 but even then it would take 50-100 GPUs to reach 10¹⁰ grid points. We've mostly been running oceanic mixed layer simulations with a focus on vertical mixing so no need for a ton of horizontal resolution, but we do have horizontal mixing problems in mind at which point we'll need to start running on multiple GPUs with MPI. This is something we're starting to get serious about as we do need it ourselves. Not sure how coarse you can go but if you can go down to ~10⁸ grid points then maybe Oceananigans can be useful. If the factor of ~2 reduction in memory usage from #98 would be useful for you, let us know and we can look into implementing it. In general, I think we're happy to work together on features that you might need. I still need to work on some documentation to showcase all the model creation options, etc. so let us know if you're not sure how to impose a certain boundary condition or forcing, etc. Out of curiosity, what LES model are you currently using?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539743886:1440,down,down,1440,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539743886,1,['down'],['down']
Availability,"> My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. It will mean that `set!` becomes more specific; ie two-dimensional set functions can only be applied to two-dimensional variables. I think there are more _possibilities_ for bugs if three-dimensional functions can be applied to two-dimensional variables. For example, you might accidentally assign the wrong initial condition to a variable. When half the variables are 2D and half are 3D, you have the possibility that a typo throws an error. We can add some `try catch` statements to throw helpful errors within `set!` when we encounter a `MethodError`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631:560,error,error,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631,2,['error'],"['error', 'errors']"
Availability,"> Nice work! I'm curious about the criteria. Should it be something like; > ; > ```julia; > dt = 10 * eps(dt) * sim.dt; > ```; > ; > ? Or does it have to be larger than that (hence the factor 1e10). I actually don't know what the proper criterion should be. With the one you proposed, the error doesn't go away in this example since the tiny time-step is about `1e-12`, but `10 * eps(dt) * sim.dt` come out to be about `1e-13`. If we use `100 * eps(dt) * sim.dt` then it works. But I don't yet know how much of this will generalize to other, more complex simulations. I still have to test these on my own simulations to see what works. > It'd be nice not to have to define `next_actuation_time` for every schedule... it doesn't really make sense for `WallTimeInterval` either. Plus, we want users to be able to provide custom schedules (since they only need to be a function of `model` that returns true/false) so that people can trigger output / action using interesting custom criteria... Yeah, agree. I'm not sure of a good workaround here though. Do you have suggestions?. For the time being we can just set a fallback method as `next_actuation_time(scheduke) = Inf` I guess? (Similar to what I did for `IterationInterval`. Also, nice to see that tests pass and nothing is breaking :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2130431035:289,error,error,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2130431035,1,['error'],['error']
Availability,"> No flux are the default for immersed boundary. It looks like you are explicitly setting an immersed boundary condition for a non-immersed field. What is `b`s grid?. The same as `model`s: a MultiRegion grid. I'm not yet using the IB grid since apparently `MultiRegionGrid` isn't working with IBs yet. When I use it, I get this error. ```julia; ERROR: LoadError: MethodError: no method matching PressureSolver(::CPU, ::MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}); Closest candidates are:; PressureSolver(::Any, ::ImmersedBoundaryGrid) at ~/.julia/packages/Oceananigans/Kq8xW/src/Models/NonhydrostaticModels/NonhydrostaticMod",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1309394728:328,error,error,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1309394728,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,> No stretched mesh is supported at the moment (that will come in a later PR). Will an info/error been thrown in this case?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2259262179:92,error,error,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2259262179,1,['error'],['error']
Availability,"> Not sure I understand this. Is this trying to check whether a location is adjacent to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. Are you confused by the _definition_, or the way it's used? `peripheral_node` and `immersed_peripheral_node` are needed to condition fluxes. `external_node` is needed for masking. For example, vorticity is valid _on_ the boundary, and thus peripheral values of vorticity should not be masked (I don't think...). But we do need to condition fluxes on peripheral nodes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100753659:354,mask,masking,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100753659,2,['mask'],"['masked', 'masking']"
Availability,"> Not sure if I should open another issue for this, but I was trying to set-up a 2D topology like `(Bounded, Flat, Bounded)` but couldn't. Apparently, however, `(Flat, Bounded, Bounded)` works.; > ; > Is there a list of available topologies to choose from? The `topology` page on the docs leads me to believe that they're all implemented but (unless I'm missing something) they're not. Is that list somewhere in the docs? I couldn't find it.; > ; > Cheers!; > ; > _Originally posted by @tomchor in https://github.com/CliMA/Oceananigans.jl/issues/1178#issuecomment-732235261_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1192:220,avail,available,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1192,1,['avail'],['available']
Availability,"> Not sure of all the changes, but from the changelog a big change is a new type encoder: https://github.com/JuliaIO/JLD2.jl/releases/tag/v0.5.0; > ; > Old JLD2 files should still be readable though. And new files are incompatible with JLD2 versions <= v0.4.53.; > ; > On that PR it seems like it resolves some JLD2.jl issues with saving functions to disk. Could this mean easy checkpointing of full simulations...? 😮. that'd be huge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3769#issuecomment-2369183980:378,checkpoint,checkpointing,378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3769#issuecomment-2369183980,1,['checkpoint'],['checkpointing']
Availability,"> Not sure what ""squash and merge"" means . Ah it's one of the three merge options, e.g. ![image](https://user-images.githubusercontent.com/20099589/117980914-70e08180-b302-11eb-9179-9e8cbad457a3.png). where it combines all the commits into one commit then merges. Then intermediate changes (like a file that was created then deleted) do not enter git history. > I deleted the file locally and then wanted to push the change but couldn't. If someone can tell me how to delete it I'm happy to do it. That should be all it takes... What error does git produce? I can also try locally. > Also, I see that the tests pass so my use of `Polynomials` presumably worked?. Ah I don't think `plot_rates_convergence_advection.jl` is actually run as part of CI right now. We could add it in this PR if you're interested. I think we'd want to actually add it to the validation pipeline (not the main pipeline) so we would add a new test set in https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_convergence.jl and add a new build step in https://github.com/CliMA/Oceananigans.jl/blob/master/.buildkite/validation-pipeline.yml then it would show up in these builds with plots, e.g.: https://buildkite.com/clima/oceananigans-validation-experiments/builds/208. > Anything else that people would like done before someone approves this PR?. I think it looks good to merge, just without the extra image file!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839764128:534,error,error,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839764128,1,['error'],['error']
Availability,"> Note on testing for this issue: the output is often correct for the _first_ evaluation of the average. Subsequent evaluations seem to produce the error. Just FYI, I was able to reproduce @ali-ramadhan's results exactly with his MWE. And I also did it with only one run of `simulation`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-870902088:148,error,error,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-870902088,1,['error'],['error']
Availability,"> OK, this is now ready to review.; > ; > I have hardcoded the boundary condition parameters! Any attempt to include them via parameters failed. Please help by showing me how (try building the docs though first before you claim success :) --- I tried a million times!); > ; > Also, I get a lot of these warnings:; > ; > ```; > ┌ Warning: type FieldBoundaryConditions{BoundaryCondition{Flux, Nothing},BoundaryCondition{Flux, Nothing},Nothing,Nothing,BoundaryCondition{Flux, Nothing},BoundaryCondition{Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.__atexample__named__horizontal_convection.#bˢ,Nothing,Tuple{},Tuple{},Tuple{}}},BoundaryCondition{Flux, Nothing}} does not exist in workspace; reconstructing; > └ @ JLD2 ~/.julia/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:358; > ```; > ; > Any idea why? My instinct says that these issues are intertwined but I can't figure out why... What's the error?. I believe that warning comes from `FieldTimeSeries`. But that's a warning, not an error, so its ok.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881793492:955,error,error,955,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881793492,2,['error'],['error']
Availability,"> Of course I agree with this. I think our basic principle should be that there is no difference in workflow, either for running or analysis, between scripts for checkpointing or not. Also, I think that overwrite_existing should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. Yes, I completely agree, if the simulation picks up from a checkpoint it should not delete data. >Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:; >; >In my experience, I typically set up a script with overwrite_existing=true from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed overwrite_existing=false because of some concern about overwriting data. It's inconvenient, in fact, to set overwrite_existing=false.; >; >My thought is that it makes more sense to ask people to intentionally request overwrite_existing=false in the rare case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Now it is clear. If we handle properly picking up simulations, I completely agree with you that best option is for the user to manually change `overwrite_existing=false` to ensure their own data. I also follow the same workflow when creating a simulation in which I rely on the `overwrite_existing=true` until I reach the ""production"" phase of the simulation. > Also curious --- do you split files to make them easier to download? . I mostly do it to keep a consistent size and chunks across files for post-processing, but supporting both things will make the user workflow more flexible, particularly when running long simulations with multiple pickups. It's likely that the post-processing you suggest ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043:162,checkpoint,checkpointing,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043,8,['checkpoint'],"['checkpoint', 'checkpointing']"
Availability,"> Ok here's an idea: replace `Scan` with `Accumulation`. I think a sum can be thought of as ""accumulating"" without any leaps. We then would have _reducing_ accumulations (intermediate accumulations are not stored), and _cumulative_ accumulations (where the result is not reduced). Pardon my being pedantic, but ""cumulative accumulations"" sounds pretty redundant. We might not have enough words in the English language to describe this functionality precisely :laughing:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104572604:352,redundant,redundant,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104572604,1,['redundant'],['redundant']
Availability,"> Ok, here's a multi-pronged strategy to address this:; > ; > 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; > ; > 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?. I'm confused as to what `T` would be here. It feels like it should be `simulation.Δt`, but that wouldn't work for variable `Δt`. > 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; > ; > 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I think this could work. We probably would need to discuss how that would interact with `min_Δt` from the `TimeStepWizard`, no? Since they're putting two different lower boundaries (I think the one in `NonhydrostaticModel` would be more ""powerful"", correct?); ; > I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not. If we discretize time do we even need the stuff above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106:667,error,error,667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106,2,['error'],['error']
Availability,"> Ok, so from what I understand, the `immersed_boundary` would be the same in case of `GridFitted` and `PartialCell` but the latter would ""add"" an additional height on top of that? (which modifies fluxes in the cell). The two changes are:. 1. A cell `is_immersed` if the _interface above the cell center_ is below the bottom (or nearly so). Actually the precise condition requires using `minimum_fractional_Δz` as noted above; I think we should have something like. ```julia; function is_immersed(i, j, k, ibg); ϵ = Δzᶜᶜᶜ(i, j, k, ibg) * ibg.immersed_boundary.minimum_fractional_Δz; z_above = znode(c, c, f, i, j, k+1, ibg.grid); return z_above - ϵ < get_bottom_height(i, j, k, ibg.grid, ibg.immersed_boundary.bottom_height); end. function get_bottom_height(i, j, k, grid, bottom_height); x, y, z = nodes(c, c, c, i, j, k, grid); return bottom_height(x, y); end. get_bottom_height(i, j, k, grid, bottom_height::AbstractMatrix) = @inbounds bottom_height[i, j]; ```. Should be inspected closely, might be an error... 2. The vertical grid spacings `Δzᶜᶜᶜ` are modified for the cells that are _just above the bottom_ (ie, `is_immersed(k)` is false, but `is_immersed(k-1)` is true). Note that the interface spacings `Δzᶠᶜᶜ` have to take the minimum between the `Δzᶜᶜᶜ` in adjacent cells.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042502195:1006,error,error,1006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042502195,1,['error'],['error']
Availability,"> Ok. I was thinking that if, for some reason, the user giver both `max_change < 1` and `min_change > 1`, this is going to give a partial error. But well, the user can just try with a different `max_change` and then get the error for `min_change` and solve for both. Note this is common. If your code has many bugs, you'll typically only be able to receive errors from one at a time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1706940582:138,error,error,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1706940582,3,['error'],"['error', 'errors']"
Availability,"> On a side note, since you asked, I am going through some difficulties running the same example with a GPU. My inexperience with GPUs is keeping me from figuring this one out. What GPU are you running on? You'll need an Nvidia GPU and the CUDA library installed. Installing Oceananigans through the Julia package manager should install all the required Julia package dependencies (but won't install CUDA itself). Are you getting any errors?. Hmmm, so there is a small caveat that `Nx` and `Ny` need to be multiples of 16 on the GPU right now, although you'd get an error about this. > Should I create another issue?. Hmmm yeah that might be a good idea just to keep each issue self-contained. > (I'm not sure how much you guys want to be involved in these debugging processes...). We're very interested in being involved with the debugging process! We're still in early development so I'd expect things to break quite often, and we still haven't ironed out all the bugs and usability issues. We've also mostly been using the model ourselves (hard to improve usability if you know all the internals haha), so if you're willing to report issues it would be a huge help with development!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539736740:434,error,errors,434,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539736740,2,['error'],"['error', 'errors']"
Availability,"> On the other hand, there is also more noise, and something is happening in the Indian ocean that crashes the simulation. Hypothesis: dissipation by WENO is beautiful but may impose time-step restrictions. Or put another way, for whatever reason the _amount_ of dissipation introduced by WENO may have limits. And, WENO dissipation is, by design, dependent on grid-scale gradients. Thus if there are dynamics that synoptically produce tiny scales WENO may be ""too weak"" to dissipate over a given ""longish"" time-step. A bit vague but that's one guess at what might be happening. Hyperviscosity is more robust of a filter perhaps (the problem is that we always have to guess the coefficient). Does ""vorticity smoothing"" (vs velocity smoothing) WENO also blow up?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064671996:602,robust,robust,602,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064671996,1,['robust'],['robust']
Availability,"> Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?. Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid. I agree that we should have a test for that and maybe something in the docs, sometime?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890:124,error,error,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890,1,['error'],['error']
Availability,"> P must be positive definite. WENO should guarantee that advection does not generate spurious minima, right? The boundary condition for phytoplankton are of no flux, so they should not generate negative values either. I am confused. WENO doesn't _strictly guarantee_ positivity (@ali-ramadhan showed that Gibbs phenomena can appear, especially in the presence of delta-function-like discontinuities that are narrower than the WENO stencil). But perhaps more to the point, we aren't using WENO in this example (simply because its a bit more expensive). We are using `UpwindBiasedFifthOrder` --- which does exhibit oscillatory errors (but far less than a centered scheme). @navidcy, does switching to WENO5 solve some of the problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1128#issuecomment-723496722:626,error,errors,626,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128#issuecomment-723496722,1,['error'],['errors']
Availability,"> Pardon if this question is naive but why is it important that users to exposed to the Field infrastructure?. Because that way they are prepared to do sophisticated post-processing! But I think you're right, maybe it's not a real ""downside"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036942707:232,down,downside,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036942707,1,['down'],['downside']
Availability,"> Pardon my being pedantic, but ""cumulative accumulations"" sounds pretty redundant. I think ""cumulative sum"" is redundant too. If I say I have an ""accumulation of beans"", I'm talking about the whole pile of beans. It doesn't seem to me that terminology exists, to answer your first question about whether ""scan"" is commonly used. There isn't any term that is commonly used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104624096:73,redundant,redundant,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104624096,2,['redundant'],['redundant']
Availability,"> Perfect! Maybe we can also raise an issue in GPUArrays.jl. Yeah I'm not 100% sure what the issue is... I think something is happening with broadcasting. Not that those lines attempt to broadcast over a `SubArray` of an `OffsetArray` of a `CuArray` --- because the syntax `a[i1:i2] .= b` creates a `view` of `a`. Since there `a` was an `OffsetArray`, this is a `view` of an `OffsetArray`. The `CuArray` is two levels down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114903011:418,down,down,418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114903011,1,['down'],['down']
Availability,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455:48,checkpoint,checkpointer,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455,6,"['checkpoint', 'error']","['checkpoint', 'checkpointer', 'error']"
Availability,"> Quick question: in what situations would this be needed? I've never used that function but from what I understand it's only used in immersed boundaries to force quantities to a certain value, no? But wouldn't masking something to `nan` propagate throughout the whole domain?; > ; > Unless maybe you wanna mask it to `nan` specifically to make sure it's not propagating outside of your immersed boundary?. I think it's useful in user scripts for plotting purposes, mainly. But not useful in the source code as you point out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1970#issuecomment-909480517:211,mask,masking,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1970#issuecomment-909480517,2,['mask'],"['mask', 'masking']"
Availability,"> Quickly looking at Lin 1997, they compare the results of their method with a finite volume (FV) method. Their method does better. I wonder if their FV method is at all similar to what the MITgcm uses?; > ; > Is it fair to say the first is easier and the second has the potential to be more accurate?. MITgcm does not use Lin 1997. Instead, they use vertical spacing from the _underlying_ grid (not the partial cell grid) to calculate the hydrostatic pressure. This somehow reduces the accuracy of the hydrostatic pressure calculation, but results in an approximation that does not have spurious pressure gradient errors. It's simple and effective. Lin 1997 _is_ a finite volume method. @glwagner and @francispoulin I think starting with Lin makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963:615,error,errors,615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963,2,['error'],['errors']
Availability,"> Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity.; > ; > The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary.; > ; > (Constructors are tested for both models, though.). Thanks @tomchor !!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399:288,down,downside,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399,2,['down'],['downside']
Availability,"> Resolves #3061; > ; > Questions:; > ; > Does it make sense to mask when`with_halos = true`? With `with_halos = true` implies that the users can use the output to compute derivative fields etc; will masking obscure this?. No, because derivatives are ""boundary aware"" and thus don't touch the regions that are masked.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3092#issuecomment-1528952307:64,mask,mask,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3092#issuecomment-1528952307,3,['mask'],"['mask', 'masked', 'masking']"
Availability,"> Same error... no idea what's happening since there are no more scaped characters. Would changing `r"".jld2""` to `raw"".jld2""` do anything?. error is in line 168 so I'm wondering if it's simply the docstring!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3113#issuecomment-1562014188:7,error,error,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3113#issuecomment-1562014188,4,['error'],['error']
Availability,"> Seems nice but what exactly is a ""download""? A fork, `Pkg.add(""Oceananigans"")` or what?. I’m not quite sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3652#issuecomment-2223857562:36,down,download,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3652#issuecomment-2223857562,1,['down'],['download']
Availability,"> Should AMD use z_dot_g_b now?. The implementation of a ""buoyancy-aware"" AMD is not correct... But yes, if we wanted to have a working version of this feature, it would have to know the direction of gravity. We'd have to add terms that depend on the horizontal directions for it to be correct I think, which probably warrants re-deriving it for generalized gravity from scratch. Since it doesn't even work for vertical gravity we should probably just nuke it and address later. Simplest would be to implement a working version for vertical gravity and throw an error if gravity is tilted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788:562,error,error,562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737548788,1,['error'],['error']
Availability,"> Should we add a test to make sure this doesn't break in the future? The low bar is just to test that interpolation doesn't error with a `Flat` direction (we don't have to test correctness, though we could do that too). Yes, probably should. The current tests have a hard coded topology . ```; function run_simple_particle_tracking_tests(arch, timestepper; vertically_stretched=false); topo = (Periodic, Periodic, Bounded). Nx = Ny = Nz = 5; ...; ```; We could add tests to check that simulations can run on different topologies without error. Alternatively, I don't see anything in the existing tests that would not be supported if one or more of the `Periodic` dimensions was `Flat`. So we could extent the existing tests to allow for different topologies.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2060761176:125,error,error,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2060761176,2,['error'],['error']
Availability,"> So it seems that execution does not have to hit the @warn for the reported failure. Also the stack trace indicates that the error happens when the macro is expanded. Precisely. > And maybe convenience interface for people who want to ignore it. That's a more robust interface for other reasons as well. Perhaps a positional argument to `lambertw`, either boolean or perhaps even better a type (to use multiple dispatch) to control behavior, things like. * `WarnFailures()` (throw warning for failures); * `MarkFailures(value=NaN)` (mark failures with a specific value, do not throw warning); * `IgnoreFailures()` ?; * `WithSolverInfo()` (return a type that contains the root, boolean `converged`, and possibly also number of iterations). > It would be nice if there were a way to redirect io or send it to dev null or otherwise disable everywhere when running on a GPU. It is interesting to consider auto-sanitization of GPU code...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911517451:77,failure,failure,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911517451,5,"['error', 'failure', 'robust']","['error', 'failure', 'failures', 'robust']"
Availability,"> So it seems that our model has an extra degree of freedom that neither Lilly nor Pressel propose. Quite! Though Lilly admits that his model amounts to ""little more than a scaling argument"" and that both `Pr_t` and the model ""constant"" are themselves unknown functions. So I actually think there is room to interpret Lilly as proposing a whole family of models. Since time is finite only one has been tested I guess (and also the structure of the model is questionable, so people have moved on to other formulations...). > I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha). Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?. If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`). A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799:1494,error,error,1494,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799,2,['error'],['error']
Availability,"> So we want to look at model.clock.time and sch.previous_interval_stop_time + sch.interval. It does seem probable the issue is roundoff error. It does seem like a roundoff error, below is the progress message. At iter:64, for example, `model.clock.time` is slightly larger than `sch.previous_interval_stop_time + sch.interval` （which I think they should've been equal):. ```julia; [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds, model clock time:0.0, previous_interval_stop_time + interval:0.1, u-avg: 0.0, window_start_time: 0.0, window_start_iteration: 0, previous_collection_time:0.0, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.0, collecting: true; [ Info: ... simulation initialization complete (231.038 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (546.837 ms).; [ Info: Iter: 11, time: 100 ms, model clock time:0.1, previous_interval_stop_time + interval:0.2, u-avg: 0.1202985845671951, window_start_time: 0.0, window_start_iteration: 0, previous_collection_time:0.1, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.1, collecting: false; [ Info: Iter: 22, time: 200 ms, model clock time:0.2, previous_interval_stop_time + interval:0.30000000000000004, u-avg: 0.8057920910530502, window_start_time: 0.11, window_start_iteration: 12, previous_collection_time:0.2, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.2, collecting: false; [ Info: Iter: 32, time: 300.000 ms, model clock time:0.30000000000000004, previous_interval_stop_time + interval:0.4, u-avg: 2.0225593735128355, window_start_time: 0.21, window_start_iteration: 23, previous_collection_time:0.30000000000000004, fetch_operand: true, interval: 0.1, previous_interval_stop_time: 0.30000000000000004, collecting: false; [ Info: Iter: 42, time: 400 ms, model clock time:0.4, previous_interval_stop_time + interval:0.5, u-avg: 3.664512241688186, window_start_time: 0.3100000000000001, window_start_iteration: 33,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2282230302:137,error,error,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2282230302,2,['error'],['error']
Availability,"> So, I need to use `sort` on `CuArray`s to calculate [available potential energy](https://github.com/CliMA/Oceananigans.jl/issues/1297) but I just realized that it's only available starting at CUDA version 2.6, which support Julia 1.6 only. Just to add --- as a first step, you might try first copying your data to the CPU and sorting there. If you don't have to do it too often, you won't suffer much of a penalty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942363:55,avail,available,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825942363,2,['avail'],['available']
Availability,"> Some of the validations are failing...?; > ; > What previously gave; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; > Stacktrace:; > [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; > [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; > [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; > [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; > [5] top-level scope; > @ REPL[3]:1; > ```; > ; > now it goes through:; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; > ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; > └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; > ```; > ; > Note that it creates an x and y coord `[1.0, 1.0)`!. I think I fixed it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968:161,ERROR,ERROR,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968,1,['ERROR'],['ERROR']
Availability,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:411,error,error,411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443,1,['error'],['error']
Availability,"> Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?. It's natural variability in hardware instructions for GPU, which is pretty scary. sverdrup has a Quadro P6000 which is a bit older and intended more for gaming. I think weird stuff goes on deep inside. If we had billions of dollars we'd get a little cluster dedicated to CI up and running and make beautiful examples and have lightning fast tests (and an engineer to maintain them). Not there yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489:63,failure,failure,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489,1,['failure'],['failure']
Availability,"> Something changed and there is an [error](https://buildkite.com/clima/oceananigans/builds/6799#086c56e0-6bf7-4373-8f4f-9b9e3da07b05/19-2421) at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/2a9f9dd2ff156ef54f9cc4e8ec662d272afee573/examples/tilted_bottom_boundary_layer.jl#L179-L182; > ; > Can anyone help me here? @glwagner, @tomchor?. Shouldn't `fields` be `outputs` in the call to NetCDFWriter? I don't see `fields` defined in this version so I'm guessing someone changed the name at some point",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103316887:37,error,error,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1103316887,1,['error'],['error']
Availability,"> Something is not right again.; > ; > There is a method `validate_closure`; seems like that's the place to put the error message?; > ; > My argument is just based on intuition from the method's name. This error seems part of the validation, right?. True, this would work for `NonhydrostaticModel`. https://github.com/CliMA/Oceananigans.jl/blob/b121003ef43e04d5792c6f0ca13cccc05f3d9385/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L168. but we have to make some changes to make this work for `HydrostaticFreeSurfaceModel` because `with_tracers` is called first. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L163-L166. so either we need to call `validate_closure` first, or we need to put in a fallback for `with_tracers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994:116,error,error,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994,4,['error'],['error']
Availability,"> Sorry I meant that we can now initialize field tuples (VelocityFields, TracerFields, etc.) with non-zero data. I updated the title. This change was important because it's required for checkpointing/restoring large model (implemented in #628). The field tuple constructors are further generalized in #631. Sounds good. Just for the record, `model.velocities` is just a named tuple, so if individual fields can be manually built with pre-allocated data, then so can the named tuples that hold velocity field data and tracer data. I suppose the change here is a function that achieves the same. If the current changes make the checkpointer code clearer, than I am for it. > fill_halo_regions! assumes field.data has a certain size consistent with the size of the grid. Let's be specific here. `fill_halo_regions!` does not assume anything about the ""size"" of data. Specifically, it invokes `getindex` on the property `parent` of `.data` at certain indices. Therefore such a method call must work for `.data`. In the case that `.data` is either a plain `Array` or a `CuArray`, we *know* from the properties of those types when such a `getindex` call for certain indicies will fail. Therefore, we should feel free to intercept such an error during `Field` construction. In other cases we cannot be sure that such a method will fail because we don't know how `getindex` works on `.parent` for arbitrary types. In the spirit of ""not assuming what we don't know"", we should opt to throw errors only in cases that we *know* an error should occur.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-587006980:186,checkpoint,checkpointing,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-587006980,5,"['checkpoint', 'error']","['checkpointer', 'checkpointing', 'error', 'errors']"
Availability,> Sorry I was too quick to merge yesterday.; > ; > This looks good but I see that it errors with the following; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-1/clima/oceananigans/test/test_checkpointer.jl:14; >   | Expression: all(test_model.timestepper.Gⁿ.w.data .≈ true_model.timestepper.Gⁿ.w.data); >  ```; > ```. That's an intermittent failure; we just have to re-run (unfortunately).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877649413:85,error,errors,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877649413,3,"['Checkpoint', 'error', 'failure']","['Checkpointer', 'errors', 'failure']"
Availability,"> Sorry, let me rephrase, users shouId pass clock and fields only when boundary conditions require it, so we need some type of warning to make sure the error is well documented.; > ; > I think it is nice to have `fill_halo_regions!(field)`, it will be a bit cumbersome to always have to pass a clock and fields also when non using complex BCs. It's not even possible to construct a field with `ContinuousForcing` outside a model constructor. The model constructor has to do things like compute the index of `fields(model)` that a field name belongs to. So its more than cumbersome, its not possible. Also we need to prioritize. We are trying to do simulations, not have uber fancy flexible field abstractions (this is just an auxiliary feature that's very nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179186646:152,error,error,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179186646,1,['error'],['error']
Availability,"> Sounds like the plan is to switch to SolutionBoundaryConditions but that might involve more refactoring so maybe best left for another PR?. This is already done, because the model constructor calls the function `ModelBoundaryConditions` here:. https://github.com/climate-machine/Oceananigans.jl/blob/e41711f6b5db492d3aa5344d2e3bc9c2fe65dd70/src/models.jl#L64. which then dispatches based on whether the argument `boundary_conditions` is a `SolutionBoundaryConditions` or a `ModelBoundaryConditions`:. https://github.com/climate-machine/Oceananigans.jl/blob/e41711f6b5db492d3aa5344d2e3bc9c2fe65dd70/src/boundary_conditions.jl#L254. Thus in either case the model is constructed with a `ModelBoundaryConditions`. Edit: note that this is required for correct checkpointing, because the checkpointer passes a `ModelBoundaryConditions` to the model constructor, while we expect users to pass a `SolutionBoundaryConditions`. . The downside to this pattern is that the type of `model.boundary_conditions` will often be different than the keyword argument `boundary_conditions`. Hopefully this is not confusing or surprising... :-/ An alternative is perhaps to specifically delineate between them; ie change the keyword argument in the `Model` constructor to `solution_boundary_conditions`. However, something to consider is that the `tendency` and `pressure` fields of `ModelBoundaryConditions` should be uniquely determined by `SolutionBoundaryConditions`. Another factor to consider is that the pattern that keyword arguments correspond to fields is not a guaranteed julia pattern, it is simply an organizational principle that we feel is helpful. Thus I think we can break it occasionally if it improves the readability and simplicity of code. We should note the difference in the documentation to the `Model` constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531491747:757,checkpoint,checkpointing,757,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531491747,3,"['checkpoint', 'down']","['checkpointer', 'checkpointing', 'downside']"
Availability,"> Still the unit tests don't pass; something else is broken. Seems like some other validation is bypassed?; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size = (16, 16, 16), x = 1, y = 2, z = 3); > ERROR: MethodError: no method matching get_face_node(::Int64, ::Int64); > ; > Closest candidates are:; > get_face_node(::Function, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:12; > get_face_node(::AbstractVector, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:13; > get_face_node(::Nothing, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:11; > ; > Stacktrace:; > [1] generate_coordinate(FT::Type, topo::Periodic, N::Int64, H::Int64, node_generator::Int64, dir::Symbol, arch::CPU); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/grid_generation.jl:39; > [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Int64, y::Int64, z::Int64, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/rectilinear_grid.jl:273; > [3] top-level scope; > @ REPL[4]:1; > ```. I wanted to make it so that grid generators don't have to subtype functions. However, that doesn't support the kind of error checking that you're mentioning. I guess I'll go back to explicitly requiring somethign to be subtyped `Function`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344:210,ERROR,ERROR,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"> Thank you for your help! I have installed the updated version of Julia and when running it appears to be Segfaulting when trying to add CUDA. I will open an issue with them if I cannot figure out how to solve it. Thank you again. @logan can you link the CUDA issue here please?. Also, if you haven't tried, erase everything on your `$JULIA_DEPOT_PATH` (really to be safe you should make a backup of everything there first) and then run the same script you've been running with `using Pkg; Pkg.instantiate()` on the first line. This should ""re-install"" all the packages from scratch. For context [`$JULIA_DEPOT_PATH`](https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_DEPOT_PATH) by default is `~/.julia`, I think, and that's where julia stores the package files it downloads. The hypothesis here is that at some point some package download/compilation went wrong and you have some broken code there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245639622:786,down,downloads,786,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245639622,2,['down'],"['download', 'downloads']"
Availability,"> Thanks @glwagner . I started but have a few questions.; > ; > * Why didn't the hydrostatic model need a `with_halo` function?; > * I started to write a `new_halo` function in `ImmersedBoundaries.jl` but don't think this is the right spot. Where should it go?; > * Most of the function is pretty easy except for when we define the new_grid. What I have [here](https://github.com/CliMA/Oceananigans.jl/blob/5ea7b9168a40619a17d2c9ab42b65b622a7c9ac1/src/ImmersedBoundaries/ImmersedBoundaries.jl#L86) is wrong but can you help me modify it? It seems like we know infomration about the bump but that is not currently passed in new_halo. Maybe we need to pass more information?. I guess the hydrostatic model doesn't call `with_halo`:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl. I think you need `with_halo` rather than `new_halo`, if I read the error message correctly. In that case I think the needed function is a one-liner:. ```julia; with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ```. But maybe I am missing something? I don't quite understand what you mean about `new_grid`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844285667:926,error,error,926,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844285667,1,['error'],['error']
Availability,"> Thanks @glwagner . I think that `PartialCellBottom` should also use the cell center to determine if a cell is immersed or not.; > ; > ; > ; > I agree that `GrifFittedBottom` is not a limiting case right now but it would be nice if we get this as a limit of `PartialCellBottom`. We could do this by instead of using the depth in the centre, we use the depth in the center truncated down to the lower cell. Something I will try and keep in mind as we move forward. If we use . bottom_height(x, y) > znode(c, c, f, i, j, k, grid). As criteria, then GridFittedBottom is a limiting case when the minimum fractional height is 1.0. But this doesn't seem like a sensible formulation for GridFittedBottom. Why do we want them to be limited cases of each other?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043168552:383,down,down,383,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043168552,1,['down'],['down']
Availability,"> Thanks @tomchor , and very nice.; > ; > What would the difference of those two curves look like in the region where there is no masking? Are they identicial or just similar?. In the simulations without the IBM that region does't exist! The domain in those cases starts at `z=0`. And in the simulation with IBM that region exists, but lies inside the immersed solid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074455752:130,mask,masking,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074455752,1,['mask'],['masking']
Availability,"> Thanks @tomchor for doing this.; > ; > I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I think in this case it's not necessary because it's a multi-CPU testing script, so no GPUs involved. And that allows us to get rid of the `Benchmarks` dependence and make the script more portable.; ; > I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is. I did! And I'm running into issues. Please check https://github.com/CliMA/Oceananigans.jl/issues/2433! Any help there is appreciated",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148:485,error,error,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148,1,['error'],['error']
Availability,> Thanks!. Thank you all for the development and maintenance of this wonderful Julia package!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2679#issuecomment-1194198127:49,mainten,maintenance,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2679#issuecomment-1194198127,1,['mainten'],['maintenance']
Availability,"> That error is from `show` though, not `compute!`. Oops, I missed that. Thanks for catching it @glwagner. In any case the error indeed doesn't seem to be caused by complexity. The first `compute!()` in the lines below works, but not the second:. ```julia; tke_ccc = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2. computed_tke = Field(tke_ccc);; compute!(computed_tke). tke_window = Field(tke_ccc, indices=(2:3, 2:3, 2:3));; compute!(tke_window);; ```. Which suggests that it's the slicing that's creating the problem. However, the line below works, which I don't really understand:. ```; tke_xy = Field(tke_ccc, indices=(:, :, 2)) ;; compute!(tke_xy); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142709219:7,error,error,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142709219,2,['error'],['error']
Availability,"> That line is inside a loop. What if `@show ""hi""` is outside the loop?. If I put `@show ""hi""` _after_ the loop then error goes away. If I put it _before_ error remains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308123902:117,error,error,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308123902,2,['error'],['error']
Availability,> That might not work because the PCG doesn't get to machine precision though right?. You can set the precision low enough to pass the regression test. This would add extra iterations but the regression test grids are pretty small so might be feasible. Or we can just increase the tolerance on the regression test.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781644482:281,toler,tolerance,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781644482,1,['toler'],['tolerance']
Availability,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393:422,error,error,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393,2,['error'],['error']
Availability,"> That way if users decide to experiment with a new feature they can also contribute their experience to the discussion. It might be more fluid and easier for everyone to work with than something more formal like a wiki?. I don't really see the wiki as being formal, but I do agree that discussions are more low-maintenance. I think if we can tag them properly as ""experimental features"" it would really help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2355#issuecomment-1072772581:312,mainten,maintenance,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355#issuecomment-1072772581,1,['mainten'],['maintenance']
Availability,"> That's a decent minimal example! Are you sure that the error requires advection=WENO() and timestepper=:RungeKutta3? The latter cannot be necessary since its the default (so omitting it has the same effect as including it).; > ; > I find I can reproduce the error without ImmersedBoundaryGrid at all. You are absolutely right! Those are not needed. Thank you so much for the detailed explanation, I get it now :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3896#issuecomment-2453136941:57,error,error,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3896#issuecomment-2453136941,2,['error'],['error']
Availability,"> The CPU tests all pass, but it seems like the GPU server isn't working? Does something need to be rebooted?. Yeah, the GPU server is down right now, linked to construction happening at MIT. Hopefully it will be back up in a few days.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3440#issuecomment-1908515940:100,reboot,rebooted,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3440#issuecomment-1908515940,2,"['down', 'reboot']","['down', 'rebooted']"
Availability,"> The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. That seems like a likely culprit. I can't remember if I looked into that. Whatever it is I agree its a flaw in the test design that some other source of error dominates before asymptotic convergence is reached...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300622:95,error,error,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300622,2,['error'],['error']
Availability,> The default now it `Implicit` right? I think `SplitExplicit` will be more efficient. `Implicit` is done on only one GPU while split explicit takes advantage of all the workers. I'm getting some errors with SplitExplicit + MultiRegionGrid. I'm trying to fix them... if I don't manage I'll leave Implicit as the default and open an issue.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1999133773:196,error,errors,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1999133773,1,['error'],['errors']
Availability,"> The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates. You mean the convention not only specifies what you have to output but also disallows _additional_ information?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516669792:6,down,downside,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516669792,1,['down'],['downside']
Availability,"> The effect of the pressure errors can be seen plainly that there is transient _injection_ of momentum into the system, which isn't physically possible. However over long periods of time the momentum goes in the right direction.; > ; > I'm wondering if anyone has experience with PALM, which I believe uses a very similar immersed boundary method (with no pressure solver correction)... ? They must have similar ""leakage"" errors. I can't help there, but I agree it's a good idea. For now I think we should test that these errors are decreasing reasonably fast with resolution. (But that can be done in another PR I think.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101513949:29,error,errors,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101513949,3,['error'],['errors']
Availability,"> The error message we are gettig now does not seem to involve this PR at all.; > ; > If that is the case do we need to reset it?. Yeah, this is an annoying error we get sometimes for reasons unbeknownst to me. I'll restart the build.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843330164:6,error,error,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843330164,2,['error'],['error']
Availability,"> The error you're getting with `topology = (Periodic, Bounded, Bounded)` seem related to cell_advection_timescale not doing the right thing on a vertically stretched grid as well... It's used to compute CFL by the `TimeStepWizard`. Ah yes, you're right. It runs ok with constant time step. So it's not an issue with topology. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-794434733:6,error,error,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-794434733,1,['error'],['error']
Availability,"> The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})`. wut. > I'm not sure what already is expected to fail. Nothing is expected to fail. Where does `Fix1` come from?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447:6,failure,failures,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447,1,['failure'],['failures']
Availability,"> The following errors but I don't think it should...; > ; > ```julia; > julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); > ERROR: AssertionError: c₁ < c₂; > Stacktrace:; > [1] generate_coordinate(FT::Type{Float64}, topo::Flat, N::Int64, H::Int64, node_interval::Tuple{Float64, Float64}, coordinate_name::Symbol, arch::CPU); > @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/grid_generation.jl:100; > [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:273; > [3] RectilinearGrid; > @ ~/Research/OC9.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; > [4] top-level scope; > @ REPL[4]:1; > ```. This errors on `main` as well right? I didn't change that line",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757847331:16,error,errors,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757847331,3,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,"> The length is correct -- 4 points plus 3 halo points on either side. You're right! That was a bad example. But like you mentioned later, an error/warning is desired",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125538583:142,error,error,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125538583,1,['error'],['error']
Availability,"> The main downside I think is that the validation repo goes stale by design. Wouldn't JuliaRegistrator keep this from happening? ; If we list Oceananigans as a dependence, it'll create a new PR with the an updated version of Oceananigans everytime we update Oceananigans.jl, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832153423:11,down,downside,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832153423,1,['down'],['downside']
Availability,"> The new default, converting Int64 exponents to Float64, seems better. Unless `power_by_squaring` performs better in realistic applications?. I don't think we ever used `power_by_squaring`, because the ""pre 1.6"" Oceananigans kernels were defined via`KernelAbstractions`, which in turn translated `^(a, b)` to `CUDA.pow(a, b)`:. https://github.com/JuliaGPU/KernelAbstractions.jl/blob/fdb7415b6f6083c23451cc526b0637144322b1cb/lib/CUDAKernels/src/CUDAKernels.jl#L289. This means that ""pre 1.6"" we were exponentiating with `nv_powi`... In ""current"" Oceanagnians (before this PR), changes to KernelAbstractions and CUDA seem to imply that we invoke `nv_pow` instead. And for some reason this can slow down our code by 10-15x (!!) as discussed on #1764 . Does CUDA C do special transformations for `powi(x, Int32(2))`? Eg, does it convert `powi(x, Int32(2))` to `x*x` (or something like that)? I've no idea but maybe there are some massive algebra reductions / expression eliminations that occur for our weird WENO5 code when we ask for `x*x` versus `x^2.0` ... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870014674:697,down,down,697,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870014674,1,['down'],['down']
Availability,"> The out-of-bounds error comes from the precomputation of stretched coefficients:; > ; > The order is not preserved in Bounded directions, so halos larger than 1 are not necessary when time-stepping. This is why also with (1, 1, 1) would be fine if directions are not stretched.; > ; > If the direction is stretched, the stretched coefficients are precomputed on every grid point. The error you see there comes from the coefficients near the boundary (which, indeed are not used) that require halo cells to be computed. Note that a 7th order WENO would require 4 halos in Periodic directions; > ; > We could remove the pre-computation of boundary coefficients in case of Bounded directions... Edit: this is wrong, high order halos are always required (also in Bounded directions) because we use `ifelse` statement to discriminate between low and high order. `ifelse` executes both branches so we need the halos for the branch that we eventually discard",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480078481:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480078481,2,['error'],['error']
Availability,> The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent aligned_time_step from returning negative time steps. Should we use `initialize_schedule!` for `TimeInterval` to set `previous_actuation_time` to the `model.clock.time`? Or is this incorrect?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766893249:26,checkpoint,checkpoint,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766893249,1,['checkpoint'],['checkpoint']
Availability,"> The plot above is the error between the IBM and nonIBM case. Ok, I understand now. So the error in the wall-normal velocity gradient is a proxy for the error that _would_ result were we to prescribe a no-slip boundary condition with non-zero viscosity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867915500:24,error,error,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867915500,3,['error'],['error']
Availability,"> The plume emerging from the tracer is due to leakage right? It's a nice way to visualize it quickly. Yes. Without the masking, the 0 concentration in the cylinder just leaks out until it's replaced by the fluid concentration. You can see it in this one:. https://user-images.githubusercontent.com/67593861/126666332-df00dec5-3c1c-4d17-9c67-cf7fdc4bd26a.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1888#issuecomment-885008488:120,mask,masking,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888#issuecomment-885008488,1,['mask'],['masking']
Availability,"> The purpose of this PR was to save mutliple scalars using `NetCDFOutputWriter` and there seemed to be some problems, i.e. some checks fail.; > ; > @glwagner mentioned that maybe `using Statistics: norm` might work without any additional work. Is this the case? If yes then I am happy to close this PR and give it a try on the shallow water Bickley jet example. Ah... the change is fairly innocuous, there's just a few things that make me nervous. 1) It _shouldn't_ fix the problem that it's intended to fix. Unless there's something I am missing... if it fixes the problem that was raised, it's due to some unintended side effect that we don't understand? (Providing some detail and the error message that was received could help, or it could be raised in an issue). A more grave concern is 2) it will slow down the code and cause memory allocation. This is almost always completely negligible since other parts of the code matter more, but it could affect small models, our CI pipeline, etc. It's hard to intentionally throw away type stability :-/ So in a way it's creating technical debt and possibly creating work for us in the future...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824916415:689,error,error,689,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824916415,2,"['down', 'error']","['down', 'error']"
Availability,"> The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langmuir number and U10 assuming Pierson-Moskowitz spectrum). So I'm not sure which way is better... @qingli411 curious your thoughts on Lenain and Pizzo (2020), who provide a model in terms of friction velocity. I think their opinion is that bulk formula tend to introduce further errors into an already approximate parameterization. I suppose this model wasn't available for prior work in 2017 so perhaps the situation is different now? One unique aspect of Lenain and Pizzo (2020) is that they can co-observe the air-sea flux directly (from R/P FLIP) along with high quality measurements of wave properties.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937:802,error,errors,802,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937,2,"['avail', 'error']","['available', 'errors']"
Availability,"> There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl. @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098:299,error,error,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098,1,['error'],['error']
Availability,"> There is definitely a wrong assumption somewhere in this pipeline.; > ; > Maybe we can focus on this:; > ; > > since it try to access the indexes (4:8, 4:8, 4:5) rather than (4:8, 4:8, 1:0). I had a typo here, the indexes that it tries to access are `(4:8, 4:8, 4:8)` as if the field was 3D (See the error below). > ; > First of all I think this means that we are using `with_halo=true`? Just want to confirm that. Nope, that is without the halo (`with_halo=False`), when using `with_halo=true` the indexes passed are `(Colon(), Colon(), Colon())` so there is no issue accessing the indexes of the `output`.; ; > Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. When I print the indexes I get `(4:8, 4:8, 1:0)` but I agree that there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:302,error,error,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['error'],['error']
Availability,"> There's no need for a new kernel because the diffusivities are `νₑ / Pr` so they can be calculated on the fly.; > ; > We need to extend `κᶠᶜᶜ` and `κᶜᶠᶜ` and `κᶜᶜᶠ`; > ; > ```julia; > @inline κᶠᶜᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑxᶠᵃᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; > @inline κᶜᶠᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑyᵃᶠᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; > @inline κᶜᶜᶠ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑzᵃᵃᶠ(i, j, k, grid, K.νₑ) / closure.Pr[id]; > ```. I may be missing something, but when I make those changes I still get the errors in #2869. The changes in this PR are the only ones I've tried that seem to solve the issue. I've implemented and pushed your solution to the [tc/smag-binary-op2 branch](https://github.com/CliMA/Oceananigans.jl/blob/tc/smag-binary-op2/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl) in case you wanna check if I understood your suggestion. Basically these are the changes:. https://github.com/CliMA/Oceananigans.jl/blob/56a76ae24d7199a3efe822d06969acc7b6ce6b16/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L127-L129. I'm getting a `device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)` error with only those changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419454342:646,error,errors,646,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419454342,2,['error'],"['error', 'errors']"
Availability,"> Therefore, we should feel free to intercept such an error during `Field` construction. In other cases we cannot be sure that such a method will fail because we don't know how `getindex` works on `.parent` for arbitrary types. In the spirit of ""not assuming what we don't know"", we should opt to throw errors only in cases that we *know* an error should occur. Good point, I'll add a simple check for this during field creation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-588308119:54,error,error,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-588308119,3,['error'],"['error', 'errors']"
Availability,> These should be `jldoctest`'d. They are. But apparently the error made it into the source files: https://github.com/CliMA/Oceananigans.jl/blob/b945655a8363f60d03077253edcd77a56936c5cc/docs/src/model_setup/output_writers.md?plain=1#L89-L101. Apparently these slipped through the cracks here: https://github.com/CliMA/Oceananigans.jl/pull/2246/files#diff-9192b98dd6db72149d0d09e5af4820a650091d3509aeb1c2327c27c3e5d8d1b4 . I'll fix these in https://github.com/CliMA/Oceananigans.jl/pull/2416,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2427#issuecomment-1095152362:62,error,error,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2427#issuecomment-1095152362,1,['error'],['error']
Availability,"> Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?. Sorry probably could have been clearer on this. This is just du/dy, calculated with a centered difference between the closest two fluid cells to the boundary, then integrated along the boundary line (ie. du/dy summed and multiplied by Lx). The plot above is the error between the IBM and nonIBM case. This plot here is the values themselves (dashed is nonIBM, solid is IBM); ![Bickley_dudy](https://user-images.githubusercontent.com/67593861/122993772-b4a0bf00-d375-11eb-9b60-2243077ce838.png); ; > > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. You are correct. I think the added tracer idea would be perfect. My mind was stuck on the cylinder concentration one I've done before, and didn't think about the difference here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816:429,error,error,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816,2,['error'],['error']
Availability,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:649,down,downside,649,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103,2,['down'],['downside']
Availability,> This feature would be used to restart a simulation from a checkpoint with additional passive tracers? Is that correct?. That is correct. That's what I'm currently trying to do (and eventually @whitleyv too) and it's much easier if with we make this change with the Checkpointer.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938#issuecomment-1440328788:60,checkpoint,checkpoint,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938#issuecomment-1440328788,2,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint']"
Availability,"> This is WENO order 5 on a stretched grid on the GPU in the nonhydrostatic model right? Seems like the problem might be in the advection of `w`. look like an out of bound error. Maybe using explicit checkbounds it will point out the error. What version of the branch was working?. Yes it is. The manifest entry for the working version is. ```; [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""CUDAKernels"", ""Crayons"", ""CubedSphere"", ""Dates"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-rev = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-url = ""https://github.com/CliMA/Oceananigans.jl.git""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.77.0""; ```. I couldn't quite figure out what version that refers to, but maybe you understand manifest entries better than I do...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940:172,error,error,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940,2,['error'],['error']
Availability,"> This is great! Have you started a PR already to support Sparse in AMDGPU proper?. @vchuravy yes here's the PR: https://github.com/JuliaGPU/AMDGPU.jl/pull/298. We're stuck for some time since we're getting some timing issues on a couple of tests; We get incorrect results depending on the timing of the operations. Even after adding synchronization after each operation, the error still persists. Other than that they seem to work fine. @jpsamaroo can update you on that. > So this PR is to merge something on an Oceananigans.jl branch, `amdgpu`. It modifies 482 files?!; > The `amdgpu` branch is waaay outdated so as a first step perhaps we need to bring that branch up to date? I'm wondering if the seemingly proposed changes to 482 files would be much reduced if we bring `amdgpu` up to date with `main`?. @navidcy @simone-silvestri I don't have write access to this branch so you can update the branch first before reviewing the PR. This work is not yet ready to be merged yet to the main branch so we decided in the past that this might be the place for it while we test it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448414562:376,error,error,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448414562,1,['error'],['error']
Availability,"> This is the issue that described what I was seeing: #3290; > ; > @johnryantaylor does that looks like what you're seeing?; > ; > If so, the two workarounds that I have come up with are; > ; > * to run on branch [Don't separate the pressure into hydrostatic and nonhydrostatic in `NonhydrostaticModel` #3080](https://github.com/CliMA/Oceananigans.jl/pull/3080) like @glwagner suggested (downside here is that this branch is kinda out-of-date and apparently stale); > * Make the `x` (or `y`) directions periodic (seems like `x`already is in your case) and tilt the domain accordingly. (The second video in [Having a domain that's periodic in the ""gravity"" direction doesn't work for `gravity_unit_vector = NegativeZDirection()` #3290](https://github.com/CliMA/Oceananigans.jl/issues/3290) illustrates that); > ; > If that's not your issue, do you mind posting the animatino you're generating?. And just to confirm @tomchor those issues are not associated with BackgroundField, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782221137:388,down,downside,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782221137,1,['down'],['downside']
Availability,"> This is the same benchmark performed with `ImplicitFreeSurface`, by imposing a divergent velocity `u(x, y, z) = x / 10` to make sure the implicit solver iterates. Looking at the results it seems like it doesn't iterate too much... (probably WENO cleans up?) And it is very weird that the `RectilinearGrid` version is not affected by the FreeSurface calculation? (I have double checked that the free surface solver is correct); > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1440×600×48`	`RectilinearGrid`	1	1.37 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	1.05 minutes	65.2%. THATS CALLED A SPEED UP 🍻 . I think bathymetry interferes with the solver more. When the velocity field is _purely_ divergent + barotropic, it just produces waves that dissipate nearly instantly ?. It'd be good to come up with a reliable 3D initial condition for benchmarking iterative solver stuff....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626:840,reliab,reliable,840,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626,1,['reliab'],['reliable']
Availability,"> This looks super cool: I'll be happy to meet for coffee and chat in person (assuming you're both at MIT) but I am not very familiar with tools in climatology* and think @meggart @visr @evetion @mkborregaard and @juliohm will be in a better position to comment about it.; > ; > *The packages in JuliaGeo have been mostly focused on IO and has not had the bandwidth to think about how it might interface with packages for (climate/ocean/etc) models. That might be useful down the line! Yes we're both around MIT. I think we're still figuring how we want to do IO in the long-term but will definitely want some way to output NetCDF. > Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project.; > ; > My last attempt at improving the NetCDF solved many of the issues with the package JuliaGeo/NetCDF.jl#61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite.; > ; > Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages.; > ; > I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:471,down,down,471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['down'],['down']
Availability,"> This seems like a matter of preference, but I kinda like that the default is a reasonable value. Ok, let's think about it. It also doesn't make sense if what you're doing is non-dimensional... I've found that AMD doesn't actually work that well when turbulence is weak and the subfilter diffusivity is ""close"" to the molecular value. It might be more symbolic than anything to have a non-zero molecular diffusivity, since setting it to zero might not have an observable effect on results ... ? What do you think? Have you found that it changes your results?. One downside of specifying a non-zero yet negligible number (in other words, the difference between this number and zero cannot be observed) is that it _implies_ that non-zeroness is important when it isn't. So if it really doesn't matter, I'm worried that it distracts from the communication of scientific results... The default for `IsotropicDiffusivity` is also this ""20 degree water"" number. Maybe that's more important to change, since simulations with `IsotropicDiffusivity` in `Oceananigans` are probably idealized rather than DNS of a miniscule box.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-747153244:565,down,downside,565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-747153244,1,['down'],['downside']
Availability,"> To do that we need to have fully 3D derivatives (i.e. no more `∂xᶜᵃᵃ`, `∂yᵃᶜᵃ` and `∂zᵃᵃᶜ`) so that we can mask them with the `solid_interface` function. This certainly might be an improvement. But, practically speaking, I think we only need to ensure that `∂x_∇²h_cᶠᶜᶜ` and `∂y_∇²h_cᶜᶠᶜ` are correct in the presence of immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L69. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L74. right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027538953:109,mask,mask,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027538953,1,['mask'],['mask']
Availability,"> To help me think about how this should look, could you help me find an example you want want to do this?. Sure thing! The example I'm developing this for specifically is a tilted bottom boundary layer. (https://github.com/CliMA/Oceananigans.jl/pull/1498). Over there I'm tilting the domain by tilting the gravity vector, really. However, to ""properly"" tilt the domain I'd need to tilt Coriolis too. In this case I'd need a x-component to `f`, which isn't available through `FPlane` or `NonTraditionalFPlane`. Thus, with this addition I'd be able to write something like. ```julia; const θ_rad = 0.2 # radians; const g̃ = (sin(θ_rad), 0, cos(θ_rad)) # domain tilt. buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=g̃) # Tilt gravity vector; coriolis = GeneralFPlane(coriolis_frequency=1e-4, rotation_axes=g̃) # Tilt rotation vector; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886257814:457,avail,available,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886257814,1,['avail'],['available']
Availability,"> To properly handle the checkpoint pickup, we manually adjusted the actuation to match the correct value based on the pre-pickup simulation. Here's an [example](https://github.com/liuchihl/Oceananigans.jl/blob/correct-averagedtimeinterval/test_netcdf_timeaverage.jl#L105-L116) to illustrate what I mean.; While this resolves the issue of checkpoint for now, it's more of a workaround. Agree we need to refactor the Checkpointer. Thank you for documenting a way to proceed for the time being.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433143553:25,checkpoint,checkpoint,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433143553,3,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint']"
Availability,"> To start working on this I think we need an MWE. Mabye that's easy, just a simulation with constant time-step and output on TimeInterval which should, in theory, work perfectly. Wouldn't the MWE I posted above work? Or do you mean a MWE that generates round-off errors at _predictable_ times? (I cannot predict when the errors will occur in the MWE above.). > Hmm and there is one more point. Round-off error is the reason we get tiny time-steps, and we should fix that. However, that would still leave open the underlying problem, which is that the pressure correction fails for machine epsilon time-steps. So I'm wondering if in fact we should fix both issues. I agree with this point, but I feel like I'm also missing something here. Let's say we change the pressure correction so that it works for machine epsilon. Won't the pressure gradient force still depend on `Δt`? That is, won't it be larger for small `Δt`s and vice-versa? If so, this implies the pressure gradient doesn't converge with `Δt` and if so, how do we close a budget where the pressure term is important? (Maybe that's a question for another place also... I don't want to derail the discussion from the specific issue at hand.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104553427:264,error,errors,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104553427,3,['error'],"['error', 'errors']"
Availability,"> To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain.; > ; > I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance... Yes I think we'd need to use `Pycall`. I agree that's hard to maintain so let's not pursue that now. I still think it'd be good to show one example with `NetCDF` writer though. Here's a question: is post-processing results directly in julia (making animations, plots, etc.) using the `NetCDF` output as easy as with the `jld2` output?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953913965:433,mainten,maintenance,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-953913965,1,['mainten'],['maintenance']
Availability,"> Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. I think I see what you're saying. `h` just goes to 0 where a layer impinges on a boundary (including an island), we don't have to mask anything. > I agree with the idea of using the z coordiante for the layer number. Seems like the main annoying thing is that `Δz` might be irrelevant (despite that it exists). I've thought about this a bit in the context of eventually supporting generalized vertical coordinates. Some codes use the name ""r"" instead of ""z"", which they believe grants them license to interpret ""r"" as density (or buoyancy) rather than height. We can also ""just"" interpret ""z"" as buoyancy. Then every grid and model property is meaningful, which I like... but on the other hand, they may not have the meaning you expect, if the name ""z"" is hard coded in your brain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115543942:303,mask,mask,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115543942,1,['mask'],['mask']
Availability,"> Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. Note that ""4th-order"" refers to the rate of convergence of the scheme as the grid spacing is reduced. For a particular resolution (and assuming that you are in the ""asymptotic regime of convergence""), the improvement gained from higher-order scheme involves both the rate of convergence / slope of the error estimate as well as a constant (the intercept) that's specific to the problem. As a result, you usually don't have a theoretical prediction for improvement at fixed resolution, I don't think (though I suppose you might be able to generate an estimate if you are differentiating a function with easily knowable properties). Empirically we usually find that higher-order schemes reduce the constant by quite a bit! Which is good --- since we often run marginally resolved problems, improving the constant (rather than the slope/rate of convergence) turns out to be the most important benefit of a high-order scheme. The plot is super busy, but the point is hopefully illustrated: higher-order advection schemes not only converge _more quickly_ to the exact solution as resolution is increased (eg, the slopes of the lines are steeper) but _also_ have reduced error at a _fixed_ resolution (eg, the error is less for WENO5 than CenteredSecondOrder at the fixed resolution 2^7):. ![image](https://user-images.githubusercontent.com/15271942/101667154-fba01600-3a1c-11eb-824e-f3ec82367229.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088:576,error,error,576,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088,3,['error'],['error']
Availability,"> Using a discretized version of the thermal wind balance is a sound suggestion, but it does not explain why the error only appears when evolving the total fields. Why not? When evolving the total fields, the condition of geostrophic balance is computed during the prognostic evolution of the total variables. When evolving just the perturbation, the algorithm for mean-perturbaiton decomposition _assumes_ that the mean fields are balanced. There is no need to worry about the tiny difference between discrete and continuous balance in the case that you only evolve perturbations. But if you want to evolve the geostrophically balanced state, you must ensure that it is perfectly balanced to within machine precision, or you will have an adjustment. That's the basis for my suggestion. I'm not sure the computation I recommended achieves numerical balance (something might be missing) --- that should be checked.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487:113,error,error,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487,1,['error'],['error']
Availability,> Usually restarting the test works for me to clear that error. Good to know. How can I do that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045:57,error,error,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045,2,['error'],['error']
Availability,"> Was it some random one-off stochastic error?. Turns out this happens on a Quadro GP100 GPU, but not on a Tesla V100. I'm using Julia 1.8.3 on NCAR's Casper server using the (current as of this message) main branch. Not sure what to do about this. Does it have to do with the Compute Capability? @navidcy which GPUs does tartarus have again?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499163705:40,error,error,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499163705,1,['error'],['error']
Availability,> We can add some `try catch` statements to throw helpful errors within `set!` when we encounter a `MethodError`. I like this idea!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777718505:58,error,errors,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777718505,1,['error'],['errors']
Availability,"> We can run our attempts at a partial cell method without any errors. :); > ; > Today we plan to look at the results and see if the are reasoanble. Thinking about some tests to add would probably be a good idea.; > ; > As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like.; > ; > I'll share our results later on and maybe that will help. Great development! I'm excited to see the results! It's great if we can have a better way to represent bathymetry, as deep cells are usually very coarse",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044783608:63,error,errors,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044783608,2,"['error', 'toler']","['errors', 'tolerance']"
Availability,"> We could just fully switch to passing the simulation to output writers and diagnostics?. Doesn't seem like there's much of a downside to that?. If `OutputWriters` are basically fancy functions of `model`, but checkpointing depends on the `Simulation`, then a `Checkpointer` might not be an output writer at all... We may want have a pow wow and rethink the whole concept of checkpointing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568:127,down,downside,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-752078568,4,"['Checkpoint', 'checkpoint', 'down']","['Checkpointer', 'checkpointing', 'downside']"
Availability,"> We could procede in a couple of ways from here:. Let me provide a few other options:. * Compute the 2D boolean masks for reduced operations in `x`, `y`, and `z` when forming `ImmersedBoundaryGrid`. Then, use those masks for conditional differencing of reduced fields, rather than calling `immersed_inactive_node`. * For `GridFittedBottom` and `PartialCellBottom`, as a stop gap, define these methods:. ```julia; @inline conditional_δx_f(ℓy, ℓz, i, j, k, ibg::GFBIBG, δx, r::ZIRF, args...) = ifelse(immersed_inactive_node(i, j, ibg.Nz, ibg, c, ℓy, ℓz) |; immersed_inactive_node(i-1, j, ibg.Nz, ibg, c, ℓy, ℓz),; zero(ibg),; δx(i, j, k, ibg.underlying_grid, r, args...)). ```. That use a condition based on whether `k == Nz` is immersed. This will fix fields that are reduced in `z` without increasing memory storage or doing a computation in the immersed boundary grid constructor. And that's the most common case anyways. * When building a `ReducedField`, compute the mask that has to be applied to abstract operations. Then, extend the `_derivative` constructor for the combination of a `ReducedField` argument + `ImmersedBoundaryGrid` using conditional operation. This has the advantage of avoiding the mask computation in `ImmersedBoundaryGrid` (since its only needed to do operations on reduced fields). The disadvantage is that different reduced fields have to redo the computation. Also, this only fixes abstract operations and does not fix the internal operators. We also have to update the conditional operators to throw away the immersed boundary grid for reduced fields, or throw away the immersed boundary grid inside the abstract operation. * A variant on the above approach is to compute the mask when forming `Derivative`. But then a new mask is computed for every operation. There's probably a lot of other options. Keep the brainstorming coming.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099195353:113,mask,masks,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099195353,6,['mask'],"['mask', 'masks']"
Availability,"> We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Yes to be clear I should have said that I'm just advocating for printing warnings, not throwing errors. Users should be able to run whatever they want. I would say that these warnings make the software more useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796846731:310,error,errors,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796846731,2,['error'],['errors']
Availability,"> We have to keep masking for velocities in the hydrostatic model.; > ; > In the nonhydrostatic model, the equivalent masking procedure acts on the predictor velocity field prior to solving for pressure:. Yes, I kept that in the nonhydrostatic model. Although I think I removed it on the hydrostatic one so I'll put it back in.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1224091327:18,mask,masking,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1224091327,2,['mask'],['masking']
Availability,"> We should make the changes needed for both nonhydrostatic and hydrostatic models. @glwagner the reason why I hadn't removed masking from the hydrostatic model is that I'm really not familiar with it at all. So it's harder for me to figure out where it's okay to remove it, and testing it. I just did a best guess and removed it from shallow water and nonhydrostatic models in the places I thought appropriate. It would be good to have some feedback from someone more familiar with the code though on that, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496:126,mask,masking,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496,2,['mask'],['masking']
Availability,"> We should modify the netCDF variable names to `λF`, `λC` or something... I didn't do this in #2979 because I didn't know if NetCDF allows unicode (and because I felt it was outside of the scope of that PR). Sorry for the delay in chiming in here. Yes, NetCDF works fine with unicode, but I suspect that due to the [SGRID conventions](https://sgrid.github.io/sgrid/) we will have to name our coordinate a default, non-unicode name, which will be different from the names we use in Oceananigans. ~The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188:501,down,downside,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188,1,['down'],['downside']
Availability,"> We want to run a simulation in which the output interval and the averaging window is between 2-3 time-steps, right? . Yes, exactly. The error occurs in this range. > Maybe we need to write out the sequence of steps that we expect to occur and then we can look at the source code and see why that is not happening. Does the problem also happen when δt = 0.02 (eg output exactly every two time-steps)?. Yes, I agree, the problem still happens when δt = 0.02.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2261204745:138,error,error,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2261204745,1,['error'],['error']
Availability,"> We will have to set up some test cases for sure.; > ; > Are you directly measuring memory allocation, or is the problem ""out of memory errors""? Because the second might have to do with temporary allocations. That's a good point! I've been measuring the memory usage right after defining `model` and right before calling `run!()` (the only things in between are the definition of `simulation` and a bunch of diagnostics), but I've definitely been focusing more on the errors. Here are some numbers that I think bring some clarity:. - Using Julia 1.6 and Oceananigans 0.77.5:; - Biggest grid I can run: `997×997×96 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 19712MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 25778MiB / 32768MiB; - Using Julia 1.7 and Oceanaigans 0.78.0:; - Biggest grid I can run: `941×941×90 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 31026MiB / 32768MiB; - Using Julia 1.8 and Oceanaigans 0.78.0:; - Biggest grid I can run: `941×941×90 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 31026MiB / 32768MiB. Note that although Julia 1.6 + Oceananigans 0.77 ends up with the smaller memory usage in the end, it apparently uses a lot of temporary allocations because I get an out-of-memory error when adding diagnostics with bigger grids. That said, it still manages to have the smallest ""permanent"" memory usage and allows me to run larger simulations. Interesting results. The biggest difference seems to be in the allocations required for the diagnostics (or maybe `Simulatio",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299523285:137,error,errors,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299523285,2,['error'],['errors']
Availability,"> We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI.; > ; > You mind if I revamp this PR and try to see what we need to do to update CUDA? I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0); > ; > Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3. That is very exciting! Do you know of any scaling results that people have done using this multiGPU approach? I'd be keen to try this with Oceananigans when it's working. I know that we tried using MPI and GPU last summer and had some problems. One, getting it to work was a pain. Two, the effiicency dropped down to 60% when going fro 1 to 2 GPUs. I now we can do better, and maybe this is a way of doing that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044679744:727,down,down,727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044679744,1,['down'],['down']
Availability,> We'll be looking here for previews: https://clima.github.io/OceananigansDocumentation/previews/PR3673. I tried this link but received a 404 error. Does it work for others?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2260613051:142,error,error,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2260613051,1,['error'],['error']
Availability,"> What I meant about trusting users for auxiliary fields is that you can do e.g. this: `model = NonhydrostaticModel(; grid, auxiliary_fields=(; A = randn(1, 2))` and it doesn't error. Why do we want to support arrays in `auxiliary_fields`?. The main usage for `auxiliary_fields` is that they can be invoked in continuous-form forcing functions. In that usage they have to be `AbstractField`, otherwise we can't figure out how to interpolate them into a forcing function. `auxiliary_fields` isn't meant to be a place to store just any information needed for a model (what would the purpose of that be?) We can adapt `auxiliary_fields` but it would be good to understand why. Separately, perhaps we should check that all `auxiliary_fields` are `AbstractField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269340649:177,error,error,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269340649,1,['error'],['error']
Availability,"> What do we need?. Maybe just CUDA v10.1+? Before erroring, all the builds seem to print this warning:. ```; Warning: This version of CUDA.jl only supports NVIDIA drivers for CUDA 10.1 or higher (yours is for CUDA 10.0.0); ```. https://buildkite.com/clima/oceananigans/builds/2396#4a537d8f-9863-489f-bb11-2520a00b83de/16-233. I feel like I've seen this warning on Buildkite before, but maybe now CUDA.jl means it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832211264:51,error,erroring,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-832211264,1,['error'],['erroring']
Availability,"> What happens if you first create Figure and Axis, and draw the heatmap into Axis? You'll want to use ""heatmap!"" rather than ""heatmap"". Sadly, I still get the error. Just to be clear, I am trying the following:. ```; fig = Figure(resolution = (1000, 1000)); ax = Axis(fig[1,1], xlabel = ""x"", ylabel = ""y"", title=""vorticity""); heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=clims); ```. In our case, `x,y`, are arrays, but in the examples, `x,y`, are vectors. Maybe heatmap doesn't work so well for this type of data?. For fun I tried `surface!`, which is used in the other visualization.jl code, and that does plot, but i get it on a desk. Not so easy to sort out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126779047:160,error,error,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126779047,2,['error'],['error']
Availability,"> What if you edit the forcing functions into the discrete form, e.g. invoking `Forcing` with `discrete_form=true`?. It helps! But doesn't solve the problem. In particular the MWE above (with two tracer) in discrete form compiles for me. But when I add more tracers (I need at least 6 tracers for my simulations) it fails again. Sometimes with a different error:. ```; ERROR: LoadError: Failed to compile PTX code (ptxas exited with code 255); Invocation arguments: --generate-line-info --verbose --gpu-name sm_60 --output-file /glade/scratch/tomasc/jl_hs9AZo7IJq.cubin /glade/scratch/tomasc/jl_XSJ4P4z47a.ptx; ptxas /glade/scratch/tomasc/jl_XSJ4P4z47a.ptx, line 5136; error : Entry function '_Z23julia_gpu_calculate_Gu_7ContextI14__CUDACtx_Namevv14__PassType_312v12DisableHooksE18_gpu_calculate_Gu_16CompilerMetadataI10StaticSizeI9_8__8__6_E12DynamicCheckvv7NDRangeILi3ES5_I9_1__1__6_ES5_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE15RectilinearGridIS9_8PeriodicS12_7BoundedS9_S9_S8_IS9_Li1ES10_IS9_Li1ELi1EEES8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES15_IS9_E5Int64EES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES10_IS9_Li1ELi1EEEvE4WENOILi3ES9_vv5TupleIS8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEES8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEES8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEES8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEEELitrueEvS17_ILi2ES9_vvS18_IS8_IS18_IS9_S9_ELi1ES10_IS18_IS9_S9_ELi1ELi1EEES8_IS18_IS9_S9_ELi1ES10_IS18_IS9_S9_ELi1ELi1EEES8_IS18_IS9_S9_ELi1ES10_IS18_IS9_S9_ELi1ELi1EEEELitrueEv12UpwindBiasedILi1ES9_vvvv8CenteredILi1ES9_vvvvEES20_ILi1ES9_vvvvEES20_ILi2ES9_vvvS20_ILi1ES9_vvvvEEEvv16SmagorinskyLillyI26ExplicitTimeDiscretizationS9_10NamedTupleI34__b____1____2____3____4____5____6_S18_IS9_S9_S9_S9_S9_S9_S9_EEE17BoundaryConditionI4FluxvEvS23_I23__velocities___tracers_S18_IS23_I12__u___v___w_S18_I9ZeroFieldIS16_Li3EES26_IS16_Li3EES26_IS16_Li3EEEES23_I34__b____1____2____3____4____5____6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112:356,error,error,356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"> What parallelism strategy makes sense? One particle per thread?. I think that makes sense, and we just queue up a huge amount of blocks like we already do with 3D kernels. Although if we use DifferentialEquations.jl then maybe we won't have to worry about parallelism here?. > Do we use linear interpolation between velocity nodes or assume a constant velocity within each cell (nearest neighbor interpolation)?. Yeah I'm not super sure what's a good approach here. We're on a regular Cartesian grid right now so maybe the difference isn't huge?. The [Parcels v2.0 paper by Delandmeter & van Sebille (2019)](https://www.geosci-model-dev.net/12/3571/2019/) discusses interpolation schemes for curvilinear C-grids using mostly Lagrange polynomials. But on a rectilinear grid like ours, it seems that it just reduces down to linear interpolation [see Eq. (3)]. Maybe a good question for @jm-c. > Obtaining prognostic quantities within particles (like reacting chemical species with reaction rates that depend on ambient temperature) may be challenging and probably requires a careful design. Agreed. It may not even be clear what a good solution is. Apparently DARWIN has a similar problem I think where many plankton species may be uptaking nutrients so the question of what to do when a nutrient are depleted is hard to solve, especially as having nutrients go below zero can be bad for the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399:816,down,down,816,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399,1,['down'],['down']
Availability,"> What's the error with `TimeInterval`?. I think the issue was the interval being stored as a Float64, but I'm not sure why that would ever endup in a kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732656499:13,error,error,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732656499,1,['error'],['error']
Availability,"> When I set the halo to be `halo=(3,3)` I get the following error message since it wants `halo=(3,3,0)`. This seems slightly less than idea. Should we make it so that either are acceptable?; > ; > ```; > [2021/05/18 12:08:59.339] WARN Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid. -@-> /home/fpoulin/software/Oceananigans.jl/src/Grid; > ```. This is a warning, not an error right?. Yes, I think it'd be good to change the warning (since it's wrong). I would save this for another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843321244:61,error,error,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843321244,2,['error'],['error']
Availability,"> When the model is created the velocities and tracers are initialized to 0 so I think the diffusivity is zero then (typically...)? I believe this is the case in your example --- isn't it correct that the diffusivities are zero?. Not in this case because it ends up not adding the molecular viscosity. > To cover the case that explicit tracer and velocity fields are supplied to a model with non-zero values, we could call update_state! in the constructor --- not a bad idea at all. That just requires changing this line:. I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885268477:583,down,downsides,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885268477,2,['down'],['downsides']
Availability,"> When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > ; > ```julia; > ERROR: LoadError: UndefVarError: `settings` not defined; > ```; > ; > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > ; > ```julia; > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > ```. Do you need help fixing these?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276:59,error,errors,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276,4,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,"> Why do you have to change the BGC setup if you change the buoyancy model? Can you give an example?. In this case, if you've set up a model with the above then you would need to tell it the list of tracers that would be present in the model e.g. (:N, :P, :Z, :D, :b), so that when the BGC model is set up it can convert some to indices, then if you changed the buoyancy model and your new tracer list looked like (:T, :S, :N, :P, :Z, :D) then the scaling would have the wrong indices. I suppose in most cases people would retain the order so the indices would be correct, but there's no guarantee that would happen. > I'm not sure how you plan to use the ""materialize"" feature so I can't say. The main issue is if a biogeochemistry model contains fields which end up being re-allocated. This can make callbacks or forcing incorrect. I see what you mean and can see why that would be a problem. I think it would be useful for this to be possible but the documentation to discourage people from using it, and then it would be down to whoever is implementing the bgc model to make sure this didn't happen.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716026302:1025,down,down,1025,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1716026302,1,['down'],['down']
Availability,"> Would a NaN in the velocity field cause an out-of-bounds error? Probably ensuring that does not happen would be relatively easy to fix.; > ; > > will understandably produce out-of-bounds results when trying to interpolate the location in the grid.; > ; > This is incorrect behavior though, right @simone-silvestri ? I thought the problem was with `Bounded`, not `Periodic`. The issue is when the velocity field + time-step is so high that multiple reflections across the entirety of a bounded direction occur in a single time-step. We don't model that situation. We can only handle a single reflection. The particles should not move in `Bounded` directions as there is no v-velocity (and no way to produce one because of no Coriolis, no viscosity, and no friction at the boundaries). Particles should move only along the x-direction where they move out-of-bounds because `CFL=10` and the particle shoots out of the domain. Shear instability should not happen because there is no viscosity/coriolis/buoyancy. In my opinion the unexpected behavior (to be corrected) is to find a NaN or a reflection. @Yixiao-Zhang can you try running on CPU with `--check-bounds=yes` or on GPU with `-g2 --check-bounds=yes` you should get more information about the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772995167:59,error,error,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772995167,1,['error'],['error']
Availability,> Would it be better to use b \boldsymbol{\hat g} and define \boldsymbol{\hat g} as the gravitational_unit_vector to match the constructors / code? There's been some confusion about the meaning of b in the past so that notation could help. I like this idea. Just made the changed. Not sure what to do about the GPU failure though. Seems to be completely unrelated to my change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1736#issuecomment-854951716:315,failure,failure,315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1736#issuecomment-854951716,1,['failure'],['failure']
Availability,"> Yeah this looks quite weird, are the boundary conditions / drag implemented correctly? (I am not sure what I did there); > . In the case without any closure (viscosity) the only boundary conditions we can impose are no-normal flow. But if we had to impose more, I would think that Neumann conditions on the tangential compoment and the height would be the best. > It seems like the southern ocean flows in the wrong direction. Looking at it, there is an incorrect minus sign in the wind stress because I just copied it from the bc which require a minus sign because of our sign convention (forcing do not). (remove the minus in lines 104 and 105) That might also help with the western boundary currents....; > . Yes, I agree that the ACC is going in the wrong direction, which suggests there is a sign error. When I look in `solution_and_tracer_tendencies.jl`, I see a `+` in front of forcings, so that looks right. Maybe there is a problem with how the wind stress is specified? . Is it easy to plot the wind stress? I imagine that would clarify what's going on. > It is also true that there is no density/salinity structure here... And the hydrostatic model is initialized with stratified ocean (maybe you want to play with the initial condition of `h`?). Also bathymetry is absent (which nucleates the eddies in the southern ocean during spinup).; > . I think starting off with `h` as constant, is a good choice. Certainly bathymetry would have an impact, but it should give us western boundary currents in the big oceans. > We should probably discuss how to implement bathymetry correctly, because I am not completely sure that what is done here is correct. On the other hand, I can also provide a spectrally ""smoothed"" bathymetry which might help with stability. @francispoulin let me know if that could be a good idea; > . I agree that it is important to do the bathymetry correctly. Smoothing it certainly would help. My first thought was to try it with the topography with 1/10 or 1/100 the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128050024:804,error,error,804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128050024,1,['error'],['error']
Availability,"> Yeah yeah, that makes sense now.; > ; > I think storing them together would be a lot harder when the infrastructure for arbitrary external states is already set up for conditions, so I'm not sure it's worth the tradeoff. It's kind of the same principle as gradient boundary conditions where the `condition` is some external information, and then `Gradient` specifies what is done with it to set the boundary point. But yeah I would be interested in what @simone-silvestri has to say. I really fail to understand how either decision makes things harder. From my point of view it's simply about how the code reads. Whenever we use a boundary condition, we have all the information available to us. Can you please explain why you think that this decision would affect what we are able to achieve?. Consider that this is the only difference between the two options:. ```julia; # option 1; bc.classification.matching_scheme. # option 2; bc.condition.matching_scheme; ```. How is it possible for this to affect how we achieve anything? We never have the `condition` separate from the `classification`. We always have them together.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986572918:681,avail,available,681,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986572918,2,['avail'],['available']
Availability,"> Yes, it doesn't throw an error, but the data of interior(c, 1, :, 1) is not assigned to interior(d, :, 1, 1) except for the first element (as seen in your MWE and mine below). Heh, true. That's a relief actually...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038968197:27,error,error,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038968197,1,['error'],['error']
Availability,"> Yesterday, with @glwagner, we discovered that using higher order advection schemes gave larger error when you don't set the halo to be the large size.; > ; > How about we check the halo size we give an error?. Just to clarify, if the halos aren't set properly then results aren't ""less accurate"" --- instead, they are wrong, even if they are finite. A segfault and program failure is another possibility.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2106#issuecomment-988882646:97,error,error,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2106#issuecomment-988882646,3,"['error', 'failure']","['error', 'failure']"
Availability,"> You are passing too many parameters in the `compute!` kernel, unfortunately. GPUs have a limit on the size of the parameters you can pass (4352 bytes, and you are using 4592 bytes). Ah I see. So basically this is just a GPU limitation and there's nothing to be done in the Oceananigans/user side (apart ofc from splitting the computations)?. Also, is there a way to know at compile time whether the max parameter size is being reached? That way I can define things without ""nesting"" `Field` calls when possible (which saves memory), and use `Field` calls only when necessary to avoid this error. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581740522:591,error,error,591,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581740522,1,['error'],['error']
Availability,> You are right that maybe horizontally `Flat` does not work in general with lat-long. I change the test to have lat-lon grids with only one. of the horizontal directions flat. I think we should add a warning/error message when someone tries to create a lat-lon grid with both lat and lon being Flat. (but not in this PR).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630240073:209,error,error,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630240073,1,['error'],['error']
Availability,"> You're right that it's a little bit misleading. It is not technically a ""divergence damping"", because the actual operator is; > ; > ```; > ∇(ν(∇ ⋅ Δu)); > ```; > ; > So it damps the laplacian of the velocity (here we switched the divergence and the laplacian operators). Thanks! And now I get why this is called biharmonic divergence damping. . We could also write the term as . ``; ∇ ( ν Δ (∇ ⋅ u)); ``. to show that it depends explicitly on the divergence of the velocity. If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. . Not a problem, but I just wanted to make sure I understand this as I didn't know about this before today. Incidently, we don't have the rotational equivalent that was mentioned before? I presume for that we would just use the Laplacian, which is simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461:593,error,error,593,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461,2,['error'],['error']
Availability,"> `Flux` is added as an a; > ; > > > > Ok but @simone-silvestri that problem with the implicit solver is indeed a bug. It's trivially fixed too.; > > > ; > > > ; > > > I wouldn't consider this a bug but rather a non-implemented feature. It is not the only place where this pattern appears in the code, in a lot of places we write; > > > ```julia; > > > fill_halo_regions!(field); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > without passing `clock` and `model_fields`. If we want to make sure that we support complex BCs also for `Value`, `Open`, and `Gradient` we need to ensure that this pattern changes everywhere in the code. Indeed, it is not difficult to do it, @tomchor if you want to can give it a try; > > ; > > ; > > Doesn't it also mean you can't use function `Flux` top and bottom boundary conditions with the implicit solver? Like quadratic bottom drag?; > ; > `Flux` is added as a tendency, not by filling halos. I have to think about it a sec but the drag might be already included in the RHS. Right ok, we can use `Flux`. Also constant or array `Value` and `Gradient` will work without an error. Function `Value`, `Gradient`, `Open` will fail. Functions could be implemented by updating the array in a callback. This can also be used for any example. The functions are just a convenience. But we should support it where its easy and obvious, don't you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179199806:1165,error,error,1165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179199806,1,['error'],['error']
Availability,"> `KernelAbstraction.synchronize(device(arch))` would be the same as the previous `wait(device(arch), event)` where the error would be thrown. Thank you. I was about to comment this:; > Another thing with the new kernels. I believe I've now got the particle advection kernels working, but unless some event causes a delay, for example printing some informaiton out, the `advect_lagrangian_particles!` event does not finish before the test tries to test that its been correctly done which causes it to fail. . >If I change it so that `advect_lagrangian_particles!` returns `advect_particles_kernel!(...`, and wrap `advect_particles_kernel!` in wait (i.e. `wait(advect_lagrangian_particles!(particles, model, Δt))`) then it does run correctly. . >This seems like a bigger issue with how kernel events are working? If other events aren't being finished in order this might cause other issues?. But the new alternative should be to call `KernelAbstraction.synchronize(device(arch))` instead then?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514597017:120,error,error,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514597017,1,['error'],['error']
Availability,"> ```julia; > @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask) ; > condition = arch_array(architecture(operand.grid), condition) ; > return ConditionalOperation(operand; func, condition, mask) ; > end ; > ```. I think there's a typo here that's making it so that the computation doesn't exclude the nodes inside the immersed boundary. I think the correct definition is closer to what I suggested in https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1904623674. Specifically `condition` need to be wrapped around `NotImmersed`:. ```julia; @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask); condition = arch_array(architecture(operand.grid), NotImmersed(condition)); return ConditionalOperation(operand; func, condition, mask); end; ```; which seems to produce the correct result on the CPU, but I can't get it to work on GPUs. Here's a MWE I cooked up where we can check that the results are correct:; ```julia; using Oceananigans; using CUDA: has_cuda_gpu. arch = has_cuda_gpu() ? GPU() : CPU(); grid_base = RectilinearGrid(arch, size = (1, 4, 4), extent = (1,1,1)); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> -1/2)). using Oceananigans.AbstractOperations: ConditionalOperation; using Oceananigans.Fields: AbstractField; import Oceananigans.Fields: condition_operand; IF = AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}; using Oceananigans.ImmersedBoundaries: NotImmersed. using Oceananigans.Architectures: architecture, arch_array; @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask); condition = arch_array(architecture(operand.grid), NotImmersed(condition)); return ConditionalOperation(operand; func, condition, mask); end. using Oceananigans.Grids: ynode, znode; yᶜᶜᶜ = KernelFunctionOperation{Center, Center, Center}(ynode, grid, Center(), Center(), Center()); zᶜᶜᶜ = KernelFunctionOperation{Center, Center,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1905170213:104,mask,mask,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1905170213,4,['mask'],['mask']
Availability,"> ```julia; > [ Info: ... simulation initialization complete (1.471 minutes); > [ Info: Executing initial time step...; > ERROR: LoadError: TaskFailedException; > ; > nested task error: TaskFailedException; > ; > nested task error: type Tuple has no field surface_TKE_flux; > Stacktrace:; > [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); > @ Base ./Base.jl:33; > [2] call; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; > [3] fallback; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; > [4] overdub; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; > [5] overdub; > @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; > [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418:122,ERROR,ERROR,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"> ```julia; > using Oceananigans; > using Oceananigans.Units; > ; > # local depth; > const H = -10meters; > # constant sinking velocity; > const w_siking = -1 # m/s; > ; > # 1D grid; > grid = RectilinearGrid(size=128, z=(H, 0), topology=(Flat, Flat, Bounded)); > ; > # constant diffusivity; > closure = ScalarDiffusivity(κ=1); > ; > # cools down at z=0; > @inline cooling_func(x, y, z, t) = ifelse(z==0,-0.1,0); > cooling = Forcing(cooling_func); > ; > # use WENO to advect down the tracer; > sinking = AdvectiveForcing(WENO5(), w=w_siking); > ; > model = NonhydrostaticModel(grid=grid, closure=closure, buoyancy=nothing, tracers=:T, forcing = (; T = (cooling, sinking))); > ; > simulation = Simulation(model, Δt = 0.01 * H/w_sinking, stop_iteration = 100); > ; > run!(simulation); > ```. Nice, thanks! I'm gonna edit this to be 2D and have a source of turbulence, I'll send a result soon!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081997904:341,down,down,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081997904,2,['down'],['down']
Availability,"> `benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`.; > ; > I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time. Is it possible to automatically pull compat entries from the repo's `Project.toml`? (If it is, should we?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921:184,down,downgrades,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417#issuecomment-1090355921,1,['down'],['downgrades']
Availability,"> `clobber=false` is probably safer. That's what I was thinking too but apparently with NCDatasets.jl the other modes are append (`""a""`) and read-only (`""r""`) so if you're creating files for the first time (the most common use case) then clobber must be used. Otherwise you get NetCDF errors when it tries to open a non-existent file. > Named tuples are trivial to support; but maybe users don't care. Personally, I much prefer them in the JLD2OutputWriter. I actually wasn't able to get named tuples to work with JLD2 but I opened an issue about that: #562. I don't see the big advantage of a `NamedTuple` over a `Dict` in this case so I'm going to keep it simple and stick to named tuples here for now. The original point of this PR was that the documentation was wrong. `NetCDFOutputWriter` needs to be refactored a little anyways, and I'd like to add some features to it as well so I'll add support for named tuples then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-564362931:285,error,errors,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-564362931,1,['error'],['errors']
Availability,"> add the ability to propagate kwargs through the constructor `FieldTimeSeries(filename, fieldname; filekwargs...)` into the `open` functions for jld2 or netcdf, or whatever else comes along. Agree this is good to future-proof. > if using `FieldTimeSeries` with other backends, would it make sense to store the kwargs in the backend?. Good point and I think we will need to do this. There are places where `jldopen` is called not in the constructor so any kwargs passed to the constructor are not available and need to be stored in the backend object. Here are two example: ; 1. https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/OutputReaders/field_time_series_indexing.jl#L78-L81; 2. https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/OutputReaders/set_field_time_series.jl#L52-L54",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3680#issuecomment-2313247144:497,avail,available,497,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3680#issuecomment-2313247144,1,['avail'],['available']
Availability,"> and round off error accumulates. Therefore you may want to increase the tolerance to `10*e_max` or something. Ah I see, thank you, I wasn't sure how this worked. It passes locally now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1492756062:16,error,error,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1492756062,2,"['error', 'toler']","['error', 'tolerance']"
Availability,"> anything larger (e.g. Nx=512) resulted in an out of memory error even when ran by itself . Sure, I doubt that 512³ fits on a single GPU...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-853447698:61,error,error,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-853447698,1,['error'],['error']
Availability,"> but then the function is applied in `mapreduce` (basically you sum `f(vector[i])`) so in this case, if we pass `f(get_neutral_mask(Base.$(reduction!))` to mask places we want to exclude, then we would sum over `f(f(get_neutral_mask(Base.$(reduction!)))` which is not the same as `f(f⁻¹(get_neutral_mask(Base.$(reduction!))) == get_neutral_mask(Base.$(reduction!)` which is what we want.; > ; > As a practical example if we use `mask = f(get_neutral_mask(Base.$(reduction!))` in case of a sum and `f(x) = x +1` we would have `sum(f, c, mask = 1, condition = (i, j, k, grid, c) -> i < Nx/2)`. Then we would subsitute `1` where `condition == true` and this would effectively add `2` for each `i >= Nx/2` (`f(mask)`). We would like to have `mask = -1` which is `f⁻¹(x)` but that is not really possible as we don't know `f⁻¹(x)` for each `f(x)` a-priori.; > ; > Or maybe I haven't interpreted correctly what you wrote?. No that's a good explanation. The ""neutral element"" for an arbitrary reduction with element-wise transformation is inverse transformation applied to the ""identity neutral element"" (for example, the neutral element for `sum(identity)` is 0, while the neutral element for `sum(i -> i+1)` is `-1`). Since we are unable (probably...) to obtain the inverse of arbitrary transformations, we need to implement a workaround. I think its a good idea to add some version of this explanation to the PR description.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023612735:157,mask,mask,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023612735,5,['mask'],['mask']
Availability,"> but this errors with Reason: unsupported call to an unknown function (call to jl_f_getfield), so I'm not sure its going to be straight forward or worthwhile trying to make the high level version work on GPU. I think that's because within a kernal on the GPU, `field` in. ```julia; @inline function interpolate(field, x, y, z); LX, LY, LZ = location(field); grid = field.grid; return interpolate(field, LX(), LY(), LZ(), grid, x, y, z); end; ```. is an OffsetArray and has no property `grid` (or a location).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370313413:11,error,errors,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370313413,1,['error'],['errors']
Availability,"> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)). Nope, it's not erroring on main. ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); 1×1×3 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [1.0, 16.0] variably spaced with min(Δz)=3.0, max(Δz)=7.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757850869:92,error,erroring,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757850869,1,['error'],['erroring']
Availability,"> hmmm, I am not sure. What does `mask_immersed_field!` mean for a `FunctionField`? We probably need to specialize `mask_immersed_field_xy!` for `Field`s only and add a fallback for `mask_immersed_field!`; > ; > ```julia; > mask_immersed_field!(field, args...; kw...) = nothing; > ```; > ; > why was the wrong mask called in the update?. Indeed I think it's ok if `mask_immersed_field!` does `nothing` for non-Fields. But also not sure why we don't already have that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1997786025:310,mask,mask,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1997786025,1,['mask'],['mask']
Availability,> it might be better to download them once at the beginning. Are the artifacts downloaded even if we don't use them?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872394091:24,down,download,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872394091,2,['down'],"['download', 'downloaded']"
Availability,"> might either throw an error or fill the LHS with junk or incorrect values . I'm not that happy mostly because it seems we don't understand? Why ""might""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033504577:24,error,error,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033504577,1,['error'],['error']
Availability,"> my only; concern (as a user) is that if you set them to zero by default,; setting `closure=IsotropicDiffusivity()` in a model will create a; simulation that will have no diffusivities and most likely will crash. From; a user perspective that's not the expected behavior I think, right?. This is definitely the right way to think about it!. I guess with this default, `closure=IsotropicDiffusivity()` is equivalent to `closure = nothing`. Note we _can_ run ""inviscid"" simulations. They don't always blow up if the time-step is small enough (even when the advection scheme conserved variances...) For example some of the work over at https://github.com/CliMA/GeophysicalDissipation.jl. We could just use 0 default for kappa and require nu. This is convenient for simulations with no tracers that don't need kappa. Then the idea I guess is that if you're using `IsotropicDiffusivity`, you have to at least specify `nu` or you get an error (rather than being able to run a model in which you don't know what the explicit dissipation model is).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1278#issuecomment-747435585:932,error,error,932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1278#issuecomment-747435585,1,['error'],['error']
Availability,"> nono we are adding another pipeline for distributed as part of #3326. You can disregard the erroring of `buildkite/oceananigans-distributed`. I see, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1756080047:94,error,erroring,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1756080047,1,['error'],['erroring']
Availability,"> note that our input is the Stokes shear, so I think the most convenient thing to have is the Stokes drift at every level. We can difference that between the top and bottom of a cell to get the ""finite volume averaged Stokes shear"". What do you think about that?. I think it would be good to have the Stokes drift profile available somewhere. So even though only the Stokes shear is used in Oceananigans, I think it is still useful to get the Stokes drift at every level and then differentiate that to get the Stokes shear. >Perhaps it makes sense to start with the Harcourt and D'Asaro 2008 model then? I'll look into that and document what I find here... In terms of implementation the ""theory wave"" is easier -- it's essentially a function of wind speed (the integration over the empirical wave spectrum is done analytically). We just need to apply it multiple time to different depths and then differentiate that to get the layer averaged Stokes drift. For the model used in Harcourt and D'Asaro (2008) we need to do the integration over the empirical wave spectrum numerically. And in addition to wind speed, it also depends on wave age. So I would probably start from the ""theory wave"". I guess it should be straightforward to convert [the Fortran function in GOTM](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) to Julia? . In terms of the resulting Stokes drift profile, ""theory wave"" usually gives a weaker Stokes shear under the same wind. The Donelan et al. (1985) spectrum used in Harcourt and D'Asaro (2008) is for pure wind-wave and gives a strong Stokes shear especially very close to the surface. . I have never used ""theory wave"" to drive an LES. But if we want to approximate the Stokes drift under a wide range of wave conditions with both wind waves and swell, I guess it might not be a bad option at least in an averaged sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882:323,avail,available,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347882,1,['avail'],['available']
Availability,"> oh now I saw that the secondary hidden commit message talks about ""a bug..."" can you reproduce the bug here? I mean, can you tell me how to reproduce the bug because I don't know exactly what you are talking about...; > ; > (there is a chance you may need to delete the dowloaded `.jld2` file to force DataDeps to download it again... perhaps that's your issue -- I'm not sure). The bug manifests when executing the following code snippet over the REPL:; ```; using Oceananigans; using DataDeps; cs32_4 = DataDep(""cubed_sphere_32_grid_with_4_halos"",; ""Conformal cubed sphere grid with 32×32 cells on each face and 4 halos on each side"",; ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/main/cubed_sphere_grids/cs32_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2"",; ""fbe684cb560c95ecae627b23784e449aa083a1e6e029dcda32cbfecfc0e26721""); DataDeps.register(cs32_4); grid_filepath = datadep""cubed_sphere_32_grid_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2""; cs_grid_MITgcm = ConformalCubedSphereGrid(grid_filepath;; Nz = 1,; z = (-1, 0),; panel_halo = (4, 4, 1),; radius = 6370e3); cs_grid_MITgcm = ConformalCubedSphereGrid(grid_filepath;; Nz = 1,; z = (-1, 0),; panel_halo = (4, 4, 1),; radius = 6370e3); ```; The complete error message is; ```; ERROR: KeyError: key ""panel1"" not found; Stacktrace:; [1] getindex(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String); @ JLD2 ~/.julia/packages/JLD2/VWinU/src/groups.jl:101; [2] getindex(f::JLD2.JLDFile{JLD2.MmapIO}, name::String); @ JLD2 ~/.julia/packages/JLD2/VWinU/src/JLD2.jl:494; [3] conformal_cubed_sphere_panel(filepath::String, architecture::CPU, FT::Type; panel::Int64, Nz::Int64, z::Tuple{…}, topology::Tuple{…}, radius::Float64, halo::Tuple{…}, rotation::Nothing); @ Oceananigans.Grids /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Grids/orthogonal_spherical_shell_grid.jl:807; [4] construct_regionally(::Int64, ::Function, ::String, ::Vararg{Any}; kwargs::@K",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954:316,down,download,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954,1,['down'],['download']
Availability,"> ok I see, then it means there must be something wrong with this line which is bypassed; > ; > https://github.com/CliMA/Oceananigans.jl/blob/a1f4f4e75e51a83cf9dec9e671866cff67de1211/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl#L28. So this line is being used when the grid has **both** lat and lon flat. But then it hits an error in the advective flux as you first guessed @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630671744:348,error,error,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630671744,1,['error'],['error']
Availability,> potentially with a default value of overwrite_existing = false. Do you run with `overwrite_existing=false`? (Outside the context of restoring from a checkpoint.),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391719659:151,checkpoint,checkpoint,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391719659,1,['checkpoint'],['checkpoint']
Availability,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876:173,avail,available,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876,2,['avail'],['available']
Availability,"> simulation tests take forever? I'll restart them... Huh, I wonder if that's a downside of this change but not sure...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3580#issuecomment-2102598666:80,down,downside,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3580#issuecomment-2102598666,1,['down'],['downside']
Availability,"> sure it is possible to define it, still it is conceptually wrong, you can easily see it if you visualize the grid:; > ; > ```julia; > julia> grid = LatitudeLongitudeGrid(size = (1, 2, 1), topology = (Periodic, Periodic, Bounded), latitude = (50, 52), longitude = (10, 11), z = (0, 1)); > 1×2×1 LatitudeLongitudeGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; > ├── longitude: Periodic λ ∈ [10.0, 11.0) regularly spaced with Δλ=1.0; > ├── latitude: Periodic φ ∈ [50.0, 52.0) regularly spaced with Δφ=1.0; > └── z: Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=1.0; > ; > julia> grid.Δxᶜᶠᵃ; > 8-element OffsetArray(::Vector{Float64}, -2:5) with eltype Float64 with indices -2:5:; > 0.0; > 74403.92868970236; > 72950.43560309989; > 71474.721107126; > 69977.2347187117; > 68458.43258671739; > 66918.77735298542; > 0.0; > ```; > ; > Note, the delta x in the halos. They are inconsistent with the periodic assumption. Even if it were, it is impossible to reconcile `Δxᶠᵃᵃ` at `Ny + 1` and `Δxᶠᵃᵃ` at 1 which should be exactly the same (but they end up being different)! This means that velocities and tracers that you use to ""fill"" the periodic halo will be exchanged between grid volumes of different size. Another example, these volumes should be the same; > ; > ```julia; > julia> Vᶜᶜᶜ(1, 3, 1, grid); > 7.526820531985937e9; > ; > julia> Vᶜᶜᶜ(1, 1, 1, grid); > 7.864569567312662e9; > ```. It's valid for a single column and that is exactly why we need this feature. If you want, we can throw an error or warning if we have more than one point in y.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3467#issuecomment-1967661513:1544,error,error,1544,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3467#issuecomment-1967661513,1,['error'],['error']
Availability,"> thanks for testing, both problems should be solved. Indeed they are! Thanks @simone-silvestri. One thing I should note is that this fails when `Nx` isn't even (I guess becasue the partition is in `x`):. ```julia; julia> grid_base = RectilinearGrid(topology=(Bounded, Periodic, Bounded), size=(5, 4, 4), extent = (1,1,1)); 5×4×4 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Bounded x ∈ [0.0, 1.0] regularly spaced with Δx=0.2; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion ~/.julia/packages/Oceananigans/E1180/src/MultiRegion/multi_region_grid.jl:64; ERROR: AssertionError: mod(Nx, p.div) == 0; Stacktrace:; [1] partition_size(p::XPartition{Int64}, grid::RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ Oceananigans.MultiRegion ~/.julia/packages/Oceananigans/E1180/src/MultiRegion/x_partitions.jl:24; [2] MultiRegionGrid(global_grid::RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePre",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304013634:897,ERROR,ERROR,897,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304013634,1,['ERROR'],['ERROR']
Availability,"> the debugger works fine on the code snippet you shared - it also works fine on all other Julia libraries where I step through the code by inserting breakpoints - today is the first time I've gotten this error while trying to step through the Oceananigans codebase by using the quick start example. Just a wild guess, but could it have to do with KernelAbstractions? Have you tried the debugger on other packages that use KernelAbstractions?. This smells like a problem with the debugger rather than an Oceananigans-specific issue. But maybe there is something we can change in the source code to help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622044750:205,error,error,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622044750,1,['error'],['error']
Availability,"> we could be calling it within flattened_cpu_interior but the method name doesn't suggest that... if you think of a way to improve do it!. Good idea. Find a new name for the function! What it does:. 1. Drops singleton dimensions; 2. Converts from CPU to GPU; 3. masks immersed regions with NaN. Perhaps simple `convert_field`, because in the context of the extension ""convert"" means to change an argument from the input into something plottable. Or perhaps `make_plottable_field(f)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308633068:263,mask,masks,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308633068,2,['mask'],['masks']
Availability,"> what is the `neutral_value`? If there is one implemented in Julia that's cool. I saw something about a `GPUarrays.neutral_element` (https://github.com/JuliaGPU/GPUArrays.jl/blob/master/src/host/mapreduce.jl) don't know if we can use it; > ; > I think if we don't want to change `mapreduce` we have to have something like `mask = f⁻¹(get_neutral_value(reduction!))`, which might be very difficult as not all the functions are readily invertible.; > ; > For the moment I added a function as a property of `ConditionalOperation` such that `getindex` of `c::ConditionalOperation` is `c.func(getindex(c.operand, args...))` when `c.condition = true`. Then a reduction like `sum(f, c, condition=condition)` will be called on a `ConditionalOperation` with `func = f` and `condition = condition`. I am thinking about other methods which do not require adding a property to the type though. I mean changing. https://github.com/CliMA/Oceananigans.jl/blob/d6a515e2ce5de7c0b10dc29427f96d777dafcf01/src/Fields/field.jl#L422-L423. to. ```julia; Base.$(reduction!)(f::Function, r::ReducedField, a::AbstractArray;; condition = nothing, mask = f(get_neutral_mask(Base.$(reduction!))), kwargs...); ```. so we pass `get_neutral_mask(r)` through `f`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023579740:324,mask,mask,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023579740,2,['mask'],['mask']
Availability,"> ~Is there a way around the order of `includ`ing files so that this works? If not, it probably isn't necessary to force that the `particles` slot in models is taken by a `Nothing` or `LagrangianParticles` as it is now? So we could get rid of the particles dependency in models and change the order to `include` particles after models?~; > ; > ~The only thing I can think of is that if a user passes something other than particles it might give a confusing error.~; > ; > ~I think I found a use case for removing the typing of the particles slot and overloading the update functions too but I can't remember what it was now.~; > ; > This won't work because particles need to already be defined for the timesteppers. My other solution would be to define a function `total_velocities` that is defined somewhere early on, and then define new methods for each model?. What is the problem you are trying to solve?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1493406171:457,error,error,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1493406171,1,['error'],['error']
Availability,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:702,down,down,702,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440,4,"['down', 'mainten']","['down', 'maintenance']"
Availability,"@ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS error might be related to CuArrays: https://github.com/JuliaGPU/CuArrays.jl/issues/255",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:2138,Error,Error,2138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,4,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"@Sbozzolo suggested that this is a bit silly and I have to agree it is sort of pointless red tape in some ways, rather like ""accepting cookies"" every time we have to visit a website. We don't really think about that anymore, we just click as fast as we can so we can move on with out lives... I think @Sbozzolo might have some idea for how to do this better. More or less I think the gist is that, rather than having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniform",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543:1714,down,downside,1714,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543,1,['down'],['downside']
Availability,"@Sumanshekhar17 can you write up a shorter example that does not involve data? Hopefully, as short as possible to reproduce the error. The code you've posted is too long to efficiently debug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902685609:128,error,error,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902685609,1,['error'],['error']
Availability,"@Sumanshekhar17 that's frustrating!. Here are command line instructions that can be copy-pasted into a terminal (I'm not sure if this can be made to work on Windows, but hopefully it will work on linux or Mac):. ```; mkdir Test; cd Test; touch Project.toml; wget https://raw.githubusercontent.com/CliMA/Oceananigans.jl/master/Manifest.toml; julia --project -e 'using Pkg; Pkg.add(""Oceananigans""); Pkg.status(); pkg""st --manifest""'; ```. This creates a directory called ""`Test`"", a file called `Project.toml`, downloads the `Manifest.toml` from Oceananigans.jl#master, uses the Julia package manager to add `Oceananigans`, and then prints the current manifest. You can verify after this that the Manifest is the same as on Oceananigans master (at least, this is what happened on my Mac). Further typing. ```; julia --project -e 'using Pkg; Pkg.add(""JLD2""); Pkg.add(""Plots""); pkg""st --manifest""'; wget https://raw.githubusercontent.com/CliMA/Oceananigans.jl/master/examples/one_dimensional_diffusion.jl; julia --project -e 'include(""one_dimensional_diffusion.jl"")'; ```. Should download and run the one-dimensional diffusion script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827268558:509,down,downloads,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827268558,2,['down'],"['download', 'downloads']"
Availability,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:50,error,errors,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332,5,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,"@ali-ramadhan , I tried running the example using the following `julia --project -p 4 mpi_shallow_water_turbulence.jl; `, and it seemed to fail because of error, see below. Any idea what I might have done wrong?. ```; ERROR: LoadError: ProcessExitedException(3). ...and 2 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347:155,error,error,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"@ali-ramadhan ; Thanks for the suggestion. I tried running it on the CPU and got a different error message, which is shown below. Additionally, the error occurs when defining background fields in the model as such; ```julia ; background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B̄_field); ```; But it runs fine like the usual way; ```julia; background_fields = (; b=B̄_field); ```. ```; [ Info: Initializing simulation...; ERROR: LoadError: type BackgroundFields has no field u; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] assemble_closure_velocities; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:35 [inlined]; [3] u_velocity_tendency; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:92 [inlined]; [4] cpu_compute_Gu!; @ ~/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; [5] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; [6] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; [7] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; [8] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; [9] launch!(::CPU, ::ImmersedBoundaryGrid{…}, ::Symbol, ::typeof(Oceananigans.Models.Nonhydros",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2432725343:93,error,error,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2432725343,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"@ali-ramadhan @christophernhill it looks like the incompressible-in-time tests are failing for a hyperbolically `VerticallyStretchedRectilinearGrid`. However, a curious aspect of the test is that we compare `maximum(|δ|)` to 0, where `δ` is the divergence. Models that use `VerticallyStretchedRectilinearGrid` fail this test because `maximum(|δ|)` is greater than 5e-8 (its around 1e-4 for AdamsBashforth, and 3e-5 for RK3). . However, it looks like `sum(δ)` is smaller than machine precision; thus mass does not accumulate in time. . The larger-than-normal error only shows up when the grid is stretched; when the coordinate spacing in `VerticallyStretchedRectilinearGrid` is constant, the tests pass. Should we modify this test? What do we want to test for and what do we expect? Presumably both non-accumulation of mass and a small divergence are both important...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474:558,error,error,558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541#issuecomment-814479474,1,['error'],['error']
Availability,"@ali-ramadhan I did not see this in PR #147 (too many lines of diff for time_steppers.jl, so i missed this).; But regarding your question about ""epsilon"", this is just an other name for parameter ""χ"" (chi).; In fact, I would prefer to have ""0.5 + χ"" i beeing called the AB-2 parameter; this way, if set to zero then ; we recover a simple first order forward time stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/160#issuecomment-479312286:321,recover,recover,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/160#issuecomment-479312286,1,['recover'],['recover']
Availability,"@ali-ramadhan I think the buildkite docs build cannot push the preview. It complains that ""there is no space on device"". Perhaps consider deleting all previous useless PR previews? Or ping somebody that can do that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1306#issuecomment-759773107:184,ping,ping,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1306#issuecomment-759773107,1,['ping'],['ping']
Availability,@ali-ramadhan do you know why the checkpointer tests are failing?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780729036:34,checkpoint,checkpointer,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780729036,1,['checkpoint'],['checkpointer']
Availability,"@ali-ramadhan interestingly, when I run your exact example things take a little longer to blow up. I wonder what gives:. ```julia; [ Info: ... simulation initialization complete (7.057 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (36.179 seconds).; iteration: 1, time: 0.1000, U_max=(1.31e-02, 4.98e-03, 5.51e-03); iteration: 2, time: 0.2000, U_max=(1.30e-02, 4.96e-03, 5.50e-03); iteration: 3, time: 0.3000, U_max=(1.39e-02, 5.50e-03, 5.45e-03); iteration: 4, time: 0.4000, U_max=(NaN, NaN, NaN); iteration: 5, time: 0.5000, U_max=(NaN, NaN, NaN); iteration: 6, time: 0.6000, U_max=(NaN, NaN, NaN); ```. In any case, when I don't specify the pressure solver and let default to the FFT-based one, things seem to run fine. So imo it does seem to point to the conjugate gradient solver struggling to find a valid solution close to the immersed boundary. PS: There seems to be a small bug when specifying the conjugate solver without specifying the preconditioner:. ````julia; julia> ConjugateGradientPoissonSolver(grid); ERROR: UndefVarError: `ImmersedBoundaryGrid` not defined; Stacktrace:; [1] ConjugateGradientPoissonSolver(grid::ImmersedBoundaryGrid{…}; preconditioner::Oceananigans.Solvers.DefaultPreconditioner, reltol::Float64, abstol::Float64, kw::@Kwargs{}); @ Oceananigans.Solvers ~/repos/Oceananigans.jl2/src/Solvers/conjugate_gradient_poisson_solver.jl:54; [2] ConjugateGradientPoissonSolver(grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}); @ Oceananigans.Solvers ~/repos/Oceananigans.jl2/src/Solvers/conjugate_gradient_poisson_solver.jl:47; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2406235013:1063,ERROR,ERROR,1063,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2406235013,1,['ERROR'],['ERROR']
Availability,"@ali-ramadhan, out of curiosity do you know why this fails?; https://buildkite.com/clima/oceananigans/builds/894#25866b57-d2c9-48ec-a969-c2f1a11d7f39. error says `ERROR: UndefVarError: CPU not defined`... weird...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1269#issuecomment-744735239:151,error,error,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1269#issuecomment-744735239,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"@ali-ramadhan, there is a strange error in the [docs log](https://buildkite.com/clima/oceananigans/builds/2637#a8b79673-9564-4527-94c6-209dedd870a2) about `Kumar16`... Any idea? Is it related with bumping up DocumenterCitations.jl from 0.2.1 -> 0.2.2?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1677#issuecomment-844532260:34,error,error,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1677#issuecomment-844532260,1,['error'],['error']
Availability,"@arnscheidt reported this error when running this script. https://github.com/ali-ramadhan/antarctic-ice-shelf-meltwater-outflow/blob/eae17968349d72613ccbd0d5b856cc76b30b7850/ice_shelf_meltwater_outflow_2d.jl. ```; InvalidIRError: compiling _set_gpu!(Cassette.Context{nametype(Ctx),Nothing,Nothing,GPUifyLoops.var""##PassType#422"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields._set_gpu!), OffsetArrays.OffsetArray{Float64,3,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, RegularCartesianGrid{Float64,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f_apply_type); ```. Looking at the full stacktrace it looks like `threadIdx` is undefined so maybe we just forgot to import CUDAnative.jl in the Fields submodule following the big reorganization in #591. There should have been a test for this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/634:26,error,error,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/634,1,['error'],['error']
Availability,@charleskawczynski Ah no just a random error but I reran the Buildkite pipeline out of habit. Feel free to merge!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1435#issuecomment-793202207:39,error,error,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1435#issuecomment-793202207,1,['error'],['error']
Availability,"@elise-palethorpe, look at [this error](https://buildkite.com/clima/oceananigans/builds/8479#01830c59-efb2-4373-89f9-4679bbb38cfd/36-801). I think it's something related with AMGX not being finalized...?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1237494366:33,error,error,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1237494366,1,['error'],['error']
Availability,@francispoulin Ah I have not seen that error before but will try to reproduce. > Yes - but there isn't anything to review much in #1430 otherwise?. Ah this PR is still a draft and might change a lot so not ready for review just yet. My plan was to merge #590 (which is marked ready for review) then rebase this branch/PR on master so @francispoulin and I could work on it more.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794029661:39,error,error,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794029661,1,['error'],['error']
Availability,@francispoulin Ah was the initial error different?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796861405:34,error,error,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796861405,1,['error'],['error']
Availability,"@francispoulin I do not know but I think it would be good to find out. `VerticallyImplicitTimeDiscretization`, despite being verbose, is actually too terse --- what we are really implementing is a _backwards_ vertically implicit time discretization. Our implementation in `QuasiAdamsBashforth2` is a first-order backwards approximation. Note that `QuasiAdamsBashforth2` is also first-order for explicit stepping, so this implementation should not change the accuracy of the scheme, I don't think. In `RungeKutta3` we implement a scheme that is backwards ""within stages"". This corresponds to some particular choice of Butcher tableau and I am not sure if it is formally 3rd order still. We might be able to develop a convergence test to an analytical solution to investigate this problem. It needs to be relatively high spatial resolution so that time-stepping errors are larger than spatial discretization errors. I propose we implement some validation tests and convergence tests in a future PR though to avoid bogging this PR down more...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639#issuecomment-838806675:860,error,errors,860,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639#issuecomment-838806675,3,"['down', 'error']","['down', 'errors']"
Availability,@francispoulin I think it's always helpful to post the full error and stacktrace. From your original post. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!; ```. suggests that the error could be happening since `b̄` is being used in a `ComputedField`'s `compute!`: https://github.com/CliMA/Oceananigans.jl/blob/9eca5780658bb8f5c0debd34146a0ad5cb73c872/examples/inertially_unstable_jet.jl#L51,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237:60,error,error,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,@francispoulin This particular failure happens occasionally and I think it's related to #1179 but haven't really investigated. Usually I just restart the test and it passes the second time. Did it here so hopefully it should pass. @tomchor Doc builds seem to be hanging recently across most PRs and commits. I haven't had time to investigate but hope to soon...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-815971255:31,failure,failure,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-815971255,1,['failure'],['failure']
Availability,"@francispoulin and @glwagner Thank you for this. before closing this issue I wanted to ask weather I have written my boundary condtion as a function `heatflux` is correct or not -; ```; function heatflux(x, y, z, t); if Q_net(t) <= 0; bias = 1; multiplier = 0; else; bias = 0; multiplier = 1; end. return bias*Q_cool; end; Temp_bc = FluxBoundaryCondition(heatflux); dTdz = 0; T_bcs = FieldBoundaryConditions( top = Temp_bc,; bottom = GradientBoundaryCondition(dTdz)); ```; I am constantly getting error stating that -; ```; TaskFailedException. nested task error: MethodError: no method matching heatflux(::Float64, ::Float64, ::Float64); Closest candidates are:; heatflux(::Any, ::Any, ::Any, ::Any) at In[9]:1; Stacktrace:; [1] call; @ C:\Users\My Account\.julia\packages\Cassette\r4kKQ\src\context.jl:456 [inlined]; [2] fallback; @ C:\Users\My Account\.julia\packages\Cassette\r4kKQ\src\context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ C:\Users\My Account\.julia\packages\Cassette\r4kKQ\src\overdub.jl:585 [inlined]; [4] overdub; @ C:\Users\My Account\.julia\packages\Cassette\r4kKQ\src\overdub.jl:585 [inlined]; [5] overdub; @ C:\Users\My Account\.julia\packages\Oceananigans\To7WB\src\BoundaryConditions\continuous_boundary_function.jl:122 [inlined]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-903087954:497,error,error,497,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-903087954,2,['error'],['error']
Availability,@francispoulin can you post the whole code that creates this error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1302675445:61,error,error,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1302675445,1,['error'],['error']
Availability,"@francispoulin sounds like a good plan! Then we can see how to proceed. Concerning the way forward with `WENOVectorInvariant`, it seems that it is very diffusive when compared to standard WENO. an example on a 256^2 periodic Bickley jet below, contours are of vertical vorticity (left) and zonal velocity (right). WENO5. https://user-images.githubusercontent.com/33547697/157509797-d61f45ba-8284-40f2-b9e9-4cafcba6db68.mp4. WENOVectorIvariant. https://user-images.githubusercontent.com/33547697/157533165-9281949b-1579-462d-ad16-e27b2f954969.mp4. Integrated Enstrophy (blue is 64^2, red is 128^2, green is 256^2, solid lines are WENO5, dashed are WENOVectorInvariant); ![enstrophy](https://user-images.githubusercontent.com/33547697/157510310-3acfaeaf-4d05-4fac-b332-e7b66563147e.png). @sandreza was pointing out that maybe the extra diffusivity comes from the fact that we are advecting vorticity which contains much thinner structures than velocity, then maybe the ""optimal WENO weight"" are not so optimal anymore. These weights are 3 constant parameters, which are quite empirical and ""free-to-choose"" (in our case just `1/10` for the downstream, `6/10` for the central and `3/10` for the upstream stencil). Dissipation can be reduced by increasing the ""central stencil weight"". The idea with @sandreza was to perform an easy calibration to try to ""reasonably"" preserve enstrophy in the Bickley jet (then maybe calibrate it also against the spherical bicklet jet or R-H waves where also Coriolis is involved). The objective is to completely eliminate explicit viscous dissipation in the horizontal direction (harmonic and/or biharmonic) for the global simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741:1138,down,downstream,1138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741,1,['down'],['downstream']
Availability,"@francispoulin, sure, I'd like to discuss the implementation of advection in the `ShallowWaterModel`. We can also zoom if you want, send me an email and we can see when we both have time. @christophernhill I'll take a look at that! It will be nice when implementing the cubed sphere. @pvthinker thanks for the comment! In this case vorticity is still the quantity being upwinded. I agree that upwinding the velocity would lead to errors since you have to ensure consistency in `div(U)` which you break by using an upwinding stencil for U (at least on a C-grid). ; Here I just relied on U to assess the ""smoothness"" of the vorticity stencils for upwinding. (if we look it in an ENO fashion, the choice of wether to upwind strongly or use a (less dissipative) centered stencil for vorticity relies on the velocity field rather than the vorticity field). . This might also be consistent with how you choose the stencils in the advection of tracers, where the choice is based on the evolved quantity (I have no mathematical proof in this case). I agree though, that maybe some more quantitative study is required to ensure that this method plays nicely. Just to share, these are the spectra (KE and enstrophy) at the final time step of the _immersed_ simulation shown above compared with a 2nd oder vector invariant (ensthrophy conserving) scheme with additional biharmonic viscosity (at a resolution of 1024^2) ; ![vel_x_spec-bih](https://user-images.githubusercontent.com/33547697/160655542-18b59170-a928-44ac-85f4-60b22b8e8dce.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1082056720:430,error,errors,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1082056720,1,['error'],['errors']
Availability,"@fredrikekre, @mortenpi. We tried here what we were chatting on slack about parallelizing the execution of literated examples but we got this:. https://buildkite.com/clima/oceananigans/builds/11572#01888a04-bcd4-490b-a0d9-c69d6586c3ca. Any ideas?. (When I tried to build the docs locally I got the same error...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576419495:303,error,error,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576419495,1,['error'],['error']
Availability,"@glwagner : I was able to get your suggestion working very easily, thanks again. Unfortuantely it doesn't help is removing the error that is introduced in the centre or the fact that it grows exponentially (I am guessing). I have looked at the pressure and it looks smooth but I suppose looking at the pertrubation pressure might be more telling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708762171:127,error,error,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708762171,1,['error'],['error']
Availability,"@glwagner : is it the separation of vorticity from the topography in the two immersed boundary cases that are the transient _injections_ that you are referring to?. If we were to try this with the `ShallowWaterModel`, where instead of having flow over a bumpy bottom, we had flow along a bumpy coastline, we would not get pressure errors since we don't solve for the pressure. How difficult would it be to set this up for that scenario? I'd be happy to run it and see what happens but it would take em a while to set things up. . The motvation is to assess how much of this is due to pressure errors versus other stuff.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101504503:331,error,errors,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101504503,2,['error'],['errors']
Availability,"@glwagner ; After merging this PR and running it on the GPU, I encounter the following error. (I'm using Julia 1.10.2 and Oceananigans v0.92.0):. ```; [ Info: Initializing simulation...; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.Models.NonhydrostaticModels.gpu_compute_Gu!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(10, 10, 10)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 10)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ::ImmersedBoundaryGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Periodic, Bounded, RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, Nothing, Nothing, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, Float64, Nothing, Nothing, Nothing}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, Nothing, Nothing}, ::Nothing, ::Tuple{WENO{3, Float64, Nothing, Nothing, Nothing, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, ConstantCartesia",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700:87,error,error,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,@glwagner ; All Krylov solvers have an in-place version where the first argument is a workspace that contains all storage needed by the solver.; You can recover the solution with `solver.x` or just `solution(solver)`. I wrote a section about in-place methods in the documentation:; https://jso.dev/Krylov.jl/dev/inplace/. The in-place version of CG is detailed [here](https://jso.dev/Krylov.jl/dev/solvers/spd/#Krylov.cg!). The cost in terms of storage of each solver is also documented:; https://jso.dev/Krylov.jl/dev/storage/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387566461:153,recover,recover,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387566461,1,['recover'],['recover']
Availability,"@glwagner ; I should have reviewed your code instead, right?. This is now complaining about `af` variable; `nested task error: UndefVarError: af not defined`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082105665:120,error,error,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082105665,1,['error'],['error']
Availability,"@glwagner @hdrake ; With the latest [commit](https://github.com/CliMA/Oceananigans.jl/pull/3721/commits/55cac93afffd1f56a963f5e2a817c420df04c77e), I believe we've addressed the remaining issues in this PR, including those that occur when 1) the saving interval differs from the window time average interval, and 2) after resuming from a checkpoint. A quick result showing the numerical solution matches well with the analytical solution even when window ≠ interval and picking up checkpoint at t=1:; <img width=""593"" alt=""image"" src=""https://github.com/user-attachments/assets/6c70d2c4-c99c-4ef5-bfe7-60de2daf9a72"">. To properly handle the checkpoint pickup, we manually adjusted the actuation to match the correct value based on the pre-pickup simulation. Here's an [example](https://github.com/liuchihl/Oceananigans.jl/blob/correct-averagedtimeinterval/test_netcdf_timeaverage.jl#L105-L116) to illustrate what I mean.; While this resolves the issue of checkpoint for now, it's more of a workaround, and a more robust high-level design is still needed. I believe some help is required with the checkpoint pickup design, but aside from that, the window time averaging appears to be functioning correctly now!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2423417335:337,checkpoint,checkpoint,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2423417335,6,"['checkpoint', 'robust']","['checkpoint', 'robust']"
Availability,"@glwagner @navidcy , I did the exact steps described in [https://github.com/CliMA/Oceananigans.jl/issues/1601](#1601).; But still, I am not getting satisfactory results. I am very confused and worried too as I am stuck to this error for the last 1 weeks.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827079436:227,error,error,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827079436,1,['error'],['error']
Availability,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754:992,avail,available,992,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754,2,['avail'],['available']
Availability,"@glwagner As you mentioned, I attempted to follow your suggestion by specifying the ```CUDA.@allowscalar```. However, I still encountered the same error on a different line. Code:; ```; function rescale!(model, energy; target_kinetic_energy = 1e-6); compute!(energy); rescale_factor = CUDA.@allowscalar √(target_kinetic_energy / energy[1, 1, 1]) ; #rescale_factor = √(target_kinetic_energy / energy[1, 1, 1]). for f in merge(model.velocities, model.tracers); f .*= rescale_factor; end. return nothing; end; ```; Error:; ```; Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question. Stacktrace:; [1] error(s::String); @ Base .\error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:116; [5] getindex(A::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:48; [6] scalar_getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:34 [inlined]; [7] _getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:17 [inlined]; [8] getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:15 [inlined]; [9] getindex; @ .\subarray.jl:290 [inlined]; [10] macro expansion; @ .\multidimensional.jl:917 [inlined]; [11] macro",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2022273164:147,error,error,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2022273164,3,"['Error', 'error']","['Error', 'error']"
Availability,"@glwagner CUDA aware MPI is supported for 11.2 but it is only built against OpenMPI 4.1.0 and 4.1.1, I think we had previously 4.0.4. Also julia 1.6.2 is available.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906712815:154,avail,available,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906712815,1,['avail'],['available']
Availability,"@glwagner Here is the whole code:. And the error is after defining the ""model"". ```; using Oceananigans; using Oceananigans.BoundaryConditions: fill_halo_regions!; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom, PartialCellBottom; using Printf; using GLMakie. arch = CPU(); tracer_advection = CenteredSecondOrder(); momentum_advection = CenteredSecondOrder(). underlying_grid = RectilinearGrid(arch,; size=(128, 64), halo=(3, 3), ; y = (-1, 1),; z = (-1, 0),; topology=(Flat, Periodic, Bounded)). # A bump; h₀ = 0.5 # bump height; L = 0.25 # bump width; @inline h(y) = h₀ * exp(- y^2 / L^2); @inline seamount(x, y) = - 1 + h(y). seamount_field = Field{Center, Center, Nothing}(underlying_grid); set!(seamount_field, seamount); fill_halo_regions!(seamount_field). minimum_fractional_Δz = 0.2; immersed_boundaries = [; PartialCellBottom(seamount_field.data;; minimum_fractional_Δz),; GridFittedBottom(seamount_field.data); ]. b = []; v = []. function progress(sim); vmax = maximum(abs, sim.model.velocities.v); @info @sprintf(""Iter: %d, time: %.2e, max|v|: %.2e"",; iteration(sim), time(sim), vmax). return nothing; end. for ib in immersed_boundaries; grid = ImmersedBoundaryGrid(underlying_grid, ib). @show grid. model = HydrostaticFreeSurfaceModel(; grid,; tracer_advection,; momentum_advection,; coriolis = FPlane(f=0.1),; tracers = :b,; buoyancy = BuoyancyTracer()). N² = 1; bᵢ(x, y, z) = N² * z; set!(model, b = bᵢ). simulation = Simulation(model; Δt=1e-3, stop_iteration=1000); simulation.callbacks[:p] = Callback(progress, IterationInterval(100)). run!(simulation). push!(b, Array(interior(model.tracers.b, 1, :, :))); push!(v, Array(interior(model.velocities.v, 1, :, :))); end. b_partial = b[1]; b_full = b[2]; Δb = b_full .- b_partial. v_partial = v[1]; v_full = v[2]; Δv = v_full .- v_partial. fig = Figure(resolution=(1200, 1800)). partial_cell_title = @sprintf(""PartialCellBottom with ϵ = %.1f"", minimum_fractional_Δz); ax_bp = Axis(fig[1, 2], title=partial_ce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1302764834:43,error,error,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1302764834,1,['error'],['error']
Availability,"@glwagner I am attempting to run the Kelvin-Helmholtz instability example on a GPU, but the model fails and throws errors. Can someone help me to sort out this error? Please find the attached error below: . ```julia; using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])""; ```. ```; Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522:115,error,errors,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522,4,"['Error', 'error']","['Error', 'error', 'errors']"
Availability,"@glwagner I am running into issues when setting up a 3D simulation. I am not sure where the error is coming from but I suspect it comes from a typo in `/Oceananigans/MuMNB/src/Operators/divergence_operators.jl` line 62, where `Ayᵂ ` is defined but not used. Should it be `Ayˢ`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106174320:92,error,error,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106174320,1,['error'],['error']
Availability,"@glwagner I am trying to run the Kelvin-Helmholtz instability example on a GPU; however, the model has failed, throwing some errors. Can someone help me to sort this error. Please find the attached error below: . using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])"". Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183:125,error,errors,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183,4,"['Error', 'error']","['Error', 'error', 'errors']"
Availability,"@glwagner I have simplified the test script (good idea as it was clunky for me to sieve through and I wrote it..) and the new tests pass on both `CPU()` and `GPU()`. ~~The error from the docs build does not look related to this PR as far as I can tell! The docs built on a previous version and I do not think I changed any code related to the docstring.~~. This PR is already likely enough but one thing that could be done is to move `src/Buoyancy/buoyancy_field.jl`. ```julia; # TODO: move to Models; buoyancy(model) = buoyancy(model.buoyancy, model.grid, model.tracers); buoyancy(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); BuoyancyField(model) = Field(buoyancy(model)); ```. to `Oceananigans.Models` and alter this so instead of returning `BuoyancyField` it returns the `KernelFunctionOperation`. ```julia; sewater_buoyancy_perturbation(model) = sewater_buoyancy_perturbation(model.buoyancy, model.grid, model.tracers); sewater_buoyancy_perturbation(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); SewaterBuoyancyPerturbation(model) = sewater_buoyancy_perturbation(model); ```. to match the behaviour of `SeawaterDensity`.; Likely better to do another day but if you think it worth doing in this PR let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047:172,error,error,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047,2,['error'],['error']
Availability,"@glwagner I might need help with this one. When I try to use `ZDirection` I keep getting this KA-related error:. ```julia; Batched tridiagonal solver [CPU()]: Error During Test at /home/tomas/repos/Oceananigans.jl3/test/test_batched_tridiagonal_solver.jl:169; Test threw exception; Expression: can_solve_single_tridiagonal_system(arch, Nz; tridiagonal_direction); MethodError: no method matching work_layout(::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ::Nothing; include_right_boundaries=false, reduced_dimensions=(), location=nothing, only_active_cells=false); Closest candidates are:; work_layout(::Any, ::Tuple; kwargs...) at ~/repos/Oceananigans.jl3/src/Utils/kernel_launching.jl:33; work_layout(::Any, ::Symbol; include_right_boundaries, location, reduced_dimensions, only_active_cells) at ~/repos/Oceananigans.jl3/src/Utils/kernel_launching.jl:51; Stacktrace:; [1] launch!(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ::Nothing, ::typeof(Oceananigans.Solvers.solve_batched_tridiagonal_system_kernel!), ::Array{Float64, 3}, ::Vararg{Any}; include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, only_active_cells::Bool, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Ocea",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1564858506:105,error,error,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1564858506,2,"['Error', 'error']","['Error', 'error']"
Availability,"@glwagner I remember now why the right-hand side `b` is an `AbstractVector{FC}`: I use the type `FC` for type stability with the keyword arguments (tolerances, etc.) as well as default values (`sqrt(eps(real(FC)))`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415639111:148,toler,tolerances,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415639111,1,['toler'],['tolerances']
Availability,"@glwagner I tested the fix locally, seems to fix the issue. I was also catching up with a past discussion on turbulence closure (https://github.com/CliMA/Oceananigans.jl/issues/1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since https://github.com/CliMA/Oceananigans.jl/issues/1277?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106333798:310,error,errors,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106333798,1,['error'],['errors']
Availability,@glwagner I think we're getting some non-deterministic CI errors again... tests are failing for this commit that didn't on the previous one.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2127959583:58,error,errors,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2127959583,1,['error'],['errors']
Availability,"@glwagner I'm running into a similar issue (v0.30.0):. ```; ERROR: LoadError: AssertionError: CUDAdrv.jl did not successfully initialize, and is not usable.; Stacktrace:; [1] libcuda at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/CUDAdrv.jl:82 [inlined]; [2] (::CUDAdrv.var""#535#cache_fptr!#11"")() at /home/mike/.julia/packages/CUDAapi/XuSHC/src/call.jl:31; [3] macro expansion at /home/mike/.julia/packages/CUDAapi/XuSHC/src/call.jl:39 [inlined]; [4] macro expansion at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/libcuda.jl:36 [inlined]; [5] macro expansion at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/error.jl:110 [inlined]; [6] cuDeviceGetCount at /home/mike/.julia/packages/CUDAapi/XuSHC/src/call.jl:93 [inlined]; [7] length at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/devices.jl:105 [inlined]; [8] iterate(::CUDAdrv.DeviceSet, ::Int64) at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/devices.jl:100 (repeats 2 times); [9] iterate at ./iterators.jl:139 [inlined]; [10] iterate(::Base.Iterators.Enumerate{CUDAdrv.DeviceSet}) at ./iterators.jl:138; [11] top-level scope at /home/mike/.julia/packages/Oceananigans/1xP6n/src/Oceananigans.jl:131; [12] include(::Module, ::String) at ./Base.jl:377; [13] top-level scope at none:2; [14] eval at ./boot.jl:331 [inlined]; [15] eval(::Expr) at ./client.jl:449; [16] top-level scope at ./none:3; in expression starting at /home/mike/.julia/packages/Oceananigans/1xP6n/src/Oceananigans.jl:124; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/788#issuecomment-653563655:610,error,error,610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788#issuecomment-653563655,1,['error'],['error']
Availability,"@glwagner I've been thinking about the WENO5 algorithm based on our discussion in https://github.com/CliMA/Oceananigans.jl/discussions/2054, and I just wanted to ask a quick question to make sure I understand the problem in this issue. If I understand correctly, the WENO5 scheme calculates the advection with different advection schemes (all of which are correct regardless of the grid) and then does a weighted sum of these solutions according so some criterion. So the issue with WENO5 and StretchedGrids is not that the advection calculated is ""wrong"", it's just that the weighting of the solutions is done in a non-optimal manner, and therefore introduces errors that could be avoided, right?. Basically I'm asking the question: is it the case the shouldn't use WENO5 with stretched grids because the answer is wrong, period? Or we can use it, it's just not gonna be as accurate as it potentially could be?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-967303636:661,error,errors,661,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-967303636,1,['error'],['errors']
Availability,@glwagner Looks like it's just one of the checkpointer tests. They occasionally fail on the GPU. I think it's related to https://github.com/CliMA/Oceananigans.jl/issues/1179. I reran the build. Should hopefully pass now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780733376:42,checkpoint,checkpointer,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780733376,1,['checkpoint'],['checkpointer']
Availability,@glwagner The goal of shifting the system is to recover a positive definite matrix by adding \lambda to all eigenvalue of the problem.; The proposition of @Yixiao-Zhang is to do that by adding v_0 * v_0^T. `v_0 * v_0^T` is ONLY semi-positive definite so not all eigenvalues will be modified. But it should lead to a positive definite A + c * v_0 * v_0^T (rank-one updating) by only updating one eigenvalue (the 0 eigenvalue). I just don't understand why we will find the same solution because CG should return one solution among an infinity of solution (before the shift).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2415314678:48,recover,recover,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2415314678,1,['recover'],['recover']
Availability,"@glwagner When I run the example above, I get an error: Cannot `convert` an object of type FunctionField to an object of type Float64 from the line where you set the smagorinksy closure. ```; van_driest_damping = FunctionField{Center, Center, Center}(van_driest_damping_function, grid; parameters). smagorinsky_lilly = SmagorinskyLilly(vitd, C=van_driest_damping); ```; I also noticed that the new function SmagorinskyLilly you changed in smagorinksy_lilly.jl isn't in the file under ""main"". So is this error because the change hasn't been fully implemented yet?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1801735572:49,error,error,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370#issuecomment-1801735572,2,['error'],['error']
Availability,"@glwagner Will do. I'll remove the dynamics from my run and see if I can get a minimum not-working example. . @tomchor I've downloaded that branch and will test when I can. Our system seems to have forgotten it's got GPUs post power cut so it's CPU only for now, I assume the underlying save functions are the same between devices?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150538709:124,down,downloaded,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150538709,1,['down'],['downloaded']
Availability,"@glwagner Yes you are right. I tried restarting Julia, and it worked without the error message. Sorry!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386824056:81,error,error,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386824056,1,['error'],['error']
Availability,"@glwagner and @simone-silvestri, thank you for the clarification. Indeed, this does not happen with `--check-bounds=yes`, as shown below:; ```julia; julia> my_field[-2, :, :]; ERROR: BoundsError: attempt to access 6×7×8 OffsetArray(::Array{Float64, 3}, -1:4, -1:5, -1:6) with eltype Float64 with indices -1:4×-1:5×-1:6 at index [-2, OffsetArrays.IdOffsetRange(values=-1:5, indices=-1:5), OffsetArrays.IdOffsetRange(values=-1:6, indices=-1:6)]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] _getindex; @ ./multidimensional.jl:888 [inlined]; [4] getindex; @ ./abstractarray.jl:1291 [inlined]; [5] getindex(::Field{Center, Center, Center, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, ::Int64, ::Function, ::Function); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:408; [6] top-level scope; @ REPL[23]:1; Some type information was truncated. Use `show(err)` to see complete types.; julia> my_field[:, -2, :]; ERROR: BoundsError: attempt to access 6×7×8 OffsetArray(::Array{Float64, 3}, -1:4, -1:5, -1:6) with eltype Float64 with indices -1:4×-1:5×-1:6 at index [OffsetArrays.IdOffsetRange(values=-1:4, indices=-1:4), -2, OffsetArrays.IdOffsetRange(values=-1:6, indices=-1:6)]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Int64, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] _ge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2153291947:176,ERROR,ERROR,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2153291947,1,['ERROR'],['ERROR']
Availability,"@glwagner and I talked yesterday and here are some points that emerged (@glwagner feel free to chime in if I'm forgetting/misrepresenting something). We agreed that the important points in this PR are two. (1) We should export all directions/formulations (`ZDirection`, `XYDirections`, `ThreeDimensional` or whatever we end up calling them) at the top level, and (2) we shouldn't reintroduce a `Vertical` direction in `TurbulenceClosures` when there already exists a `ZDirection` defined in `Grids` that's used for buoyancy purposes. However, we need to agree on a notation. A few main options emerged from our talk:. ### Option 1. First option is we keep calling the directions `Vertical` and `Horizontal`, since those names are pretty intuitive and play well with already-defined terms like `VerticallyImplicit` (which are also intuitive and widely used in the literature). The downside to this option, if we were to follow (2), appears as an inconsistency whenever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:880,down,downside,880,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915,2,['down'],['downside']
Availability,"@glwagner can the failures here be rerun, the PR otherwise should be fine now",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3790#issuecomment-2377250462:18,failure,failures,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3790#issuecomment-2377250462,1,['failure'],['failures']
Availability,"@glwagner can you review this? The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})` and I'm not sure what already is expected to fail",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838:35,failure,failures,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838,1,['failure'],['failures']
Availability,@glwagner could you run the `zonally_averaged_channel.jl`? I get an error I can't interpret. The error seems to be related to; https://github.com/CliMA/Oceananigans.jl/blob/c99e3e8b285d080016b84abc7c46cdb57ad823c1/validation/mesoscale_turbulence/zonally_averaged_channel.jl#L238-L273; because when I comment them out simulation runs!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983330158:68,error,error,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983330158,2,['error'],['error']
Availability,@glwagner could you write up the equations solved by the `HydrostaticFreeSurfaceModel` somewhere in `docs/src/physics/hydrostatic_free_surface_model.md`? Just write down the eqs --- no need to format or anything. I'll deal with the rest.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1690#issuecomment-848435361:165,down,down,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1690#issuecomment-848435361,1,['down'],['down']
Availability,"@glwagner do you mind if I merge main here? I wanna re-run my simulations after https://github.com/CliMA/Oceananigans.jl/pull/2587 but also with this bugfix. I can also take a look at the tests that are failing and fix them so that we can merge this. On recent versions of Oceananigans with IBM some of the more complex abstract operations that used to compile (without IBM) are not compiling anymore for me and are instead throwing this error: `CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)`. So I'm pretty sure is what's happening here and we just have to simplify the abstract operations used here: https://github.com/CliMA/Oceananigans.jl/blob/525984e8d013517fb40fc9a374fa99b46544d9fd/test/test_computed_field.jl#L529-L534",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200:438,error,error,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200,4,['error'],['error']
Availability,"@glwagner for some reason your suggestion using tuples didn't work. I was getting a ""scalar indexing disallowed"" error on that same line, which was weird. So I changed it to an `@allowscalar` statement. It's also weird that the test I added (which supposedly tests both CPUs and GPUs) didn't catch that.... not sure why",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-954396122:113,error,error,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-954396122,1,['error'],['error']
Availability,"@glwagner if you're okay with this, I'm gonna merge this since tests are passing. Or you can merge it yourself. My rationale for merging right now is that this seems like a reasonably important bug that's being fixed and I have no idea what's causing the errors on the GPU. So maybe we can merge this and then open a second PR to deal with the GPU tests that are failing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1166183656:255,error,errors,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1166183656,1,['error'],['errors']
Availability,"@glwagner please help here... I can't even say `using Oceananigans`.... ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: UndefVarError: NFBC not defined; Stacktrace:; [1] top-level scope; @ ~/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; [2] include(mod::Module, _path::String); @ Base ./Base.jl:386; [3] include(x::String); @ Oceananigans.BoundaryConditions ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; [4] top-level scope; @ ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:45; [5] include(mod::Module, _path::String); @ Base ./Base.jl:386; [6] include(x::String); @ Oceananigans ~/Research/OC/src/Oceananigans.jl:1; [7] top-level scope; @ ~/Research/OC/src/Oceananigans.jl:173; [8] include; @ ./Base.jl:386 [inlined]; [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [10] top-level scope; @ none:1; [11] eval; @ ./boot.jl:360 [inlined]; [12] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [13] top-level scope; @ none:1; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; in expression starting at /Users/navid/Research/OC/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_fSB7qw.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334:183,ERROR,ERROR,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334,1,['ERROR'],['ERROR']
Availability,"@glwagner that sounds like a good strategy, ideally you would want to front-load the most useful tests for catching errors to the degree possible (the whole goal here is to reduce iteration time). If using Linux we can have up to 60 concurrent actions going so spawning as many as is useful for reducing the iteration time is the correct strategy (probably you could set this up as a job matrix for compactness). If spawning up a ton of github actions you can maximize concurrency by killing stale jobs (old push commits) as we do here: https://github.com/CliMA/ClimaCore.jl/blob/main/.github/workflows/Linux-UnitTests.yml#L24",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759:116,error,errors,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759,1,['error'],['errors']
Availability,@glwagner the CI error seems unrelated?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3799#issuecomment-2380638813:17,error,error,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3799#issuecomment-2380638813,1,['error'],['error']
Availability,@glwagner the Enzyme CI appears to pass here whereas failures appear unrelated.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1915012052:53,failure,failures,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1915012052,1,['failure'],['failures']
Availability,@glwagner the same error is returned whether I set the velocity or buoyancy tracer fields individually.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1117335654:19,error,error,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1117335654,1,['error'],['error']
Availability,"@glwagner the solution seems the same but two difference are that (1) `VectorInvariant` does not crash, (2) `WENOVectorInvariant` deviates from the pattern later. ; ; In this paper https://www.tandfonline.com/doi/pdf/10.3402/tellusa.v52i2.12258 they claim that : ""In the FV model, small departures from the flow pattern are triggered initially by grid related truncation errors but subsequently grow through the dynamical instability"" . I guess ""time-to-instability"" is itself a diagnostic of the performance of the scheme? . @francispoulin As implemented in (https://reader.elsevier.com/reader/sd/pii/S0021999105800166?token=A3A72AC493072CED8ECF098513A0BD1F822D2F2224207E533C86FB7D40361903E7AC0B4304841E64E089CBBFCEAFD08B&originRegion=us-east-1&originCreation=20220308154939) the cosine bell advection only tests the tracer advection, do you have any example of a test of that kind that tests momentum advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114:371,error,errors,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114,1,['error'],['errors']
Availability,"@glwagner this almost became stale but I think it's ready to review and possibly merge. It doesn't re-work the code like you suggest [here](https://github.com/CliMA/Oceananigans.jl/pull/2752/#issuecomment-1315578507), but it does make the functions more easily understandable on first pass by being more verbose. . It also changes the behavior of `viscosity()` and `diffusivity()`, which no longer sum over all individual closures by default when the closure is a tuple, avoiding user error (as you suggested [here](https://github.com/CliMA/Oceananigans.jl/pull/2752/#issuecomment-1273620776)). Finally it also changes the function `calc_κᶜᶜᶜ` ro `calc_nonlinear_κᶜᶜᶜ` in order to differentiate from `κᶜᶜᶜ`. Although I'm agnostic about the name and could change it to anything else. This PR used to also remove a fallback that was a bit problematic because it silently returned zero diffusivity values for closures like Smagorinsky, but it seems some other PR got around to that first before merging this one :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398498518:485,error,error,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398498518,1,['error'],['error']
Availability,"@glwagner this should reproduce the error. The message is thrown when calling `set(model,...)`. ```using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom, mask_immersed_field!. using Oceananigans.Architectures: device; using Oceananigans.Grids: xnode, znode; using KernelAbstractions: MultiEvent; using JLD2; using Printf; #using GLMakie; using SpecialFunctions. arch = GPU(); Nx = 256; Nz = 64 # Resolution; #Ny = 64; κ = 1e-6 # Diffusivity and viscosity (Prandtl = 1). underlying_grid = RectilinearGrid(arch,; size = (Nx, Nz),; x = (0, 5),; z = (-0.05, 1.0),; halo = (3, 3),; topology = (Bounded, Flat, Bounded)). #const gamx = 2.0; #const gamy = 20.0. @inline bottom_topography(x,y) = 0.0;#*exp.(-gamy*y.^2); grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom_topography)). no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(bottom=no_slip, immersed=no_slip); w_bcs = FieldBoundaryConditions(immersed=no_slip); boundary_conditions = (; u = u_bcs, w = w_bcs). model = NonhydrostaticModel(grid = grid,; advection = WENO5(),; boundary_conditions = boundary_conditions,; closure = ScalarDiffusivity(ν=κ,κ=κ),; coriolis = nothing,; tracers = :b,; buoyancy = BuoyancyTracer()). b₀(x,y, z) =0.5*(erf.((x.-1.0)*10).-1.0); set!(model, u = 0.0, b = b₀)```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111858087:36,error,error,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111858087,1,['error'],['error']
Availability,"@glwagner yes, that was more along the lines of what I was saying. From the docs it seemed to me using a Gaussian mask in the relaxation should be equivalent to a sponge layer, which is why I expected the gaussian function to be set-up with a sharp cut-off. But I think we're on the same page about what a sponge layer should be. . So I think it may be a matter of maybe making the docs clearer? Maybe also, like you said, constructing an example that uses sponge layers (I think there's an issue about there somewhere, right?). The Langmuir example might a good one. In the original paper by Jim they use a radiation boundary condition at the bottom which doesn't have an analog in the Langmuir example at the moment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733365742:114,mask,mask,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733365742,1,['mask'],['mask']
Availability,"@glwagner, I got rid of this ```UnderVarError``` but now I am facing ```domain error``` while applying Chebyshev spacing in z.; But at the same time, when I apply any linear profile, It works. linear function like -``` (2k-1/2Nz)```; . I get the error message after applying the set() function.- . ```. julia> # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ); ERROR: TaskFailedException:; DomainError with -1.1554673348527535e-7:; Exponentiation yielding a complex result requires a complex argument.; Replace x^y with (x+0im)^y, Complex(x)^y, or similar.; ```; If we see the error message, it says to replace x^y, but there is no arithmetic like that in my code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-818569992:79,error,error,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-818569992,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"@glwagner, I think you're right that the error is coming from this line:; https://github.com/CliMA/Oceananigans.jl/blob/10a9479ec462f4f5f053e7447ff667fdfe20542d/src/Distributed/distributed_fft_based_poisson_solver.jl#L65; I checked the sizes of these variables, and here xc is sized on the global grid while lambda x is sized on the local grid. I'm not sure which grid this operation is intended to be performed on. The code here is impressively compact but not particularly easy to decipher (at least for me).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658:41,error,error,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658,1,['error'],['error']
Availability,"@glwagner, I tried to add a test but look,. ```Julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1)); 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.5; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.5. julia> Fu = ones(size(grid)); 2×2×2 Array{Float64, 3}:; [:, :, 1] =; 1.0 1.0; 1.0 1.0. [:, :, 2] =; 1.0 1.0; 1.0 1.0. julia> model = NonhydrostaticModel(; grid, forcing=(u=Fu,)); ERROR: TaskFailedException. nested task error: MethodError: objects of type Array{Float64, 3} are not callable; Use square brackets [] for indexing an Array.; Stacktrace:; [1] u_velocity_tendency; @ ~/Research/OC10.jl/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:71 [inlined]; [2] cpu_compute_Gu!; @ ~/.julia/packages/KernelAbstractions/Zcyra/src/macros.jl:287 [inlined]; [3] cpu_compute_Gu!(__ctx__::KernelAbstractions.CompilerMetadata{…}, Gu::Field{…}, grid::RectilinearGrid{…}, interior_map::Nothing, args::Tuple{…}); @ Oceananigans.Models.NonhydrostaticModels ./none:0; [4] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/Zcyra/src/cpu.jl:115; [5] (::KernelAbstractions.var""#18#21""{…})(); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/Zcyra/src/cpu.jl:90. ...and 1 more exception. Stacktrace:; [1] sync_end(c::Channel{Any}); @ Base ./task.jl:448; [2] macro expansion; @ ./task.jl:480 [inlined]; [3] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1983444380:583,ERROR,ERROR,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1983444380,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"@glwagner, after 9c10cb5 tests break. See https://buildkite.com/clima/oceananigans/builds/4750#6ef5a18e-4db4-4881-aabe-e39eafaf2196/40-312. I thought that the mistake was because I had prescribed `Value` bc's for u at East/West. But the errors persists after I [changed](https://github.com/CliMA/Oceananigans.jl/pull/2103/commits/842861f152fa4193a8fb75d58324e209d5f124e5) that to Open. Could you have a look at:; https://github.com/CliMA/Oceananigans.jl/blob/d6deb950cdcd489ceb872568663ecf5b2c8ccb2a/test/test_boundary_conditions_integration.jl#L213-L226",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989314987:237,error,errors,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989314987,1,['error'],['errors']
Availability,"@glwagner, give us a couple of more days to figure sort this out. I'm not so sure that we need a fundamental redesign, but I think that should be revisited when we decide to take on the more challenging issue of checkpointing partially-accumulated time-averages so that `windowed_time_average` always works as intended when picking up from checkpoints.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379756292:212,checkpoint,checkpointing,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379756292,2,['checkpoint'],"['checkpointing', 'checkpoints']"
Availability,"@glwagner, how can we avoid `collect`? E.g., at. https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130. I tried `arch_array` but seems like we need to write some more methods for it?. ```julia; julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[6]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. julia> r_array = arch_array(arch, interior(r)); ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[7]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827:357,ERROR,ERROR,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827,2,['ERROR'],['ERROR']
Availability,"@glwagner, regarding the error with the simulations with multiple Coriolises:; seems like adding a `@show ""hi""` *before* the `@apply_regionally correct_velocities_and_store_tendecies!(model, Δt)` in. https://github.com/CliMA/Oceananigans.jl/blob/b1997713b35f41b42a1f5cc5660d6ceb2ec3e305/src/TimeSteppers/quasi_adams_bashforth_2.jl#L95-L97. makes the error go away. Does this give a hint for what might be causing it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298018536:25,error,error,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298018536,2,['error'],['error']
Availability,"@glwagner, regarding the; ```Julia; ERROR: LoadError: UndefVarError: bc not defined; ```; in the Docs, is it related to; https://github.com/JuliaDocs/Documenter.jl/issues/228; perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879623792:36,ERROR,ERROR,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879623792,1,['ERROR'],['ERROR']
Availability,"@glwagner:; > I'm still not sure we want to analytically integrate one of the pressure gradient terms `h dx(h) = dx(h^2/2)` but leave the other unchanged. If we treat them both similarly then we would write the pressure gradient term; > ; > ```; > -g h * ∂ₓ(h + b); > ```; > ; > It might be worth testing both possibilities to see if one has favorable numerical properties?; > ; > Perhaps this is related to the whole issue re: well-balanced methods, etc... ?. @francispoulin:; > I agree with @glwagner . Currently, `ShallowWaterModel` separates out the advection terms and the pressure term, which makes sense since they are inherently different.; > ; > One issue is that since we are using a finite volume method, the above term presents a bit of a problem as it's not in divergence form However, even in the other formulation, as you can see from the paper cited above, we still end up getting a term that is not in divergence form, `h dh_B/dx`.; > ; > I support trying @glwagner 's proposal of keeping the pressure term as he wrote it above. So it seems the best way forward for implementing bathymetry is to do it in the non-conservative form of the equations after #2522 is merged. Do we then want to have the conservative form of `ShallowWaterModel` be available only for `bathymetry == nothing`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1120402030:1260,avail,available,1260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1120402030,1,['avail'],['available']
Availability,"@hennyg888 etc.. - this looks great. If we can get some scripts together then we can start automating some of this so we can see how things change, as well as tracking down anomalies. . CUDA.jl has a chart ( https://speed.juliagpu.org/changes/?exe=6&env=1&tre=50 ) that shows timing trends for different bits of the system. Not sure how they generate this!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890029727:168,down,down,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890029727,1,['down'],['down']
Availability,"@hennyg888 thanks posting this. a few thoughts - . I assume what @hennyg888 is running is based on this https://github.com/christophernhill/onan-jcon2021-bits/blob/main/run/satori/run-on-bench-on-rhel7-satori-with-mpi ? . There are quite a few things to double (triple) check. 1. **are you running on multiple GPUs?** ; There is some obscure foo for that here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is not in Oceananigans or ImplicitGlobal as downloaded. Its not really particularly documented anywhere either (except in a blog post for this https://github.com/NVIDIA-developer-blog/code-samples/blob/master/posts/cuda-aware-mpi-example/src/CUDA_Aware_MPI.c as far as I can tell)! Without this bit you may end up running all ranks on the same GPU. The blog post here https://developer.nvidia.com/blog/benchmarking-cuda-aware-mpi/ gives a bit of background. . 2. **is there anything else running on the node when you test?** ; When I looked earlier in the week satori had become annoyingly busy. You need to request an exclusive node - and then wait unfortunately because of every else using. If you skip asking for exclusive you may end up sharing node - which is OK for getting work done, but confusing for benchmarking. . 3. **as @vchuravy mentions you may or may not be using messaging that goes direct GPU to GPU?** ; There is an issue with recent CUDA.jl that makes that hard (possibly not even possible). We are working to resolve that. @vchuravy has a suggested fix, but I found that caused other problems. The ImplicitGlobal team found @vchuravy fix to work, but with a very recent version of CUDA.jl where I think it isn't supposed to work - so they may have been mistaken. I was planning to look at this a bit more after having coffee with a Nvidia colleague who is involved in all this tomorrow. . The ImplciitGlobalGris stuff should get reasonable behavior with the `selec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885334231:560,down,downloaded,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885334231,1,['down'],['downloaded']
Availability,"@iuryt you're right, the environment here is really amazing! . I will think and write down some FV discretisation equations by the time we zoom in. I'm not the best person to talk on how we should implement it in Oceananigans in terms of using z-coordinate as different levels, but it seems like a great and innovative idea. . Perhaps I'm asking a silly question but it's not clear to me that the equations I've written up (and I'll double check this with someone else too) seems to consider varying bathymetry, and I'm not sure if Oceananigans explicitly models bathymetry by adding a pressure gradient, and whether we would be double counting the effects of bathymetry using the equations I shared above. I agree with @francispoulin, maybe it doesn't matter much whether we use density or buoyancy as our vertical coordinate. I do like the idea of using buoyancy instead of density, but that's just a personal preference.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117301031:86,down,down,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117301031,2,['down'],['down']
Availability,@jatkinson1000 sorry for the delay. I'm trying to download the datasets mentioned on the [original xgcm sgrid issue](https://github.com/xgcm/xgcm/issues/109) (namely the ones mentioned [here](https://github.com/xgcm/xgcm/issues/109#issuecomment-408855581) and [here](https://github.com/xgcm/xgcm/issues/109#issuecomment-408858235)) but I'm getting errors. Could you please dig some files out and either attach them here (I think you may need to zip them first) or email them to me? You can find my email through my personal website.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1533516695:50,down,download,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1533516695,2,"['down', 'error']","['download', 'errors']"
Availability,"@jm-c suggested the following changes that might improve `Float32` precision for simulations with 100,000+ iterations. > Regarding issue with float32 precision: I looked to the code and; > I can see few things that would be easy to change and could make some difference; > regarding this precision issue:; > 1) Temp in Celcius instead of Kelvin (but this is probably not a big problem); > 2) recompute W from continuity instead of stepping forward W using: G_w - d.PNH/dz; > 3) apply pressure solver on provisional solution:; > with RHS = Div(u*,v*,w*) with u* = U + DeltaT * Gu (same for v*,w*); > instead of on tendencies with RHS = Div.(Gu,Gv,Gw); > ; > The problem with the way (2) is currently done is that the error in continuity equation; > are larger ; And with the way we currently do (3), these error can accumulate with time.; > Finally, with T in Kelvin, error in continuity equation can produce larger error in; > temperature.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/161:716,error,error,716,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/161,4,['error'],['error']
Availability,"@jm-c was right about Smagorinsky requiring a larger halo size than the rest of the code. Running `test_smag_divflux_finiteness(T)` causes a `BoundsError` when trying to access index `-1` which suggests we need halos of at least size 2. We do support halos of arbitrary size in all three directions so it would be easy to increase the size of the halos if Smagorinsky is used as a closure. Just wanted to open this issue to see if this is what we wanted to do. For now I'm skipping the test so it's showing up as broken. ```julia; Constant Smagorinsky: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:466; Test threw exception; Expression: test_smag_divflux_finiteness(T); BoundsError: attempt to access OffsetArray(::Array{Float32,3}, 0:4, 0:4, 1:3) with eltype Float32 with indices 0:4×0:4×1:3 at index [3, -1, 2]; Stacktrace:; [1] throw_boundserror(::OffsetArray{Float32,3,Array{Float32,3}}, ::Tuple{Int64,Int64,Int64}) at ./abstractarray.jl:484; [2] checkbounds at ./abstractarray.jl:449 [inlined]; [3] getindex at /home/alir/.julia/packages/OffsetArrays/ruvC7/src/OffsetArrays.jl:130 [inlined]; [4] ∂y_afa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:8 [inlined]; [5] ∂y_u(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:14; [6] Σ₁₂ at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:33 [inlined]; [7] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:44 [inlined]; [8] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:80 [inlined]; [9] ▶x_caa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:191 [inlined]; [10] ▶y_aca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:217 [inlined]; [11] ▶xy_cca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:275 [inlined]; [12] ΣᵢⱼΣᵢⱼ_ccc at /home/alir/Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/260:553,Error,Error,553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260,1,['Error'],['Error']
Availability,"@johncmarshall54 agreed, that's a challenge we have to confront. If we implement immersed boundaries using the ""continuous forcing technique"", then a boundary may be defined essentially by a masking function of `(x, y, z)` (it is also possible for it to be a function of time). In this case, we might be able to ""label"" each boundary / masking function with a name or number. The boundary condition objects we then give to fields would have to define a condition to be applied both at the boundaries of the numerical grid (which we currently support), as well as any immersed boundaries, where immersed boundaries are referenced by name or number. By the way, if we use a continuous forcing technique, we do not have to change the pressure solver. This is a major simplification. Recent work suggests there is no disadvantage in terms of accuracy in using the continuous forcing technique over discrete forcing techniques (which I think is the category the MITgcm solver falls under). I'm not sure if this is too good to believe or not --- we should discuss and take a deeper look at the literature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605461456:191,mask,masking,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605461456,2,['mask'],['masking']
Availability,@liuchihl Have you tried running on the CPU to see if you get a more useful error message?. I think; ```; Reason: unsupported call to an unknown function (call to jl_f_getfield); ```; could just be the result of a typo in an expression like `a.b`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429559746:76,error,error,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429559746,1,['error'],['error']
Availability,"@liuchihl I think the best way forward is to write a simple test that illustrates the error. Then I can help fix the error to make the test pass. Once that is done, we may be ready to merge this PR. What do you think?. PS it is always best to work with minimal examples, and to paste code directly into a discussion stream (rather than providing links). This will help us keep up an efficient workflow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433044270:86,error,error,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433044270,4,['error'],['error']
Availability,"@liuchihl, can you explain a bit more your caveat about the new method only passing the test if the timestep is small enough? With the new method, the windowed-time-averages still look good by eye but quantitatively the errors are larger than the default relative tolerance of 1e-5, right? That seems it would still be an improvement over spurious zeros that sometimes show up with the previous method?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379299790:220,error,errors,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379299790,2,"['error', 'toler']","['errors', 'tolerance']"
Availability,"@liuchihl, did you find any cases where the `windowed_time_average` in this PR fails the test with `window_nΔt == interval_nΔt`? Maybe we have an indexing error when we are waiting for the window to start and we actually average over slightly the wrong period? It also would be good to confirm that the problem is with `windowed_time_average`, and not with the analytical solution that we're comparing to!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2378120645:155,error,error,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2378120645,1,['error'],['error']
Availability,"@liuchihl, thanks for cleaning up these changes by separating them from the [background flux PR](https://github.com/CliMA/Oceananigans.jl/pull/3646)—it's much clearer now. Consolidating @glwagner and @navidcy's earlier comments, it seems there are three things that need to be done before this can be merged:; 1) Review the [the existing OutputWriter tests](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_output_writers.jl) and verify that they still pass with the new implementation in this PR; 2) Create a new, more rigorous, test that is capable of flagging the bizarre behavior you found in [your issue](https://github.com/CliMA/Oceananigans.jl/issues/3670) but (hopefully) now passes thanks to the changes in this branch.; 3) Add some warnings to let users know that `TimeInterval` and `AveragedTimeInterval` (and probably other diagnostic schedules) are currently broken and give incorrect results after picking up from a checkpoint whenever the checkpoint interval is not an integer multiple of the scheduled time interval.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2302951223:942,checkpoint,checkpoint,942,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2302951223,4,['checkpoint'],['checkpoint']
Availability,"@m3azevedo and me are doing a simulation of an unstable baroclinic jet in the context of the Nonhydrostatic model and having some success but some difficulties as well. We have tried two different approaches: . Method 1: define the jet and stratification to be part of the background field and evolve the perturbations. Method 2: define the jet and stratification as part of the initial conditons and evolve the total field. These are mathematically equivalent and should both yield the same results, but we are finding a difference and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = U",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251:813,error,errors,813,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251,1,['error'],['errors']
Availability,@maeckha I can reproduce your error when calling `simulate_lid_driven_cavity()`. I feel that this validation experiment was done with an older version of Oceananigans compared to the v0.53.0 are running and some things are deprecated. @ali-ramadhan might comment more on that perhaps. But the thermal bubble example from the Readme (just copy paste the code from there) runs just fine! Do you get an error with that also?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807466260:30,error,error,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807466260,2,['error'],['error']
Availability,@maleadt . CUBLAS error (for `cublasDnrm2_v2`) in https://buildkite.com/clima/oceananigans/builds/9877#018622f8-7cb1-4d4a-b58b-9e12aec6c441. Might be https://github.com/JuliaGPU/CUDA.jl/issues/1755#issuecomment-1417166636,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2902#issuecomment-1418248505:18,error,error,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2902#issuecomment-1418248505,1,['error'],['error']
Availability,"@maleadt we are seeing a couple odd errors here:. ```; /net/ocean/home/data44/data5/glwagner/julia-1.8.5/bin/julia: relocation error: /data5/glwagner/.julia-10861/artifacts/ebadc1bf983003ca3f714f062af4451365761171/lib/libcublas.so: symbol cublasLt_for_cublas_DDD version libcublasLt.so.11 not defined in file libcublasLt.so.11 with link time reference; ```. and. ```; Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_models.jl:197; Test threw exception; Expression: time_step_hydrostatic_model_works(grid; free_surface); CUBLASError: the GPU program failed to execute (code 13, CUBLAS_STATUS_EXECUTION_FAILED); Stacktrace:; [1] throw_api_error(res::CUDA.CUBLAS.cublasStatus_t); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:11; [2] macro expansion; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:24 [inlined]; [3] cublasDnrm2_v2(handle::Ptr{CUDA.CUBLAS.cublasContext}, n::Int64, x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, incx::Int64, result::Base.RefValue{Float64}); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/utils/call.jl:26; [4] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:168 [inlined]; [5] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:173 [inlined]; [6] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:108 [inlined]; [7] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:107 [inlined]; [8] cg_iterator!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Pl::Oceananigans.Solvers.SparseInversePreconditioner{CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}}; abstol::Float64, reltol::Float64, maxiter::Int64, statevars::IterativeSolvers.CGStateVariables{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, initially_zero::Bool); @ IterativeSolvers ~/.julia-10861/packages/I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526:36,error,errors,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526,3,"['Error', 'error']","['Error', 'error', 'errors']"
Availability,"@michel2323 @vchuravy this looks like an error in KA indexing, which I recall you guys resolved previously? [and @glwagner there was that weird offset issue before iirc]. ```julia. Enzyme on advection and diffusion: Error During Test at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/test/test_enzyme.jl:93; --;   | Got exception outside of a @test;   | BoundsError: attempt to access 16×16×1 Array{Tuple{Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{UInt64, 0}}, 3} at index [1, 1, 2];   | Stacktrace:;   | [1] setindex!;   | @ ./array.jl:971 [inlined];   | [2] setindex!;   | @ ./multidimensional.jl:670 [inlined];   | [3] aug_fwd;   | @ /storage5/buildkite-agent/.julia-14477/packages/KernelAbstractions/WoCk1/ext/EnzymeExt.jl:20 [inlined];   | [4] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(64, 64, 8)}, typeof(EnzymeExt.aug_fwd)}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(4, 4, 8)}, KernelAbstractions.NDIte",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929:41,error,error,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929,2,"['Error', 'error']","['Error', 'error']"
Availability,"@miguelraz my two cents are that I think this is certainly feasible. I think the first step is to write up some kind of document (can you use latex?) that outlines the problem(s) you would like to solve. This is the biggest barrier. The spin-down problem is probably the simplest. I think thermal wind should also be possible, but I would use a simpler profile than in #179 with sines and cosines rather than Gaussians. . Another fun problem would be the propagation of an internal wave (or some shape), which is simpler than baroclinic instability (which requires you to solve an eigenvalue problem for some assumed initial condition --- because our domain is periodic, this may be slightly non-trivial). The most difficult problem suggested in this post is probably the saturated Rayleigh-Benard solutions. Once the problems and their solutions are written out and well-defined, it should not be too difficult to implement them in Oceananigans (especially if we lend a helping hand). I'm happy to help with the internal wave example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/157#issuecomment-489888890:242,down,down,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/157#issuecomment-489888890,1,['down'],['down']
Availability,@mukund-gupta Maybe try this branch to see if it fixes the issue you encountered with this error: https://buildkite.com/clima/oceananigans/builds/1947#b5157111-6448-4db8-bc8b-8a777f85001a/19-300,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1561#issuecomment-816263736:91,error,error,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1561#issuecomment-816263736,1,['error'],['error']
Availability,"@mukund-gupta reported the following error:. ```; [ Info: Oceananigans will use 16 threads; [ Info: Starting the simulation...; [ Info: i: 0010, t: 1.667 minutes, Δt: 10 seconds; ERROR: LoadError: MethodError: no method matching isless(::typeof(depth_dependent_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1104:37,error,error,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"@navidcy . I am copying my output below and I believe it does throw `AssertionError`. Maybe you can try it locally and see if you get the same thing?. ```; julia> ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; [2022/06/01 18:12:45.154] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; [2022/06/01 18:12:45.155] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; ERROR: AssertionError: ShallowWaterModel requires `topology(grid, 3) === Flat`. Use `topology = (Periodic, Periodic, Flat)` when constructing `grid`.; Stacktrace:; [1] ShallowWaterModel(; grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, gravitational_acceleration::Int64, clock::Clock{Float64}, momentum_advection::UpwindBiasedFifthOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, mass_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, coriolis::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, bathymetry::Nothing, tracers::Tuple{}, diffusivity_fields::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, timestepper::Symbol, formulation::Oceananigans.Models.ShallowWaterModels.ConservativeFormulation); @ Oceananigans.Models.ShallowWaterModels ~/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:121; [2] ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500:664,ERROR,ERROR,664,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500,1,['ERROR'],['ERROR']
Availability,"@navidcy @glwagner this should superceded all previous enzyme prs (including compatbwlper), which I've gone ahead and closed just now. Some non enzyme tests had a nondeterministic ci failure about a directory not being empty, but otherwise all pass (incl enzyme tests). Once landed we should add a lot more integration test cases like @jlk9 your flux boundary",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3618#issuecomment-2195453317:183,failure,failure,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3618#issuecomment-2195453317,1,['failure'],['failure']
Availability,"@navidcy Ah sorry about that error, it was fixed in PR #1552. I merged `master` into this branch which should fix the unit tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817873104:29,error,error,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817873104,1,['error'],['error']
Availability,"@navidcy I think @waywardpidgeon is saying that `run!(simulation)` succeeds, but the plotting afterwards does not... We may want to make some comment about clean environments somewhere. Or, make this process more robust",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1922694548:213,robust,robust,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1922694548,1,['robust'],['robust']
Availability,"@navidcy I'm trying to add a drag flux to this example like we talked about in https://github.com/CliMA/Oceananigans.jl/issues/3148 but I'm getting an error that I can't figure out. Using `u` as an example, I'm trying to implement the BCs as . ```julia; @inline u_drag(x, y, t, u, v, w, p) = - p.cᵈ * u * √(u^2 + v^2 + w^2); @inline u_drag(x, y, z, t, u, v, w, cᵈ) = u_drag(x, y, t, u, v, w, cᵈ). u_drag_bc = FluxBoundaryCondition(u_drag, field_dependencies=(:u, :v, :w), parameters=(; cᵈ=1e-3)); boundary_conditions = (u = FieldBoundaryConditions(bottom=u_drag_bc),); ```. but when time-stepping the model I get. ```; ERROR: LoadError: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ::NamedTuple{(:u, :v, :w, :b, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.Cent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1667152069:151,error,error,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1667152069,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"@navidcy PyPlot is used for the log2 scale for the x-axis of certain graphs. The normal backend of Plots,jl only has natural log scale axis option. Log-base-2 scale works best for these plots since most of them have an independent variable that scales based on powers of 2. The inclusion of Oceananigans in `benchmark/Project.toml` is likely due to a Julia package config suggested by @ali-ramadhan. What was done was that in Julia's package manager, `dev ..` was inputted to enable what I assume is the dev version of the Oceananigans package folder. Before this was done, there were numerous output errors with the benchmark scripts, and doing so fixes them all.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-864599629:601,error,errors,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-864599629,1,['error'],['errors']
Availability,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:911,checkpoint,checkpointing,911,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050,10,['checkpoint'],"['checkpoint', 'checkpointed', 'checkpointing']"
Availability,@navidcy any idea what the documenter error is?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3627#issuecomment-2245965525:38,error,error,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3627#issuecomment-2245965525,1,['error'],['error']
Availability,"@navidcy if halos are too small then the code often NaNs or seg faults. The issue here is that we auto adjust halos in the model constructor:. https://github.com/CliMA/Oceananigans.jl/blob/ebd7858000c78f7b1754112a68c587e6195e620b/src/Models/IncompressibleModels/incompressible_model.jl#L111-L112. this means that with a higher-order advection scheme, `model.grid` ends up being different from what the user passes into the constructor. This is a usability issue, because it means that `VelocityFields(arch, grid)` built before the `model` is wrong for the default grid in common scenarios with high-order advection. Thus if users want to build `VelocityFields(arch, grid)` before building a `model`, they need to know about halos. We think this is undesirable. Neatly summed the issue is mainly that we probably can't rely exclusively on the model constructor to infer halo sizes, because the grid is a crucial object that often needs to have correct halo sizes before the model is constructed. Thus we need another solution to this usability issue. I'm proposing that we make the default halos large enough to accommodate almost all use cases to solve this problem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-744385156:64,fault,faults,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-744385156,2,['fault'],['faults']
Availability,"@navidcy is a tease! The ""other repo"" is https://github.com/CliMA/ClimaOcean.jl. That's where we plan to build out the features needed for high-quality realistic simulations, eg interpolating bathymetry from one grid to another, ""recipes for realism"" such as parameterization and boundary condition choices. There's already a tool there for downloading some repeat-year forcing JRA55 data; we still need to build a tool for the entire dataset, and also tools for restricting to some region, etc. The vision in the end though is to get as close as possible to ""one click regional modeling"" as we can. @navidcy is right that the tools are not so useful now unless you want to get into the weeds. But if you want to help, it's greatly appreciated. Feedback on issues or wishlist features could also be fun to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733:341,down,downloading,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733,1,['down'],['downloading']
Availability,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:547,error,error,547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['error'],['error']
Availability,"@navidcy it's probably related to this:. https://github.com/CliMA/Oceananigans.jl/blob/22c3aafd4aa9b5812c24dd060a4f4ab57d113a3a/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L55-L67. where we use a special ""xy"" function for the free surface. When that `if` statement fails, we call the wrong `mask_immersed_field`. Probably that code can be improved so that it's more robust, or to throw a more obvious error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1997645278:409,robust,robust,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1997645278,2,"['error', 'robust']","['error', 'robust']"
Availability,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59:673,down,down,673,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59,2,"['degraded', 'down']","['degraded', 'down']"
Availability,@peterahrens suggested that instead of having `@inbounds` and `@inline` everywhere in [ops_regular_cartesian_grid_elementwise.jl](https://github.com/ali-ramadhan/Oceananigans.jl/blob/master/src/operators/ops_regular_cartesian_grid_elementwise.jl) we can use a `@inbounds begin` and it should propagate all the way down unless we explicitly use `@boundscheck`. See: [Julia Docs: Propagating inbounds](https://docs.julialang.org/en/v1/devdocs/boundscheck/index.html#Propagating-inbounds-1),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/58:314,down,down,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/58,1,['down'],['down']
Availability,"@raphaelouillon reported this error when running `examples/langmuir_turbulence.jl` using julia 1.4.1:. ```julia; [ Info: i: 0100, t: 8.333 min, Δt: 5.000 s, umax = (7.7e-02, 2.4e-02, 2.0e-02) ms⁻¹, wall time: 11.796 s; [ Info: i: 0200, t: 17.500 min, Δt: 5.500 s, umax = (8.3e-02, 2.9e-02, 1.7e-02) ms⁻¹, wall time: 14.838 s; [ Info: i: 0300, t: 27.583 min, Δt: 6.050 s, umax = (8.7e-02, 3.4e-02, 1.6e-02) ms⁻¹, wall time: 17.098 s; [ Info: i: 0400, t: 38.675 min, Δt: 6.655 s, umax = (8.5e-02, 4.2e-02, 2.0e-02) ms⁻¹, wall time: 19.350 s; [ Info: i: 0500, t: 50.876 min, Δt: 7.321 s, umax = (9.9e-02, 4.4e-02, 2.1e-02) ms⁻¹, wall time: 21.588 s; [ Info: i: 0600, t: 1.072 hr, Δt: 8.053 s, umax = (9.1e-02, 5.3e-02, 2.2e-02) ms⁻¹, wall time: 23.869 s; [ Info: i: 0700, t: 1.315 hr, Δt: 8.773 s, umax = (9.5e-02, 5.9e-02, 2.5e-02) ms⁻¹, wall time: 26.116 s; [ Info: i: 0800, t: 1.548 hr, Δt: 8.392 s, umax = (9.3e-02, 6.6e-02, 2.6e-02) ms⁻¹, wall time: 28.362 s; [ Info: i: 0900, t: 1.787 hr, Δt: 8.595 s, umax = (9.6e-02, 6.7e-02, 2.5e-02) ms⁻¹, wall time: 30.612 s; [ Info: i: 1000, t: 2.019 hr, Δt: 8.331 s, umax = (9.4e-02, 6.3e-02, 2.2e-02) ms⁻¹, wall time: 32.931 s; [ Info: i: 1100, t: 2.255 hr, Δt: 8.515 s, umax = (9.6e-02, 6.8e-02, 2.7e-02) ms⁻¹, wall time: 35.212 s; [ Info: i: 1200, t: 2.486 hr, Δt: 8.321 s, umax = (9.5e-02, 7.3e-02, 2.7e-02) ms⁻¹, wall time: 37.449 s; [ Info: i: 1300, t: 2.721 hr, Δt: 8.455 s, umax = (9.3e-02, 7.7e-02, 2.2e-02) ms⁻¹, wall time: 39.705 s; [ Info: i: 1400, t: 2.960 hr, Δt: 8.615 s, umax = (9.1e-02, 8.8e-02, 3.3e-02) ms⁻¹, wall time: 42.052 s; ^P[ Info: i: 1500, t: 3.206 hr, Δt: 8.826 s, umax = (8.9e-02, 9.0e-02, 2.8e-02) ms⁻¹, wall time: 44.425 s; [ Info: i: 1600, t: 3.452 hr, Δt: 8.888 s, umax = (9.2e-02, 8.9e-02, 2.3e-02) ms⁻¹, wall time: 46.877 s; [ Info: i: 1700, t: 3.695 hr, Δt: 8.730 s, umax = (8.6e-02, 9.0e-02, 2.5e-02) ms⁻¹, wall time: 49.291 s; [ Info: i: 1800, t: 3.943 hr, Δt: 8.922 s, umax = (9.2e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall tim",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/787:30,error,error,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787,1,['error'],['error']
Availability,@sangeethasankar01 if you post the whole error message that you get with the stack trace we will understand more which line triggered this error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2018666356:41,error,error,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2018666356,2,['error'],['error']
Availability,"@siddharthabishnu could you help by adding some simple unit tests for views of views? It'd be nice to test correctness, I think something like this would work:. ```julia; grid = RectilinearGrid(size=(1, 1, 3), x=(0, 1), y=(0, 1), z=(0, 1)); c = CenterField(grid); set!(c, (x, y, z) -> rand()). # First test that regular view is right; cv = view(c, :, :, 2:3); @test c[1, 1, 2] == cv[1, 1, 2]; @test c[1, 1, 3] == cv[1, 1, 3]. # Now test views of views; cvv = view(cv, :, :, 3); @test cv[1, 1, 3] == cvv[1, 1, 3]; ```. We may also want to test that things error correctly like. ```julia; julia> view(cv, :, :, 1); ERROR: ArgumentError: view indices (Colon(), Colon(), 1) do not intersect field indices (Colon(), Colon(), 2:3); Stacktrace:; [1] view(f::Field{…}, i::Function, j::Function, k::Int64); @ Oceananigans.Fields ~/Projects/dev/Oceananigans.jl/src/Fields/field.jl:315; [2] top-level scope; @ REPL[25]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Maybe. ```julia; @test_throws ArgumentError view(cv, :, :, 1); ```. Not sure what else we might want maybe @navidcy has ideas.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091009630:555,error,error,555,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091009630,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,@siddharthabishnu there are errors on the tests on GPUs:. https://buildkite.com/clima/oceananigans/builds/15275#018e8708-1af0-41a5-9a4a-e9d5e2bc223c/24-757,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2027413614:28,error,errors,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2027413614,1,['error'],['errors']
Availability,@siddharthabishnu this remark is relevant:. https://github.com/CliMA/Oceananigans.jl/blob/7e411f63c4f763ef79cc1464dbaf66e34bde72f4/src/Fields/field.jl#L704-L720. since the error you came across comes from filling the halo region of the free surface which _is_ actually a field with non-trivial indices.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743107148:172,error,error,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743107148,1,['error'],['error']
Availability,"@simonbyrne do you have any advice for how to avoid these annoying round-off errors? Basically I'm wondering if theres a robust way to get. ```; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ```. here we are given the length of the domain (2pi), but then we have to construct a range of nodes which extends _left_ of 0, so that it includes our halo region. The problem is when we do that, the first face (which is then something like `range[4]` if we have 3 halo points) has round-off error (or at least that's how I'm interpreting it... maybe there's no way around it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017:77,error,errors,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017,3,"['error', 'robust']","['error', 'errors', 'robust']"
Availability,"@simone-silvestri , thanks to your help I am now able to print out the norms of the perturbation buoyancy in the case when we evolve the total fields. The error that arises in this case, but not when we evolve the perturbation fields, decreases quadratically with increasing resolution. I could pick a resolution where this is small but in the first hour the norm or buoyancy grows by three orders of magnitude, which looks like an instability. It is not noisy and very well resolved, it can't be a baroclinic instability and does not look anything like an inertial instability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762:155,error,error,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762,1,['error'],['error']
Availability,"@simone-silvestri : Good news is that it is running with `Δt = 10seconds`. It's taking some time but still stable after 6 hours. I am tryinig to look at the data set to see what's going on but I am having some trouble. After `using NCDatasets` I try reading it and get the following error. Is this because it's writing at the same time and I can't open it until the file is closed? Or is there something else going on here. ```; julia> ds = NCDataset(""near_global_lat_lon_1440_600__fine_surface.jld2"", ""r""); ERROR: NetCDF error: Opening path near_global_lat_lon_1440_600__fine_surface.jld2: NetCDF: HDF error (NetCDF error code: -101); Stacktrace:; [1] nc_open(path::String, mode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:273; [2] NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, attrib::Vector{Any}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/dataset.jl:187; [3] NCDataset(filename::String, mode::String); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/dataset.jl:157; [4] top-level scope; @ REPL[5]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/Uurn4/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126245147:283,error,error,283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126245147,5,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"@simone-silvestri : I looked at the errors and both of them seem to be due to a version problem. Any idea what the problem could be?. ```; ERROR: The manifest file you are using was most likely generated by a different version of Julia and is not compatible with this Julia version; ```. Also, I looked at what the viscosity terms look like in vector invariant form for the shallow water model . Should I put that in another issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124077820:36,error,errors,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124077820,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,"@simone-silvestri : I tried running the branch in it's current version and received a GPU error. Is this something that works on your machine?. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Guh!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.v; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785:90,error,error,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,@simone-silvestri @jagoosw I think this PR may solve the race condition issue. The essential reason is that the Manifest was being re-resolved after init because downstream tests imported additional packages that were not imported during the initial instantiation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361545069:162,down,downstream,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361545069,1,['down'],['downstream']
Availability,"@simone-silvestri Do you mean `mask`? When I look in the file that's the only string I find in `immersed_boundary`. ```; julia> keys(file[""grid/immersed_boundary""]); 1-element Vector{String}:; ""mask""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128173670:31,mask,mask,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128173670,2,['mask'],['mask']
Availability,@simone-silvestri I see this error:. https://buildkite.com/clima/oceananigans/builds/12166#01897e82-b6c9-4935-b819-d578f7976262/19-338. Is this because of the changes in AbstractOperations?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1646762912:29,error,error,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1646762912,1,['error'],['error']
Availability,"@simone-silvestri I think another error has now come up with the original MWE in issue #3681. I tried the `main` branch and this branch on two different systems and I'm getting a different CUDA illegal memory access error. Since it's probably not related to this PR I'll open a new issue about it. I'm guessing something is out of bounds in an `@inbounds`. I'll try catching it with `--check-bounds=yes`. MWE:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); ```. Error:. ```julia; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_stru",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:34,error,error,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,5,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"@simone-silvestri In addition to the NetCDF issue I mentioned [here](https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524), I found out that the `cell_advection_timescale()` and `interior()` aren't working with `MultiRegionGrids` yet. Here's an error example:. ```julia; ERROR: LoadError: type MultiRegionObject has no field parent; Stacktrace:; [1] getproperty; @ ./Base.jl:38 [inlined]; [2] cell_advection_timescale(model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, MultiRegionGrid{Float64, Bounded, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, RightConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, LeftConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, MultiRegionObject{Tuple{Tuple{Colon, Colon, Colon}, Tuple{Colon, Colon, Colon}}, Tuple{CPU, CPU}}, MultiRegionObject{Tuple{OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, Tuple{CPU, CPU}}, Any, MultiRegionObject{Tuple{FieldBoundaryConditions{Nothing, Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304574572:267,error,error,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304574572,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"@simone-silvestri Unfortunately, my run died just before 20 days. I guess the simple advection scheme that I was using without viscosity wasn't stable enough. . Could you help me to set up the one you suggested on the previous PR? I tried was you suggested but got an error, which is copied above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988340134:268,error,error,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988340134,2,['error'],['error']
Availability,"@simone-silvestri Will do!. At the moment I am using `momentum_advection = VectorInvariant()`. If it goes unstable I will try the one you suggested on the other PR. I also tried what you suggested on the other PR,. ```; VectorInvariant(vorticity_scheme = WENO(), kinetic_energy_gradient_scheme = WENO()); ```. This failed because of the error below. Any idea what I need to do to fix this?. ```; ERROR: LoadError: MethodError: no method matching _symmetric_interpolate_yᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{…}, ::EnergyConserving{…}, ::typeof(Oceananigans.Advection.δx_v²), ::Field{…}, ::Field{…}). Closest candidates are:; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Union{Centered{2}, Centered{3}, Centered{4}, Centered{5}, Centered{6}, UpwindBiased{2}, UpwindBiased{3}, UpwindBiased{4}, UpwindBiased{5}, UpwindBiased{6}, WENO}, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/ImmersedBoundaries/conditional_fluxes.jl:210; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Union{Centered{1}, UpwindBiased{1}}, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/ImmersedBoundaries/conditional_fluxes.jl:207; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::Any, ::VectorInvariant{<:Any, <:Any, true}, ::Any, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/Advection/vector_invariant_advection.jl:250; ... ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1984534233:337,error,error,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1984534233,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"@simone-silvestri and I created a new branch to try and start tackle these issues, `fp-ss/shallow-water-version2`. When ran the `shallow_water_Bickley_jet.jl` on this branch there was an error. We were using superscripts `fcc` and `cfc` instead if `faa` and `cfc` on the averaging operators. I have since fixed that. . Now I'm going to try and merge main into this branch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1942287636:187,error,error,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1942287636,1,['error'],['error']
Availability,"@simone-silvestri any idea why the [gpu distributed hydrostatic model tests](https://buildkite.com/clima/oceananigans-distributed/builds/1102#018d6aa2-a044-4abd-8215-8d90ce471c50/186-4607) and how should I debug this? I mean, can I reproduce this on my laptop for example? Is it a tolerance issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1925160996:281,toler,tolerance,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1925160996,1,['toler'],['tolerance']
Availability,@simone-silvestri can you have a look here? Some help with this would be great... Just have a look at the error of the tests that fail and let me know if you can understand where the root of the manner is?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1312826687:106,error,error,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1312826687,1,['error'],['error']
Availability,"@simone-silvestri continuing our conversation on slack, this is the MWE I was able to generate. The example below gives me a bounds error when run on a GPU using this branch:. ```julia; using Oceananigans; using CUDA; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. if has_cuda_gpu(); arch = GPU(); else; arch = CPU(); end. grid_base = RectilinearGrid(arch,; size=(4, 4, 4),; x=(0, 1), y=(0,1),; z=(0, 1),; halo=(3,3,3),; ). bathymetry(x, y) = grid_base.Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENO5(grid=grid_base)); @info model. simulation = Simulation(model, Δt=0.1,; stop_iteration=10,; ); run!(simulation); ```. I haven't been able to isolate the error, besides the fact that it seems to be coming from `v_velocity_tendency`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1157031200:132,error,error,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1157031200,2,['error'],['error']
Availability,"@simone-silvestri could you point me to a test/validation that confirms 1) that the changes of the PR didn't have an effect on regular grids. Also, a benchmark to see how this PR might have speedup/slowed down things? There were some benchmarks in the first comment when the PR was opened but many changes were pursued after. Should we repeat those benchmarks or something along those lines?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814:205,down,down,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814,1,['down'],['down']
Availability,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:324,mainten,maintenance,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426,2,['mainten'],['maintenance']
Availability,@simone-silvestri have you seen this error:. ```; NetCDF output writer [GPU]: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-9/clima/oceananigans/test/test_netcdf_output_writer.jl:786; --;   | Got exception outside of a @test;   | This object is not a GPU array;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33; ```. before? It occurs here: https://buildkite.com/clima/oceananigans/builds/7106#944c7ad6-33d9-461a-af46-324a2563205f/24-526,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162:37,error,error,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162,4,"['Error', 'error']","['Error', 'error']"
Availability,@simone-silvestri im getting a lot of errors after merging your suggestions… can you take a look?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2881#issuecomment-1472015231:38,error,errors,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2881#issuecomment-1472015231,1,['error'],['errors']
Availability,"@simone-silvestri is this what's causing the error seem in the Oceanostics CI?: https://github.com/tomchor/Oceanostics.jl/pull/151. The error is. ```; ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:466; [2] isregional(t::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/RnhUQ/src/Utils/multi_region_transformation.jl:105; [3] _findfirst_rec (repeats 10 times); @ ./tuple.jl:414 [inlined]; [4] _findfirst_rec(f::typeof(Oceananigans.Utils.isregional), i::Int64, t::Tuple{Tuple{DataType, DataType, DataType}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.NegativeZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryCo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:45,error,error,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352,2,['error'],['error']
Availability,"@simone-silvestri maybe you can help here. It looks like reductions sometimes don't get type inferred properly and suffer a huge slowdown. Here's a clue. Starting with. ```julia; using Oceananigans; grid = RectilinearGrid(size=(1000, 64, 100), extent=(1, 1, 1), topology=(Periodic, Periodic, Bounded));; c = CenterField(grid; indices=(1:grid.Nx, 1:grid.Ny, 1:grid.Nz));; averaged_c = Field(Average(c, dims=2)); ```. we find that. ```julia; using Statistics; @time mean!(interior(averaged_c), interior(c)); ```. compiles after the first execution and is fast. But. ```julia; @time mean!(averaged_c, c); ```. is slow and looks like it suffers from type inference failure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2168836975:661,failure,failure,661,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2168836975,1,['failure'],['failure']
Availability,"@simone-silvestri this doesn't seem to be working when the domain is `Bounded` in the x direction. Is this expected?:. ```julia; ERROR: LoadError: MethodError: no method matching PressureSolver(::CPU, ::MultiRegionGrid{Float64, Bounded, Bounded, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, RightConnected, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, LeftConnected, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:24; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:25; PressureSolver(::Any, ::ImmersedBoundaryGrid) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:28; ...; Stacktrace:; [1] NonhydrostaticModel(; grid::MultiRegionGrid{Float64, Bounded, Bounded, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302898706:129,ERROR,ERROR,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302898706,1,['ERROR'],['ERROR']
Availability,"@simone-silvestri, do you know if the buildkite CI re-downloads the artifacts every time? I think it does...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1450294530:54,down,downloads,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1450294530,1,['down'],['downloads']
Availability,"@simone-silvestri, have a look at this error when you find time:; https://buildkite.com/clima/oceananigans-distributed/builds/1464#018e1b66-735b-43bc-9c77-4bb7b4646c2d/192-4782",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3487#issuecomment-1985172875:39,error,error,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3487#issuecomment-1985172875,1,['error'],['error']
Availability,"@syou83syou83 can you share your code that leads to this error?. check this out: https://gist.github.com/scmx/eca72d44afee0113ceb0349dd54a84a2 for how to create ""expandable"" widgets in your markdown posts",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084461600:57,error,error,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084461600,1,['error'],['error']
Availability,"@tomchor After this PR, I believe there are no issues.; Except we currently have to manually adjust the actuation to match the correct value based on the pre-pickup simulation during setup. ; For example, we have to do something like this: ; ```julia; # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, window_nΔt, interval_nΔt, stride, true); run!(simulation); checkpointed_wta = simulation.output_writers[:single_output_time_average].outputs[""c1""]; checkpointed_actuations = checkpointed_wta.schedule.actuations. # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, window_nΔt, interval_nΔt, stride, false); simulation.output_writers[:single_output_time_average].outputs[""c1""].schedule.actuations = checkpointed_actuations; run!(simulation, pickup=checkpoint); ```. The point is to ensure that the actuation after the pickup matches the actuation value from before the checkpoint.; ```julia; simulation.output_writers[:single_output_time_average].outputs[""c1""].schedule.actuations = checkpointed_actuations; ```. Sorry for the confusion, [test_netcdf_timeaverage.jl](https://github.com/CliMA/Oceananigans.jl/pull/3721/files/eb7d6dac13694e830f118e19225e5b00b3de84c7#diff-60f3eb03acc634682fc82a022d0a0b32382d1e890be3057750545a3d0ada1c09) is just my minimum working example, which is modified from [test_netcdf_output_writer.jl](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_netcdf_output_writer.jl#L639 ). So I believe that MWE I created is not really needed (it's not the original test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433135360:292,checkpoint,checkpoint,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433135360,5,['checkpoint'],['checkpoint']
Availability,"@tomchor Are you still encountering this issue?. I was able to run your MWE with no errors on small and large grids in three different environments with Julia 1.10.4, CUDA.jl v5.4.3, and Oceananigans.jl v0.91.8:; * Linux + A100 (compute capability 8.0); * Windows + RTX 3080 (compute capability 8.6); * Windows + GTX 1050 (compute capability 6.1). I was gonna test on some compute capability 3.0 Quadro GPUs but they're too old for CUDA.jl lol. For comparison, Tartarus has Titan V GPUs (compute capability 7.0) and your Quadro GP100 is compute capability 6.0. So if it's solely tied to compute capability then it could just be an issue with <=6.0?. I found this list of CUDA compute capabilities useful: https://developer.nvidia.com/cuda-gpus. ---. MWE:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(GPU(), size=(44, 8, 52), extent=(1, 1, 1)); 44×8×52 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0227273; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0192308. julia> minimum_zspacing(grid); 0.019230769230769232. julia> minimum_xspacing(grid); 0.022727272727272728. julia> minimum_yspacing(grid); 0.125; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-2299083371:84,error,errors,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-2299083371,1,['error'],['errors']
Availability,"@tomchor I think we should revisit this PR. Rather than ""moving"" the masking, I think we should start by adding a feature to both output writers that defines a ""mask value"" for immersed regions. What do you think about that? I would like to open a new PR for that. And before that, I'm going to open an issue so we can discuss the user interface. Once we have a nice feature for masking output, we can consider whether or not to also mask (or not) within the time-stepping. These are separate questions, I think. If you agree with that then we can close this PR and I will open an new issue to discuss the user API.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998:69,mask,masking,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998,4,['mask'],"['mask', 'masking']"
Availability,"@tomchor I think your solution might help RK3, but as you noted there is _also_ a problem with AB2:. > In this particular MWE if I switch the time-stepper to Adams-Bashforth the issue seemingly goes away (even though there's an initial jump in the pressure that I wouldn't expect), but it does persist (albeit more mildly) in more complex simulations. There's an issue somewhere in. https://github.com/CliMA/Oceananigans.jl/blob/fb2c670626e38e3bffe298c485f95625fb1d83be/src/Simulations/run.jl#L41-L56. I'm also wondering if one issue is that we need to change the line. ```julia; aligned_Δt = schedule_aligned_Δt(sim, aligned_Δt); ```. and maybe instead have an interface where callbacks return the next time of actuation. `TimeInterval` may also need to be redesigned... the fact that we compute the next actuation time b. https://github.com/CliMA/Oceananigans.jl/blob/fb2c670626e38e3bffe298c485f95625fb1d83be/src/Utils/schedules.jl#L65. maybe invites round-off error. To start working on this I think we need an MWE. Mabye that's easy, just a simulation with constant time-step and output on `TimeInterval` which should, in theory, work perfectly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103294147:963,error,error,963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103294147,1,['error'],['error']
Availability,"@tomchor `ConditionalOperation` is used ""under-the-hood"" to reduce a field with a condition. A reduction on a field can now be called with two additional keyword arguments: `condition` and `mask`. Where `condition` evaluates to `false` the field to be reduced will be masked with `mask` which (if not specified) is `-Inf, Inf, 1, 0` for `maximum, minimum, prod` and `sum`, respectively, such that region where `condition = false` can be excluded from the reduction. . (probably not the right place to say it but I see now that we might have a problem with specific functions, for example `maximum(abs, field, condition = something) = Inf`. We probably should mask after the function is applied). An example is here; ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. A `ConditionalOperation` just contains the ""operand"" to reduce (might be an `AbstractField` or an `AbstractOperation`), a grid, the condition (which can be a `Function` or an `AbstractArray`),",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235:190,mask,mask,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022269235,4,['mask'],"['mask', 'masked']"
Availability,"@tomchor and @whitleyv this PR adds a script that we can use to _estimate_ the relative effect of bottom drag vs form drag in buoyancy-stratified simulations over hilly bathymetry. This script only produces an estimate, because the bottom drag is implemented in a flat bottom setup, while form drag requires bathymetry. I'd hypothesis that we get more drag when there are both hills and bottom drag, because 1) greater shear at the bottom and 2) stronger downwards mixing of momentum due to strong turbulence. We could use #2275 to extend the results obtained here to cases with both drag and hills. I think it'll also be interesting if more accurate bathymetry representations like the one in #2306 lead to a reduction in form drag (cc @francispoulin). Possibly the spurious form drag is a nice metric to use to judge developments in our representation of bathymetry... I'll run these simulations at high resolution and report some results, hopefully soon. Side note: it's annoying that we don't serialized the immersed boundary so I might try to fix that here too...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402:455,down,downwards,455,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402,1,['down'],['downwards']
Availability,"@tomchor just wanted to echo @ali-ramadhan's thank you for finding that bug!. Right now Oceananigans shines for medium-size LES problems around 256^3, perhaps up to 384^3. For that application I think you may find it is as fast or faster than other codes. On that note, it'd be great to compare performance with other codes for this problem size. . For utterly massive problems like the one reported in the Sullivan paper you've posted, Oceananigans is probably not the right tool right now. We haven't experimented with multi-node parallelism yet, but as @ali-ramadhan suggests, its possible we will start working on either multi-CPU parallelism or multi-GPU parallelism soon. For reproducing the Sullivan paper, you may want multi-CPU parallelism simply because of the sheer number of nodes you'll need. It's worth noting that our AMD turbulence closure *may* be less resolution-dependent than the TKE-based closure used by NCAR LES / Sullivan (and yourself?) and thus it may be possible to run at lower resolution (potentially saving factors of 10-100 in resolution. A [paper by Abkar and Moin (2017)](https://link.springer.com/article/10.1007/s10546-017-0288-4) hints at the potential for very coarse simulations with AMD.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569:24,echo,echo,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569,1,['echo'],['echo']
Availability,"@tomchor suggested that the increased error might be due to errors from low-order numerics piling up over many iterations. Indeed, switching to WENO-5 + RK3 reduces the error by an order of magnitude!. ```; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660130013623816e-6, Δ = 1.2402422057088938e-10 at t = 10 hours with θ=60 # CenteredSecondOrder + QAB2; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.000172734522595e-6, Δ = -1.7273452259476338e-10 at t = 10 hours with θ=60 # CenteredSecondOrder + QAB2; N² * g̃[2] = 8.660254037844387e-6, mean(∂y_b) = 8.660230615917627e-6, Δ = 2.3421926760073770e-11 at t = 10 hours with θ=60 # WENO5 + RK3; N² * g̃[3] = 5.0e-6, mean(∂z_b) = 5.00003008535181e-6, Δ = -3.0085351809812464e-11 at t = 10 hours with θ=60 # WENO5 + RK3; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796451828:38,error,error,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-796451828,3,['error'],"['error', 'errors']"
Availability,"@tomchor there was an interface location at which high order methods were looking ""into"" the immersed boundary. This is because the boundary treatment was the same as for regular boundaries where we always fill at least one halo. Since the value inside the immersed region is zero because of the masking, this was producing an effectively higher (lower) and lower (higher) tracer source in two consecutive cells (i.e. a spurious maximum and minimum). . This problem was difficult to find because in some way it is ""masked"" by the WENO weighting procedure:; WENO evaluates three different stencils and weights them based on their individual smoothness. Most of the times, the stencil containing the invalid cell has a very low smoothness which means that it is removed by the calculation. This might seem like a fix but it can lead to stability problems because the only stencils remaining might be the ""centered"" and ""downwind"" stencil which are inherently more unstable than the upwind stencil. The issue is immediately visible if you try to advect a constant tracer field `c=1` with high order reconstruction such as Upwind 5 or Upwind 3 (it is not immediately visible in WENO because of the above reason). . If you run this code you'll notice that the advective fluxes (which should be only 0 and 1) actually have a different value (0.96666667) at one specified location near the immersed boundary; ```; using Oceananigans; using Oceananigans.BoundaryConditions; using Oceananigans.ImmersedBoundaries; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10), topology = (Bounded, Bounded, Bounded)). Nx, Ny, Nz = size(grid). boundary = zeros(Nx, Ny, Nz); boundary[1:2, :, :] .= 1; boundary[:, 1:2, :] .= 1; boundary[:, :, 1:2] .= 1. ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary(boundary)). model = HydrostaticFreeSurfaceModel(grid = ibg, ; closure = nothing, ; buoyancy = nothing, ; tracers = :c, ; tracer_advection = Up",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454:296,mask,masking,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454,3,"['down', 'mask']","['downwind', 'masked', 'masking']"
Availability,"@tomchor this is the report from Shu deriving ENO coefficients for a finite volume scheme https://www3.nd.edu/~zxu2/acms60790S13/Shu-WENO-notes.pdf (In particular equation 2.20 which becomes equation 2.21 for uniform grids and reduces to the coefficient we used before) I can add some documentation on the WENO. . By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?. @francispoulin Cool! I'll check the convergence then. What I mean in the comments is that I use a Nonhydrostatic model which computes pressure and there is no infrastructure in Nonhydrostratic.jl for a pressure solver on a non-uniform horizontal grid (it will throw an error ""no method Pressuresolver(grid::RectilinearGrid)"". I maybe should change that test to an hydrostatic model...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968990386:760,error,error,760,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968990386,1,['error'],['error']
Availability,"@tomchor's MWE from his original post works for me (as of Oceananigans.jl v0.91.11) so there's no error anymore, although open BCs for hydrostatic models aren't implemented. Is it worth closing this issue?. > If you use the SplitExplicit the error disappears. This is not to say that the solution will be correct because still the barotropic velocities and barotropic volume fluxes will not account for those open boundary conditions. ; > ; > _Originally posted by @simone-silvestri in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2178789178_. Now that PR #3482 has been merged, is this still the thing missing for proper hydrostatic open BCs? I'm guessing that the implementation is different for each free surface solver?; * The implicit free surface solver needs to account for a non-zero surface volume flux $M$? See equation (9) of the [Implicit free surface pressure operator](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/elliptic_solvers/#Implicit-free-surface-pressure-operator) docs.; * The split-explicit free surface solver's evolution kernels has difference functions that need to be modified to support open boundary conditions? See [this comment](https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L35-L42). If it makes sense, I can open a new issue to discuss hydrostatic open BCs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312551038:98,error,error,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312551038,2,['error'],['error']
Availability,"@tomchor, if you want I can remove it from the hydrostatic model; it should be the same as for the nonhydrostatic. . Actually, I saw that you already removed it. I am wondering though if we don't need to keep the masking for the velocities, as those need an ""impenetrability"" condition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223709635:213,mask,masking,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223709635,1,['mask'],['masking']
Availability,"@vchuravy - I modified `src/Grid/zeros_and_ones.jl` to be; ```; using CUDA; using AMDGPU; using Oceananigans.Architectures: CPU, CUDAGPU, ROCmGPU, AbstractArchitecture; using KernelAbstractions; import Base: zeros. zeros(FT, ::CPU, N...) = zeros(FT, N...); zeros(FT, ::CUDAGPU, N...) = CUDA.zeros(FT, N...); zeros(FT, ::ROCmGPU, N...) = KernelAbstractions.zeros(AMDGPU.ROCBackend(), FT, N...). zeros(arch::AbstractArchitecture, grid, N...) = zeros(eltype(grid), arch, N...); zeros(grid::AbstractGrid, N...) = zeros(eltype(grid), architecture(grid), N...). @inline Base.zero(grid::AbstractGrid) = zero(eltype(grid)); @inline Base.one(grid::AbstractGrid) = one(eltype(grid)); ```. This throws the same error as just using `AMDGPU.jl`. For reference. ```; ERROR: LoadError: Not implemented; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GP",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420:700,error,error,700,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"@vchuravy could you have a look here? this seems to run (that is it does not error), but e.g., were there any tests actually tested in https://buildkite.com/clima/oceananigans/builds/11987#018912fd-4e55-4160-87ce-0e7195b271aa ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3042#issuecomment-1616067399:77,error,error,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3042#issuecomment-1616067399,1,['error'],['error']
Availability,@vchuravy how about now? still there is some weird TOML parser error...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3042#issuecomment-1627604232:63,error,error,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3042#issuecomment-1627604232,1,['error'],['error']
Availability,@weymouth Is iterating between the application of the boundary conditions and the pressure correction what you would recommend if we determine the errors are unacceptably large?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-856034601:147,error,errors,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-856034601,1,['error'],['errors']
Availability,"@wsmoses should we add a new buildkite run dedicated solely to the enzyme extension? It might help for debugging / interpreting failures. (If that makes sense, I can shuffle things around to make that work.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759711880:128,failure,failures,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1759711880,1,['failure'],['failures']
Availability,"A ""dynamic function invocation"" means that the compiler thinks a function is being called whose scope can change ""dynamically"" (I think). This is the error one gets when a function depends on a global variable that is not `const` (for example). In this case, the error tells us that the types of the objects involved in calling `getindex` defined on `BinaryOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/AbstractOperations/binary_operations.jl#L34. are not correctly inferred. The way getindex comes into play is in the kernel function `_compute!` that evaluates the `AbstractOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Fields/computed_field.jl#L84-L87. calling `getindex(operand, i, j, k)` (or equivalently `operand[i, j, k]`) triggers recursive `getindex` calls that traverse the `AbstractOperation` tree. It seems that when the tree is too large, this traversal cannot be entirely compiled. Perhaps there are tricks we might use to help the compiler parse this kind of operation, like putting some type annotations / hints into `getindex(b::BinaryOperation, ...)`. Not sure. Another possibility is to figure out how to simplify the object `BinaryOperation`, `MultiaryOperation`, so that the compiler is less stressed trying to compile them... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140:150,error,error,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140,2,['error'],['error']
Availability,A centered second order advection should be okay but you have to pair it with some diffusion otherwise oscillatory errors will break your solution,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3266#issuecomment-1723500085:115,error,errors,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3266#issuecomment-1723500085,1,['error'],['errors']
Availability,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2180:189,error,error,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180,3,['error'],['error']
Availability,"A couple of notes:. I realized that the doctests in the NetCDFWriter docstring and the NetCDFWriter session in `model_setup` are pretty much the same. I think it's good that both have the information, but it would be nice if we could write that stuff only once and then automatically display in both places. Maybe something for a different PR?. I'm getting errors like the one below in the docs, indicating that there are some leftover files in the server:. ```; ┌ Warning: fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; └ @ Oceananigans.OutputWriters ~/builds/tartarus-10/clima/oceananigans/src/OutputWriters/netcdf_output_writer.jl:290; ```. I thought these files were automatically deleted on the CI server. Is there anything I have to do to prevent them?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969648031:357,error,errors,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969648031,2,['error'],['errors']
Availability,"A couple of quick things: . - Has anyone tried to reproduce this result independently so far?; - I'm assuming we're close to releasing a new version. Should we remove this feature for now? Everything so far points to it producing qualitatively wrong results for a functionality that's kinda basic. This could easily introduce pretty major errors in someone's research (and it almost did for me; I was lucky to catch this). Again, that's all assuming this error is real. Which we can't be sure until someone else double-checks me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817931493:339,error,errors,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817931493,2,['error'],"['error', 'errors']"
Availability,A different error!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1406405519:12,error,error,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1406405519,1,['error'],['error']
Availability,"A few comments:. 1. Let's call this `materialize_biogeochemistry`. We would like to change the names of the functions to ""materialize"" as well.; 2. This should be avoided unless strictly necessary. Generally, this step introduces complexity and fragility to model setup. One source of insidious bugs is when the user-build `biogeochemistry` is different from `model.biogeochemistry`. Can you provide an example of when this is necessary to motivate this feature, given its serious downsides?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1714600321:481,down,downsides,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1714600321,1,['down'],['downsides']
Availability,"A few ideas:. 1. Allow `grid` as a positional argument so we can write `WENO5(grid)` rather than `WENO5(grid=grid)`; 2. Emit a warning about ""stretched WENO"" in the model constructor rather than `WENO5`. It's misleading to throw a warning when using WENO5 on a uniform grid; we should only throw a warning if users specify `WENO5` with a stretched grid.; 3. Alternatively to 2, we can re-build WENO in model constructors with a `validate_advection` method. We already have `validate_momentum_advection` for hydrostatic models:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L127. The downside to 3 is that it's bad for testing, since it might _prevent_ us from using the ""uniform"" flavor of WENO on stretched grids. (@simone-silvestri is that true?) Also something that's not clear to me --- @simone-silvestri do coefficients like. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L30. become `Nothing` in regular directions, even with `WENO5(grid=grid)`? Or are they only `Nothing` for `WENO5()`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2271:699,down,downside,699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271,1,['down'],['downside']
Availability,A little benchmarking to make sure that the single grid models have not slowed down in the process...; #### Main; ```; NonhydrostaticModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.775 ms │ 2.790 ms │ 2.823 ms │ 3.051 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 64 │ 20.168 ms │ 20.463 ms │ 20.409 ms │ 20.515 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 128 │ 211.542 ms │ 211.646 ms │ 211.700 ms │ 212.026 ms │ 520.84 KiB │ 1044 │ 10 │; │ CPU │ Float64 │ 256 │ 2.511 s │ 2.532 s │ 2.532 s │ 2.552 s │ 520.84 KiB │ 1044 │ 2 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; HydrostaticFreeSurfaceModel benchmarks; ┌───────────────┬─────────────┬─────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 1.195 ms │ 1.205 ms │ 1.254 ms │ 1.626 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 64 │ 2.041 ms │ 2.051 ms │ 2.100 ms │ 2.503 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 128 │ 5.778 ms │ 5.833 ms │ 5.873 ms │ 6.254 ms │ 830.98 KiB │ 1831 │ 10 │; │ CPU │ Float64 │ 256 │ 23.662 ms │ 23.740 ms │ 23.730 ms │ 23.840 ms │ 830.98 KiB │ 1831 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; ShallowWaterModel benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬──────────┬────────────┬───────,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428:79,down,down,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116031428,1,['down'],['down']
Availability,"A lot of times the docs build fail. I notice that there are errors in the installation of deps and precompilation part of the docs build. I'm not totally sure that Manifest.toml is the culprit but shipping docs with its Manifest does require us to use non-conventional ways to build the docs. Specifically, we can't use `Pkg.develop` to install the required deps eg. ```; julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'; ```. and instead we have to rely to. https://github.com/CliMA/Oceananigans.jl/blob/adb728c8f5bdcd24729b8b9282459fc0344bca5b/docs/make.jl#L5-L11. I would like to experiment whether removing docs/Manifest.toml and using proper compat entries in docs/Project.toml will alleviate some of the issues",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3520:60,error,errors,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3520,1,['error'],['errors']
Availability,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:838,error,errors,838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142,2,['error'],['errors']
Availability,"A more minimal example:. ```Julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, PartialCellBottom. arch = CPU(). underlying_grid = RectilinearGrid(arch,; size=(128, 64), halo=(3, 3), ; y = (-1, 1),; z = (-1, 0),; topology=(Flat, Periodic, Bounded)). @inline seamount(x, y) = - 1 + 0.5 * exp(- y^2 / 0.25^2). minimum_fractional_Δz = 0.2. grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(seamount; minimum_fractional_Δz)). tracer_advection = CenteredSecondOrder(); momentum_advection = CenteredSecondOrder(). model = HydrostaticFreeSurfaceModel(; grid,; tracer_advection,; momentum_advection,; coriolis = FPlane(f=0.1),; tracers = :b,; buoyancy = BuoyancyTracer()); ```. ```julia; ERROR: TaskFailedException. nested task error: TaskFailedException. nested task error: BoundsError: attempt to access 1×134 OffsetArray(::Matrix{Float64}, 1:1, -2:131) with eltype Float64 with indices 1:1×-2:131 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, ::Int64, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:420 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:420 [inlined]; [6] overdub; @ ~/Research/OC2.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; [7] immersed_cell(::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.Twi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1302841826:729,ERROR,ERROR,729,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1302841826,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,A preview of the docs will be available at . https://clima.github.io/OceananigansDocumentation/previews/PR2639. (after the docs are build... it takes ~2hrs),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1173386910:30,avail,available,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1173386910,1,['avail'],['available']
Availability,"A question for @glwagner . At the moment the tendencies in the evolution equation for height is computed here using essentailly a second-order finite difference method. This is fine for a start, but as discussed elsehwere, it would be better to use finite volume and therefore using the advection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:662,error,error,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952,2,['error'],['error']
Availability,"A quick fix is to change. https://github.com/CliMA/Oceananigans.jl/blob/f70d0949f7688df89a7f8a9e7d44177cde27091a/validation/immersed_boundaries/flow_over_hills.jl#L30. to . ```julia; underlying_grid = RectilinearGrid(architecture, size = (Nx, Nz), halo = (4, 4), ; ```. ie increase the number of halo points by 1. It does beg the question whether we should increase the number of default halo points to 4 from 3. Both #2989 and #2827 should increase the problem with cryptic errors.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860#issuecomment-1480508282:475,error,errors,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860#issuecomment-1480508282,1,['error'],['errors']
Availability,"A simple fix might write an `initialize_schedule!` method for `TimeInterval` that sets the `previous_actuation_time` to the current `model.clock.time`. The schedules are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Simulations/run.jl#L140. `initialize_schedule!` for `TimeInterval` goes to the fallback:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L10. I think you'll also want to change the syntax of `initialize_schedule` to take `model` as an input, so all the functions will look like `initialize_schedule!(schedule, model)`. This also affects the one non-trivial `initialize_schedule!` method here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L92. Ultimately I think @qwert2266 is right. We need to checkpoint both models and output writers, or, better yet, the entire `simulation`. This checkpointing issue also affects time-averages since they have to be checkpointed too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280:903,checkpoint,checkpoint,903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280,6,['checkpoint'],"['checkpoint', 'checkpointed', 'checkpointing']"
Availability,"A warning is emitted if output is requested but `collecting=true`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L201-L203. But if you're not getting a warning then this isn't occurring. Do you have an MWE? If so we can play around. I suspect you might be hitting a flaw / bug in the algorithm that the tests don't hit. To figure out what that flaw is, we need an MWE that produces the error. It probably makes sense to average something that doesn't oscillate around 0 so spurious accumulation is obvious.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872471651:471,error,error,471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872471651,1,['error'],['error']
Availability,"ADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1379,ERROR,ERROR,1379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,1,['ERROR'],['ERROR']
Availability,"AExt [ed7ef945-33a4-511e-97fe-2b89c7a130ca]; ERROR: LoadError: UndefVarError: `IntervalBox` not defined; Stacktrace:; [1] top-level scope; @ ~/.julia/packages/TaylorSeries/2qRvJ/ext/TaylorSeriesIAExt.jl:182; [2] include; @ ./Base.jl:495 [inlined]; [3] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2222; [4] top-level scope; @ stdin:3; in expression starting at /Users/navid/.julia/packages/TaylorSeries/2qRvJ/ext/TaylorSeriesIAExt.jl:1; in expression starting at stdin:3; ┌ Error: Error during loading of extension TaylorSeriesIAExt of TaylorSeries, use `Base.retry_load_extensions()` to retry.; │ exception =; │ 1-element ExceptionStack:; │ Failed to precompile TaylorSeriesIAExt [ed7ef945-33a4-511e-97fe-2b89c7a130ca] to ""/Users/navid/.julia/compiled/v1.10/TaylorSeriesIAExt/jl_TNauRw"".; │ Stacktrace:; │ [1] error(s::String); │ @ Base ./error.jl:35; │ [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); │ @ Base ./loading.jl:2468; │ [3] compilecache; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:1119,error,error,1119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['error'],['error']
Availability,"A_Runtime_Discovery; ✓ PrecompileTools; ✓ JLLWrappers; ✓ Tables; ✓ RandomNumbers; ✓ Atomix; ✓ TimerOutputs; ✓ AbstractFFTs → AbstractFFTsTestExt; ✓ NVTX_jll; ✓ JuliaNVTXCallbacks_jll; ✓ MacroTools; ✓ LLVMExtra_jll; ✓ CUDA_Driver_jll; ✓ Random123; ✓ DataStructures; ✓ StringManipulation; ✓ FixedPointNumbers; ✓ SortingAlgorithms; ✗ CUDA_Runtime_jll; ✓ ColorTypes; ✓ LLVM; ✓ LLVM → BFloat16sExt; ✓ StaticArrays; ✓ Adapt → AdaptStaticArraysExt; ✓ StaticArrays → StaticArraysStatisticsExt; ✓ UnsafeAtomicsLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_CUC33l"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:4725,fault,fault,4725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['fault'],['fault']
Availability,Abstract operations `compute_kinetic_energy` test fails with CUDA error,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/732:66,error,error,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732,1,['error'],['error']
Availability,AbstractAverages and Checkpointing fixes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/783:21,Checkpoint,Checkpointing,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/783,1,['Checkpoint'],['Checkpointing']
Availability,"Actually I think the fact that the error comes from set!(model, ...) might imply deeper issues. Can you set fields individually? You might try figuring out exactly what kernel is causing the problem...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1116137572:35,error,error,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1116137572,1,['error'],['error']
Availability,"Actually I'll reopen this since I'm still getting an error, albeit a different one:. ```; julia> grid; 44×8×52 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [4.35026e-15, 894.427) regularly spaced with Δx=20.3279; ├── Periodic y ∈ [-8.74514e-15, 178.885) regularly spaced with Δy=22.3607; └── Bounded z ∈ [-178.885, 178.885] variably spaced with min(Δz)=4.76685, max(Δz)=21.2525. julia> minimum_zspacing(grid); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:89; [2] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/utils/call.jl:26; [4] #39; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CuStream, CuFunction, CuDim3, CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CuDeviceArray{Float64, 4, 1}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Of",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457:53,error,error,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457,5,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Actually, I get NaNs in the `h` field after just one time step (on the south USA coast near florida)... It must be an implementation error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129127651:133,error,error,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129127651,1,['error'],['error']
Availability,"Actually, I'm just noticing that `Reduction` has a option `mask`. Is that already enough to mimic the windowing behavior?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021775876:59,mask,mask,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021775876,1,['mask'],['mask']
Availability,"Actually, the problem looks like its with the method `has_velocities`. I got this error:. ```julia; ERROR: BoundsError: attempt to access (); at index [1]; Stacktrace:; [1] getindex(::Tuple, ::Int64) at ./tuple.jl:24; [2] has_velocities(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:101; [3] tracernames(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:105; [4] tracernames(::NamedTuple{(),Tuple{}}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:106; [5] show(::IOContext{REPL.Terminals.TTYTerminal}, ::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Cell,Oceananigans.Face,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/700:82,error,error,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/700,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Actually, this was just to test that all the Implicit free surface methods were giving the same results with immersed boundaries (nothing physically meaningful) We could think at a more in-depth test maybe?. As to why this test was failing is because the PR containing this test was merged before the PR which reverted `WENO5` on `halo = (1,1,1)` to an error instead of a warning (I think). We have to check if the error showed up when we merged the latter",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670:353,error,error,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1006089670,2,['error'],['error']
Availability,"Actually, we can't test this because while it fixes the error, it seems there's another bug that prevents the boundary condition from being fulfilled. However, I put a fix for this second bug in #2437 .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100708867:56,error,error,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2441#issuecomment-1100708867,1,['error'],['error']
Availability,Add Downloads badges on README.md,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3652:4,Down,Downloads,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3652,1,['Down'],['Downloads']
Availability,Add support for only keeping the latest checkpoint,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1341:40,checkpoint,checkpoint,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1341,1,['checkpoint'],['checkpoint']
Availability,Added a list of available topologies,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1193:16,avail,available,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1193,1,['avail'],['available']
Availability,"Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated). There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one. > if the name is changed to include Cartesian then we can merge this and discuss further in an issue. Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033:376,toler,tolerance,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033,2,['toler'],['tolerance']
Availability,"Adding `convert` to `xnode` etc. or `getnode` seems like a better solution than changing the type of the ranges, which might introduce rounding errors. But did you mean to dispatch on `::AbstractArray{FT}`? I thought the issue was with `::StepRangeLen`? Or will dispatching on `::AbstractArray{FT}` also include offset arrays which house all the ranges anyway?. > I feel like this is a bug, what do you think?. I agree. Just not sure in which package. I'll try to produce a MWE with just a range inside a CUDA kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445728824:144,error,errors,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445728824,1,['error'],['errors']
Availability,"After discussing with @ali-ramadhan, it seems more clear that a simple solution is just to use a default halo size of 3. For most models that use the highest order advection scheme we offer this has no effect. For models that use a lower-order advection scheme but don't change the halo size, the memory foot print of the model is ever-so-slightly larger than it needs to be. But this slightly-larger footprint probably isn't noticeable for most problems. So in summary, minimal halo sizes are a minor optimization that has little effect on most problems. Auto-optimizing the halo size has major downsides for usability, so I think the trade-off leans towards big default halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883:596,down,downsides,596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883,2,['down'],['downsides']
Availability,"After discussion in #3177 I noticed that the warning only warns for Julia v1.7 and earlier... But it should warn for Julia v1.8 as well. (Although, if we decide to add a compat entry for Julia v1.9 as a response to #3184 then the warning is rendered redundant.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3182:250,redundant,redundant,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3182,1,['redundant'],['redundant']
Availability,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:12,down,down,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801,12,"['down', 'error']","['down', 'error', 'errors']"
Availability,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1179:192,failure,failures,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179,6,"['Checkpoint', 'ERROR', 'error', 'failure']","['Checkpointer', 'ERROR', 'errored', 'failures']"
Availability,After the considerations yesterday I made the following changes:. 1. Mask the product / operation `Lϕ` so that it is 0 in immersed regions.; 2. Change the sign of `regularization` so that `regularization > 0` implies that $\tilde L$ is negative-definite. I'm no longer convinced that this PR actually makes progress on #3831. But it could be the basis for further investigation. I also think that `RegularizedPreconditioner` needs some improvement; it has a property `preconditioner` (the non-regularized preconditioner) which leads to silly constructs like `pressure_solver.conjugate_gradient_solver.preconditioner.preconditioner`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2422530544:69,Mask,Mask,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2422530544,1,['Mask'],['Mask']
Availability,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798:205,error,error,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Agree this is redundant and if we aren't checking in the grid constructor, we should.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2595#issuecomment-1144794360:14,redundant,redundant,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2595#issuecomment-1144794360,1,['redundant'],['redundant']
Availability,"Agreed! I went back and see that things are much better on my cpu. There are a few warnings but then it gets down to business. I am estimating that it might take 14 hours, and now I believe that it is progressing (unlike before). On a future world, when one sees that things are taking a while, it would be nice to run things in parallel using distrubed version of the model. I see there are distributed models for IncompressibleModel and ShallowWater, but not HydrostaticModel, yet. . Maybe I'll create an issue since this is something that I presume we would like to have going forward. ```; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ┌ Warning: HydrostaticFreeSurfaceModel is experimental. Use with caution!; └ @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/software/Second_Oceananigans/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:106; ┌ Warning: Cannot save Function property into grid/immersed_boundary/mask; └ @ Oceananigans.OutputWriters ~/software/Second_Oceananigans/Oceananigans.jl/src/OutputWriters/output_writer_utils.jl:21; ┌ Warning: Could not initialize ./internal_tide.jld2: data may already be initialized.; └ @ Oceananigans.OutputWriters ~/software/Second_Oceananigans/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:193; [ Info: [0.06%], iteration: 100, time: 0.055, max|w|: 9.46e-06; [ Info: [0.11%], iteration: 200, time: 0.110, max|w|: 2.67e-05; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867970305:109,down,down,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867970305,2,"['down', 'mask']","['down', 'mask']"
Availability,"Agreed. Useful and related comment. > I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR [vchuravy/GPUifyLoops.jl#18](https://github.com/vchuravy/GPUifyLoops.jl/pull/18).; > ; > The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in [#59 (comment)](https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181)) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs.; > ; > You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations.; > ; > Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.; >; >_Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/115#issuecomment-470782067_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910:657,degraded,degraded,657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910,1,['degraded'],['degraded']
Availability,"Ah CI doesn't even initialize on the CPU now... Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):. ```julia; shell> hostname; tartarus. julia> ENV[""CUDA_VISIBLE_DEVICES""]; ""-1"". julia> using CUDA. julia> CUDA.has_cuda(); false. julia> CUDA.has_cuda_gpu(); ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; [2] macro expansion; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; [3] cuDeviceGetCount; @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; [4] ndevices; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; [5] length; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; [6] has_cuda_gpu (repeats 2 times); @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; [7] top-level scope; @ REPL[5]:1; [8] top-level scope; @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232:176,error,errors,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232,6,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,Ah I think we only get a doc preview if the Buildkite build was started after the PR was opened so that there's an associated PR number. This PR only has one commit so I think the build was started right when you `git push`ed but before the PR was opened (so no PR number was available). Usually I just push an empty commit to trigger Buildkite for these occasions.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1652#issuecomment-839392086:276,avail,available,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1652#issuecomment-839392086,1,['avail'],['available']
Availability,Ah Julia 1.1 is quite old and will end up using an ancient version of Oceananigans.jl so you probably need Julia 1.5+ (you should be able to download a binary from https://julialang.org/downloads/). But in this case I think Oceananigans is mispelled as Oceanigans.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799634970:141,down,download,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799634970,2,['down'],"['download', 'downloads']"
Availability,"Ah Julia 1.7!. Results look similar... ```julia; gregorywagner:~/ $ julia [16:23:13]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.7.0 (2021-11-30); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> const a = 1; 1. julia> const a = 1; 1. julia> const a = ""hi""; ERROR: invalid redefinition of constant a; Stacktrace:; [1] top-level scope; @ REPL[3]:1; ```. but I'll take that into account...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1004424163:431,ERROR,ERROR,431,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1004424163,1,['ERROR'],['ERROR']
Availability,"Ah Julia installed Oceananigans v0.5.1 (an extremely ancient version), probably due to conflicts between dependency versions. The latest release is Oceananigans v0.57.1. To grab the latest version you can try to explicitly update by typing `] add Oceananigans@0.57.1` in the REPL. There may be conflicts with some other packages like CUDA v3.1.0. Oceananigans is still depending on CUDA v2 so you might have to `] rm CUDA` to be able to `] add Oceananigans@0.57.1`. This might also explain the weird error you reported in #1635. PS: You might encounter issues when using Oceananigans.jl with Julia 1.6 right now. It still requires Julia 1.5 for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832291603:500,error,error,500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832291603,1,['error'],['error']
Availability,Ah actually we have 34 instances of `has_cuda` in the repo so it could perhaps explain a lot of the failures? https://github.com/CliMA/Oceananigans.jl/search?p=4&q=has_cuda,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942848201:100,failure,failures,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942848201,1,['failure'],['failures']
Availability,"Ah good point, thanks for looking into this @navidcy! Definitely my fault for using `Base.typename` when I knew it was an internal unexported function. Will revisit this PR soon now that docs aren't getting stuck on Buildkite + Julia 1.5 anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-819477263:68,fault,fault,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-819477263,1,['fault'],['fault']
Availability,"Ah haha right, feels like a lot more tests would have failed because of that though but it was only CPU tests groups that failed last time so maybe that line is responsible for most of the failures?. PS: Sorry for accidentally closing!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942854704:189,failure,failures,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942854704,1,['failure'],['failures']
Availability,"Ah interesting, why do you create `coarse_model`? Is that so `coarse_model.grid` gets saved down? I think we can make it so that isn't needed probably...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091020036:92,down,down,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091020036,1,['down'],['down']
Availability,Ah is it worth doing something with #3740 then so the model doesn't error with `free_surface = nothing` or would that just be misleading?. I can also update the PR to get rid of `rigid_lid.jl` to avoid confusing users into thinking a rigid lid mode exists.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3735#issuecomment-2313395254:68,error,error,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735#issuecomment-2313395254,1,['error'],['error']
Availability,Ah it was just a try. `\bm` comes from the `bm` LaTeX package which I guess was available with KaTeX. For MathJax we might have to define the `\bm` command at the top of the pages that use it?. [Equation numbering still doesn't work](https://clima.github.io/OceananigansDocumentation/previews/PR1530/numerical_implementation/time_stepping/) but apparently it's because MathJax3 doesn't enable it by default: http://docs.mathjax.org/en/latest/input/tex/eqnumbers.html. Looks like we can configure it by passing a dict to the `MathJax3` constructor though: https://juliadocs.github.io/Documenter.jl/stable/lib/internals/writers/#Documenter.Writers.HTMLWriter.MathJax3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-811481173:80,avail,available,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-811481173,1,['avail'],['available']
Availability,"Ah it's possible that `AnisotropicBiharmonicDiffusivity` isn't doing the right thing on a vertically stretched grid... Certainly it's not tested. The error you're getting with `topology = (Periodic, Bounded, Bounded)` seem related to `cell_advection_timescale` not doing the right thing on a vertically stretched grid as well... It's used to compute CFL by the `TimeStepWizard`. We should fix these soon but for now you could try running with a constant time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-794035595:150,error,error,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-794035595,1,['error'],['error']
Availability,"Ah ok so I think this is just an issue with running `makedocs` multiple times after each other without cleaning up what `makedocs` has done before. So it's complaining that when it ran the `jldoctest` a second time it got this message:. ```; more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; ```. so the output is different. I guess we have 3 possible automated fixes (manual fix being to remove the files manually):; 1. We can clean up and remove these files as part of `make.jl`.; 2. Using `NetCDFOutputWriter` in `jldoctest` we should use the `mode = ""c""` kwarg to avoid the info/warning message.; 3. `jldoctest` blocks should remove files at the end of the block (and there should be a way to hide this from the docs but not 100% sure right now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994:405,error,errors,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994,1,['error'],['errors']
Availability,Ah right sorry I missed that! Unfortunately yeah the error by itself isn't super helpful... Did the initial error come with any more info higher up in the log? Could also be nice to post the full log (if there's more to it).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796869175:53,error,error,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796869175,2,['error'],['error']
Availability,"Ah sorry you're right, good catch! I updated the original list with the actually supported topologies. Although I guess a side note worth mentioning is that I think you can create a grid with any topology and it won't error until it tries to construct a pressure solver. Might be clearer and more user friendly to print a useful error/warning when constructing the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1192#issuecomment-732278652:218,error,error,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1192#issuecomment-732278652,2,['error'],['error']
Availability,"Ah sorry, should have read your earlier message. I was able to reproduce the error locally with. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid); NetCDFOutputWriter(model, fields(model), filepath=""test.nc"", schedule=IterationInterval(1)); ```. <details><summary>Stacktrace</summary><p>. ```; Error showing value of type NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}:; ERROR: MethodError: no method matching short_show(::FieldSlicer{Colon,Colon,Colon}); Closest candidates are:; short_show(::AveragedTimeInterval) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/windowed_time_average.jl:209; Stacktrace:; [1] show(::IOContext{REPL.Terminals.TTYTerminal}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:490; [2] show(::IOContext{REPL.Terminals.TTYTerminal}, ::MIME{Symbol(""text/plain"")}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825:77,error,error,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825,3,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"Ah sorry. I think you should use. ```julia; pressure_solver = FFTBasedPoissonSolver(grid, FFTW.ESTIMATE); ```. PS try triple backticks (```) rather than single backticks (`) for formatting blocks of code / error messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294054674:206,error,error,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294054674,1,['error'],['error']
Availability,"Ah sure, you can use the mask! (I forgot this was a `GridFittedBoundary` and not a `GridFittedBottom`); In this case you just have to covert the mask to Int and then NaN it; ```; mask = Int.(mask); mask[mask .== 1] .= NaN; ```. then you add that to the `@lift`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480:25,mask,mask,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480,6,['mask'],['mask']
Availability,Ah we should probably add @johncmarshall54's suggested test before merging: ensure an ocean stratified along the direction of g remains at rest (up to some tolerance? not sure if it'll be machine precision zero).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783517290:156,toler,tolerance,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783517290,1,['toler'],['tolerance']
Availability,Ah we should probably add a warning/error in the `MultiGPU` constructor if `MPI.has_cuda() == false` in case a user tries to use `MultiGPU` without CUDA-aware MPI?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799556216:36,error,error,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799556216,1,['error'],['error']
Availability,Ah yeah that also gives the fft error,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731605078:32,error,error,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731605078,1,['error'],['error']
Availability,"Ah yes indeed, sorry I should have specified that the data sets were still usable, I was just confused by the error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1125115817:110,error,error,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1125115817,2,['error'],['error']
Availability,"Ah! Good to know! Thanks.; Argel Ramírez Reyes. > On Jan 14, 2022, at 3:10 PM, Navid C. Constantinou ***@***.***> wrote:; > ; > ; > I don't understand what is going on with my two PRs that are not passing the tests. Should I close and create them again from the latest master?; > ; > Nope. It's not your fault. We are having issues with the CI.; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013533717>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ABVLG6KOMQMGZB2JFMSZFMTUWCUM7ANCNFSM5K45P62A>.; > Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. ; > You are receiving this because you were mentioned.; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013539188:304,fault,fault,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130#issuecomment-1013539188,1,['fault'],['fault']
Availability,"Ah, I see. Sounds like it wouldn't be trivial to add that support. I guess a workaround to avoid partially-averaged results when picking up would be to set the `Checkpointer` to only write checkpoints when the `TimeAveraged` results are also written. I'm not sure what that would do to other (more frequent) outputs though, since it'd potentially try to write some time steps twice (and not in monotonic ordering)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1969259005:161,Checkpoint,Checkpointer,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1969259005,2,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoints']"
Availability,"Ah, I see... ```; @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); ```; that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054866428:164,robust,robust,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054866428,1,['robust'],['robust']
Availability,"Ah, apparently the error appears when we have an `AveragedTimeInterval`. Change the `simple_output` call to. ```julia; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, wout,; schedule = AveragedTimeInterval(10seconds),; filepath = ""windowed_avg.nc"", mode = ""c""); ```. and we have the following error:. ```; ERROR: LoadError: Custom output Uw needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{Coordinat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:19,error,error,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056,5,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Ah, but the ""cape"" is oriented in x --- it sticks out from the southern boundary with unit 1 and tapers to 0 as x -> -infty and +infty. If the flow comes in from the west, it would impinge on the cape. Right?. Note that y < exp(-x^2) is true along the entire southern boundary where `y=0` and `x` varies from `-10` to `+10`. So imposing an inflow along the southern boundary will be masked out, I believe, depending on the order of operations in `update_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852778265:383,mask,masked,383,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852778265,1,['mask'],['masked']
Availability,"Ah, it's true that in the continuous equations a Dirichlet condition can be specified without invoking the boundary normal. I'm not sure that holds for us though because we use the weak form of the equations. This means that all the boundary conditions boil down to specification of a `Flux`. In a sense `Value` and `Gradient` are really convenience features that _infer_ what the flux needs to be (assuming second order evaluation of the gradient across the boundary). So I think we need to know about the boundary normal for all boundary conditions... The name ""vector invariant"" is confusing but only refers to the advection of momentum, so I don't think it helps. After thinking about it a little bit I think we can implement a hack that will allow us to proceed for most cases. I think we can prescribe a priori a zero component of the boundary normal component of the viscous momentum flux. This will allow users to specify drag conditions. For example, a drag condition specifies only boundary-tangential viscous fluxes, and has the form `flux = C * u | u |` for boundaries with both `y` and `z` normal vectors (where `| u |` can be correctly evaluated due to masking). To specify a no-slip condition we would also have a normal component of the viscous flux, so we'll have to get a little smarter for that case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-849952733:258,down,down,258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-849952733,2,"['down', 'mask']","['down', 'masking']"
Availability,"Ah, thanks for clarifying as clearly I was mistaken. I thought I needed to impose the boundary conditions on the total field, background + deviation. If that's not the case then the boundary conditions are set up correctly. I believe the next thing to try is the same set up but without `BackgroundField` and imposing the Neumann boundary conditions associated with the buoyancy frequency. If that behaves correctly, then the problem would appear to be in `BackgroundField`, as you suspect. . **Update:** ; I made the following changes,. - Removed the background field from model,; - Added `N^2 * (z + D)` into the initial conditiosn of the buoyancy,; - Imposed `buoyancy_gradient_bc` at the top and bottom of the domain. Unfortunately, the same problems occur at the boundary. . This does not seem to be imposing the correct boundary conditions on a tracer field at the top and bottom. **Periodic condition:**; I did try setting the vertical direction to periodic and unfortunately that gave an error, copied below. . Is this a seperate problem or do people think it's related?. ```; ERROR: LoadError: ArgumentError: batching dims must be sequential; Stacktrace:; [1] create_plan(::CUDA.CUFFT.cufftType_t, ::Tuple{Int64,Int64,Int64}, ::Array{Int64,1}) at /home/fpoulin/.julia/packages/CUDA/wTQsK/lib/cufft/fft.jl:140; [2] plan_fft! at /home/fpoulin/.julia/packages/CUDA/wTQsK/lib/cufft/fft.jl:256 [inlined]; [3] plan_forward_transform at /home/fpoulin/software/Oceananigans.jl/src/Solvers/plan_transforms.jl:42 [inlined]; [4] plan_transforms(::GPU, ::RegularRectilinearGrid{Float64,Flat,Bounded,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CUDA.CuArray{Complex{Float64},3}, ::UInt32) at /home/fpoulin/software/Oceananigans.jl/src/Solvers/plan_transforms.jl:106; [5] Oceananigans.Solvers.FFTBasedPoissonSolver(::GPU, ::RegularRectilinearGrid{Float64,Flat,Bounded,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815670594:996,error,error,996,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815670594,2,['error'],['error']
Availability,"All the tests seem to pass but I get two errors. The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:41,error,errors,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141,4,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,AllSchedule for combining scheduling criteria and avoiding checkpointing with NaNs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2088:59,checkpoint,checkpointing,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088,1,['checkpoint'],['checkpointing']
Availability,Allow NaNChecker.erroring,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2087:17,error,erroring,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087,1,['error'],['erroring']
Availability,Allow `pickup=true` with zero checkpoints,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1161:30,checkpoint,checkpoints,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1161,1,['checkpoint'],['checkpoints']
Availability,Allow users to mask output,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3092:15,mask,mask,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3092,1,['mask'],['mask']
Availability,"Alright. Should I merge this as is for now and change later (I don't see much downsides in having an extra `view`), or should we wait for that bug to be fixed upstream?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866269536:78,down,downsides,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866269536,1,['down'],['downsides']
Availability,"Also curious --- do you split files to make them easier to download? I'm wondering if there is a better way. For example it would not be hard to design a utility that would automatically separate a file along some axis (such as the time axis) to produce smaller files for the purpose of downloading. For example something like. ```julia; download_chunk(download_spec, time_window=(0, 60days)); ```. where `download_spec` has the filename, remote directory, remote address, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392164334:59,down,download,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392164334,2,['down'],"['download', 'downloading']"
Availability,Also note the error comes from `ynode` (which is the `Flat` direction). I think that `ynode` is defined incorrectly for your grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860#issuecomment-1367096792:14,error,error,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860#issuecomment-1367096792,1,['error'],['error']
Availability,"Also reported by @qwert2266 but this is my fault since GitLab CI doesn't seem to be actually running GPU tests... Using something like; ```julia; @inline FT(x, y, z, t, T, p) = - exp(z/p.ℓ) * 2p.K/p.Δz^2 * T; T_forcing = Forcing(FT, field_dependencies=:T, parameters=bc_params); forcing = (T=T_forcing,); ```. causes. ```; ERROR: LoadError: GPU compilation of kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Oceananigans.Advection.CenteredSecondOrder, NonTraditionalFPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:43,fault,fault,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,2,"['ERROR', 'fault']","['ERROR', 'fault']"
Availability,Also the docs seem to fail because it can't find the docs for `ShallowWatermodel`?. ```; ┌ Error: no docs found for 'ShallowWaterModel' in `@docs` block in src/model_setup/overview.md:26-28; --;   | │ ```@docs;   | │ ShallowWaterModel;   | │; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126829065:91,Error,Error,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126829065,1,['Error'],['Error']
Availability,"Also to elaborate a bit: file extensions are _always_ arbitrary. The extension is just for people reading the contents of a directory, so they know what kind of data is contained in a file. For example this is fine:. ```bash; $ echo 'println(""Hello world!"")' >> test.txt ; $ julia --project test.txt [11:28:26]; Hello world!; ```. It's just poor communication to put your julia code in files appended with `.txt`. And your text editor won't highlight it correctly 😱 . So I think we really should somehow enforce extensions to help users communicate and love each other.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098308190:228,echo,echo,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098308190,1,['echo'],['echo']
Availability,"Also you will never get an error of the form ""X function is not implemented by CUDA"". The way GPU compilation works, functions with known CUDA analogues are converted appropriately at compile time. The rest are attempted to compile directly. The error you're getting probably means that `lambertw` cannot be completely type-inferred and compiled. For example the error involves a function invoked from `strings/io.jl` --- suggesting that `lambertw` may be trying to print something from your GPU kernel...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904984376:27,error,error,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904984376,3,['error'],['error']
Availability,"Also, I don't understand why we're calling masking events at update for every `NonhydrostaticModel` regardless of it having an `ImmersedGrid` or not:. https://github.com/CliMA/Oceananigans.jl/blob/d4a45adf21918f95ca4d23ec7167e720c44c501b/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl#L14-L19. The same goes for the hydrostatic model. Why not something like. ```julia; if model.grid isa ImmersedBoundaryGrid; # call masking; end; ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1225936417:43,mask,masking,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1225936417,2,['mask'],['masking']
Availability,"Also, I forgot to post an example of the error that happens when you pass an operation as a `condition`. Here's the error that I get in that case:. ```; ERROR: LoadError: MethodError: no method matching arch_array(::CPU, ::KernelFunctionOperation{Center, Center, Face, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64, typeof(boundary_node), Tuple{Center, Center, Face}}). Closest candidates are:; arch_array(::Distributed, ::Any); @ Oceananigans ~/repos/Oceananigans.jl/src/DistributedComputations/distributed_architectures.jl:263; arch_array(::CPU, ::Array); @ Oceananigans ~/repos/Oceananigans.jl/src/Architectures.jl:59; arch_array(::CPU, ::CUDA.CuArray); @ Oceananigans ~/repos/Oceananigans.jl/src/Architectures.jl:60; ... Stacktrace:; [1] condition_operand; @ ~/repos/Oceananigans.jl/src/ImmersedBoundaries/immersed_reductions.jl:24 [inlined]; [2] sum(f::Function, c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Periodic, Periodic, B",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1907385408:41,error,error,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1907385408,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Also, I noticed there was an error at the very beginning, copied below. ```; TEST_GROUP=shallow_water julia --project -e 'using Pkg; Pkg.test()'; Testing Oceananigans; ┌ Error: Pkg.Resolve.ResolverError(""Unsatisfiable requirements detected for package JLLWrappers [692b3bcd]:\n JLLWrappers [692b3bcd] log:\n ├─possible versions are: [1.0.0-1.0.2, 1.1.0-1.1.4, 1.2.0] or uninstalled\n ├─restricted to versions 1.1.3 by an explicit requirement, leaving only versions 1.1.3\n └─restricted by compatibility requirements with IntelOpenMP_jll [1d5cc7b8] to versions: 1.2.0 — no versions left\n └─IntelOpenMP_jll [1d5cc7b8] log:\n ├─possible versions are: 2018.0.3 or uninstalled\n └─restricted to versions 2018.0.3 by an explicit requirement, leaving only versions 2018.0.3"", nothing); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975:29,error,error,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975,2,"['Error', 'error']","['Error', 'error']"
Availability,"Also, I tried the following that mostly worked:; ```; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), y=(0, 5), topology=(Periodic, Bounded, Flat)). # Gaussian bump of width ""1""; bump(x, y, z) = y < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)); model = ShallowWaterModel(grid=grid_with_bump, gravitational_acceleration=1); ```. and it worked until the last line, which gave an error I copied below. I presume we should fix this before we think about doing any merging. Any suggestions @glwagner ?. ```; Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids ~/software/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: MethodError: no method matching with_halo(::Tuple{Int64, Int64, Int64}, ::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}); Closest candidates are:; with_halo(::Any, ::RegularRectilinearGrid) at /home/fpoulin/software/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:218; with_halo(::Any, ::VerticallyStretchedRectilinearGrid) at /home/fpoulin/software/Oceananigans.jl/src/Grids/vertically_stretched_rectilinear_grid.jl:242; Stacktrace:; [1] ShallowWaterModel(; grid::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}, gravitational_acceleration::Int64, architecture::Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844218915:559,error,error,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844218915,1,['error'],['error']
Availability,"Also, did you really wanted to include `RafsPlots.jl` in the PR? :). @sandreza, I'm adding [WIP] in the PR's title to denote ""Work in Progress"". Please remove it and ping us when you feel this PR is ready to be reviewed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-818240356:166,ping,ping,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-818240356,1,['ping'],['ping']
Availability,"Also, maybe we want to have a `dot` product that allows masking immersed regions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1237088551:56,mask,masking,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1237088551,1,['mask'],['masking']
Availability,"Also, the docs are failing to build with this error:. ```; ERROR: LoadError: IOError: sendfile: no space left on device (ENOSPC); ```. Do we still have a storage problem? I believe these tests run on tartarus, not sverdrup, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867678106:46,error,error,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867678106,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Also, what's the correct syntax to define kernel_parameters over one dimension? For example, the line; ```julia; kernel_parameters = KernelParameters((Nc, 1), (0, Nz_grid-1)); ```; works correctly. However, when I try to define it for one dimension with; ```julia; kernel_parameters = KernelParameters((1,), (Nz_grid-1,)); ```; I encounter the following error:; ```julia; ERROR: LoadError: MethodError: no method matching heuristic_workgroup(::Int64). Closest candidates are:; heuristic_workgroup(::Any, ::Any, ::Any, ::Any); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-aquaplanet/src/Utils/kernel_launching.jl:48; heuristic_workgroup(::Any, ::Any, ::Any); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-aquaplanet/src/Utils/kernel_launching.jl:48; heuristic_workgroup(::Any, ::Any); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-aquaplanet/src/Utils/kernel_launching.jl:48; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3611#issuecomment-2138476721:354,error,error,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3611#issuecomment-2138476721,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Also, you don't need the `field_dependencies` argument with `discrete_form=true` (but I think that has no effect, so just a side comment, maybe we should throw an error for that)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401332558:163,error,error,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401332558,1,['error'],['error']
Availability,Also:. * Changes test_examples.jl to spew example file into the build log on error.; * Makes a minor correction to the replace strings for the `ocean_wind_mixing_ and_convection.jl` example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/748:77,error,error,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/748,1,['error'],['error']
Availability,Also:; * Print available `CuDevice`s at startup; * Throw `ArgumentError` when attempting to construct a `Model{GPU}` when no CUDA-enabled GPU is detected. Resolves #82,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/148:15,avail,available,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/148,1,['avail'],['available']
Availability,"Although it seems an easy fix, I'm leaning more towards to dropping support for v1.8 since we don't test there any more. Even if this bug can be alleviated, who knows whether something else is broken (or even silently broken, without even spitting out an error).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1637026804:255,error,error,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1637026804,1,['error'],['error']
Availability,"Although the new `test_netcdf_file_splitting` is working, I'm currently having issues in with the `test_netcdf_time_averaging`, where this test fails.; https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/test_netcdf_output_writer.jl#L683; I've tested the PR & the `main` upstream branch in my computer and I have the same error:; ```; Stacktrace:; [1] macro expansion; @ ~/.julia/juliaup/julia-1.10.2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/Test/src/Test.jl:672 [inlined]; [2] test_netcdf_time_averaging(arch::CPU); @ Main ~/github/Oceananigans.jl/test/test_netcdf_output_writer.jl:727; [3] macro expansion; @ ~/github/Oceananigans.jl/test/test_netcdf_output_writer.jl:889 [inlined]; [4] macro expansion; @ ~/.julia/juliaup/julia-1.10.2+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/Test/src/Test.jl:1577 [inlined]; [5] top-level scope; @ ~/github/Oceananigans.jl/test/test_netcdf_output_writer.jl:880; NetCDF output writer [CPU]: Test Failed at /Users/jmtzmo/github/Oceananigans.jl/test/test_netcdf_output_writer.jl:727; Expression: all(isapprox.((ds[""c2""])[:, n + 1], c̄2(averaging_times), rtol = rtol)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3506#issuecomment-1994369830:362,error,error,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3506#issuecomment-1994369830,1,['error'],['error']
Availability,"Am I doing something wrong?; ```julia; navid:Oceananigans.jl/ (master) $ julia --project [19:00:13]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.1.0 (2019-01-21); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> include(""examples/internal_wave.jl""); ERROR: LoadError: could not open file /Users/navid/Research/Oceananigans.jl/examples/utils.jl; ...; ```. I guess the problem is the `include(""utils.jl"")` line found in all example .jl scripts. Is this supposed to be `src/utils.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/254:382,ERROR,ERROR,382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/254,1,['ERROR'],['ERROR']
Availability,Ambiguous halo size error in HydrostaticFreeSurfaceModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2983:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2983,1,['error'],['error']
Availability,Ambiguous method error when calculating a conditional `Average()` with an `ImmersedBoundaryGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:17,error,error,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['error'],['error']
Availability,"An important missing component of our user interface is a function-based API for extracting properties from models. For example, we often write. ```julia; u, v, w = model.velocities; ```. when we really should write something like. ```julia; u, v, w = velocity_field(model); ```. A major advantage of a function-based interface is that it is more robust to changes to the underlying model implementation. For example, we will eventually need a `VectorField` implementation for velocities (eg for the cubed sphere, or non-orthogonal grids). We'll be sorry that we've written `u, v, w = model.velocities` everywhere when we need to change `model.velocities` to `model.velocity_field`. But with a function-based interface we only have to change `velocity_field(model) = model.velocities` to `velocity_field(model) = model.velocity_field`. A few other functions besides `velocity_field` that we might want are. * `tracers(model)`; * `free_surface_displacement(model)`; * `kinematic_pressure(model)`; * `buoyancy(model)`. `viscosity(model)` and `diffusivities(model)` might be nice too. One challenge there is figuring out what to do when the viscosity or diffusivities are really tensors rather than scalars (eg we need `VectorField` but we also may need `TensorField`...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2156:347,robust,robust,347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156,1,['robust'],['robust']
Availability,"An update:. ```Julia; using Oceananigans. using Statistics; using Oceananigans.Units; using Oceananigans.Architectures: device_event; using Oceananigans.TimeSteppers: update_state!; using LinearAlgebra: norm. using Oceananigans.Models.HydrostaticFreeSurfaceModels:; ImplicitFreeSurface,; FreeSurface,; PCGImplicitFreeSurfaceSolver,; implicit_free_surface_step!. function set_simple_divergent_velocity!(model); # Create a divergent velocity; grid = model.grid. u, v, w = model.velocities; η = model.free_surface.η. u .= 0; v .= 0; η .= 0. # pick a surface cell at the middle of the domain; i, j, k = Int(floor(grid.Nx / 2)) + 1, Int(floor(grid.Ny / 2)) + 1, grid.Nz. inactive_cell(i, j, k, grid) && error(""The nudged cell at ($i, $j, $k) is inactive.""). if grid isa RectilinearGrid; Δy = grid.Δyᵃᶜᵃ; end. if grid isa LatitudeLongitudeGrid; Δy = grid.Δyᶜᶠᵃ; end. if grid isa ImmersedBoundaryGrid; if grid isa ImmersedBoundaryGrid && grid.underlying_grid isa RectilinearGrid; Δy = grid.underlying_grid.Δyᵃᶜᵃ; elseif grid.underlying_grid isa LatitudeLongitudeGrid; Δy = grid.underlying_grid.Δyᶜᶠᵃ; end; end. Δz = CUDA.@allowscalar grid.Δzᵃᵃᶜ. # We prescribe the value of the zonal transport in a cell, i.e., `u * Δy * Δz`. This; # way `norm(rhs)` of the free-surface solver does not depend on the grid extensd/resolution.; transport = 1e5 # m³ s⁻¹; CUDA.@allowscalar u[i, j, k] = transport / (Δy * Δz). update_state!(model). return nothing; end. arch = CPU(). rectilinear_grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (-5000kilometers, 5000kilometers),; y = (0, 100kilometers),; z = (-500, 0),; topology = (Bounded, Periodic, Bounded)). Lz = rectilinear_grid.Lz; width = rectilinear_grid.Lx / 20. bump(x, y) = - Lz * (1 - 0.2 * exp(-x^2 / 2width^2)). grid = ImmersedBoundaryGrid(rectilinear_grid, GridFittedBottom(bump)). free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; abstol=1e-15, reltol=0). model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938:698,error,error,698,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938,1,['error'],['error']
Availability,And if I modify the default free surface model to `free_surface = ImplicitFreeSurface(gravitational_acceleration=eltype(grid)(g_Earth))` I also get the same error (the docstring is also wrong for what the default free surface model is).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731593651:157,error,error,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731593651,1,['error'],['error']
Availability,"And just to clarify, this is what `dropdims(data, dims=(1, 2, 3))` does:. ```julia; julia> a = reshape([1], 1, 1, 1); 1×1×1 Array{Int64, 3}:; [:, :, 1] =; 1. julia> dropdims(a, dims=(1, 2, 3)); 0-dimensional Array{Int64, 0}:; 1; ```. A 0D array can only contain one value, but I guess it still cannot be automatically cast to a scalar:. ```julia; julia> b = dropdims(a, dims=(1, 2, 3)); 0-dimensional Array{Int64, 0}:; 1. julia> b[]; 1. julia> Float32(b); ERROR: MethodError: no method matching Float32(::Array{Int64, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] top-level scope; @ REPL[7]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857#issuecomment-1349668504:456,ERROR,ERROR,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857#issuecomment-1349668504,1,['ERROR'],['ERROR']
Availability,"And when I ran the same code, i received a segmentation fault and Julia failed!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2106#issuecomment-989086708:56,fault,fault,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2106#issuecomment-989086708,1,['fault'],['fault']
Availability,"Another PhD student working with me ran into this problem of very long initialization times too. He was using a Windows laptop and, like @jagoosw, I have been able to reproduce it using an apple silicon mac. Also, we are using JLD2 instead of NetCDF, so I don't think the problem is specific to apple silicon or NetCDF. Also, the problem goes away when I downgrade to Oceananigans v0.85.0. Wrapping the output in Field() as @zhihua-zheng suggested does seem to help, but even when doing that, the startup is quite slow using v0.90.1 when complex diagnostics are calculated. Downgrading to v0.85.0 downgrades other dependencies, so its hard to tell where the problem is arising. In case its useful, here is the list of packages that are downgraded when I go from 0.90.1 to 0.85.0:; ⌅ [052768ef] ↓ CUDA v5.1.0 ⇒ v4.4.1; ⌅ [0c68f7d7] ↓ GPUArrays v9.1.0 ⇒ v8.8.1; ⌅ [61eb1bfa] ↓ GPUCompiler v0.25.0 ⇒ v0.21.4; ⌅ [85f8d34a] ↓ NCDatasets v0.13.1 ⇒ v0.12.17; ⌃ [9e8cae18] ↓ Oceananigans v0.90.1 ⇒ v0.85.0; ⌅ [0e08944d] ↓ PencilArrays v0.19.2 ⇒ v0.18.1; ⌅ [4ee394cb] ↓ CUDA_Driver_jll v0.7.0+0 ⇒ v0.5.0+1; ⌅ [76a88914] ↓ CUDA_Runtime_jll v0.10.0+1 ⇒ v0.6.0+0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786:355,down,downgrade,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786,4,"['Down', 'down']","['Downgrading', 'downgrade', 'downgraded', 'downgrades']"
Availability,"Another idea after talking with @josuemtzmo: add another function called `checkpoint!(simulation, schedule)` that adds a checkpointer with an automatically generated name. (More to come on this idea)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2393923610:74,checkpoint,checkpoint,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2393923610,2,['checkpoint'],"['checkpoint', 'checkpointer']"
Availability,Another idea: check that the grid architecture and model architecture match to avoid issues like the test failure in #1467.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799734876:106,failure,failure,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799734876,1,['failure'],['failure']
Availability,"Another issue! I'm getting this error when setting up a NetCDFWriter:. ```julia; caused by: MethodError: no method matching construct_output(::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, MultiRegionObject{Tuple{Tuple{Colon, Colon, Colon}, Tuple{Colon, Colon, Colon}}, Tuple{CPU, CPU}}, MultiRegionObject{Tuple{OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, Tuple{CPU, CPU}}, Any, MultiRegionObject{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:32,error,error,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524,1,['error'],['error']
Availability,"Another possibility is to get rid of `diffusivity_fields` altogether and put fields inside the closures. Then users have to write things like `AnisotropicMinimumDissipation(grid)`, and we probably also need to stop ""auto halo inflation"" (instead throwing an error). Might be worth it though. Also if we have `halo = (3, 3, 3)` by default then users will basically never have issues with grid construction / halo sizes. Putting fields inside the closures also makes `OceanLearning.jl` more complicated. For example, if we want to change the parameters of a model closure, we ""only"" have to build a new closure with the same type but different parameters. If we put fields inside the closures, we have to work a little harder to combine the existing closure fields with new closure parameters. Those problems are all solvable, so it's just a question of whether simplifications here are worth complications elsewhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064169065:258,error,error,258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064169065,2,['error'],['error']
Availability,"Another though: I think we should limit errors to when we _know_ something is incorrect. Here we restricting what users can do because of our ""opinion"" about how users should write code, which I think is a misguided philosophy. A warning is appropriate because this is a mistake in the majority of cases, however.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126377818:40,error,errors,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126377818,1,['error'],['errors']
Availability,Another way would be to pass Oceananigans' `Clock` as an index. . This might be convenient because we usually pass the `clock` to functions (such as forcing and bc) so we always have it available,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696116590:186,avail,available,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696116590,1,['avail'],['available']
Availability,Any clue as to what amount of error we're introducing by using WENO5+`StretchedGrids`? Maybe enough to put an approx upper bound to the level of stretching we should use? I'm assuming this only becomes important when the grid stretching is too aggressive but who knows... Also I wonder how this plays out with https://github.com/CliMA/Oceananigans.jl/issues/1705,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-876037155:30,error,error,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-876037155,1,['error'],['error']
Availability,Any idea why docs fails? https://buildkite.com/clima/oceananigans/builds/8381#0182beb4-dc53-4ca9-9d6c-76d43f05f6b6. ```; /bin/bash: line 2: 815367 Segmentation fault (core dumped) /storage5/buildkite-agent/julia-1.6.7/bin/julia --color=yes --project=docs/ docs/make.jl; --;   | 🚨 Error: The command exited with status 139;   | user command error: exit status 139; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1221624853:160,fault,fault,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1221624853,3,"['Error', 'error', 'fault']","['Error', 'error', 'fault']"
Availability,"Anyone has any idea why all the errors with `all` or `interior` or `parent`? E.g.,. https://buildkite.com/clima/oceananigans/builds/11267#0187fd3b-6ccf-4f23-be19-445f384d6722/35-377",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1539359127:32,error,errors,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1539359127,1,['error'],['errors']
Availability,"Anyways, I don't quite see it but that could be the issue. So we can try replacing. ```julia; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval) ; ```. with. ```julia; if model.clock.time == wta.schedule.previous_interval_stop_time + wta.schedule.interval; wta.schedule.previous_interval_stop_time = model.clock.time; else; # Reset the ""previous"" interval time, subtracting a sliver that presents overshoot from accumulating. ; wta.schedule.previous_interval_stop_time = model.clock.time - rem(model.clock.time, wta.schedule.interval); end; ```. Another possible solution is to have a different algorithm in which time-averaging is ""finalized"" when output is retrieved. Retrieval occurs here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L197-L205. And we could set `collecting=false` and reset `wta_schedule.previous_interval_stop_time` there. The only downside is that bad things might happen if for some reason the `WindowedTimeAverage` is called in a callback (for logging or something) apart from when output is being asked for (since that would restart time averaging when not desired...). These issues do seem to motivate figuring out how to record the averaging window / iterations somehow when saving `WindowedTimeAverage` to disk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904:1100,down,downside,1100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747093904,1,['down'],['downside']
Availability,"Apologies - other urgent work and family needs have delayed me. I'm using; Julia 1.9.3; CairoMakie v0.9.4; and have in my status report; GLMakie v0.7.4 and Makie v0.18.4. I tried to use update with the pkg manager to no effect, but see I should be using CairoMakie@0.11, which I am now installing.; This was not successful. For example the file S7LmV_3TYIX.dll would not load giving a permission denied error, but my check of the properties/security did not reveal a deficiency. However, the example worked fine. Many thanks - Kevin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1920152651:403,error,error,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1920152651,1,['error'],['error']
Availability,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:155,error,error,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784,5,"['ERROR', 'error']","['ERROR', 'error', 'errorhandling']"
Availability,"Apparently defining a forcing in this way actually slows the model down by a lot. It's ~2x slower with just this one forcing function which seems a little excessive. ```julia; @inline FT(grid, U, Φ, i, j, k) = ifelse(k == 1, -1e-4 * (Φ.T[i, j, 1] - 0), 0); forcing = Forcing(FT=FT); ```. Seems that maybe the exact way the forcing function is defined could have a huge impact on performance.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365:67,down,down,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365,1,['down'],['down']
Availability,"Apparently the new syntax does help avoid `@allowscalar` instances, and things do compile locally for me, but the errors on buildkite are still [there](https://buildkite.com/clima/oceananigans/builds/9727#01860b25-0d9a-419e-bd01-3ec11bcb8c6b/38-603):. ```; Computations with Averaged Fields [GPU, RectilinearGrid]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-13/clima/oceananigans/test/test_computed_field.jl:583; --;   | Expression: all(interior(tke_yz) .== 9 / 2); ```. Any ideas on what might be the cause of the differences between builkite and my local server? If someone could also run one of the failing tests on a GPU locally and see if they get the same errors that buildkite is throwing, that would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1414131063:114,error,errors,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1414131063,2,['error'],['errors']
Availability,Are doctest failures where the output writer is reporting the file size differently to what the doctrine from a different PR and fixed now?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2273539332:12,failure,failures,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2273539332,1,['failure'],['failures']
Availability,"Are the `state_callbacks` something completely deprecated?. ```Julia; julia> using Oceananigans. julia> model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> function modify_tracer(model, params); model.timestepper.Gⁿ[params.c] .+= params.δ; end; modify_tracer (generic function with 1 method). julia> model.state_callbacks[:modify_u] = Callback(modify_tracer, IterationInterval(1), (c = :u, δ = 1)); ERROR: MethodError: no method matching Callback(::typeof(modify_tracer), ::IterationInterval, ::NamedTuple{(:c, :δ), Tuple{Symbol, Int64}}). Closest candidates are:; Callback(::F, ::S, ::P, ::CS) where {P, F, S, CS}; @ Oceananigans ~/Research/OC10.jl/src/Simulations/callback.jl:8; Callback(::Any, ::Any; parameters, callsite); @ Oceananigans ~/Research/OC10.jl/src/Simulations/callback.jl:46; Callback(::Oceananigans.OutputWriters.WindowedTimeAverage, ::Any; kw...); @ Oceananigans ~/Research/OC10.jl/src/Simulations/callback.jl:68; ... Stacktrace:; [1] top-level scope; @ REPL[56]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3454#issuecomment-1925614234:744,ERROR,ERROR,744,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3454#issuecomment-1925614234,1,['ERROR'],['ERROR']
Availability,"Are you sure this is exactly the same code that you ran? . I tried executing it as is and found an error on this line. ```; T_bcs = FieldBoundaryConditions( top = FluxBoundaryCondition(heatflux(t)),; bottom = GradientBoundaryCondition(dTdz)); ```. The error is the following:. ```; ERROR: UndefVarError: t not defined; Stacktrace:; [1] top-level scope; @ REPL[38]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902649636:99,error,error,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902649636,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"As @glwagner pointed out, the code is not set up to support this feature. . `ContinuousBoundaryFunction`s and `DiscreteBoundaryFunction`s are supported only for `Flux` boundary conditions at the moment, where the boundary contribution is added as an additional tendency rather than filling the halo regions. . If we want to support these more complicated BC for `Open`, `Value` and `Gradient`, we have to make sure that in all places where we use the `fill_halo_regions!` we also pass as arguments the `clock` and all the `model_fields`, which might be doable. In this case you are hitting this problem in the hydrostatic model because in the `ImplicitFreeSurfaceSolver` there is a `fill_halo_regions!` for velocities that does not pass `clock` and `model_fields`, making julia complain. https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L137. If you use the SplitExplicit the error disappears. This is not to say that the solution will be correct because still the barotropic velocities and barotropic volume fluxes will not account for those open boundary conditions.; Also for `Nonhydrostatic`, even if the script does not error, there might be some subtleties for which the result is incorrect. The correct implementation of open boundary conditions should be in #3842",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2178789178:979,error,error,979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2178789178,2,['error'],['error']
Availability,"As @navidcy hints I think the difficulties here are using `Plots.jl` on a headless system. To address this issue @navidcy is suggesting that you execute / write `ENV[""GKSwstype""] = ""100""` at the top of the tutorial. Alternatively, you can avoid remote plotting and attempt to run the `@animate` block locally, after downloading the data. I do think it is convenient to plot remotely however, so it'd be nice if you can make that work for you. Searching ""headless plotting julia Plots"" might turn up more information (I didn't find anything immediately, but I've seen useful threads before and it'd be nice to paste them here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1281#issuecomment-752068938:316,down,downloading,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281#issuecomment-752068938,1,['down'],['downloading']
Availability,"As GPUifyLoops.jl relies on Julia 1.1+, so does Oceananigans. We should print an error (there must be some Julia pattern people do here) if someone tries to run Oceananigans with Julia <1.1. Currently it's really bad for usability as Ubuntu repositories are ancient as usual and still on Julia 1.0.3, and Debian is probably even worse. And you get pretty cryptic messages if running Oceananigans from Julia 1.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/193:81,error,error,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/193,1,['error'],['error']
Availability,"As a side note, I noticed recently that Julia does something similarly specific and helpful for the MATLABians at the REPL:. ```julia; julia> a = [1]; 1-element Vector{Int64}:; 1. julia> a(1); ERROR: MethodError: objects of type Vector{Int64} are not callable; Use square brackets [] for indexing an Array.; Stacktrace:; [1] top-level scope; @ REPL[5]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047878192:193,ERROR,ERROR,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047878192,1,['ERROR'],['ERROR']
Availability,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644:253,error,error,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644,2,['error'],['error']
Availability,"As an update, I have pushed a commit consisting of a working version of the double gyre example, where Δz is replaced by zspacings and znodes, the plots are improved with additional attributes, and visualization is performed on the CPU even if the code runs on the GPU. I still need to incorporate some of the suggested modifications listed above. I am uploading the plots and animation here. In today's meeting with Navid and Simone, we looked at switching to the lat-lon grid and more. In the upcoming commits, I will run for longer time on a lat-lon grid, introduce checkpoints for restarting the simulation, and add a topography. . [double_gyre_grid_spacing.pdf](https://github.com/CliMA/Oceananigans.jl/files/11493173/double_gyre_grid_spacing.pdf). [double_gyre_circulation.pdf](https://github.com/CliMA/Oceananigans.jl/files/11493174/double_gyre_circulation.pdf). https://github.com/CliMA/Oceananigans.jl/assets/12926768/cf148a0c-58c8-4ba2-b649-cb40418d0665",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-1550535207:569,checkpoint,checkpoints,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-1550535207,1,['checkpoint'],['checkpoints']
Availability,"As discussed in #3177 , there is a version bug with `fkeep` and Julia 1.8.3 (1.9.2 works fine).; Trying to use `ImmersedBoundaryGrid` with `HydrostaticFreeSurfaceModel` returns the following error:. ```julia; MethodError: no method matching fkeep!(::Oceananigans.Solvers.var""#60#61"", ::SparseArrays.SparseMatrixCSC{Float64, Int64}); ```. Minimal reproducible example:. ```julia; using Oceananigans. underlying_grid = RectilinearGrid(; size=(100, 100, 10),; x=(-2pi, 2pi),; y=(-2pi, 2pi),; z=(-2, 0),; topology=(Bounded, Bounded, Bounded),; halo=(4, 4, 4); ). @inline bathymetry(x,y) = sin(x)*sin(y)-1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)). model = HydrostaticFreeSurfaceModel(; grid); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184:191,error,error,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184,1,['error'],['error']
Availability,"As for the `with_halo`, I am testing things out in REPL. Below you see that I have `with_halo` defined already but when I try the line you suggested it says that the function must be explicitly exported to be extended. Sorry that my function defining chops are not skilled enough to figure this out. ```; julia> methods(with_halo); # 2 methods for generic function ""with_halo"":; [1] with_halo(new_halo, old_grid::RegularRectilinearGrid) in Oceananigans.Grids at /home/fpoulin/software/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:218; [2] with_halo(new_halo, old_grid::VerticallyStretchedRectilinearGrid) in Oceananigans.Grids at /home/fpoulin/software/Oceananigans.jl/src/Grids/vertically_stretched_rectilinear_grid.jl:242. julia> with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ERROR: error in method definition: function Grids.with_halo must be explicitly imported to be extended; Stacktrace:; [1] top-level scope; @ none:0; [2] top-level scope; @ REPL[40]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844329017:858,ERROR,ERROR,858,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844329017,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"As pointed out by @kburns, if you're interested in bit reproducibility you may also need to set the FFTW plan (by default, FFTW is not reproducible even on identical architectures). I'm not sure this is your issue (I have doubts...) but if you want to be thorough you may want to check this. To set the plan you have to build the pressure solver manually with something like:. ```julia; using Oceananigans.Solvers: FFTBasedPoissonSolver; using FFTW. pressure_solver = FFTBasedPoissonSolver(grid, planner_flag=FFTW.ESTIMATE); model = NonhydrostaticModel(; grid, pressure_solver, other_kwargs...); ```. I'd be surprised if ""round-off errors"" accumulate enough to cause the differences you're seeing (but it does seem at least possible, especially for very long runs at relatively coarser resolutions where slight differences in the eddy diffusivity might lead to slightly different turbulent trajectories). Hope that helps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1293645479:632,error,errors,632,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1293645479,1,['error'],['errors']
Availability,Assert that the topology is Flat in the vertical and also have a test that `Periodic` or `Bounded` in the vertical creates an error.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662:126,error,error,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662,1,['error'],['error']
Availability,"At least some of the tests are failing with the error. ```; [2021/05/17 14:55:47.365] INFO Testing distributed FFT-based Poisson solver...; --; &nbsp; | Error During Test at AssertionError: ShallowWaterModel requires `topology(grid, 3) === Flat`. Use `topology = (Periodic, Periodic, Flat)` when constructing `grid`.; ```. In other words, the tests are hitting the assertion that this PR adds. The tests should be fixed to use grids with a `Flat` vertical topology.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842646162:48,error,error,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842646162,2,"['Error', 'error']","['Error', 'error']"
Availability,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] Spin down of a flow-field under the influence of friction; - [ ] Thermal wind balance: specify a density structure and compare model velocity fields with analytical solution; - [ ] Rayleigh–Bénard convection (I think analytic solutions exist at low Rayleigh number?); - [ ] Onset of baroclinic instability: compare growth rates with analytical predictions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/157:155,down,down,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/157,1,['down'],['down']
Availability,"At the moment the error throwing in the function `validate_index()` isn't working due to an undefined variable. For indices that aren't valid, the error ends up being not useful:. ```julia; caused by: UndefVarError: I not defined; Stacktrace:; [1] validate_index(idx::UnitRange{Int64}, loc::Type, topo::Type, N::Int64, H::Int64); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:90; [2] validate_index; @ /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:94 [inlined]; ```. This PR fixes that with a simpler error message.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2824:18,error,error,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824,3,['error'],['error']
Availability,"At the moment this is possible:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = 1:1:10, y=1:1:10,; z = 1:1:10, ; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 5.0) variably spaced with min(Δx)=1.0, max(Δx)=1.0; ├── Periodic y ∈ [1.0, 5.0) variably spaced with min(Δy)=1.0, max(Δy)=1.0; └── Bounded z ∈ [1.0, 5.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> grid.Nz; 4. julia> length(grid.zᵃᵃᶜ); 10; ```; Meaning, you can pass a certain size to the constructor, say `Nx`, and also pass an array for that direction (to ""stretch it"") that has a different size than `Nx`. I haven't investigated the consequences of this, but this feels like it could cause problems. Should we throw a warning/error in these cases?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2548:818,error,error,818,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548,1,['error'],['error']
Availability,"At the moment, . ```Julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 10×1×10 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [-100.0, 100.0) regularly spaced with Δx=20.0; ├── Flat y; └── Bounded z ∈ [-100.0, 0.0] regularly spaced with Δz=10.0. julia> free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7); SplitExplicitFreeSurface with Oceananigans.Models.HydrostaticFreeSurfaceModels.FixedTimeStepSize{Float64, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.averaging_shape_function)}(0.44706193949348216, Oceananigans.Models.HydrostaticFreeSurfaceModels.averaging_shape_function); ```; doesn't error!. (A show method is in order though...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3311#issuecomment-1748796662:757,error,error,757,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3311#issuecomment-1748796662,1,['error'],['error']
Availability,"At the moment, restarting from checkpoints does not allow to restart from data with different halo size.; In particular, I encountered this issue when I wanted to restart a simulation with a different advection order from already evolved data. We might want to support this feature since, when dealing with large complex simulations, a lot of trial and error has to be done in order to find the optimal parameters, which include order of advection (and sub-stepping size for the free surface, which involves halo size for distributed simulations). If there is interest in this feature, I can start implementing it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3206:31,checkpoint,checkpoints,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206,2,"['checkpoint', 'error']","['checkpoints', 'error']"
Availability,"At the moment, to solve equations on a two-dimensional grid one has to provide `Nz=1` and any `Lz` they wish. For example, giving `Lz=2e-16` works pretty well:. ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, eps(Float64))); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [0.0, 6.283185307179586], z ∈ [-2.220446049250313e-16, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 2.220446049250313e-16); ```. However, `Lz=0` spits out an error...; ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, 0)); ERROR: ArgumentError: Elements of extent=(6.283185307179586, 6.283185307179586, 0) must be > 0!; Stacktrace:; [1] validate_tupled_argument at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:306 [inlined]; [2] validate_regular_grid_size_and_extent(::Type{T} where T, ::Tuple{Int64,Int64,Int64}, ::Tuple{Float64,Float64,Int64}, ::Tuple{Int64,Int64,Int64}, ::Nothing, ::Nothing, ::Nothing) at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:330; [3] RegularCartesianGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Nothing, y::Nothing, z::Nothing, extent::Tuple{Float64,Float64,Int64}, topology::Tuple{DataType,DataType,DataType}, halo::Tuple{Int64,Int64,Int64}) at /Users/navid/Research/Oceananigans.jl/src/Grids/regular_cartesian_grid.jl:126; [4] top-level scope at REPL[33]:1; ```. Perhaps it makes sense that there should be a check and each dimension that has extent =0 and number of grid-points =1 should be treated ""specially"" and bypass the validation at https://github.com/CliMA/Oceananigans.jl/blob/e808a821d78949b0482b8372533e992cabb5d65f/src/Grids/grid_utils.jl#L306?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1001:665,error,error,665,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1001,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Auxiliary fields not directly available to tracer forcing functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2730:30,avail,available,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2730,1,['avail'],['available']
Availability,Available Potential Energy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297:0,Avail,Available,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297,1,['Avail'],['Available']
Availability,"Awesome! And to be more clear, I think the reason we want it to work is so that we can also reuse all the other schedules. Another reason to use it is because we may need to change `TimeInterval` in the future if we support different time types (for example `DateTime`, or other time types that solve the annoying problem of rounding error). So in all those cases it will be nice not to have to worry about different implementations of time interval schedules.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3523#issuecomment-2023010994:334,error,error,334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3523#issuecomment-2023010994,2,['error'],['error']
Availability,"Awesome! I'm happy to sit down and chat. I've had two meetings today with; MIT groups (ocean engineering and self-assembly lab), so maybe next week...; ;-). Gabriel D Weymouth; _______________________________________________; ""Computers are useless. They can only give you answers."" Pablo Picasso. On Fri, Oct 30, 2020 at 3:52 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Fun pair programming sesh with @ali-ramadhan; > <https://github.com/ali-ramadhan> @whitleyv <https://github.com/whitleyv>; > lead to this!; >; > [image: flow_around_cylinder]; > <https://user-images.githubusercontent.com/15271942/97726829-083c6080-1aa6-11eb-8c62-c38771eac0bf.gif>; >; > Implementation is here:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/src/TimeSteppers/correct_immersed_tendencies.jl; >; > and the script that produced the above animation:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/examples/flow_around_cylinder.jl; >; > We just did something very simple as a starting point --- hopefully more; > to come.; >; > @weymouth <https://github.com/weymouth> thanks for your insights ---; > could make sense to schedule a meeting sometime soon to discuss next steps.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719635414>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AADSKJYHOUF5GATVQ66VU7TSNLOMHANCNFSM4SNJ4CSA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719715164:26,down,down,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719715164,1,['down'],['down']
Availability,"Awesome, thank you, that's helpful. Stochastic errors are troubling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-747098083:47,error,errors,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-747098083,1,['error'],['errors']
Availability,"BTW, in the next release of `NCDatasets.jl`,`defVar` will throw an error if there is an unrecognized keyword \(See this [change](https://github.com/Alexander-Barth/NCDatasets.jl/issues/212)\). That means that older versions of `Oceananigans.jl` \(\< 0.84\) will not work with newer versions of `NCDatasets.jl` \(\>0.12.17\).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608564895:67,error,error,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608564895,1,['error'],['error']
Availability,"Backend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/l",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:3641,ERROR,ERROR,3641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['ERROR'],['ERROR']
Availability,"Bah, fail. How about typing. ```julia; julia> using Oceananigans.Fields: AbstractGPUField; ```. For example on my laptop I get:. ```julia; julia> using Oceananigans.Fields: AbstractGPUField; [ Info: Oceananigans will use 8 threads; ERROR: UndefVarError: AbstractGPUField not defined; ```. whereas on a machine with a GPU I get no error. As @ali-ramadhan noted it looks like the method for `set!` that's defined in a `@hascuda` block is not defined for your version of Oceananigans. (You may also need to rebuild Oceananigans after you verify that `CUDA.has_cuda()` returns `true`? I've never encountered this issue but some others may have.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1555#issuecomment-815424494:232,ERROR,ERROR,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1555#issuecomment-815424494,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Barebones checkpointing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/324:10,checkpoint,checkpointing,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/324,1,['checkpoint'],['checkpointing']
Availability,"Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:611; [25] maximum; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:606 [inlined]; [26] #maximum#36; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:620 [inlined]; [27] maximum; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:620 [inlined]; [28] data_summary(field::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Gri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:18878,mask,mask,18878,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['mask'],['mask']
Availability,"Based on. https://github.com/CliMA/Oceananigans.jl/blob/2e4ba6b36bf012d5dcb89ddc7160a10f774aadbe/src/TurbulenceClosures/turbulence_closure_diagnostics.jl#L67-L69. CATKE should also have an infinite cell diffusion timescale with the default implicit time discretization. When CATKE is run with explicit time discretization I suppose the cell diffusion timescale should be computed from the maximum viscosity/diffusivity in `model.diffusivity_fields`. Happy to add these `cell_diffusion_timescale` methods. I know `CATKEVerticalDiffusivity` is not exported so I'm just opening the issue to document. ---. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = RectilinearGrid(size=(12, 12, 12), extent=(1, 1, 1)); closure = CATKEVerticalDiffusivity(); buoyancy = SeawaterBuoyancy(); tracers = (:T, :S, :e). model = HydrostaticFreeSurfaceModel(; grid, closure, buoyancy, tracers). DiffusiveCFL(1.23)(model); ```. Error:. ```; ERROR: MethodError: no method matching cell_diffusion_timescale(::CATKEVerticalDiffusivity{…}, ::@NamedTuple{…}, ::RectilinearGrid{…}). Closest candidates are:; cell_diffusion_timescale(::Nothing, ::Any, ::Any); @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:22; cell_diffusion_timescale(::ScalarBiharmonicDiffusivity{Dir}, ::Any, ::Any) where Dir; @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:40; cell_diffusion_timescale(::SmagorinskyLilly, ::Any, ::Any); @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:47; ... Stacktrace:; [1] cell_diffusion_timescale(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.TurbulenceClosures ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:21; [2] (::CFL{…})(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.Diagnostics ~/atdepth/Oceananigans.jl/src/Diagnostics/cfl.jl:25; [3] top-level scope",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3772:963,Error,Error,963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3772,1,['Error'],['Error']
Availability,"Before the recent overhaul to callbacks, `NaNChecker` exited with an error. While I agree that exiting without an error is convenient at times, it would be good to have the built-in option to keep the original behavior. For example, consider a code that runs a simulation and then writes a checkpointer after it's done running. The legacy behavior was that if the simulation blew up, `run!` threw an error and the rest of the script (including the checkpointing) wouldn't happen. That would allow the user to restart the simulation from the latest checkpointer (possibly with a lower cfl threshold). Now if the simulation blows up, a checkpointer (full of NaNs) is still written, possibly overwriting the previous checkpointer. I know we can cook up a callback that manually throws an error, but this seems like a common enough case that there should be a built-in option for it. (Or maybe it's just me?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086:69,error,error,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086,9,"['checkpoint', 'error']","['checkpointer', 'checkpointing', 'error']"
Availability,"Before this PR, the following would *NOT* error:. ```Julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. After this PR:. ```Julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:109; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Vector{Float64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[13]:1; ```. ```; julia> grid = LatitudeLongitudeGrid(size=(2, 2, 2), longitude=(-20, 20), latitude=(10, 20), z=[0, -0.5, -1], topology=(Bounded, Bounded, Bounded)). ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319:42,error,error,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Before this PR:. ```julia; julia> using Oceananigans. julia> NamedTuple(); Error showing value of type NamedTuple{(), Tuple{}}:; ERROR: ArgumentError: collection must be non-empty; ```. After this PR:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 8 threads. julia> NamedTuple(); NamedTuple(); ```. you'd think this stuff would be easy. Closes #2398",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2401:75,Error,Error,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2401,2,"['ERROR', 'Error']","['ERROR', 'Error']"
Availability,"Below is a link to a paper that compares the scalability of multi-threading in Python, Julia and Chapel. . Brief Summary: They find that none of them do as well as OpenMP but give some reasons as to why. But they do find some improvements going up to 64 threads, but the effiicency in some cases go down to 20%. It seems that Python might do better on low numbers of threads but Julia does better on more. This was last year so I am sure this should probably redone. Also, I should mention I don't believe their problem is like ours but it's an example and has some pictures, so that's nice to see. https://hal.inria.fr/hal-02879767/document",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610:299,down,down,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610,1,['down'],['down']
Availability,"Below is a minimal working example of the problem:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(Float64,; size = (4, 4, 4),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). b_initial(x, y, z) = rand(). model = NonhydrostaticModel(; ; grid = grid,; buoyancy = BuoyancyTracer(),; tracers = (:b),; timestepper = :RungeKutta3). simulation = Simulation(model, Δt=0.1, stop_iteration=200); outputs = merge(model.velocities, model.tracers). simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""$(FILE_DIR)/instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=1). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399:705,checkpoint,checkpointer,705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399,2,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpointer']"
Availability,"Below you will see two plots of the rates of convergence rusing schemes that exist in Oceananigans. . This plot uses the solution obtained from Oceananigans directly. The lower order methods produce the correct slopes but the high order methods flatten out because of truncation error. The error I is consistent with single precision accuracy. ; (The slopes in the legend are taken from the plot shown below and are not the slopes of the curves from Oceananigans.) . ![convergence_rates_oceananigans](https://user-images.githubusercontent.com/8239041/103024246-79841700-451d-11eb-8321-454171fa2381.png). This plot is similar but computed using my own time-stepping code but it does use `advective_tracer_flux_x`. In developing this code I was able to ensure that everything is double precision and they give the correct slopes. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103024241-7721bd00-451d-11eb-8717-6437c7c2c577.png). **Good news:** The advection schemes in Oceananigans can produce the correct slopes, as predicted by theory. **Bad news:** Some part of Oceananigans (maybe times-stepping?) must use single precision accuracy, and that truncates the error of the method as a whole. Question: where is the bottleneck that reduces the global spatial accuracy from double to single precision?. This third figure shows the result for increased spatial resolution and we observe that the higher order methods saturate near `1e-16`, as you would expect from double precision. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103028959-c7514d00-4526-11eb-94c6-81fb3d429882.png). In case you are interested, these are the calculations of the rates of convergence for the two sets of calculations. ```; Method = Center2ⁿᵈ, Rate of Convergence = 1.99, Expected = 2; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = Upwind3ʳᵈ, Rate of Convergence = 2.99, Expected = 3; Method = UpwindBiasedThirdOrder(), Rate of Convergenc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595:279,error,error,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595,2,['error'],['error']
Availability,Better error when the closure is not valid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753:7,error,error,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753,1,['error'],['error']
Availability,"Biharmonic operator requires more halo cells than the classical Laplacian, so the `conditional_flux` method for the immersed boundary must be adapted to shut down fluxes from biharmonic diffusion up to 2 cells distance from an immersed boundary. Or maybe find a more sustainable solution, for example refactoring the biharmonic diffusivity to be calculated `∇²κ∇²` (which might require some work)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2209:158,down,down,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209,1,['down'],['down']
Availability,Binary comparison operators and more robust support for Fields-as-conditionals,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2169:37,robust,robust,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2169,1,['robust'],['robust']
Availability,"Bleh, I get the same error with `immersed_hydrostatic_diffusion.jl`. I think there's a bug in the constructor. Let's not worry about it here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900468098:21,error,error,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900468098,1,['error'],['error']
Availability,"Btw, I noticed in the error stack that @ali-ramadhan pasted above that the Nonhydrostatic model method is used at some point... ```; [14] cufunction(f::typeof(Oceananigans.Models.NonhydrostaticModels.gpu__update_hydrostatic_pressure!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, LatitudeLongitudeGrid{…}, Buoyancy{…}, @NamedTuple{…}}}; kwargs::@Kwargs{always_inline::Bool, maxthreads::Int64}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:375; ```. Is this expected?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439727625:22,error,error,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439727625,1,['error'],['error']
Availability,"Btw, the problem is not related with bathymetry directly. It's related with the Heptadiagonal Matrix-based free surface solver. When there is an immersed boundary the default free-surface solver is the Heptadiagonal Matrix-based solver so that's why we get the error above. But an immersed boundary grid is not really required. ```julia; test_Oceananigans/ $ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.5 (2023-01-08); _/ |\__'_|_|_|\__'_| |; |__/ |. (@v1.8) pkg> activate .; Activating new project at `~/Research/test_OC`. (test_Oceananigans) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General.toml`; Resolving package versions...; Updating `~/Research/test_OC/Project.toml`; [9e8cae18] + Oceananigans v0.84.1; Updating `~/Research/test_OC/Manifest.toml`; [621f4979] + AbstractFFTs v1.4.0; [79e6a3ab] + Adapt v3.6.2; [4fba245c] + ArrayInterface v7.4.11; [a9b6321e] + Atomix v0.1.0; [ab4f0b2a] + BFloat16s v0.4.2; [fa961155] + CEnum v0.4.2; [179af706] + CFTime v0.1.2; [052768ef] + CUDA v4.4.0; [1af6417a] + CUDA_Runtime_Discovery v0.2.2; [d360d2e6] + ChainRulesCore v1.16.0; [9e997f8a] + ChangesOfVariables v0.1.8; [1fbeeb36] + CommonDataModel v0.2.4; [34da2185] + Compat v4.7.0; [a8cc5b0e] + Crayons v4.1.1; [7445602f] + CubedSphere v0.2.3; [9a962f9c] + DataAPI v1.15.0; [864edb3b] + DataStructures v0.18.14; [e2d170a0] + DataValueInterfaces v1.0.0; [ffbed154] + DocStringExtensions v0.9.3; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.9; [7a1cc6ca] + FFTW v1.7.1; [5789e2e9] + FileIO v1.16.1; [0c68f7d7] + GPUArrays v8.8.1; [46192b85] + GPUArraysCore v0.1.5; [61eb1bfa] + GPUCompiler v0.21.4; [c27321d9] + Glob v1.3.1; [615f187c] + IfElse v0.1.1; [40713840] + IncompleteLU v0.2.1; [3587e190] + InverseFunctions v0.1.11; [92d709cd] + IrrationalConstants v0.2.2; [42fd0dbc] + IterativeSolvers v0.9.2;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:261,error,error,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['error'],['error']
Availability,"Builds off @vchuravy's work in #261. Preliminary design of user API for concrete models. Probably most of the time the user will have to specify boundary conditions prior to building the model. We'll have to come up with good syntax for that. What we have is ok, but can be improved. The checkpointing tests currently fail, I think because they attempt to change the types of the some of the model fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/263:288,checkpoint,checkpointing,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/263,1,['checkpoint'],['checkpointing']
Availability,Bump down to 0.64.0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2038:5,down,down,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2038,1,['down'],['down']
Availability,Bump v0.49.0 (as a checkpoint),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1388:19,checkpoint,checkpoint,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1388,1,['checkpoint'],['checkpoint']
Availability,Bumping down to 0.64.0 since #1971 accidentally bumped too far to 0.65.0.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2038:8,down,down,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2038,1,['down'],['down']
Availability,But I wouldn't mind adding the post-processing masking step with the hope we can eliminate it when masking is enabled for OutputWriters; see https://github.com/CliMA/Oceananigans.jl/pull/3092,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983800733:47,mask,masking,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983800733,2,['mask'],['masking']
Availability,"But `Δt = clock.time - wta.previous_collection_time ` is not the simulation time-step. It's the time increment between collections. We can change the symbol to `T = clock.time - wta.previous_collection_time` to help clarify this. Moreover, do you think that a small error in `T` would cause the kind of issue that @liuchihl is seeing? It looks to me like the average is not calculated at all --- rather than having a small round-off error. . PS I updated your comment to show more of the code so that we could see explicitly the part of the code you were referring to. EDIT: and just to clarify the time increment between collections can be more than one time-step because we support strided averages (eg computing the averaged quantity less frequently than every time step).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2263780904:266,error,error,266,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2263780904,2,['error'],['error']
Availability,But locally I get no error! That's strange.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630234724:21,error,error,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630234724,1,['error'],['error']
Availability,"But the `solid_interface` function would have to be different right? . I ll give an example:. ```. Solid Fluid; -------.................; | ∘ | ∘ |; f c f c f; i-1 i-1 i i i+1. ```; In this case `z(c[i-1]) < immersed_boundary` (i.e. `solid_interface(f, i, j, k, grid) = true`) but here I think we do not want to mask the normal velocity which resides on `f[i]`. Actually, what are we going to do with that velocity? . I think usually people interpolate using `f[i+1]` and assuming that `u` is zero at the actual immersed boundary (inbetween `c[i-1]` and `f[i]`)....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042484279:312,mask,mask,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042484279,1,['mask'],['mask']
Availability,"But the change here doesn't affect whether the approximation converges with spatial resolution (ie it is correct). It's just that, in the presence of numerical _error_, the change has different properties. I think its helpful to take ""bug"" to mean something that produces incorrect results, not low quality results. For example, certain ways of writing arithmetic lead to larger round-off error than others. This doesn't mean the ""worse"" ways are a ""bug"". It's just that their error properties can be improved. If we take this definition further, then `CenteredSecondOrder` has a ""bug"", because it produces a lot of oscillatory errors. Is that the definition of ""bug"" we want?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529051454:389,error,error,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529051454,3,['error'],"['error', 'errors']"
Availability,"By ""mutable"" function you mean one that modifies its args? But don't they all return nothing?. Seems you are getting down to the bottom it yourself... Perhaps try writing a simple code of your own then and running the debugger there? E.g. ```julia; function my_own_function!(a); a = 2a; return nothing; end. a = 17. my_own_function!(a). b = 10a; ```. or something like that and see if you get the same error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616937963:117,down,down,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616937963,4,"['down', 'error']","['down', 'error']"
Availability,"By default `NetCDFOutputWriter` uses `mode = ""c""` which overwrites existing files. The problem arises when using the same script to checkpoint and pickup (i.e. running the same script over and over): `mode = ""c""` is fine the first run but after that you want `mode = ""a""`. Making the user explicitly select the `mode` will force the user to check if there's a checkpoint to select a mode, which will add boilerplate code like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. mode = checkpointed ? ""a"" : ""c""; ```. Would be nice if `NetCDFOutputWriter` switched to `mode = ""a""` if a file exists (and print a warning).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1160:132,checkpoint,checkpoint,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1160,6,['checkpoint'],"['checkpoint', 'checkpointed', 'checkpoints']"
Availability,"By the way, WENO (and other advection schemes) are always going to be at most second order as they are implemented right now. So the _order_ might not be the correct metric to look at the performance, the truncation error is probably what we want to look at",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164473690:216,error,error,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164473690,1,['error'],['error']
Availability,"By the way, we originally thought we might be able to solve this issue by setting the checkpointing interval to be an integer multiple of the averaging interval (and window) but that is evidently not the case since the bug shows up in the MWEs above that satisfy this condition (where the checkpoint time is `T1 = 6` and the averaging interval is `δt = 0.03`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260981595:86,checkpoint,checkpointing,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260981595,2,['checkpoint'],"['checkpoint', 'checkpointing']"
Availability,"CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}}, Tuple{CPU, CPU}}}, Float64, typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.identity4), MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, Float64}}}}}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, Nothing, NamedTuple{(), Tuple{}}}}}); ```. Let me know if you need a MWE! (I'm assuming you can figure it out from the error alone)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:118010,error,error,118010,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524,1,['error'],['error']
Availability,CUDA ERROR,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:5,ERROR,ERROR,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['ERROR'],['ERROR']
Availability,CUDA error with immersed boundary when running on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:5,error,error,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,1,['error'],['error']
Availability,"CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. Solution: probably some of the suggestions on #746 are useful; we might need to submit a PR to CUDA.jl for this. I think this might be the toughest of all (more argument for also resolving #1246)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:2655,error,errors,2655,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593,1,['error'],['errors']
Availability,"CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS) when using Lagrangian particles under large CFL number",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320:5,error,error,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320,1,['error'],['error']
Availability,CUDA scalar operations error on GPU in `show` functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:23,error,error,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,1,['error'],['error']
Availability,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140:156,checkpoint,checkpointing,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140,3,"['Checkpoint', 'checkpoint']","['Checkpointing', 'checkpoint', 'checkpointing']"
Availability,"Came across a rather cryptic error message that had me puzzled, so I've added this new error message to make sure it doesn't happen to other people.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753:29,error,error,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753,2,['error'],['error']
Availability,Can somebody have a look at ; https://buildkite.com/clima/oceananigans/builds/8443#0182e818-e897-4fda-ac01-56a95319fd1e/33-764. Seems like a GPU-related error with `fill_bottom_and_top_halo!`? Probably same issue as https://github.com/CliMA/Oceananigans.jl/issues/2709?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1230000276:153,error,error,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1230000276,1,['error'],['error']
Availability,"Can someone have a look at the gpu bc error in the ci? @simone-silvestri , @glwagner ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1524188389:38,error,error,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1524188389,1,['error'],['error']
Availability,"Can we also have `checkpoint(simulation, prefix)` if a checkpointer has not already been created?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538996:18,checkpoint,checkpoint,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538996,2,['checkpoint'],"['checkpoint', 'checkpointer']"
Availability,Can we also use `mask = f(neutral_value)` or no?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023492365:17,mask,mask,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200#issuecomment-1023492365,1,['mask'],['mask']
Availability,"Can we just compare 1) the topology and 2) all of the nodes? I think that would be sufficient to determine equality. I'm worried if we don't explicitly check the topology that we might run into some edge cases where the nodes / spacings are the same but the topologies are different (these would possibly be pathological with 0 halo in a periodic / flat direction, but still good to explicitly check I think...). When comparing numeric equality for nodes, we should add `@allowscalar` as needed there. I think we should add a test that equality works as expected, as well. We should also add a test for checkpointing on stretched grids. I think its ok if we don't support a numeric equality for other grids --- we can build them up one at a time. They are specific to each grid. The main downside here is that we need to refactor our grid implementation to have a single `RectilinearGrid` (there's no reason to have different rectilinear grid types, since we can dispatch on the case that certain directions have constant spacing easily). So this code will go away when we make that change. But I think it's a useful incremental improvement for now while we still have two rectilinear grids, so I'm fine to have it go in once it's cleaned up. Because of this:. ```julia; julia> using CUDA. julia> a = rand(2); 2-element Vector{Float64}:; 0.8207604162394306; 0.3815099688071648. julia> b = CuArray(a); 2-element CuArray{Float64, 1}:; 0.8207604162394306; 0.3815099688071648. julia> CUDA.@allowscalar a == b; true; ```. I think that this will work if the checkpointed grid is deserialized onto the CPU, even though `model.grid` is on the GPU. I think this is what we want, so that's fortunate the above works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406:603,checkpoint,checkpointing,603,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406,3,"['checkpoint', 'down']","['checkpointed', 'checkpointing', 'downside']"
Availability,"Can we output the super long message that appears on the REPL when running the model to a text file so that the actual *key* error message will not be overwhelmed by the other irrelevant stuff? Something like the default option in MITgcm with the STDOUT/STDERR files. For those who run on a terminal, this is probably fine because they can scroll up (assuming they don't miss it!) but in VScode there's a limit on how much you can output.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2363:125,error,error,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363,1,['error'],['error']
Availability,"Can we update the PR description to state this goal? ""This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers...""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938#issuecomment-1440485748:92,checkpoint,checkpoint,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938#issuecomment-1440485748,1,['checkpoint'],['checkpoint']
Availability,Can you help me a bit here?. There is this error from the `mask_immersed_field!`:. https://buildkite.com/clima/oceananigans/builds/14988#018e3cf8-4e46-4915-a961-5065db6b172a/24-615. which I can't seem to know how to track down.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1997534701:43,error,error,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1997534701,2,"['down', 'error']","['down', 'error']"
Availability,Can you please post the errors that you obtain in each case?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-746668137:24,error,errors,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-746668137,1,['error'],['errors']
Availability,Can you put it somewhere public and use Base.download?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1131228070:45,down,download,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1131228070,1,['down'],['download']
Availability,Can you tell me if you still get the same error in the latest tagged release or on master?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-826107695:42,error,error,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-826107695,1,['error'],['error']
Availability,"Can you tell us a bit more about your system?. What is `versioninfo(verbose=true)` and `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:338,fault,fault,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,11,"['ERROR', 'error', 'fault']","['ERROR', 'error', 'fault']"
Availability,Cannot construct GPU models on PowerPC architectures: `ERROR: cfunction: closures are not supported on this platform`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:55,ERROR,ERROR,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,1,['ERROR'],['ERROR']
Availability,Captures the masking of immersed cells for visualization in #3725. We can use this in https://github.com/CliMA/ClimaOcean.jl/pull/156,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3729:13,mask,masking,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3729,1,['mask'],['masking']
Availability,"Cause stuff like. ```julia; model = HydrostaticFreeSurfaceModel(; grid, coriolis, boundary_conditions = (; u_bcs)); ```. doesn't fail, it just doesn't actually apply boundary conditions to `u` (which was intended here). In the past we've allowed some fairly complex input. So maybe we can just pass a warning when keys of `boundary_conditions` are not prognostic fields. Even more neutral would be error if _none_ of the keys are prognostic fields (which would still catch the issue above but could miss some other annoying typos).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3788:398,error,error,398,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3788,1,['error'],['error']
Availability,"CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:condition, :mask, :dims), Tuple{Array{Bool, 3}, Int64, Tuple{Int64, Int64, Int64}}}}); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:654; [3] Reduction(avg::Average, field::Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Array{Bool, 3}, mask::Int64, dims::Function); ```. I imagine fixing it would only take one extra method definition (as suggested by the error message), but I haven't been able to figure it out so far :grimacing:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:6390,mask,mask,6390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,2,"['error', 'mask']","['error', 'mask']"
Availability,Change `TimeInterval` to avoid roundoff error issue plus some cleanup,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3616:40,error,error,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3616,1,['error'],['error']
Availability,"Changing the function call to ; ```julia; function define_output_variable!(dataset,; wsa::Union{WindowedSpatialAverage, WindowedTimeAverage{<:WindowedSpatialAverage}},; name, array_type, compression, attributes, dimensions); ```; raises some other errors and I'm not sure the best way to fix them. I think the issue is that a `WindowedTimeAverage` doesn't have the properties `field` (it has `operand`) and it doesn't have the property `dims`. . For example, running the code above I get:. ```; ERROR: LoadError: type WindowedTimeAverage has no field field; Stacktrace:; [1] getproperty(::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::Symbol) at ./Base.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryCo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:248,error,errors,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,"Changing to. ```julia; @inline function κuᶜᶜᶠ(i, j, k, grid, closure, velocities, tracers, buoyancy, surface_buoyancy_flux); w★ = ℑzᵃᵃᶠ(i, j, k, grid, turbulent_velocityᶜᶜᶜ, closure, tracers.e); ℓu = momentum_mixing_lengthᶜᶜᶠ(i, j, k, grid, closure, velocities, tracers, buoyancy, surface_buoyancy_flux); κu = ℓu * w★; κu_max = closure.maximum_viscosity; κu★ = min(κu, κu_max); return convert(eltype(grid), κu★); end; ```. produces no errors or exceptions (as expected I suppose). So I'm wondering why the version just above with `::FT` does throw an exception...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441917596:435,error,errors,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441917596,1,['error'],['errors']
Availability,Checkpoint at the end of `run!`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1545:0,Checkpoint,Checkpoint,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545,1,['Checkpoint'],['Checkpoint']
Availability,Checkpoint is never created after upgrade (both with Julia 1.5 and 1.6),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547:0,Checkpoint,Checkpoint,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547,1,['Checkpoint'],['Checkpoint']
Availability,Checkpointer bug fixes and improved interface,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/839:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer cannot restore when using fields with OffsetArrays.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/177:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer cannot serialize functions to disk with JLD.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer does not work for ShallowWaterModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2866:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866,1,['Checkpoint'],['Checkpointer']
Availability,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2866:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866,10,"['Checkpoint', 'ERROR', 'Error', 'checkpoint']","['Checkpointer', 'ERROR', 'Errors', 'checkpoint', 'checkpointed', 'checkpointer', 'checkpointing']"
Availability,Checkpointer fails if boundary condition is a CuArray,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/420:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/420,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer needs a previous field,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/375:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/375,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer required properties includes `:architecture` despite it can be inferred from `grid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3463:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3463,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer revival,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer should not use the unstable Serialization package.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/30:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/30,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer that checkpoints the model to a NetCDF files,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1929:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929,2,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoints']"
Availability,Checkpointer warning if properties included make restoring impossible,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/417:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/417,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer was failing due to an upstream bug in JLD2.jl that has now been fixed: https://github.com/JuliaIO/JLD2.jl/issues/247,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1039:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1039,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointing docs are stale,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/660:0,Checkpoint,Checkpointing,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/660,1,['Checkpoint'],['Checkpointing']
Availability,"Checkpointing, NetCDF, and golden master tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140:0,Checkpoint,Checkpointing,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140,1,['Checkpoint'],['Checkpointing']
Availability,Clean up redundant errors in `FieldTimeSeries`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3869:9,redundant,redundant,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3869,2,"['error', 'redundant']","['errors', 'redundant']"
Availability,Clearer Model instantiation error when HAVE_CUDA=false,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/295:28,error,error,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295,1,['error'],['error']
Availability,Clearer error in operation average constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858:8,error,error,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858,1,['error'],['error']
Availability,"Closes #3295. Before this PR:. ```Julia; julia> using Oceananigans. julia> grid = ConformalCubedSphereGrid(; panel_size = (3, 3, 3), z = (-1, 0));. julia> model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); ERROR: UndefVarError: `rotation_from_panel_index` not defined; Stacktrace:; [1] with_halo(new_halo::Tuple{Int64, Int64, Int64}, csg::ConformalCubedSphereGrid{Float64, FullyConnected, ....; @ Oceananigans.MultiRegion ~/Research/OC8.jl/src/MultiRegion/multi_region_cubed_sphere_grid.jl:431; [2] Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver(grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl:47; [3] build_implicit_step_solver(#unused#::Val{:Default}, grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.MultiRegion ~/Research/OC8.jl/src/MultiRegion/unified_implicit_free_surface_solver.jl:67; [4] FreeSurface(free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:95; [5] HydrostaticFreeSurfaceModel(; grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:169; [6] top-level scope; @ REPL[63]:1; ```. With this PR:. ```Julia; julia> using Oceananigans. julia> grid = ConformalCubedSphereGrid(; panel_size = (3, 3, 3), z = (-1, 0));. julia> model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); HydrostaticFreeSurfaceModel{CPU, MultiRegionGrid}(time = 0 seconds, iteration = 0); ├── grid: 3×3×3 ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 6×6×6 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3296:240,ERROR,ERROR,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3296,1,['ERROR'],['ERROR']
Availability,"Closes https://github.com/CliMA/Oceananigans.jl/issues/3637. This PR implements the scale-invariant dynamic Smagorinsky. My main reference for this was [Bou-Zeid et al. (2005)](https://dx.doi.org/10.1063/1.1839152), just because it's nicely summarized there. As a refresher, the coefficient in this case is calculated as. ```math; c_s^2 = \frac{\langle L_{ij} M_{ij}\rangle}{\langle M_{ij} M_{ij} \rangle},; ```; where $M_{ij}$ and $L_{ij}$ are obtained by applying the Germano identity and minimizing the error. $\langle \cdot \rangle$ is an average which usually is implemented as planar averaging. I'm implementing it here with an arbitrary `DirectionalAveraging` procedure that can average in whatever direction the user wants. Following a suggestion by @glwagner in #3637, I'm also starting to put the pieces in place for a more general averaging procedure so that eventually we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a d",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642:506,error,error,506,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642,1,['error'],['error']
Availability,"Co-authored-by: Francis J. Poulin <fpoulin@uwaterloo.ca>. I've added back the threaded benchmark written by @francispoulin in an older branch. I also added plots to it.; There is actually already a threaded benchmark script:; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading.jl; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading_single.jl; They differ in that the one I'm adding is essentially weak scaling shallow water model, while the one that's already there is strong scaling nonhydrostatic model.; If everyone thinks that it's appropriate, then I'll likely change the name of the extant benchmarking scripts to more accurately reflect their content. ; I would likely also do some more minor changes such as changing the default grid size down from 512^3, adding in plots, and configuring the output tables a bit more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881:821,down,down,821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881,1,['down'],['down']
Availability,"Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CUDA.CuDeviceArray{Float64, 4, 1}, ::Oceananigans.AbstractOperations.Condition",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:2821,error,error,2821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['error'],['error']
Availability,"Column Hydrostatic models don't have a free surface and, therefore, produce an error here:; https://github.com/CliMA/Oceananigans.jl/blob/ce461f90e991a85105962e165ca4ceab15b1159a/src/Models/HydrostaticFreeSurfaceModels/show_hydrostatic_free_surface_model.jl#L13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2210:79,error,error,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2210,1,['error'],['error']
Availability,"Compilation actually speeds up, its run time that slows down. (The examples are probably running very very very very slow.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480594643:56,down,down,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480594643,1,['down'],['down']
Availability,Compute third stage time-step for RK3 in a way that reduces the accumulation of error,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3617:80,error,error,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3617,1,['error'],['error']
Availability,Construct grid parameters with `BigFloat` to avoid round-off error,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2499:61,error,error,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499,1,['error'],['error']
Availability,"Contributing to my confusion is that I think the documentation has a typo in that there is a sign error between equations (3) and (4) of the [description of the implementation of the Gradient Boundary Condition](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/boundary_conditions/#Gradient-boundary-conditions). I think $c_{i,j,0}$ and $c_{i,j,1}$ should maybe be swapped in eq. (3)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3651#issuecomment-2219477206:98,error,error,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3651#issuecomment-2219477206,1,['error'],['error']
Availability,"Contributors,. We are planning to re-license Oceananigans under the [Apache License 2.0](https://www.apache.org/licenses/LICENSE-2.0), as required by the primary sponsors of the Climate Modeling Alliance, [Schmidt Sciences](https://www.schmidtsciences.org/). Practically speaking, [the two licenses are similarly permissive and open](https://soos.io/apache-vs-mit-license). However, the Apache license adds some additional protection for contributors (like yourselves) by, for example, requiring downstream applications that depend on Oceananigans to disclose major changes. Let us know if there are any concerns. Otherwise, we plan to make the change on August 19. The top 20 outside contributors are tagged here:. @ali-ramadhan ; @tomchor ; @francispoulin ; @hennyg888 ; @elise-palethorpe ; @whitleyv ; @suyashbire1 ; @jagoosw ; @vchuravy ; @xiaozhour ; @maeckha ; @iuryt ; @kburns ; @jbisits ; @maleadt ; @wsmoses ; @Moelf ; @RaphaelRR ; @simonbyrne ; @josuemtzmo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3708:496,down,downstream,496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3708,1,['down'],['downstream']
Availability,Convenience function: `checkpoint(simulation)`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1249:23,checkpoint,checkpoint,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249,1,['checkpoint'],['checkpoint']
Availability,Cool! Two other possible bugs I found:. https://github.com/CliMA/Oceananigans.jl/blob/1522ae47996a4df9092a27e0d32bfffc1bf53fad/test/test_enzyme.jl#L331. I think should be `dedν[1][1]` instead. And. https://github.com/CliMA/Oceananigans.jl/blob/1522ae47996a4df9092a27e0d32bfffc1bf53fad/test/test_enzyme.jl#L261-L264. produces an out of bounds error with the z axis. I replaced `3` with `end`. Happy to push those changes.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438727494:342,error,error,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438727494,1,['error'],['error']
Availability,"Cool. Getting to the finish line will be a bit of work I guess. I think we usually want to integrate downwards so that's annoying. Not sure if that exists exactly, or we have to implement some lazy version of `reverse` to achieve it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2098991202:101,down,downwards,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2098991202,1,['down'],['downwards']
Availability,"Copied below. ```; ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299:19,ERROR,ERROR,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299,6,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"Copy-pasting this error from the #2618 :. ```julia; model = HydrostaticFreeSurfaceModel(; grid); ERROR: Metal does not support Float64 values, try using Float32 instead; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] check_eltype(T::Type); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:32; [3] Metal.MtlArray{Float64, 3, Metal.MTL.MTLResourceStorageModePrivate}(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:50; [4] (Metal.MtlArray{Float64, 3})(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:98; [5] MtlArray; @ ~/.julia/packages/Metal/lnkVP/src/array.jl:157 [inlined]; [6] Metal.MtlArray(A::Array{Float64, 3}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:173; [7] arch_array(#unused#::Oceananigans.Architectures.MetalBackend, a::Array{Float64, 3}); @ Oceananigans.Architectures ~/Documents/Projects/Oceananigans.jl/src/Architectures.jl:75; [8] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}, planner_flag::UInt32); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:61; [9] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:51; [10] Oceananigans.Models.Hydr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732648465:18,error,error,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732648465,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Correct error message in `validate_lat_lon_grid_args`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3887:8,error,error,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3887,1,['error'],['error']
Availability,Cosmetic improvement to checkpointer docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2531:24,checkpoint,checkpointer,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2531,1,['checkpoint'],['checkpointer']
Availability,"Could the false tracer extrema be due to the advection scheme, which exhibits more errors in the case that the pressure is not separated? Note that the pressure solver is approximate in either case. But when the pressure is separated, I think the pressure solver may be more accurate. I'm not sure there is any way that the pressure separation could directly impact the conservation of tracer, so I'm hypothesizing that the effect is indirect and occurs through the differences in the emergent dynamics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2265942222:83,error,errors,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2265942222,1,['error'],['errors']
Availability,"Currently I can't operate on a reduction using `AbstractOperation`s:. ```julia; julia> using Oceananigans;. julia> grid = RectilinearGrid(size=(4,4,4,), extent=(1,1,1));. julia> model = NonhydrostaticModel(grid = grid);. julia> Average(model.velocities.u)/2; ERROR: MethodError: no method matching /(::Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Tuple{Int64, Int64, Int64}}, ::Int64); Closest candidates are:; /(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractGrid, ::Any, ::Any, ::Number, ::Oceananigans.AbstractOperations.BinaryOperation) at /glade/work/tomasc/.julia/packages/Oceananigans/Ey1oO/src/AbstractOperations/binary_operations.jl:88; /(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractGrid, ::Any, ::Any, ::Oceananigans.AbstractOperations.BinaryOperation, ::Number) at /glade/work/tomasc/.julia/packages/Oceananigans/Ey1oO/src/A",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2856:259,ERROR,ERROR,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2856,1,['ERROR'],['ERROR']
Availability,"Currently an error during grid validation is actually not printed, instead you get; ```; ERROR: UndefVarError: N! not defined; ```; as string interpolation is expecting a variable called `N!` when the variable is `N`. This PR fixes this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2845:13,error,error,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2845,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Currently halo regions are filled _prior_ to performing a time-step. This means that _after_ the time-step, they are incorrect. We therefore cannot output fields with correct halo regions, since data is outputted after a time-step is taken. But it gets worse. If the average of a field is taken, we zero out the halo regions. Zeroing out the halo regions corrupts near-boundary data for all subsequent computations with the fields. Currently, abstract operations cannot be trusted in boundary-adjacent cells. To remedy this we need to fill halo regions on fields prior to performing computations. One way we might do this is to write a `compute!` method for fields:. ```julia; compute!(field::Field) = fill_halo_regions!(field); ```. We can also define a `conditional_compute!` method for `Field`s and add a `status` property, so that halo regions are not filled ""redundantly"". For this to work, we also need to invalidate `field.status` when halo regions are zeroed out by `compute!(averaged_field::AveragedField)`, (for example by setting `field.status.time = NaN`). This won't work currently, of course, due to #971 . So this issue cannot be resolved until #971 is resolved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1063:864,redundant,redundantly,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1063,1,['redundant'],['redundantly']
Availability,"Currently restoring a model from a checkpoint uses the function `restore_from_checkpoint`. However, this design can be difficult to use because, in general, restoring a model requires passing the forcing functions and boundary condition functions explicitly to `restore_from_checkpoint`. This means that part of the setup script needs to be replicated in the script that restores a model from the checkpoint. A different solution is possible that may require less work on the part of users to restore a model from a checkpoint: if we extend `run!` with the keyword argument `pickup`. . If `pickup=true` (and a checkpointer has been added to `simulation.output_writers`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068:35,checkpoint,checkpoint,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068,6,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint', 'checkpointer']"
Availability,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1131:365,error,errors,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,"Currently the `JLD2OutputWriter` labels output in a timeseries by `model.clock.iteration`. It might be easier to handle output if data is labeled by ""save point"", so it goes 0, 1, 2... This is easier to work with at the REPL, since you always know, for example, that `file[""timeseries/u/1""]` exists (rather than having to manually inspect the file to figure out the iterations that data ended up being saved at). We can add a field `iteration` so that the model iteration can be recovered, if that's needed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/963:479,recover,recovered,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963,1,['recover'],['recovered']
Availability,"Currently the user may pass `diffusivity_fields` into model constructors, but `Oceananigans.TurbulantClosures.DiffusivityFields` resets these to the value of `validate_field_tuple_grid` which nominally is `nothing`. I have changed this to return the field values if `validate_field_tuple_grid` does not error instead. E.g. ```julia. using Oceananigans; using Oceananigans.TurbulenceClosures: DiffusivityFields. grid = RectilinearGrid(size = (64, 64, 16), extent = (150, 150, 10)). tracers = (:T, :S). closure = AnisotropicMinimumDissipation(). diffusivity_fields = diffusivity_fields = DiffusivityFields(grid, tracers, NamedTuple(), closure). model = NonhydrostaticModel(; grid,; tracers,; closure,; diffusivity_fields); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3367:303,error,error,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3367,1,['error'],['error']
Availability,"Currently users get the more obscure `MethodError`:. ```julia; julia> fill_halo_regions!(Ψ, CPU()); ERROR: MethodError: no method matching fill_west_halo!(::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::Oceananigans.BoundaryConditions.DefaultPrognosticFieldBoundaryCondition, ::CPU, ::KernelAbstractions.NoneEvent, ::ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1968#issuecomment-906604350:100,ERROR,ERROR,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968#issuecomment-906604350,1,['ERROR'],['ERROR']
Availability,"Currently we use a convention for fields wherein the ""halo points"" of a field stored on faces actually includes locations that are on the boundary of our domain. Is this strange? What I am saying, in other words, is that for the field `u = Field{Face, Cell, Cell}(arch, grid)`, the point. ```julia; u[grid.Nx+1, 1, 1]; ```. is defined as a ""halo point"", even though it is located *on* the right `x` boundary (it is inside the physical domain, not outside it). I think this is potentially odd and we should *consider* adopting the convention that `Face` fields include their boundary points by default. This would not change the algorithm; it only changes the user API. The reason why I recommend considering / discussing this change rather than immediately adopting it is because there are some downsides. One is a slight increase in memory allocation that is not needed. This is minor for large 3D problems but could be annoying for small 1D or 2D problems with ""flat"" dimensions. This last problem can potentially be solved by invoking special behavior for the ""flat"" dimensions of a grid (see #330).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/455:795,down,downsides,795,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/455,1,['down'],['downsides']
Availability,"Currently, `IncompressibleModel` keeps a reference to `TimeStepper`:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/Models/incompressible_model.jl#L33. This means that every model has one time stepper, and we use `time_step!(model, dt)` to advance a model forward. Yet this is not a necessary entanglement. A perfectly valid time-stepping loop is. ```julia; for i = 1:100; time_step!(model, forward_euler_stepper, dt); time_step!(model, rk3_stepper, dt); end; ```. (obviously we don't have a forward Euler time-stepper, which is a separate issue, but hopefully the point is made.). We can disentangle the timestepper from model by moving the timestepper reference over to `Simulation`. This would also clean up the interface since we wouldn't need to use symbols to specify the time-stepping method (#1119, this might be a hint that we're on the right track...). ```julia; model = IncompressibleModel(...); simulation = Simulation(model, RungeKutta3TimeStepper(model), kwargs...); ```. I think there's a conceptual advantage to this too. `Simulation`s manage the creation of a time-series, while a `Model` is more the idealization of a discrete physical system at a particular moment in time. To make this change, we first have to checkpoint `Simulation`s rather than `Model`s to support time-steppers that require history like AB2. I think this is something we need anyways. This is a major API change, though it could be mitigated if we put a default into the `Simulation` constructor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1175:1276,checkpoint,checkpoint,1276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1175,1,['checkpoint'],['checkpoint']
Availability,Cut down the examples. Moved stuff into a sandbox.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/230:4,down,down,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/230,1,['down'],['down']
Availability,"Damn, it looks like the tests on the GPU are not working because CUDA is not loaded properly. ; I am trying to address this in #3880. A segmentation fault probably means the MPI is not CUDA-aware. Typically, the MPI that is shipped with MPI_jll is not cuda-aware. A good way to check is; ```julia; julia> using MPI. julia> MPI.has_cuda(); true; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878#issuecomment-2443869989:149,fault,fault,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878#issuecomment-2443869989,1,['fault'],['fault']
Availability,"Dear Oceananigans developers,; I want to run an example on a HPC server where GPU nodes have no network access. Is it possible to force downloads on the frontend even if GPU is not available ?; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035:136,down,downloads,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035,2,"['avail', 'down']","['available', 'downloads']"
Availability,"Dear Oceananigans team,. I am new to Julia and Oceananigans.; I installed Julia version 1.6.2 (2021-07-14) on Ubuntu 20.04 LTS, then Oceananigans v0.62.1 as instructed. I am interested in ""stratified plane Couette flow"" .; When I run the case using ""julia run_stratified_couette_flow_simulations.jl"", I am having following error;. **""; ERROR: LoadError: UndefVarError: Value not defined; Stacktrace:; [1] simulate_stratified_couette_flow(; Nxy::Int64, Nz::Int64, arch::GPU, h::Int64, U_wall::Int64, Re::Int64, Pr::Float64, Ri::Int64, Ni::Int64, end_time::Int64); @ Main ~/Desktop/stratified_couette_flow/stratified_couette_flow.jl:103; [2] top-level scope; @ ~/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; in expression starting at /home/ilyas/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; ""****. It complaints about undefined Boundary Condition Value (stratified_couette_flow.jl:103).; Can you help me to fix it?. Please forgive me if I missed something obvious or made a trivial mistake.; Thanks,. Ilyas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1981:323,error,error,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Delta t^2 ) \eta_{ijk} = b_{ijk}""> . the coefficients are specified as 3D arrays (also fields should be good). To solve for a `Center, Center, Center` value, `Ax` should be on `Face, Center, Center`, `Ay` should be on `Center, Face, Center`, `Az` on `Center, Center, Face` and `C` and `D` on `Center, Center, Center`. . `b` (the rhs) is specified as a 1D `Array` (or `CuArray` on GPUs). Example: coefficients to solve a Poisson equation of the form <img src=""https://render.githubusercontent.com/render/math?math=\nabla^2 \eta = b""> in a finite volume framework <img src=""https://render.githubusercontent.com/render/math?math=\sum_k A_k \nabla \eta = b \cdot V""> are shown in `test/test_matrix_poisson_solver.jl`. to construct the type, a part from the coefficients it is possible to specify; - the type of `iterative_solver` desired (`cg` is the default) ; - `reduced_dim::Tuple(Bool, Bool, Bool)` to have a lower-dimensional solve (a reduced dimension will mean that the matrix will be filled with the coefficients of index 1 in that direction, as an example, if `reduced_dim=(false, true, false)`, the matrix will be filled with `Ax[i, 1, k], Az[i, 1, k], C[i, 1, k]` and `D[i, 1, k]`) ; - `settings` which include `maximum_iterations`, `tolerance`, `precondition` (`false` or `true`). The preconditioner employed on the CPU is the (always perfect) ILU factorization (from the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:2186,toler,tolerance,2186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,1,['toler'],['tolerance']
Availability,"Did you test it? :). I think providing a string as a closure doesn't even make it to the new error message you added so you get a MethodError from `with_tracers`!. ```Julia; julia> using Oceananigans, Test; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 129 already precompiled. julia> grid = RectilinearGrid(CPU(), size=(2, 2, 2), extent=(1, 2, 3)); 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; ├── Periodic y ∈ [0.0, 2.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-3.0, 0.0] regularly spaced with Δz=1.5. julia> closure = ""not a closure""; ""not a closure"". julia> NonhydrostaticModel(; grid, closure); ERROR: MethodError: no method matching with_tracers(::Tuple{}, ::String). Closest candidates are:; with_tracers(::Any, ::Nothing, Any...; kwargs...); @ Oceananigans ~/Research/OC11.jl/src/Utils/with_tracers.jl:44; with_tracers(::Any, ::Oceananigans.TurbulenceClosures.TwoDimensionalLeith{FT}) where FT; @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl:61; with_tracers(::Any, ::ScalarBiharmonicDiffusivity{F, N}) where {F, N}; @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl:85; ... Stacktrace:; [1] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{}, closure::String, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, hydrostatic_pressure_anomaly::Oceananigans.Models.NonhydrostaticModels.DefaultHydrostaticPressureAnomaly, nonhydrostatic_pressure::Field{…}, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::@Na",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325306269:93,error,error,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325306269,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Distinguish between ""masking"" and ""enforcing impenetrability"" in immersed boundary routines",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2249:21,mask,masking,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249,1,['mask'],['masking']
Availability,Distributed tests actually fail with errors :(,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2394903510:37,error,errors,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2394903510,1,['error'],['errors']
Availability,Distributed tests keep failing due to segfaults and MPI communication errors... Is there a trick to get them to work or should I just merge this PR as the non-distributed tests all pass?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3769#issuecomment-2383655329:70,error,errors,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3769#issuecomment-2383655329,1,['error'],['errors']
Availability,Do we get an error if we aren't using `Flat`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1305904393:13,error,error,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1305904393,1,['error'],['error']
Availability,Do we have good ideas for a test that will catch the error observed in #3670 ? Also I think it will be important to precisely pinpoint the problem and describe it in the top post.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295323633:53,error,error,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295323633,1,['error'],['error']
Availability,Do we want to be able to compute Available Potential Energy (APE) to get an idea as to the energtics of a flow?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297:33,Avail,Available,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297,1,['Avail'],['Available']
Availability,"Do we want to update the one and two dimensional examples to include `Flat`? . If not then we can ignore this PR. . If yes, then this is my attempt to do so. The good news is that most of the one and two dimensional examples work very easily. Unfortunately, a couple of them, geostrophic adjustment and convecting plankton, do not. I don't know why at the moment and these should certainly be fixed before a merge happens. If it happens. The error get I get is `NaN` after (I believe) the first interval. So I suspect one of the tendencies is not being computed correctly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1513:442,error,error,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513,1,['error'],['error']
Availability,"Docs are previewing here: https://clima.github.io/OceananigansDocumentation/previews/PR3080/. I checked all the examples with `NonhdyrostaticModel` and they all look the same as they do on the `stable` branch. Furthermore, the few tests failures that we have are all something like. ```; JLD2 output writer [CPU]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/test/test_jld2_output_writer.jl:131; --;   | Expression: wu == zero(FT);   | Evaluated: -3.009265538105056e-35 == 0.0; ```. i.e. very small approximation errors that aren't indicative of any significant errors in the model. In other words, I think this is working well! I vote we simplify the model and get rid of the hydrostatic separation. @glwagner as you mentioned, this isn't a trivial change. If you wanna move forward with it, feel free to push to this PR or close this one and open another. I can also help if you want, just lmk what I should focus on. PS: Just like we did in https://github.com/CliMA/Oceananigans.jl/pull/1910 we might need/want to replace the `stratified_fluid_remains_at_rest_with_tilted_gravity_buoyancy_tracer()` test for something simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1518394718:237,failure,failures,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1518394718,6,"['error', 'failure']","['errors', 'failures']"
Availability,"Does it have to do with output? Do you know what the time-step is when this happens? I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2102989649:173,error,error,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2102989649,1,['error'],['error']
Availability,Does someone have a minimal example that reproduces this error? I'm just curious to learn more about the problem.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738823622:57,error,error,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738823622,1,['error'],['error']
Availability,"Does this branch only work on 1.7? I'm getting. ```julia; (Oceananigans) pkg> resolve; ┌ Error: Could not parse entry for `deps`; └ @ Pkg.Types /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/manifest.jl:150; ERROR: MethodError: no method matching get(::Pair{String, Any}, ::String, ::Nothing); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983957163:89,Error,Error,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983957163,2,"['ERROR', 'Error']","['ERROR', 'Error']"
Availability,Don't we get the error by only running one model and comparing the two grid points?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308163237:17,error,error,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308163237,1,['error'],['error']
Availability,"Done!. ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); 1×1×3 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [1.0, 16.0] variably spaced with min(Δz)=3.0, max(Δz)=7.0. julia> grid = RectilinearGrid(size=3, z= x->-x^2, topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z should have increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::var""#41#42"", dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:126; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::var""#41#42""); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Function); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[22]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751328718:357,ERROR,ERROR,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751328718,1,['ERROR'],['ERROR']
Availability,Downbump to 0.71.4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2279:0,Down,Downbump,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2279,1,['Down'],['Downbump']
Availability,"During the coefficients down to 1e-9 (!!) allows 3 stable time steps _when continents / bathymetry are removed_:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 226.942 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (288.084 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.446 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.452 seconds; │ ├── max(u): (1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:24,down,down,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807,1,['down'],['down']
Availability,"EDIT: I just found a small error in the results posted in this last comment, so I'll re-post them after I correct it! Sorry",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809553813:27,error,error,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809553813,1,['error'],['error']
Availability,"EDIT: This has nothing to do with Oceananigans.jl per se. Better pursued on LambertW.jl. I agree with https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904990127 . This part of the stack trace suggests that it is the `@warn` that is causing the problem. It should be possible to remove that somehow. Better would be to remove the `@warn` entirely and instead return the result along with info on the convergence. And maybe convenience interface for people who want to ignore it. That's a more robust interface for other reasons as well. I don't know anything about running on GPUs. Does `@warn` cause failure if it is anywhere in the package being compiled? or anywhere in the function being called? Or does execution have to hit the `@warn` so that io is attempted at run time?. EDIT: I missed this above:; >> Do you get a warning during CPU execution ?. > Nope. Everything seems to run pretty smoothly:. So it seems that execution does not have to hit the `@warn` for the reported failure. Also the stack trace indicates that the error happens when the macro is expanded. EDIT: so the following comment may be relevant, but perhaps not. It would be nice if there were a way to redirect io or send it to dev null or otherwise disable everywhere when running on a GPU. ```; Reason: unsupported call to an unknown function (call to jl_f__call_latest); Stacktrace:; [1] #invokelatest#2; @ ./essentials.jl:816; [2] invokelatest; @ ./essentials.jl:813; [3] macro expansion; @ ./logging.jl:381; [4] lambertw_root_finding; @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:188; [5] lambertw_branch_zero; @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:117; [6] _lambertw; @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:93; [7] lambertw (repeats 2 times); @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:73; [8] W; @ /glade/derecho/scratch/tomasc/twake4/headland_simulations/mwe.jl:9; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1910836945:510,robust,robust,510,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1910836945,4,"['error', 'failure', 'robust']","['error', 'failure', 'robust']"
Availability,"EEES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES10_IS9_Li1ELi1EEEvES9_ES30_IS28_S28_S28_S31_S8_IS9_Li3ES10_IS9_Li3ELi1EEES9_S34_S35_S11_IS9_S12_S12_S13_S9_S9_S8_IS9_Li1ES10_IS9_Li1ELi1EEES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES10_IS9_Li1ELi1EEEvES9_EEEEES23_I46__u___v___w___b____1____2____3____4____5____6_S18_I15DiscreteForcingIS23_I13______u______S18_IS16_S16_S9_EE9_sponge_uES37_IS23_I13______u______S18_IS16_S16_S9_EE9_sponge_vES37_IS23_I13______u______S18_IS16_S16_S9_EE9_sponge_wES37_IS23_I13______u______S18_IS16_S16_S9_EE9_sponge_bE12_zeroforcingS42_S42_S42_S42_S42_EES8_IS9_Li3ES10_IS9_Li3ELi1EEES23_I27__time___iteration___stage_S18_IS9_S16_S16_EE' uses too much parameter space (0x1a10 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_XSJ4P4z47a.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:428; [3] #224; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:347 [inlined]; [4] JuliaContext(f::CUDA.var""#224#225""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Cassette.overdub), Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(8, 8, 6)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 6)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArra",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112:5183,error,error,5183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112,1,['error'],['error']
Availability,EGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_solver.jl:134; + [inlined]; Oceananigans.Models.NonhydrostaticModels; + calculate_pressure_correction! ~/.julia/packages/Oceananigans/mwXt0/src/Models/NonhydrostaticModels/pressure_correction.jl:15; > Oceananigans.TimeSteppers; v + #time_step!#8 ~/.julia/packages/Oceananigans/mwXt0/src/TimeSteppers/runge_kutta_3.jl:138; Oceananigans.Simulations; + time_step! ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:134; + #run!#7 ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:97; + run! ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:85; + [top-level]; (system); ```; I can't get the whole error message because its longer than the screen length but this seems to be the relevant bit when using InteractiveErrors. . If I make the grid smaller it gets more iterations done before it errors but is nowhere near using all of the GPUs memory (A100 with 80GB and model is about 2GB when 256x256x64). This is with the latest version of Oceananigans (87.4). I'll try to make an MWE.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:3769,error,error,3769,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,2,['error'],"['error', 'errors']"
Availability,ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/686:0,ERROR,ERROR,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686,1,['ERROR'],['ERROR']
Availability,ERROR: MethodError: no method matching initarray! on Julia v1.8.0-rc1,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2663:0,ERROR,ERROR,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663,1,['ERROR'],['ERROR']
Availability,ERROR: Unsatisfiable requirements detected for package CuArrays,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:0,ERROR,ERROR,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['ERROR'],['ERROR']
Availability,ERROR: importing Flux into Main conflicts with an existing identifier,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1285:0,ERROR,ERROR,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1285,1,['ERROR'],['ERROR']
Availability,"ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_5Az___E9identity1S30_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_E5FieldIvvS14_vvvS22_IS7_Li3ES9_IS7_Li3ELi1EEES7_vvvES31_S32_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_ES_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvE11NotImmersedI8truefuncES4_S7_E' uses too much parameter space (0x11f0 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLG",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140:4333,error,errors,4333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140,1,['error'],['errors']
Availability,"Easy mistake to make if you're new to Julia or unfamiliar with the package. Would be easy to do some input validation and throw an informative error. Examples:. Should be `CPU()` instead of `CPU` here:; ```julia; julia> model = Model(architecture=CPU, grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)));. ERROR: MethodError: no method matching Field(::Tuple{DataType,DataType,DataType}, ::Type{CPU}, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}); Closest candidates are:; Field(::Any, ::Any, ::Any, ::Any, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:50; Field(::Tuple, ::Oceananigans.AbstractArchitecture, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:32; Field(::Tuple, ::AbstractArray, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:42; Stacktrace:; [1] Field(::Type, ::Type, ::Type, ::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:50; [2] Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,A,G} where G where A(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:109; [3] VelocityFields(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/models.jl:177; [4] (::getfield(Core, Symbol(""#kw#Type"")))(::NamedTuple{(:architecture, :grid, :buoyancy, :tracers),Tuple{DataType,RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},DataType,Symbol}}, ::Type{Model}) at ./none:0; [5] top-level scope at REPL[7]:1; ```. Should be `BuoyancyTracer()` instead of `BuoyancyTracer` here:; ```julia; julia> model = Model(architecture=CPU(), grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)), buoyancy=BuoyancyTracer, tracers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/465:143,error,error,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Easy to get burned by accidentally applying e.g. no-slip boundary conditions along a periodic dimension (mixing up `east` and `north`). Oceananigans should probably print a warning or error if you apply inconsistent boundary conditions. Definitely occurred to me multiple times (and recently encountered by @whitleyv too).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1177:184,error,error,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1177,1,['error'],['error']
Availability,"Eg for. ```julia; julia> κ; BinaryOperation at (Center, Center, Center); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; └── tree:; + at (Center, Center, Center);    ├── 1.0e-5;    └── / at (Center, Center, Center);       ├── 0.01;       └── + at (Center, Center, Center);          ├── 1;          └── * at (Center, Center, Center);             ├── 5;             └── ^ at (Center, Center, Center);                ├── 1×1×128 Field{Center, Center, Center} on RectilinearGrid on CPU;                └── 3; ```. we get. ```julia; julia> closure = ScalarDiffusivity(; κ); ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0, κ=BinaryOperation at (Center, Center, Center)). julia> model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer()); ERROR: MethodError: no method matching tracer_diffusivities(::Tuple{Symbol}, ::BinaryOperation{Center, Center, Center, typeof(+); ```. It looks like `tracer_diffusivities` is being used to catch invalid diffusivity fields cause. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/TurbulenceClosures/turbulence_closure_utils.jl#L3. But it's kinda silly cause. ```julia; julia> closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). julia> model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer()); ```. works just fine. So we should either. 1. Include `AbstractArray` in objects supported by `tracer_diffusivities`, and throw a useful error as a fallback rather than going to `MethodError`; 2. Relax https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/TurbulenceClosures/turbulence_closure_utils.jl#L3 to a fallback so it works for any object",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2342:810,ERROR,ERROR,810,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2342,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Egregious errors in `NonhydrostaticModel` simulations on `ImmersedBoundaryGrid` when nonhydrostatic pressure is not separated,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677:10,error,errors,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677,1,['error'],['errors']
Availability,"Encountered this pretty weird error where `compute!(::AveragedField)` fails when the grid is larger than 22^3. Not sure what's causing it but last thing on the stacktrace in Oceananigans.jl is `sum!` in `mapreduce_abstract_fields.jl` so maybe something changed with `CUDA.mapreducedim!` in v3?. Putting the _high priority_ tag on this issue since it breaks LESbrary.jl pretty badly and I expect other people's scripts too... ```julia; using Oceananigans. # grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)) # OK; # grid = RegularRectilinearGrid(size=(22, 22, 22), extent=(1, 1, 1)) # OK; # grid = RegularRectilinearGrid(size=(23, 23, 23), extent=(1, 1, 1)) # NOT OK; grid = RegularRectilinearGrid(size=(32, 32, 32), extent=(1, 1, 1)) # NOT OK. model = IncompressibleModel(grid=grid, architecture=GPU()). U = AveragedField(model.velocities.u, dims=(1, 2)); compute!(U); ```. ```; ERROR: MethodError: Cannot `convert` an object of type CUDA.CuDeviceArray{Float64, 4, 1} to an object of type Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}} ; Closest candidates are:; convert(::Type{T}, ::LinearAlgebra.Factorization) where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58; convert(::Type{T}, ::T) where T<:AbstractArray at abstractarray.jl:14; convert(::Type{T}, ::T) where T at essentials.jl:205; ...; Stacktrace:; [1] cconvert(T::Type, x::CUDA.CuDeviceArray{Float64, 4, 1}); @ Base ./essentials.jl:396; [2] macro expansion; @ ~/.julia/packages/CUDA/3VnCC/lib/cudadrv/execution.jl:83 [inlined]; [3] convert_arguments(::CUDA.var""#32#33""{Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:threads, :blocks, :shmem), Tuple{Int64, Int64, I",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684:30,error,error,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Enhance Checkpointer + TendencyCallsite callback example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3461:8,Checkpoint,Checkpointer,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3461,1,['Checkpoint'],['Checkpointer']
Availability,Enhances docstring for the `ImplicitFreeSurface` constructor to include the available solver methods. Closes #2620,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2621:76,avail,available,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2621,1,['avail'],['available']
Availability,"Enzyme tests seems to be failing with:. ```; Enzyme + Oceananigans Initialization Broadcast Kernel: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-9/clima/oceananigans/test/test_enzyme.jl:134; Got exception outside of a @test; StackOverflowError:; Stacktrace:; [1] getproperty; @ ./Base.jl:32 [inlined]; [2] unwrap_unionall; @ ./essentials.jl:379 [inlined]; [3] fieldnames; @ ./reflection.jl:169 [inlined]; [4] augmented_julia_fieldnames_26436wrap; @ ./reflection.jl:0; [5] macro expansion; @ ~/.julia-16536/packages/Enzyme/aEyGD/src/compiler.jl:6673 [inlined]; [6] enzyme_call; @ ~/.julia-16536/packages/Enzyme/aEyGD/src/compiler.jl:6273 [inlined]; [7] AugmentedForwardThunk; @ ~/.julia-16536/packages/Enzyme/aEyGD/src/compiler.jl:6161 [inlined]; [8] runtime_generic_augfwd(activity::Type{Val{(false, false)}}, width::Val{1}, ModifiedBetween::Val{(true, true)}, RT::Val{@NamedTuple{1, 2, 3}}, f::typeof(fieldnames), df::Nothing, primal_1::Type{FieldBoundaryConditions}, shadow_1_1::Nothing); @ Enzyme.Compiler ~/.julia-16536/packages/Enzyme/aEyGD/src/rules/jitrules.jl:313; --- the last 6 lines are repeated 7889 more times ---; [47343] boundary_conditions; @ /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-9/clima/oceananigans/src/Fields/field.jl:357 [inlined]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2254226935:100,Error,Error,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2254226935,1,['Error'],['Error']
Availability,"Error for `maximum(::Field{Face, Center, Center})` on GPU",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['Error'],['Error']
Availability,Error from benchmark/test distributed nonhydrostatic model scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,1,['Error'],['Error']
Availability,Error if expected input is not a NamedTuple,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1206:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1206,1,['Error'],['Error']
Availability,Error if using too low julia version?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2142:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2142,1,['Error'],['Error']
Availability,Error in AveragedTimeInterval Output,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670,1,['Error'],['Error']
Availability,Error in ConjugateGradientPoissonSolver for nonuniform grids,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3889:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3889,1,['Error'],['Error']
Availability,Error in `num_prod`?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2747:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2747,1,['Error'],['Error']
Availability,Error in `visualize_barotropic_gyre.jl` in validation exps,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,1,['Error'],['Error']
Availability,Error in free surface build for `HydrostaticFreeSurfaceModels` on a `ConformalCubedSphereGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3295:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3295,1,['Error'],['Error']
Availability,Error in update,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1468:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468,1,['Error'],['Error']
Availability,Error interpolating on an irregularly spaced grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2911:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2911,1,['Error'],['Error']
Availability,Error on invalid time interval + time window combinations for AveragedTimeInterval,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1288:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1288,1,['Error'],['Error']
Availability,Error only while debugging in VSCode,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171,1,['Error'],['Error']
Availability,Error related to conjugate gradient Poisson solver when setting initial condition,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3896:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3896,1,['Error'],['Error']
Availability,Error running on GPUs using `CUDA>=3.10`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['Error'],['Error']
Availability,Error setting `boundary_conditions` for `Field`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2837:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2837,1,['Error'],['Error']
Availability,Error showing value of type IncompressibleModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/707:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/707,1,['Error'],['Error']
Availability,Error tagging new release,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/87:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/87,2,['Error'],['Error']
Availability,Error using HorizontalScalarBiharmonicDiffusivity with VerticalScalarDiffusivity on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2591:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2591,1,['Error'],['Error']
Availability,Error using `ScalarDiffusivity` where the viscosity or diffusivity are functions with parameters,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840,1,['Error'],['Error']
Availability,Error using closure tuples with CATKEVerticalDiffusivity,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3804:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3804,1,['Error'],['Error']
Availability,Error using immersed boundary on GPUs with buoyancy tracer,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2558:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558,1,['Error'],['Error']
Availability,Error when attempting to plot results in langmuir_example.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/787:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787,1,['Error'],['Error']
Availability,Error when constructing a `NetCDFOutputWriter` with an immersed lat-lon grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3775:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775,1,['Error'],['Error']
Availability,Error when setting GPU field using CuArray,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/634:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/634,1,['Error'],['Error']
Availability,Error when trying the hot bubble with GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/451:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451,1,['Error'],['Error']
Availability,Error when trying to diagnose `Average` of an abstract operation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/857:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/857,1,['Error'],['Error']
Availability,Error when trying to use `MultipleForcings`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3736:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736,1,['Error'],['Error']
Availability,Error when using `ImmersedBoundaryGrid` with `HydrostaticModel` and drag boundary condition,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711,1,['Error'],['Error']
Availability,Error when using `OpenBoundaryCondition` with `HydrostaticFreeSurfaceModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628,1,['Error'],['Error']
Availability,Error when writing `Field`s reduced over 3 dimensions to NetCDF,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857,1,['Error'],['Error']
Availability,Error while implementing Vertical stretched grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571,1,['Error'],['Error']
Availability,Error while using `ImmersedBoundaries` on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367,1,['Error'],['Error']
Availability,"Error with NetCDF output - Julia v1.5, Oceananigans v0.34.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/862:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/862,1,['Error'],['Error']
Availability,Error with default `HydrostaticFreeSurfaceModel` on `TripolarGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806,1,['Error'],['Error']
Availability,Errors in the output writers docs page,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2427:0,Error,Errors,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2427,1,['Error'],['Errors']
Availability,Example/tutorial on checkpointing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1136:20,checkpoint,checkpointing,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1136,1,['checkpoint'],['checkpointing']
Availability,"Excellent to see the results. I agree that the conservative scheme is not getting any better with increasing the order of accuracy. The vector invariant scheme is slightly better, but there is not a bit difference when we increase the order of accuracy. I don't suppose it's the temporal error that is drowning this out? Maybe it's the pressure terms, which are of low order?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164710575:288,error,error,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164710575,1,['error'],['error']
Availability,"Executing the validation/multi_region/cubed_sphere_steady_state.jl file yields an error partially shown below:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 41.133 ms, wall time: 0 seconds; [ Info: ... simulation initialization complete (820.774 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching _fill_south_halo!(::Int64, ::Int64, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, NamedTuple{(:ξ, :η, :rotation), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Rotations.RotXY{Float64}}}, CPU}, ::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.South, Oceananigans.MultiRegion.North, Nothing}}, ::Tuple{Center, Center, Face}). Closest candidates are:; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Open}, ::Any, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_open.jl:36; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Flux}, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_flux.jl:32; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryCondition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619:82,error,error,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"FFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:76931,Error,Error,76931,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Error'],['Error']
Availability,"FTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:38063,Error,Error,38063,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Error'],['Error']
Availability,"FYI @francispoulin I fixed issues with syntax and the constructor, and found that now the Poisson solver tests legitimately fail for `VerticallyStretchedRectilinearGrid`. So the `FourierTridiagonalPoissonSolver` currently does not work with `Flat` dimensions. I think this is a low-priority issue so it may make sense to write a warning / error in the constructor for `FourierTridiagonalPoissonSolver` constructor and then remove the tests for it. However, I wanted to give you the chance to look into what changes might need to be made to get the FFT + tridiagonal solve working if x or y are `Flat` if you wanted to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-820559470:339,error,error,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-820559470,1,['error'],['error']
Availability,File size in the doctest coming back to slow down development again...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3860#issuecomment-2435670713:45,down,down,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3860#issuecomment-2435670713,1,['down'],['down']
Availability,"First attempt at this. Still wasn't able to make sure the code in the example works. In fact, so far it has failed:. ```julia; julia> using Oceananigans.Operators. julia> using Oceananigans.Grids. julia> function isotropic_viscous_dissipation_rate_ccc(i, j, k, grid, u, v, w, ν); Σˣˣ² = ∂xᶜᵃᵃ(i, j, k, grid, u)^2; Σʸʸ² = ∂yᵃᶜᵃ(i, j, k, grid, v)^2; Σᶻᶻ² = ∂zᵃᵃᶜ(i, j, k, grid, w)^2. Σˣʸ² = ℑxyᶜᶜᵃ(i, j, k, grid, fψ_plus_gφ², ∂yᵃᶠᵃ, u, ∂xᶠᵃᵃ, v) / 4; Σˣᶻ² = ℑxzᶜᵃᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᵃᵃᶠ, u, ∂xᶠᵃᵃ, w) / 4; Σʸᶻ² = ℑyzᵃᶜᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᵃᵃᶠ, v, ∂yᵃᶠᵃ, w) / 4. ϵ[i, j, k] = ν[i, j, k] * 2 * (Σˣˣ² + Σʸʸ² + Σᶻᶻ² + 2 * (Σˣʸ² + Σˣᶻ² + Σʸᶻ²)); end; isotropic_viscous_dissipation_rate_ccc (generic function with 1 method). julia> ε = KernelFunctionOperation(Center, Center, Center, isotropic_viscous_dissipation_rate_ccc, grid;; computed_dependencies=(u, v, w, ν)); ERROR: MethodError: no method matching KernelFunctionOperation(::Type{Center}, ::Type{Center}, ::Type{Center}, ::typeof(isotropic_viscous_dissipation_rate_ccc), ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}; computed_dependencies=(Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux), Field located at (Center, Face, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux), Field located at (Center, Center, Face); ├── data: OffsetArra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1758:883,ERROR,ERROR,883,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1758,1,['ERROR'],['ERROR']
Availability,"First of all, thank god this model runs on GPU. It is awesome how fast this is!!. I am trying to run the the model using the following function for `ScalarDiffusivity`:; ```; width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; ```; which returns the error below while running the model. ```; ┌ Warning: Cannot save Function property into closure/2/ν; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:22; ┌ Warning: Cannot save Function property into closure/2/κ/b; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:22; ┌ Info: Initializing simulation...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:168; ┌ Info: ... simulation initialization complete (27.506 ms); └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:203; ┌ Info: Executing initial time step...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:113; InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 4000, 50)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 16, 50)}, KernelAbstractions.NDIteration.StaticSize{(1, 256, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359:317,error,error,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359,1,['error'],['error']
Availability,"First, I think it would be great to have multi-order `WENO` advection, if it's not too difficult. Second, you can see an older version of the plot [here](https://github.com/CliMA/Oceananigans.jl/pull/1648). Since then we've added first order upwinding. I haven't tried running this for a while and hope it works but I guess I should try it and find out. I should point out that this script uses `ShallowWaterModel`. It is easy enough to change it for another of the two models, but I did see some odd behaviour. For `ShallowWaterModel` we have that the error goes down to 1e-14, basically machine precision and the slopes are what we should expect. When I tried this for `NonhydrostaticModel`, I found that the error didn't get any better than 1e-11 or so. I looked into this but never figured out why. The major difference between the two models is that `ShallowWater` does no thave a pressure solve, so I suspect that might be part of the problem. In the end I decided that the latter was probably the best way to test pure advection. But in retrospect, if we used `PrescribedVelocity`, then the pressure solve would not be a factor, and things should work out nicely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969007656:553,error,error,553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969007656,3,"['down', 'error']","['down', 'error']"
Availability,Fix minor error in `internal_wave.jl`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2500:10,error,error,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2500,1,['error'],['error']
Availability,Fixes bug in error for `validate_index`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2824:13,error,error,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824,1,['error'],['error']
Availability,Fixes checkpointer GPU to CPU loading and writing fields with function boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/797:6,checkpoint,checkpointer,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/797,1,['checkpoint'],['checkpointer']
Availability,Fixes error when reducing `Fields` with a `condition` on `ImmersedBoundaryGrids`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3440:6,error,error,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3440,1,['error'],['error']
Availability,Fixes interpolation error in centered fourth order tracer advection,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/935:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/935,1,['error'],['error']
Availability,Fixes off-by-one indexing error in hydrostatic pressure integrat…,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/612:26,error,error,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/612,1,['error'],['error']
Availability,Fixes sign error in HydrostaticSphericalCoriolis!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1439:11,error,error,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1439,1,['error'],['error']
Availability,Fixes sign error in flux divergence of `AnisotropicBiharmonicDiffusivity`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1703:11,error,error,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1703,1,['error'],['error']
Availability,Fixes strange error in ocean wind mixing and convection examples,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/748:14,error,error,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/748,1,['error'],['error']
Availability,"Fixing an error in the quick start code: set!(model, u=\epsilon, v=\epsilon) fails if the function \epsilon only has two arguments. Code runs if a third argument is added to the \epsilon definition.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3551:10,error,error,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3551,1,['error'],['error']
Availability,"Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ::Array{Bool, 3}, ::Int64) is ambiguous. Candidates:; condition_operand(func::Function, operand::Oceananigans.Fields.AbstractField, condition::AbstractArray, mask); @ Oceananigans.AbstractOperations /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/AbstractOperations/conditional_operations.jl:96; condition_operand(func::Function, op::Oceananigans.Fields.AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}, cond, mask); @ Oceananigans.ImmersedBoundaries /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/ImmersedBoundaries/immersed_reductions.jl:18. Possible fix, define; condition_operand(::Function, ::Oceananigans.Fields.AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}, ::AbstractArray, ::Any). Stacktrace:; [1] sum(f::Function, c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetM",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:2565,mask,mask,2565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['mask'],['mask']
Availability,"Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{}, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressures::Nothing, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.NonhydrostaticModels . ~/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:198. [21] (::Core.var""#Type##kw"")(::NamedTuple{(:grid, :advection), Tuple{RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, WENO{3, Float64, Nothing, Nothing, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}}}, ::Type{NonhydrostaticModel}); @ Oceananigans.Models.NonhydrostaticModels . ~/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:107; [22] top-level scope; @ ~/ocean_ex_1.jl:10; ```. I'm trying to step through the code to understand the code better, but I'm not able to figure out why I only get this error when I insert breakpoints. I'd greatly appreciate any help understanding this better, thank you",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171:3596,error,error,3596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171,1,['error'],['error']
Availability,Flux.jl is a pretty popular package. It seems Oceananigans conflicts with it.; If I do `using Flux` I get:; ```; ERROR: importing Flux into Main conflicts with an existing identifier; ```; Is there any way to import both?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1285:113,ERROR,ERROR,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1285,1,['ERROR'],['ERROR']
Availability,Following a discussion with @glwagner I have tried to use the Immersed Boundary Method for `ShallowWaterModel`. I have not succeeded yet but hope we can have a fruitful discussison here to fix my error. . Can someone help me figure out what I'm doing wrong?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663:196,error,error,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663,1,['error'],['error']
Availability,"Following the comments, I included a better discussion of models in the buoyancy section of model setup. I believe this is an improvement regardless of the default behavior, since we only mentioned `NonhydrostaticModel` before. The preview will be available here: https://clima.github.io/OceananigansDocumentation/previews/PR1989/model_setup/buoyancy_and_equation_of_state/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-971796207:248,avail,available,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-971796207,1,['avail'],['available']
Availability,"Following up from https://github.com/climate-machine/Oceananigans.jl/issues/73 it would be nice if the forcing can be also be expressed as an array. This might be nice for a couple of applications:; 1. A forcing that is constant and very expensive to compute (e.g. lots of calculations, branching statements, or intermediate calculations).; 2. Forcing array can be passed around and filled elsewhere, e.g. by a biogeochemical agent-based model. Pinging: @zhenwu0728",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110:445,Ping,Pinging,445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110,1,['Ping'],['Pinging']
Availability,"For `*` you can just mask one of the so you save computation time (you can use the same function as for `/`); Sorry forget this comment, I forgot about the numbers...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269930915:21,mask,mask,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269930915,1,['mask'],['mask']
Availability,"For a given time step at z=50 (surface) the rounding error in mantissa bits in the tendency addition. If red approaches 23 mantissa bits then there would be a stagnation due to rounding errors, but as long as this doesn't happen systematically it should be fine. ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/eee6d63d-c76c-4362-816d-cb931ecdb827)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672138501:53,error,error,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672138501,2,['error'],"['error', 'errors']"
Availability,"For a single gaussian vortex in geostrophic balance integrated to `t=10` the results are the following (`N^2 = 64^2`):. ```; ╭──────────────┬───────┬─────────────┬───────────────────┬─────────────┬───────────────────╮; │ Formulation │ Order │ L₂ error(h) │ L₂ error(u or uh) │ L∞ error(h) │ L∞ error(u or uh) │; ├──────────────┼───────┼─────────────┼───────────────────┼─────────────┼───────────────────┤; │ Conservative │ 3 │ 1.66e-03 │ 9.43e-03 │ 5.05e-02 │ 3.86e-01 │; │ VI_Vorticity │ 3 │ 6.80e-04 │ 2.50e-03 │ 1.63e-02 │ 8.11e-02 │; │ VI_Velocity │ 3 │ 6.20e-04 │ 2.30e-03 │ 1.49e-02 │ 7.33e-02 │; │ Conservative │ 5 │ 1.63e-03 │ 9.03e-03 │ 4.95e-02 │ 3.73e-01 │; │ VI_Vorticity │ 5 │ 5.30e-04 │ 1.95e-03 │ 1.03e-02 │ 5.63e-02 │; │ VI_Velocity │ 5 │ 4.93e-04 │ 1.94e-03 │ 9.35e-03 │ 5.04e-02 │; │ Conservative │ 7 │ 1.63e-03 │ 8.87e-03 │ 4.93e-02 │ 3.67e-01 │; │ VI_Vorticity │ 7 │ 4.99e-04 │ 1.86e-03 │ 9.17e-03 │ 5.24e-02 │; │ VI_Velocity │ 7 │ 4.84e-04 │ 1.86e-03 │ 8.93e-03 │ 4.93e-02 │; │ Conservative │ 9 │ 1.64e-03 │ 8.63e-03 │ 4.96e-02 │ 3.62e-01 │; │ VI_Vorticity │ 9 │ 4.66e-04 │ 1.73e-03 │ 7.81e-03 │ 4.52e-02 │; │ VI_Velocity │ 9 │ 4.55e-04 │ 1.74e-03 │ 7.57e-03 │ 4.61e-02 │; ╰──────────────┴───────┴─────────────┴───────────────────┴─────────────┴───────────────────╯; ```. So, indeed, conservative formulation is not as good as the vector invariant formulation (at least in this case), especially when looking at momentum. . @francispoulin the resolution of the figures above is 400^2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715:246,error,error,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715,4,['error'],['error']
Availability,"For complicated models and examples, user-defined forcing functions can impose significant penalties on simulation performance. In addition to that, models with extensive and complicated diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:260,down,down,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,1,['down'],['down']
Availability,"For example, this line:. ```julia; model.output_writers[:checkpointer] = Checkpointer(model; interval=1e6, prefix=""model_checkpoint""); ```. fails because `model` does not have a field `output_writers`. We need to use a `Simulation` here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/660:57,checkpoint,checkpointer,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/660,2,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpointer']"
Availability,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1045:251,error,error,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045,1,['error'],['error']
Availability,"For example,. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. errors with. ```julia; julia> include(""problem.jl""); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/OHYQj/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:223; ERROR: LoadError: ArgumentError: halo must be ≤ size for coordinate y; ```. Sad, because I didn't actually ask for a halo (3, 3, 3)! Manually setting things doesn't help:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. I guess the restriction on the halo size is supposed to be an optimization, but its not working in this case because I can't even set up my model. @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3622:239,error,errors,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3622,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,"For example. ```julia; using Oceananigans; using OrthogonalSphericalShellGrids; using Oceananigans.Fields: interpolate!. trg = TripolarGrid(size = (10, 10, 10), z = (0, 1)); llg = LatitudeLongitudeGrid(size = (10, 10, 10), latitude = (-75, 75), longitude = (0, 360), z = (0, 1)). ctrg = CenterField(trg); cllg = CenterField(llg). interpolate!(cllg, ctrg); ```. fails with. ```julia; julia> interpolate!(cllg, ctrg); ERROR: MethodError: no method matching fractional_x_index(::Float64, ::Tuple{…}, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}). Closest candidates are:; fractional_x_index(::Any, ::Any, ::ImmersedBoundaryGrid); @ Oceananigans ~/.julia/packages/Oceananigans/A6YUV/src/ImmersedBoundaries/ImmersedBoundaries.jl:283; fractional_x_index(::Any, ::Any, ::Oceananigans.Grids.XRegularLLG); @ Oceananigans ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:74; fractional_x_index(::Any, ::Any, ::LatitudeLongitudeGrid); @ Oceananigans ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:89; ... Stacktrace:; [1] _fractional_indices; @ ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:165 [inlined]; [2] fractional_indices; @ ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:154 [inlined]; [3] interpolate; @ ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:240 [inlined]; [4] macro expansion; @ ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:337 [inlined]; [5] cpu__interpolate!; @ ~/.julia/packages/KernelAbstractions/3B1v2/src/macros.jl:291 [inlined]; [6] cpu__interpolate!(__ctx__::KernelAbstractions.CompilerMetadata{…}, to_field::Field{…}, to_grid::LatitudeLongitudeGrid{…}, to_location::Tuple{…}, from_field::Field{…}, from_grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}, from_location::Tuple{…}); @ Oceananigans.Fields ./none:0; [7] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3745:416,ERROR,ERROR,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3745,1,['ERROR'],['ERROR']
Availability,"For example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> b = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> f = 1; 1. julia> vz_op = @at (Face, Center, Center) - ∂x(b) / f; ERROR: LoadError: MethodError: no method matching var""@at""(::LineNumberNode, ::Module, ::Expr); Closest candidates are:; var""@at""(::LineNumberNode, ::Module, ::Any, ::Any) at /Users/gregorywagner/Projects/Oceananigans.jl/src/AbstractOperations/at.jl:42; in expression starting at REPL[16]:1; ```. Found with @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415:950,ERROR,ERROR,950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415,1,['ERROR'],['ERROR']
Availability,"For example:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(3, 3, 3), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2424:476,ERROR,ERROR,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424,2,"['ERROR', 'Error']","['ERROR', 'Error']"
Availability,For example:; https://buildkite.com/clima/oceananigans/builds/17468#0191fc2c-b421-4cf7-80b5-0429336b1d7f; https://buildkite.com/clima/oceananigans/builds/17473#0191fd88-d8b9-48d5-9c7f-18efc6747ea7; I believe this is because we are launching the docs from many different branches on a relatively small GPU. I think it would be best to move this test on the caltech cluster. Since the caltech cluster works with a slurm scheduler this error would never happen (I can open a PR to fix this),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779:433,error,error,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779,1,['error'],['error']
Availability,For hydrostatic models I get errors about trying to pass double precision numbers to a kernel,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1728461532:29,error,errors,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1728461532,1,['error'],['errors']
Availability,"For now the 10 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". Maybe we just have to define `convert` for Fields with OffsetArrays?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/177:181,checkpoint,checkpointing,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177,5,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpointing']"
Availability,"For reducing any `AbstractField` over ""windows"", `ConditionalOperation` is sufficient. The task there is to define `condition` appropriately (`mask` is chosen as the ""neutral"" value for the particular reduction). I guess there isn't an ordinary constructor for `ConditionalOperand`, but there is a function `condition_operand`... https://github.com/CliMA/Oceananigans.jl/blob/b5bf45ed51587954f61ca7492e946fef69ff72ee/src/AbstractOperations/conditional_operations.jl#L23. (@simone-silvestri why is this function not simply a constructor for `ConditionalOperand`?) This feature is new so the API might change. We also need doc strings... ## On views of `Field`... We may also eventually want to implement the concept of `view`s of `Field`s. I think if that were implemented properly, we'd be able to reduce those objects. . #2177 is related; the location `Level` proposed there could handle slices across a whole dimension (but not necessarily ""windowing""...). This is for another issue, but field ""windows"" might be easy to support by using a `view` for `data`. Cause then:. ```julia; julia> a = rand(4); 4-element Vector{Float64}:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> b = OffsetArray(a, -1); 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> c = view(b, 2:3); 2-element view(OffsetArray(::Vector{Float64}, 0:3), 2:3) with eltype Float64:; 0.14802797670131396; 0.17994410698438923. julia> typeof(c); SubArray{Float64, 1, OffsetVector{Float64, Vector{Float64}}, Tuple{UnitRange{Int64}}, true}. julia> c.indices; (2:3,); ```. we have our indices. The challenge here is, if we are doing computations (eg `compute!`, broadcasting, or calling a reduction), we have to somehow reduce / compute over a view of the _operand_, using the indices stored in the _target_ appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677:143,mask,mask,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677,2,['mask'],['mask']
Availability,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:238,error,error,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"For simple cases, like @francispoulin mentioned, changing the architecture from `CPU()` to `GPU()` are often enough. Although if you wanna run simulations that are a bit more complicated, there are a few other things you might need to worry about. You can see a recent discussion about it [here](https://github.com/CliMA/Oceananigans.jl/issues/1509). Mostly you have to define everything that is being used in the model calculations as a constant, otherwise the GPU won't know what to do with it. So for example you probably will need to change some of your lines to. ```julia; const Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; const Hz = grid.Lz; Ξ(z) = randn() * z / Hz * (1 + z / Hz); # noise. ## Velocity initial condition: random noise scaled by the initial stress.; uᵢ(x, y, z) = abs(Qo) * 1e-3 * Ξ(z);; wᵢ(x, y, z) = abs(Qo) * 1e-6 * Ξ(z); # This was added to reduce the scale of the w profile; ```; (probably the same goes in other places too.). I recommend you first run the very simple examples that appear in the `README` document of this repo on a GPU to make sure that Oceananigans+GPU is working correctly. And then only after that you should try to change your example to a GPU one. If you come across some errors that you can't solve we can take it from there :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747:1262,error,errors,1262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747,2,['error'],['errors']
Availability,"For small scale testing we could use JuliaGPUs buildkite. On Wed, Sep 4, 2024 at 12:32 PM Simone Silvestri ***@***.***>; wrote:. > Right, I think the problem is the availability of AMD GPUs to run tests.; > If we find one, I can revamp this.; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328512985>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XVCEUJNTZHWDD36KDZU3OVLAVCNFSM6AAAAABDHAZB6GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGMRYGUYTEOJYGU>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328706255:165,avail,availability,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328706255,1,['avail'],['availability']
Availability,"For some cases, we _want_ these two parameters to be different (eg to ""slow down"" the free surface wave speed by using reduced gravity). But it might be friendly to some unsuspecting users to throw a warning in the constructor for `HydrostaticFreeSurfaceModel`, just in case this was not intended. cc @simonbyrne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2148:76,down,down,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2148,1,['down'],['down']
Availability,"For some reason when I tested the code after merging https://github.com/CliMA/Oceananigans.jl/pull/2028 it didn't really work on my main code for GPUs. . It worked for a MWE when I tested it [here](https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-952089949) but I guess I must have done something wrong? In any case, I apologize!. I also expanded the test to test grids on GPUs (which would have caught this error) so I think this'll help. Given that we _just_ released a new version, I didn't bump this to 0.63.4 here. But let me know if I should do that. CC: @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030:423,error,error,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030,1,['error'],['error']
Availability,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:46,error,errors,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,5,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,"Forgot to use dynamic launch configs for the `calculate_G*` kernels. But, hmmm, this actually slows things down a bit... ```; ─────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 247s / 29.9% 14.9GiB / 0.56% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 34.0s 46.1% 3.40s 292KiB 0.34% 29.2KiB; 256×256×256 (CPU, Float32) 10 30.5s 41.4% 3.05s 227KiB 0.26% 22.7KiB; 128×128×128 (CPU, Float64) 10 3.94s 5.35% 394ms 292KiB 0.34% 29.2KiB; 128×128×128 (CPU, Float32) 10 3.54s 4.80% 354ms 227KiB 0.26% 22.7KiB; 64× 64× 64 (CPU, Float64) 10 417ms 0.57% 41.7ms 292KiB 0.34% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 406ms 0.55% 40.6ms 227KiB 0.26% 22.7KiB; 256×256×256 (GPU, Float64) 10 337ms 0.46% 33.7ms 11.0MiB 13.0% 1.10MiB; 256×256×256 (GPU, Float32) 10 254ms 0.34% 25.4ms 9.62MiB 11.4% 0.96MiB; 32× 32× 32 (CPU, Float64) 10 52.6ms 0.07% 5.26ms 292KiB 0.34% 29.2KiB; 128×128×128 (GPU, Float64) 10 47.3ms 0.06% 4.73ms 11.0MiB 13.0% 1.10MiB; 32× 32× 32 (CPU, Float32) 10 46.9ms 0.06% 4.69ms 227KiB 0.26% 22.7KiB; 128×128×128 (GPU, Float32) 10 36.4ms 0.05% 3.64ms 9.62MiB 11.4% 0.96MiB; 32× 32× 32 (GPU, Float64) 10 26.6ms 0.04% 2.66ms 11.0MiB 13.0% 1.10MiB; 32× 32× 32 (GPU, Float32) 10 24.6ms 0.03% 2.46ms 9.61MiB 11.4% 0.96MiB; 64× 64× 64 (GPU, Float64) 10 24.6ms 0.03% 2.46ms 11.0MiB 13.0% 1.10MiB; 64× 64× 64 (GPU, Float32) 10 22.6ms 0.03% 2.26ms 9.62MiB 11.4% 0.96MiB; ─────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedup:; 32× 32× 32: 1.122; 64× 64× 64: 1.027; 128×128×128: 1.114; 256×256×256: 1.114. GPU Float64 -> Float32 speedup:; 32× 32× 32: 1.081; 64× 64× 64: 1.086; 128×128×128: 1.301; 256×256×256: 1.326. CPU -> GPU speedup:; 32× 32× 32 (Float32): 1.903; 32×",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/308:107,down,down,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/308,1,['down'],['down']
Availability,"Found where the promotion is occurring in the former which solves that error, and get us back to the FFT transform planning error that the nonhydostatic model gives",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731580137:71,error,error,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731580137,2,['error'],['error']
Availability,From the test log; ```; WARNING: using CUDAdrv.device in module TimeSteppers conflicts with an existing identifier.; ```. Was also responsible for test failures on PR #559. Another reason to prefer `import` over `using`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/563:152,failure,failures,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/563,1,['failure'],['failures']
Availability,"From what I understand, we need to go through the entire domain and find out how much volume (or area in 2D) of each density we have. Then find the basic state where we have the different densities layed out flat, with the heaviest on the bottom. It sounds like the hard part is looking through the density profile to see how much of each density we have. . I have read, and believe, that it gets more complicated if you have geostrophic balance, which we typically would, but starting off with a 2D non-rotating example would be a reasonable first step. Is this what other people understand?. During non-covid times, I could walk down two doors and ask Kevin Lamb for help on how to do this. Even though I can't ask him in person I can email him questions, when they arise.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759473177:631,down,down,631,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759473177,1,['down'],['down']
Availability,Further increase tolerance in implicit free surface solver tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1689:17,toler,tolerance,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1689,1,['toler'],['tolerance']
Availability,"GPU error messages are a little iffy because the CPU and GPU are not synchronized. ; The error appears in the pressure solver because it is the first location in the code where the GPU is synchronized (in this case through a memory copy).; ; There are a couple of ways to catch errors/debug, in general, what I recommend is to ; 1. use `--check-bounds=yes` this will allow you to pinpoint better the issue; 2. run a breaking code on the CPU, everything is easier there!; if this is not possible you can use the `-g 2` flag to allow GPU debugging but it is still a little more difficult than just migrating the code on CPU and making sure it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979:4,error,error,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979,3,['error'],"['error', 'errors']"
Availability,"GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:1757,error,error,1757,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"Generally looks fine. Some nice clean up!. It seems you're gravitating towards having fewer files which I think is a bad idea. Having more modular files helps a lot with both readability and organization, especially for someone who's looking through the code for the first time. It also becomes harder to find stuff with longer files. For example, It's not logically clear to me that forcings and field sets should be in `models.jl`. And if I'm looking through the file for the first time, I might find it hard to comprehend all the different functionalities provided in the file. Unrelated to this PR but working on the checkpointer in `output_writers.jl` the file has become a long list of functions, some of which are shared between multiple output writers so I think it makes more sense to split it into a set of shared functions and a file for each output writer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517483988:621,checkpoint,checkpointer,621,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517483988,1,['checkpoint'],['checkpointer']
Availability,"Getting rid of this term seems like a good idea. I can't site the lines now but they are used to compute the divergence and gradient in the tendencies. What else should we be using for these quantities?. Francis. ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Thursday, May 20, 2021 1:15:58 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Author ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] Trying to use immersed boundary method for `ShallowWaterModel` (#1663). I'd like to eliminate Δx from the code because this grid metric is only valid on regular horizontal grids. Where in ShallowWaterModel to you use Δx? I think in the stack trace for the error you received you should be able to locate where the problematic Δx is called. —; You are receiving this because you authored the thread.; Reply to this email directly, view it on GitHub<https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-845306836>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB63PQM55I6E5SLFNIYKDJLTOU7U5ANCNFSM45BACYIQ>.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-845428750:713,error,error,713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-845428750,1,['error'],['error']
Availability,"Glad someone found this and we are discussing it. Maybe a silly question but what happens when we have purely 1D problems in `x`, `y` and `z`? If we get a slow down in `z` then maybe that is an even more MWE?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891863904:160,down,down,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891863904,1,['down'],['down']
Availability,Glad you could figure it out. Did you want me to test if this change removes the error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3790#issuecomment-2374825497:81,error,error,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3790#issuecomment-2374825497,1,['error'],['error']
Availability,"Good idea! Here is the code I used: [https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/](https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/). I just copied the entire thing, and I realised that the error is mostly because of the way stop_time is defined. It is a number, and I think the code is unable to compare date time and a number. ` simulation = Simulation(model, Δt = 1e-2, stop_time = 150)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1452949101:284,error,error,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1452949101,1,['error'],['error']
Availability,"Good news: shallow water tests pass!. Bad news: the halo tests now has 12 fails, of 600 in total. . ```; <div class=""JobLogOutputComponent"" style=""box-sizing: border-box; background: rgb(23, 23, 23); border-radius: 3px; min-height: 85px; color: white; font-size: 12px; padding: 0px 0px 15px; width: 1108px; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;""><div class=""JobLogOutputComponent__Body"" style=""box-sizing: border-box; font-family: SFMono-Regular, Monaco, Menlo, Consolas, &quot;Liberation Mono&quot;, Courier, monospace;"">; Oceananigans \| 818 12 830; --; &nbsp; | Distributed MPI Oceananigans \| 816 12 828; &nbsp; | Multi architectures rank connectivity \| 28 28; &nbsp; | Local grids for distributed models \| 24 24; &nbsp; | Injection of halo communication BCs \| 168 168; &nbsp; | Halo communication \| 588 12 600; &nbsp; | Time stepping IncompressibleModel \| 4 4; &nbsp; | Time stepping ShallowWaterModel \| 4 4; &nbsp; | Distributed FFT-based Poisson solver \| 2 2; &nbsp; | ERROR: ERROR: ERROR: ERROR: LoadError: LoadError: LoadError: LoadError: Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:1449,ERROR,ERROR,1449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,5,"['ERROR', 'error']","['ERROR', 'errored']"
Availability,Good observation and I would vote for yes. I would prefer if we check and if the sizes don't match the user gets an error and is asked to fix it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125402382:116,error,error,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125402382,1,['error'],['error']
Availability,Good observation. I've simplified the code down to just `left_gradient` and `right_gradient` as suggested so there's still one duplicate definition but it'll be much better than having 5 duplicates once we support `Value` and `Gradient` boundary conditions in x.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/690#issuecomment-597544840:43,down,down,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/690#issuecomment-597544840,1,['down'],['down']
Availability,"Got bitten by CuArray scalar operations while debugging some Europa runs so this PR adds an `__init__()` function to the Oceananigans module that disables CuArray scalar operations once the module has been loaded and only allows scalar ops via the `CUDA.@allowscalar` macro. Now when we accidentally perform scalar ops on CuArrays we should get an error, which is much better than having silent performance regressions which has happened multiple times in the past. Two remaining problems:; 1. `set!(u::Field, v::Number) = @. u.data = v` actually incurs scalar ops because `a::CuArray .= 1.5` does not but `a::OffsetArray{CuArray .= 1.5` does, so it's probably something we have to fix by adapting broadcasting over offsetarrays?; 2. For similar broadcasting reasons I think; ```julia; data = cpudata(output); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```; also incurs scalar ops during NetCDF output so I will try changing back to the old behavior where we used something like `	 ; ```julia; data = interiorparent(output); !isa(output, Array) && (data = Array(data)); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```. Resolves #276",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/851:348,error,error,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851,1,['error'],['error']
Availability,"Got the regression tests error (tests pass locally), it was from the change to the order of halo filling with open boundaries separated from normal boundaries which I have now corrected",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2152786764:25,error,error,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2152786764,1,['error'],['error']
Availability,"Great example @navidcy . Do we want to mask the hill in the animations? (Especially since https://github.com/CliMA/Oceananigans.jl/pull/3092 isn't merged yet.) The top plot specifically keeps changing color where the hill is supposed to be, which might throw off some readers. This could probably be done with [`Makie.poly`](https://docs.makie.org/dev/examples/plotting_functions/poly/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1576895842:39,mask,mask,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1576895842,1,['mask'],['mask']
Availability,"Great stuff guys. Can we now put a ridge down our eddying channel? Is an; island possible? John. On Fri, Oct 30, 2020, 11:52 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Fun pair programming sesh with @ali-ramadhan; > <https://github.com/ali-ramadhan> @whitleyv <https://github.com/whitleyv>; > lead to this!; >; > [image: flow_around_cylinder]; > <https://user-images.githubusercontent.com/15271942/97726829-083c6080-1aa6-11eb-8c62-c38771eac0bf.gif>; >; > Implementation is here:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/src/TimeSteppers/correct_immersed_tendencies.jl; >; > and the script that produced the above animation:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/examples/flow_around_cylinder.jl; >; > We just did something very simple as a starting point --- hopefully more; > to come.; >; > @weymouth <https://github.com/weymouth> thanks for your insights ---; > could make sense to schedule a meeting sometime soon to discuss next steps.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719635414>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRK6RHZWBUDAPODUQLSNLOMHANCNFSM4SNJ4CSA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-720000502:41,down,down,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-720000502,1,['down'],['down']
Availability,Great work. . What's the error with `TimeInterval`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732432961:25,error,error,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732432961,1,['error'],['error']
Availability,"Greetings everyone,; I was recently started writing my outputs into a NetCDF file. Now I realize that I have to use checkpointer that can checkpoint the model to a NetCDF files, But I haven't found any method. There is for JLD2 files. So can you please look into this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1929:116,checkpoint,checkpointer,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929,2,['checkpoint'],"['checkpoint', 'checkpointer']"
Availability,"Greg, Ali, and what if we began to consider more complex geometries etc -; hard to resist going in that direction..... we'd have to change the solvers; - more MITgcm-like, congrad etc - but what would the implications be for; boundary conditions? More food for thought. John. On Sat, Mar 28, 2020 at 10:22 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Mostly I am worried about scalability and sustainability in this design,; > or future designs.; >; > Currently our models are fairly simple, but its challenging to place; > bounds on potential future complexity. For example, models in the future; > may require additional fields associated with closures or; > parameterizations, such as (two-dimensional) boundary layer depth fields,; > plume quantities, mixing lengths and perhaps other auxiliary fields; > associated with various prognostic / diagnostic LES models. We probably; > can't plan to support setting boundary conditions on every possible field; > via the model constructor.; >; > With our current design we have essentially special-cased turbulent; > diffusivities because our focus is LES, turbulent diffusivities are; > relatively common, and it convenient for us. However doing this incurs some; > maintenance burden --- which will increase if we plan to hard-code; > validation and error checking.; >; > Food for thought.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605453798>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT642WME2EIX3DDSITRJYBYXANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060:1229,mainten,maintenance,1229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060,2,"['error', 'mainten']","['error', 'maintenance']"
Availability,"Greg, I have notes on a 'capacitance method' that we used in qg models in; complex geometries in the 1980s. That also would not require us to change; the solver. You carry out Green's function calculations in a rectangular; region where the delta-functions vorticities are placed at the positions of; the irregular boundary within the larger rectangular region. I will look; them out. John. On Sat, Mar 28, 2020 at 11:20 AM Gregory L. Wagner <notifications@github.com>; wrote:. > @johncmarshall54 <https://github.com/johncmarshall54> agreed, that's a; > challenge we have to confront.; >; > If we implement immersed boundaries using the ""continuous forcing; > technique"", then a boundary may be defined essentially by a masking; > function. In this case, we might be able to ""label"" each boundary / masking; > function with a name or number.; >; > The boundary condition objects we then give to fields would have to define; > a condition to be applied both at the boundaries of the numerical grid; > (which we currently support), as well as any immersed boundaries, where; > immersed boundaries are referenced by name or number.; >; > By the way, if we use a continuous forcing technique, we do not have to; > change the pressure solver. This is a major simplification. Recent work; > suggests there is no disadvantage in terms of accuracy in using the; > continuous forcing technique, either. I'm not sure if this is too good to; > believe or not --- we should discuss and take a deeper look at the; > literature.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605461456>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQHGXSSKOU7EIXSLBTRJYIVFANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605466623:720,mask,masking,720,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605466623,2,['mask'],['masking']
Availability,"Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), y=(0, 5), topology=(Periodic, Bounded, Flat)). # Gaussian bump of width ""1""; bump(x, y, z) = y < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)); model = ShallowWaterModel(grid=grid_with_bump, gravitational_acceleration=1); ```. and it worked until the last line, which gave an error I copied below. I presume we should fix this before we think about doing any merging. Any suggestions @glwagner ?. ```; Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids ~/software/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: MethodError: no method matching with_halo(::Tuple{Int64, Int64, Int64}, ::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}); Closest candidates are:; with_halo(::Any, ::RegularRectilinearGrid) at /home/fpoulin/software/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:218; with_halo(::Any, ::VerticallyStretchedRectilinearGrid) at /home/fpoulin/software/Oceananigans.jl/src/Grids/vertically_stretched_rectilinear_grid.jl:242; Stacktrace:; [1] ShallowWaterModel(; grid::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}, gravitational_acceleration::Int64, architecture::Oceananigans.Architectures.CPU, clock::Oceananigans.TimeSteppers.Clock{Float64}, advec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844218915:974,ERROR,ERROR,974,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844218915,1,['ERROR'],['ERROR']
Availability,"Grid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 10×10×10 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> bcs = FieldBoundaryConditions(grid, (Center, Center, Face); top=GradientBoundaryCondition(1), bottom=GradientBoundaryCondition(1)); Oceananigans.FieldBoundaryConditions, with boundary conditions; ├── west: PeriodicBoundaryCondition; ├── east: PeriodicBoundaryCondition; ├── south: PeriodicBoundaryCondition; ├── north: PeriodicBoundaryCondition; ├── bottom: GradientBoundaryCondition: 1; ├── top: GradientBoundaryCondition: 1; └── immersed: FluxBoundaryCondition: Nothing. julia> b_z = Field(∂z(b), boundary_conditions=bcs); ERROR: ArgumentError: Cannot specify bottom boundary condition GradientBoundaryCondition: 1 on a field at Face()!; Stacktrace:; [1] validate_boundary_condition_location(bc::BoundaryCondition{Oceananigans.BoundaryConditions.Gradient, Int64}, loc::Face, side::Symbol); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/Ey1oO/src/Fields/field.jl:52; [2] validate_boundary_conditions(loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, bcs::FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryConditi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2837:1776,ERROR,ERROR,1776,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2837,1,['ERROR'],['ERROR']
Availability,"Grid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [0.0, 8.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); 1.0. julia> grid = RectilinearGrid(GPU(), size=(16, 16, 16), x=(0,1), y=(0,1), z=0:16); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:89; [2] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/utils/call.jl:26; [4] #39; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CUDA.CuDeviceArray{Float64, 4, 1}, ::KernelFunctionOperation{Center, Center, C",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490603313:1173,error,error,1173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490603313,1,['error'],['error']
Availability,"Ha! It seems @glwagner has cracked it! Top figure is the pressure std and bottom figure is `model.clock.last_Δt`:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/29ca5731-668c-4e5b-9a25-123600f4a771). I still don't fully understand why this seems to affect the simulations that I pointed out but not others, but it's hard to argue against that correlation. @glwagner to prevent these round-off errors all we need to to is to ensure that `first_stage_Δt`, `second_stage_Δt` and `third_stage_Δt` add up to `Δt` in ; https://github.com/CliMA/Oceananigans.jl/blob/fb2c670626e38e3bffe298c485f95625fb1d83be/src/TimeSteppers/runge_kutta_3.jl#L94-L96. correct?. If so, would it be a good idea to work backwards in the last statement and set `third_stage_Δt = Δt - first_stage_Δt - second_stage_Δt` and use locally defined `γ³` (or `ζ³`) from it? The difference would be either zero or very small by construction. ---. On a side note, while plotting this I realized that I was confused about `model.clock.last_Δt`, since I assumed it was the last Δt of the simulation (so in my MWE it would be `25` at all time steps except for maybe eventual round-off errors), but it's the Δt of the time-stepper substeps, which makes more sense but now I'm thinking maybe the name is a bit misleading and should be changed to `last_substep_Δt` or something. But that's an issue for another issue :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103076211:413,error,errors,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103076211,2,['error'],['errors']
Availability,"Ha, @rabernat beat me to it. I just wanted to mention that I am also available for questions and maybe clarify one more point of confusion that seems to stem from our current docs (working on improving that with @tomchor s input). . There are two parts in the NetCDF output that would make the integration with xgcm smooth: ; - Proper metadata for the dimensions (as mentioned by @rabernat above); - Output of grid metrics, which are distances, areas and cell volume of the grid. An important detail there is that each of the metrics should describe properties of the *surrounding cell*. So if you have a tracer value on the point `xT` and the cell bounds are given by a staggered coordinate `xC`, the distance (lets call it `dx`) for each `xT` point should describe the distance between the two surrounding `xC` points (and have `xC` as coordinate, so it can be matched correctly by xgcm). Currently the user has to input these manually but it might be convenient to add the [cf-attribute `cell_measures`](http://cfconventions.org/cf-conventions/cf-conventions.html#cell-measures), which we might support in the future with a more complete support for cf-metadata (see e.g. https://github.com/xgcm/xgcm/issues/127)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849:69,avail,available,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849,1,['avail'],['available']
Availability,Haha that last error might actually be worth framing on a wall!. RIP PTX assembler,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738871561:15,error,error,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738871561,1,['error'],['error']
Availability,"Happens with Julia 1.6.7 and 1.8.1 with Oceananigans v0.77.5. Not sure if this is connected to #2530 or #2709 although this errors on the CPU. ~Minimal~ working example:. ```julia; using Oceananigans. topo = (Bounded, Bounded, Bounded); domain = (x=(-1, 1), y=(-1, 1), z=(-1, 0)); grid = RectilinearGrid(CPU(); topology=topo, size=(8, 8, 8), domain...). v_bcs = FieldBoundaryConditions(grid,; east = ValueBoundaryCondition(0),; west = ValueBoundaryCondition(0); ). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(constant_salinity=true),; tracers = :T,; boundary_conditions = (v=v_bcs,); ); ```. Stacktrace from Julia 1.8.1: https://gist.github.com/ali-ramadhan/e45cc2d447f2ece001b4f2d9295b36b1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2768:124,error,errors,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768,1,['error'],['errors']
Availability,"Happy to open an issue (or post to #1634) when I have the time to work on CI. What should we do with this PR? I think it's a net positive change so I'm happy to approve as long as the images aren't in git history. If we decide to nuke this part of the docs then I suppose this PR is moot and should be closed. > _when_ / _if_ somebody can take responsibility for maintaining it. I think responsibility for maintaining the pipeline should fall on all maintainers/developers, otherwise it's not sustainable. Ideally if you open a PR that breaks a validation experiment you should fix it. If done concurrently it should only consist of small changes so it should only be a small burden (although burdens to add up). I guess we don't run the validation CI on every PR since it's too expensive so maintenance is tough right now. Maybe we can run validation CI before every tagged release or something? Better infrastructure is needed I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889:792,mainten,maintenance,792,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889,1,['mainten'],['maintenance']
Availability,"Happy to try these. The first one failed in the same way as before. The second one failed because the syntax does not seem right with clock. I instead tried this. ```; model = IncompressibleModel(architecture=GPU(), advection=WENO5(), clock=Clock{Float64}(0,0,1), grid=grid); ```; and that also had an error, with what seems to be the same message. Hmm...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870707388:302,error,error,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870707388,1,['error'],['error']
Availability,"Hello everyone,; I am facing some difficulty in running this code. This doesn't show any error and generates an output JLD2 file and then seemed to freeze. No sign appears. It even doesn't write any output in the file. From the system point of view, I can see that Julia correctly recognizes GPUs as being am_70 type and compiles some code for them. Then it starts to execute the following statement:. ```run!(simulation)```. That statement is running for some time and get freezes. Can you please run it in your system, I want to check whether it is the code or my system creating this strange behaviour. . ```; using Printf; # using Pkg; # pkg""add Oceananigans#ali/unclog-docs""; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Units: minute, minutes, hour; using Oceananigans.Grids: nodes; using Oceananigans.Diagnostics; using Oceananigans.OutputWriters: JLD2OutputWriter, FieldSlicer, TimeInterval; using Statistics; using CUDA. #number of grid spacing in south,north and vertical direction and in oceananigans ; #they call this as the size of one grid in that direction; const Nx=256; const Ny=256; const Nz=64. #Length of grid in south, north and vertical direction; const Lx=4; const Ly=4; const Lz=0.1. #Vetrical temperature gradient; const dTz = 70. #scaled gravitational acceleration; const g=300. const R0=1; const T0=30; const Factor_T =1e-6; const Factor_V=1e-8. Name_of_simulation = ""ocean_convection_Fplane_GPU"". #Coefficient of Thermal expansion; const alpha= 2e-4; #Coefficient of Salinity; const saline=0; #diffusive viscocity; const v=1e-5 ; #diffusivity; const k=2e-6 . const l=Lx/2 #center of gaussian field; const m=Ly/2 #center of gausian field. const Bo=3.6e-4 #maximum surface flux; const f=-0.5 #coriolis parameter. computational_grid = RegularRectilinearGrid(size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz)); show(computational_grid). ##xC,yC,zC are not defined for vertically stretched grid; # computational_grid.zᵃᵃᶜ; # computational_grid.xᶜᵃᵃ; # computational_gri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613:89,error,error,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613,1,['error'],['error']
Availability,"Hello! I am new to Julia, Oceananigans, and computational fluid dynamics, so please forgive me if I missed something obvious or made a trivial mistake. As a first exercise with Oceananigans I am trying to simulate some high salinity, low temperature water above low salinity, high temperature water (with a bit of random noise), with a small initial westward velocity component and a 10 second time step. The documentation was quite helpful (thanks for that), and the simulation works as expected until about t=50s, when small water parcels at the density interface heat up or cool down to unnatural levels (see attached gifs at bottom), and occasionally the entire temperature matrix fills with NaN's. I've tried removing all my boundary conditions to see if they were the problem, but the issue persisted. For reference, I am using Julia v1.5 with Oceananigans 0.44.1, with this platform:; OS: macOS (x86_64-apple-darwin18.7.0); CPU: Intel(R) Core(TM) i5-6360U CPU @ 2.00GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, skylake). And here is a minimal example, along with code to gif-ify the output. Lowering the timestep down to 1 second from the current 10 seconds also does not fix anything. Also using a time step wizard with initial del_t at 1 second and cfl=0.3 still generates unrealistic temperatures; however, it then seems to freeze before converting entirely to NaN's and would not progress given an extra (real-life) hour to run compared to the fixed timestep. ```; using Oceananigans; using Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(250, 250, 250), y=(-500,500), x=(-500,500), z=(-500,0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3),; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=Anisotropi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190:582,down,down,582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190,1,['down'],['down']
Availability,"Hello, . I've tested it in `Oceananigans v0.91.8` with:. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd48430 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 64 × Intel(R) Xeon(R) Gold 6130 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, skylake-avx512); Threads: 1 default, 0 interactive, 1 GC (on 64 virtual cores); Environment:; JULIA_CUDA_MEMORY_POOL = none. julia> Oceananigans.CUDA.versioninfo(); CUDA runtime 12.1, artifact installation; CUDA driver 12.1; NVIDIA driver 530.30.2. CUDA libraries:; - CUBLAS: 12.1.3; - CURAND: 10.3.2; - CUFFT: 11.0.2; - CUSOLVER: 11.4.5; - CUSPARSE: 12.1.0; - CUPTI: 2023.1.1 (API 18.0.0); - NVML: 12.0.0+530.30.2. Julia packages:; - CUDA: 5.4.3; - CUDA_Driver_jll: 0.9.2+0; - CUDA_Runtime_jll: 0.14.1+0. Toolchain:; - Julia: 1.10.4; - LLVM: 15.0.7. Environment:; - JULIA_CUDA_MEMORY_POOL: none. Preferences:; - CUDA_Runtime_jll.version: 12.1. 1 device:; 0: Tesla V100-PCIE-32GB (sm_70, 30.884 GiB / 32.000 GiB available); ```; and the issue seems solved. ; I agree with @ali-ramadhan, it seems that this issue was fixed at some point, although I haven't managed to pinpoint the version, I think I had the issue when I was using `CUDA v5.1.2`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2298503471:1077,avail,available,1077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2298503471,1,['avail'],['available']
Availability,"Hello, . I've worked implementing this automatic concatenation for the output, when a simulation is picked up from a checkpoint, with the flag splitting_files on. This feature addresses the fact that otherwise the simulation output filename needs to be changed manually each time the simulation is restarted. . In other words, if a simulation is run to output in a `file.nc` with the flag splitting_files, different files will be created such as `file_part1.nc`, `file_part2.nc`. If the overwrite_output is true, these files will be rewritten and the data will be deleted. If the overwrite_output is false, the simulation will crash since it will not find the original `file.nc`. The new code ensures that if overwrite_output is false, then the model will append the output to the last file. i.e. `file_part2.nc`. . Before working more on this (i.e. including joining output in jld2), I'm wondering if this will be useful to implement in the other schedulers and merge to master. What do you think @glwagner @tomchor @navidcy ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818:117,checkpoint,checkpoint,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818,1,['checkpoint'],['checkpoint']
Availability,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1635:25,error,error,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635,3,"['Down', 'error']","['Downloaded', 'error', 'errored']"
Availability,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:523,error,errored,523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,2,"['ERROR', 'error']","['ERROR', 'errored']"
Availability,"Hello,. I've been working with @johnryantaylor, and we've been using Lagrangian Particles but have come across an issue. To preface, the issue be my miss understanding of how to use tracked fields but I can't find an obvious solution. Essentially the problem seems to be that to define an tracked field for a tracer you have to already have the model defined, but to do that you have to have the particles defined. A work around for this was to make the model, then define the particles, then redefine the model. This would run and not error, but would result in the tracked field property of the particles not actually being updated. Running it yet again appears to fix it and make it; work. In order to fix this I've modified the `update_particle_properties!` function to explicitly use the models tracer fields when it is a tracer field being tracked. I've also updated the tests which seem to run. If you run the tests on the previous version of the code then the property t does not get updated (but will run with this set up). I hope this is the best place for me to make this pull request since you're updating particle tracking anyway!. Jago",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2662:536,error,error,536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2662,1,['error'],['error']
Availability,"Hello,; I noticed a vertically irregular grid can be passed to a nonhydrostatic model and seems to run without a problem, but when the same formulation is applied to the horizontal, a method error is returned by the PressureSolver. The error persists if either the FFTBasedPoissonSolver or the FourierTridiagonalPoissonSolver are called. Is this a known issue?. A MWE follows. Notice the MWE is a reduction of the example given in the [grid documentation](https://clima.github.io/OceananigansDocumentation/stable/model_setup/grids/), which also gives back the same error when passed to a nonhydrostatic model.; ``` ; using Oceananigans. Lx, Ly, Lz = 1e4, 1e4, 1e3;; Nx, Ny, Nz = 64, 64, 32;; chebychev_spaced_y_faces(j) = - Ly/2 * cos(π * (j - 1) / Ny). grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = (-Lz,0); ). model = NonhydrostaticModel(; grid); ```. Gives:; ``` ; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, ; Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:23; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:24; PressureSolver(::Any, ::ImmersedBoundaryGrid) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\Nonhydrosta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2940:191,error,error,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2940,3,['error'],['error']
Availability,"Hello,; maybe this is an easy one since those mentioned scripts ([lid_driven_cavity](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/lid_driven_cavity/lid_driven_cavity.jl) & [thermal_bubble](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/thermal_bubble/thermal_bubble.jl)) don't seem that complicated. But after several days of reading code, poking around and trying stuff out I couldn't get rid of this Error when running them.; Did someone have or can point me to a solution?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507:438,Error,Error,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507,1,['Error'],['Error']
Availability,"Hello. Thank you for this contribution. I am really interested in using it. . I tried to run the example here: https://clima.github.io/OceananigansDocumentation/v0.22.0/generated/ocean_wind_mixing_and_convection/. I am getting the error: RegularCartesianGrid not defined; Is there something I need to import? Thank you! Sorry, I am a novice with Julia.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3083:231,error,error,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3083,1,['error'],['error']
Availability,Helpful error message for incorrect usage of `FieldBoundaryConditions`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1968:8,error,error,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968,1,['error'],['error']
Availability,"Helpful error when using an invalid `schedule` in OutputWriters, Diagnostics, and Callbacks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2180:8,error,error,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180,1,['error'],['error']
Availability,"Here I've removed the over-specification that `DiscreteForcing` must have a `Function` in the second parameter so that an object can be put there instead, and a method on that object be the forcing function (don't think I'm describing this very well). This is useful if you want to pass information to a forcing by defining a struct like:; ```julia; struct StructForcing{D}; data :: D; end. (forcing::StructForcing)(i, j, k, grid, clock, model_fields) = forcing.data[i, j, k]; ```. Then this would fail with this error:; <details>; <summary>; MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; </summary>; Struct method forcing [CPU]: Error During Test at /Users/jago/Documents/Projects/Oceananigans.jl/test/test_forcings.jl:204; Test threw exception; Expression: struct_method_forcing(arch); MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; Stacktrace:; [1] u_velocity_tendency; @ ~/Documents/Projects/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:71 [inlined]; [2] cpu_calculate_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; [3] cpu_calculate_Gu!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{3}, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, Gu::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3237:513,error,error,513,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237,2,"['Error', 'error']","['Error', 'error']"
Availability,"Here are a couple of comments that come to mind when looking at your code. 1. You're using a call to `znodes(Center,grid)`, which indicates that you're using an out-of-date version of the code. I suggest you update the code to the latest version and then try again. It's good to always keep your code up-to-date (especially when posting here) because the code is always being improved upon (and in some instances some bugs get fixed which may be important to your example!). 2. That said, about this:. > Finally, in this case the z-axis is range from -15 to 0, so I can't use `const z₁ = -1*znodes(Center,grid)[1]` because if I do that, the value of z1 will change to 14.88. My code `const z₁ = -1*znodes(Center,grid)[grid.Nz]` will keep z1 equals to Closest grid center to the bottom (0.12). This isn't the best way to define $z_1$. The current statement will break if you, for example, decide to stretch the grid vertically. The more robust way to define $z_1$ is. ```julia; julia> grid = RectilinearGrid(CPU(), size=(64,64,64), extent=(π*H, π*H, H)); 64×64×64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408:936,robust,robust,936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408,2,['robust'],['robust']
Availability,"Here are some plots for the incompressible model's benchmarks. Note that I also added a benchmark for Nx=256 however, anything larger (e.g. Nx=512) resulted in an out of memory error even when ran by itself. times; ![incompressible_times](https://user-images.githubusercontent.com/45054739/120524817-77b06080-c3a5-11eb-999b-48a936947268.png). speedups going from cpu to gpu; ![incompressible_speedup](https://user-images.githubusercontent.com/45054739/120527123-f7d7c580-c3a7-11eb-90b5-05d451f10663.png); ; Also, a small change done to the shallow water graph above. The y-axis label has been changed to ""Time (ms)"" for more clarity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-853237538:177,error,error,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-853237538,1,['error'],['error']
Availability,"Here are some plots that maybe help to explain the difficulties we are having here. First, a plot of the free-surface height and we see two regions in the Indian ocean where the height is close to zero. ![η557](https://github.com/CliMA/Oceananigans.jl/assets/8239041/e66a77bf-b87c-4725-ab66-be1c4edf54b7). Second, this is a close up of the region in the centre of the Indian ocean. ![η557_closeup1](https://github.com/CliMA/Oceananigans.jl/assets/8239041/e7200982-bdae-4cdc-9a17-f2bf3580c248). Third, we see the topography for the same close up region. ![bat_closeup1](https://github.com/CliMA/Oceananigans.jl/assets/8239041/630863a4-6268-4a3c-8a0e-4d99d72dce59). Fourth, this is a zonal slice of the bathymetry, and see see that the height gets very shallow, it's `86 m` below.; ; ![bat_slice_closeup1](https://github.com/CliMA/Oceananigans.jl/assets/8239041/43cd6ae0-94ec-4bf0-adee-396915b2d66b). @simone-silvestri Do we want to change the tolerance parameters of the simultion or smooth the bathymetry?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2008110162:942,toler,tolerance,942,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2008110162,1,['toler'],['tolerance']
Availability,"Here are some results for weak and strong scaling of distributed shallow water model on one node with 32 cores. The efficiency for both goes down to 80% on 32 cores. This is comparable to what @ali-ramadhan found a while back, but not sure if that made it on an issue or a PR. I'm now trying to go to 64 cores on 2 nodes, and hope to have some results to show soon, after I figure out some weird behavour. ```; Shallow water model weak scaling benchmark; ┌──────────────┬─────────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├──────────────┼─────────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ (4096, 256) │ (1, 1) │ 357.509 ms │ 357.738 ms │ 357.932 ms │ 359.397 ms │ 1.60 MiB │ 2774 │ 10 │; │ (4096, 512) │ (1, 2) │ 371.114 ms │ 371.639 ms │ 372.070 ms │ 381.467 ms │ 1.49 MiB │ 3116 │ 20 │; │ (4096, 1024) │ (1, 4) │ 371.134 ms │ 372.336 ms │ 372.644 ms │ 379.017 ms │ 1.49 MiB │ 3116 │ 40 │; │ (4096, 2048) │ (1, 8) │ 376.120 ms │ 376.283 ms │ 378.017 ms │ 409.322 ms │ 1.49 MiB │ 3116 │ 80 │; │ (4096, 4096) │ (1, 16) │ 388.076 ms │ 394.677 ms │ 396.207 ms │ 426.799 ms │ 1.49 MiB │ 3116 │ 160 │; │ (4096, 8192) │ (1, 32) │ 428.043 ms │ 444.197 ms │ 445.236 ms │ 479.791 ms │ 1.49 MiB │ 3116 │ 320 │; └──────────────┴─────────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘; [2021/06/08 11:49:56.194] INFO Writing Shallow_water_model_weak_scaling_benchmark.html...; Shallow water model weak scaling speedup; ┌──────────────┬─────────┬──────────┬────────────┬──────────┬─────────┐; │ size │ ranks │ slowdown │ efficiency │ memory │ allocs │; ├──────────────┼─────────┼──────────┼────────────┼──────────┼─────────┤; │ (4096, 256) │ (1, 1) │ 1.0 │ 1.0 │ 1.0 │ 1.0 │; │ (4096, 512) │ (1, 2) │ 1.03886 │ 0.962595 │ 0.930602 │ 1.12329 │; │ (4096, 1024) │ (1, 4) │ 1.04081 │ 0.960794 │ 0.930602 │ 1.12329 │; │ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-857089098:141,down,down,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-857089098,1,['down'],['down']
Availability,"Here is the MWE related to this issue:; ```julia; # this is a MWE for reproducing AveragedTimeInterval errors; using Oceananigans; using Printf; using Plots. function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(1δt, window=δt, stride = 1),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. function progress_message(sim) ; wta = sim.output_writers[:timeavg].outputs[""u""]; wd = wta.window_start_time; ws = wta.window_start_iteration; pc = wta.previous_collection_time; fo = wta.fetch_operand; res = sum(wta.result); mct = model.clock.time; interval = wta.schedule.interval; window = wta.schedule.window; timestep = model.clock.last_stage_Δt; # pis = wta.schedule.previous_interval_stop_time; cll = wta.schedule.collecting; nat = next_actuation_time(wta.schedule); fat = wta.schedule.first_actuation_time; actuation = wta.schedule.actuations; @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", pre",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:103,error,errors,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,5,"['Checkpoint', 'checkpoint', 'error']","['Checkpointer', 'checkpointer', 'errors']"
Availability,Here's a `cg` implementation:. https://jso.dev/Krylov.jl/stable/examples/cg/. @amontoison is there an in-place version that accepts a preallocated solution `x`? We'd prefer that since we carefully manage memory and want to create the possibility of maximizing available memory on GPUs.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387464195:260,avail,available,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387464195,1,['avail'],['available']
Availability,"Here's a clue: this fixes the issue. ```julia; Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). progress_cb = simulation.callbacks[:progress]; @show actuations = progress_cb.schedule.actuations. # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); progress_cb = simulation.callbacks[:progress]; progress_cb.schedule.actuations = actuations; run!(simulation, pickup=checkpoint); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246088650:232,checkpoint,checkpoint,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246088650,4,['checkpoint'],['checkpoint']
Availability,"Here's a simple hydrostatic model benchmark. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)); model = HydrostaticFreeSurfaceModel(; grid, momentum_advection=WENO(), tracer_advection=WENO()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Results. ```julia; 10.220 s (85845109 allocations: 37.94 GiB) # this PR; 6.284 s (66184308 allocations: 16.31 GiB) # this PR with KA downgraded to 0.7.2; ```. So we are close but not there yet. What about solvers ... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3026#issuecomment-1482146085:637,down,downgraded,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3026#issuecomment-1482146085,2,['down'],['downgraded']
Availability,"Here's an MWE:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size=(2, 2), x = (0, 4), z=(0, 4), topology = (Periodic, Flat, Bounded)); mask = CenterField(grid); mask[1, 1, 1] = 1; grid = ImmersedBoundaryGrid(grid, GridFittedBoundary(mask)). c = CenterField(grid); w = ZFaceField(grid); set!(c, 1); set!(w, 1). @show maximum(c) maximum(w); ```. as might be expected this returns . ```julia; maximum(c) = 1.0; maximum(w) = 1.0; ```. but then writing. ```julia; mask_immersed_field!(c, NaN); mask_immersed_field!(w, NaN). @show maximum(c) maximum(w); ```. leads to. ```julia; maximum(c) = 1.0; maximum(w) = NaN; ```. The reason is because `mask_immersed_field` will touch nodes that `maximum` does not ignore. But we want consistency between the two for many reasons, including analysis. I believe @simone-silvestri's suggestion is to fix `condition_operand` to ignore all `peripheral_nodes` --- not just `inactive` and `immersed_peripheral_node`. The difference between the two are points that lie on non-immersed boundaries, and only affect fields with at least one Face location (like `w` above).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3791:204,mask,mask,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3791,3,['mask'],['mask']
Availability,"Here's an even simpler MWE that illustrates the fundamental issue:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1, stop_time=6). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(2)). # Run a simulation that saves data to a checkpoint; model.clock.iteration = 1 # we want to start here for some reason; run!(simulation); ```. which produces. ```julia; julia> include(""test2.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (383.622 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (620.680 μs).; [ Info: Iter: 2, time: 1 second; [ Info: Iter: 3, time: 2 seconds; [ Info: Iter: 5, time: 4 seconds; [ Info: Iter: 7, time: 6 seconds; [ Info: Simulation is stopping after running for 25.701 ms.; [ Info: Simulation time 8 seconds equals or exceeds stop time 8 seconds.; [ Info: Iter: 9, time: 8 seconds; ```. Basically here there is a ""spurious actuation"" at the first iteration (here iteration 2, because we started from iteration 1). This fixes the issue:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1, stop_time=6). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); progress_cb = Callback(progress_message, TimeInterval(2)); simulation.callbacks[:progress] = progress_cb. # Run a simulation that saves data to a checkpoint; model.clock.iteration = 1 # we want to start here for some reason; progress_cb.schedule.actuations = 1; run!(simulation); ```. producing. ```julia; julia> include(""test2.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (595.408 μs); [ I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246123947:474,checkpoint,checkpoint,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246123947,2,['checkpoint'],['checkpoint']
Availability,"Here's an example:. ```; using Oceananigans; grid = RectilinearGrid(arch, size=(20, 20, 20), extent=(1, 1, 1)); a_field = Oceananigans.Fields.Field{Center, Center, Center}(grid; indices=(:, :, 1:1)); model = NonhydrostaticModel(grid = grid, auxiliary_fields=(;a_field)); simulation = Simulation(model, Δt=1.0, stop_iteration=1). simulation.output_writers[:a_field] = JLD2OutputWriter(model, (model.auxiliary_fields), filename=""example.jld2"", schedule=IterationInterval(1)); ```; And the error I get:; ```; ERROR: BoundsError: attempt to access 26×26×1 Array{Float64, 3} at index [4:23, 4:23, 4:23]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:227; [5] view; @ ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:286 [inlined]; [6] construct_output; @ ~/.julia/packages/Oceananigans/p4kDj/src/OutputWriters/output_construction.jl:49 [inlined]; [7] construct_output(user_output::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061:487,error,error,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Here's another concept for an API. As I understand this, the basic operations we want to support divide a 2D plane into a rectilinear grid. Based on this principle, we can support only a dimension-by-dimension specification (ie x and y are specified independently). Example use cases are:. * equal partitioning of one or both dimensions among `R` ranks; * non-uniform partitioning based on the number of grid points carried by each rank; * non-uniform partitioning based on the relative size (necessarily approximate) associated with each rank. Is there anything else we want to support?. Here's a syntax that achieves those:. ```julia; p = Partition(x=Equal()) # computation equally partitioned among available ranks, however many are available.; p = Partition(x=4) # computation equally partitioned between 4 ranks. There must be 4 available ranks; p = Partition(x=2, y=Equal()) # computational divided among 2 ranks in x, and the remaining distributed equally in y. There must be at least 2 ranks.; p = Partition(x=Equal(), y=Equal()) # somehow ""almost evenly"" divided among xy?; p = Partition(x=Relative(0.1, 0.3, 0.6)) # computational unevenly distributed among 3 ranks in x each given grids that contain 10%, 30%, 60% of the total grid points. There must be 3 ranks.; p = Partition(x=Relative(1, 3, 6)) # same as above (eg we normalize by the total amount, not requiring =1); p = Partition(x=Equal(), y=Relative(1, 3, 6)) # computation unevenly distributed in y among 3 ranks, but evenly distributed in x amoung remaining ranks. There must be at least 3 ranks.; p = Partition(x=[16, 32, 64]) # computational distributed among 3 ranks each with 16, 32, and 64 grid points total. The total size of the grid must be 16 + 32 + 64 = 112 and there must be 3 ranks.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762141808:702,avail,available,702,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762141808,3,['avail'],['available']
Availability,"Here's another observation:; ```julia; u[region][1, 1-Hc:0, k] .= view(u[region_W], Nc+1-Hc:Nc, 1, k); ```; neither updates the LHS with any value nor triggers an error. The fix is either; ```julia; u[region][1, 1-Hc:0, k] = u[region_W][Nc+1-Hc:Nc, 1, k]; ```; or; ```julia; view(u[region], 1, 1-Hc:0, k).data .= reshape(view(u[region_W], Nc+1-Hc:Nc, 1, k).data, 1:1, 1-Hc:0, k:k); ```; (preferred).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2034695371:163,error,error,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2034695371,1,['error'],['error']
Availability,"Here's some sample code:. ```julia; damping_rate = 1/100 # relax fields on a 100 second time-scale. const x0 = 10 # center point of sponge; const dx = 1.0 # sponge width; smoothed_step_mask(x, y, z) = 1/2 * (1 + tanh((x - x0) / dx)). uh_sponge = Relaxation(rate=damping_rate, mask=smoothed_step_mask, target=1); h_sponge = Relaxation(rate=damping_rate, mask=smoothed_step_mask, target=1); ```. Might need to fiddle with numbers but hopefully that's a good template. We should probably have a `SmoothStepMask` or `TanhMask` or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852539492:276,mask,mask,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852539492,2,['mask'],['mask']
Availability,"Here's the docstring before this PR. ```julia; help?> Oceananigans.Fields.FunctionField; FunctionField{LX, LY, LZ}(func, grid; clock=nothing, parameters=nothing) where {LX, LY, LZ}. Returns a FunctionField on grid and at location LX, LY, LZ. If clock is not specified, then func must be a function with signature func(x, y, z). If clock is specified, func must be a; function with signature func(x, y, z, t), where t is internally determined from clock.time. A FunctionField will return the result of func(x, y, z [, t]) at LX, LY, LZ on grid when indexed at i, j, k. ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. FunctionField{LX, LY, LZ}(func::FunctionField, grid; clock) where {LX, LY, LZ}. Adds clock to an existing FunctionField and relocates it to (LX, LY, LZ) on grid. ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. FunctionField(L::Tuple, func, grid). Returns a stationary FunctionField on grid and at location L = (LX, LY, LZ), where func is callable with signature func(x, y, z).; ```. Three docstrings come up. But we only want users to use one of them. Moreover the second one is actually redundant with the first and provides no new information. The last one is supposed to be for internal use only. But as a user who is new to julia (perhaps), you may see only the last docstring. This is what happened over on the discussion linked at the top.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3678#issuecomment-2269968189:1270,redundant,redundant,1270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3678#issuecomment-2269968189,1,['redundant'],['redundant']
Availability,"Here's the error that I get right now when running this locally:. ```; ERROR: LoadError: Enzyme cannot deduce type; Current scope:; ; Function Attrs: mustprogress nofree readonly willreturn; define ""enzyme_type""=""{[0]:Integer, [1]:Integer, [2]:Integer, [3]:Integer, [4]:Integer, [5]:Integer, [6]:Integer, [7]:Integer, [8]:Integer, [9]:Integer, [10]:Integer, [11]:Integer, [12]:Integer, [13]:Integer, [14]:Integer, [15]:Integer, [16]:Integer, [17]:Integer, [18]:Integer, [19]:Integer, [20]:Integer, [21]:Integer, [22]:Integer, [23]:Integer, [24]:Integer, [25]:Integer, [26]:Integer, [27]:Integer, [28]:Integer, [29]:Integer, [30]:Integer, [31]:Integer, [32]:Integer, [33]:Integer, [34]:Integer, [35]:Integer, [36]:Integer, [37]:Integer, [38]:Integer, [39]:Integer, [40]:Integer, [41]:Integer, [42]:Integer, [43]:Integer, [44]:Integer, [45]:Integer, [46]:Integer, [47]:Integer, [48]:Float@double, [56]:Float@double, [64]:Float@double, [72]:Float@double, [80]:Float@double, [88]:Float@double, [96]:Float@double, [104]:Float@double, [112]:Float@double, [120]:Integer, [121]:Integer, [122]:Integer, [123]:Integer, [124]:Integer, [125]:Integer, [126]:Integer, [127]:Integer, [128]:Integer, [129]:Integer, [130]:Integer, [131]:Integer, [132]:Integer, [133]:Integer, [134]:Integer, [135]:Integer, [136]:Integer, [137]:Integer, [138]:Integer, [139]:Integer, [140]:Integer, [141]:Integer, [142]:Integer, [143]:Integer, [144]:Float@double, [152]:Float@double, [160]:Float@double, [168]:Float@double, [176]:Integer, [177]:Integer, [178]:Integer, [179]:Integer, [180]:Integer, [181]:Integer, [182]:Integer, [183]:Integer, [184]:Integer, [185]:Integer, [186]:Integer, [187]:Integer, [188]:Integer, [189]:Integer, [190]:Integer, [191]:Integer, [192]:Integer, [193]:Integer, [194]:Integer, [195]:Integer, [196]:Integer, [197]:Integer, [198]:Integer, [199]:Integer, [200]:Float@double, [208]:Float@double, [216]:Float@double, [224]:Float@double, [232]:Float@double, [240]:Float@double, [248]:Integer, [249]:Integer, [2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140:11,error,error,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140,1,['error'],['error']
Availability,Here's the first offending function: . https://github.com/CliMA/Oceananigans.jl/blob/775d1544610d5af6f602254ec5dff3dec7f18480/src/Fields/field.jl#L353-L359. did this code or something down the line change in this PR?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2262051722:184,down,down,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2262051722,1,['down'],['down']
Availability,"Here's the specific error we got when we tried to get `Field`, including all its glorious boundary conditions, to compile on the GPU:. ```; Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max); ```. dredged up from #746 . Some workarounds were suggested there, but I think our solution is actually better / simpler (adapt fields by unwrapping the underlying data and throwing away boundary conditions, rather than wrestling to get all the field info onto the poor GPU).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738767849:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738767849,1,['error'],['error']
Availability,"Here's what I posted earlier:. > Correct: time-averaging a TKE ComputedField; Wrong: time-averaging a TKE KernelComputedField; Wrong: time-averaging a dissipation ComputedField; Wrong: time-averaging a dissipation KernelComputedField. From this list I might infer that the two ingredients are 1) `KernelComputedField` OR 2) gradients. Gradients / interpolation ping boundary conditions, which are tricky so there's good reason to test that. Maybe two tests: one for `ComputedField` with interpolation or derivatives, and another with `KernelComputedField` (that's maybe a bit simpler)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499:361,ping,ping,361,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499,2,['ping'],['ping']
Availability,"Here's where we're at.; I've made the following modifications to `baroclinic_adjustment.jl`. ```; using Oceananigans, AMDGPU; ```; and the grid construction now specifies GPU architecture with `GPU(AMDGPU.ROCBackend())`, ie,. ```; grid = RectilinearGrid(GPU(AMDGPU.ROCBackend());; size = (48, 48, 8),; x = (0, Lx),; y = (-Ly/2, Ly/2),; z = (-Lz, 0),; topology = (Periodic, Bounded, Bounded)); ```. When running this, we hit a runtime issue at `plan_forward_transform`. ```; $ julia --project=. baroclinic_adjustment.jl ; ERROR: LoadError: MethodError: no method matching plan_forward_transform(::ROCArray{ComplexF64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, ::Periodic, ::Vector{Int64}, ::UInt32). Closest candidates are:; plan_forward_transform(::CUDA.CuArray, ::Union{Bounded, Periodic}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:36; plan_forward_transform(::Array, ::Periodic, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:16; plan_forward_transform(::Union{CUDA.CuArray, Array}, ::Flat, ::Any...); @ Oceananigans ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:47; ... Stacktrace:; [1] plan_transforms(grid::RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, GPU{ROCBackend}}, storage::ROCArray{ComplexF64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, planner_flag::UInt32); @ Oceananigans.Solvers ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:93; [2] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1946746065:521,ERROR,ERROR,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1946746065,1,['ERROR'],['ERROR']
Availability,"Heres an MWE. ```julia; julia> using Statistics, CUDA. julia> N = 32; a = randn(N, N, N) |> CuArray;. julia> R = zeros(1, 1, N+1) |> CuArray;. julia> V = view(R, 1, 1, 1:N);. julia> mean!(V, a); ERROR: MethodError: Cannot `convert` an object of type CuDeviceArray{Float64, 4, 1} to an object of type Base.ReshapedArray{Float64, 4, SubArray{Float64, 1, CuDeviceArray{Float64, 3, 1}, Tuple{Int64, Int64, UnitRange{Int64}}, true}, Tuple{}}; Closest candidates are:; convert(::Type{T}, ::LinearAlgebra.Factorization) where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58; convert(::Type{T}, ::T) where T<:AbstractArray at abstractarray.jl:14; convert(::Type{T}, ::T) where T at essentials.jl:205; ...; Stacktrace:; [1] cconvert(T::Type, x::CuDeviceArray{Float64, 4, 1}); @ Base ./essentials.jl:396; [2] macro expansion; @ ~/.julia/packages/CUDA/3VnCC/lib/cudadrv/execution.jl:83 [inlined]; [3] convert_arguments(::CUDA.var""#32#33""{Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:threads, :blocks, :shmem), Tuple{Int64, Int64, Int64}}}, CuFunction}, ::Type{Tuple{CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 1, CuDeviceArray{Float64, 3, 1}, Tuple{Int64, Int64, UnitRange{Int64}}, true}, Tuple{}}, CuDeviceArray{Float64, 3, 1}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CuDeviceArray{Float64, 4, 1}, ::CuDeviceArray{Float64, 3, 1}); @ CUDA ~/.julia/packages/CUDA/3VnCC/lib/cudadrv/execution.jl:79; [4] cudacall(::CuFunction, ::Type, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::Vararg{Any, N} where N; kwargs::Base.Iterators.Pairs{Symbol, In",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845617107:195,ERROR,ERROR,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845617107,1,['ERROR'],['ERROR']
Availability,"Hey all,. Awesome software, I am really enjoying using it. I was wondering if you have any recommendations for compatibility with [DrWatson.jl](https://github.com/JuliaDynamics/DrWatson.jl)? In particular, I am hoping to combine the [`tagsave`](https://juliadynamics.github.io/DrWatson.jl/dev/save/#DrWatson.tagsave) functionality (which stores meta information about a simulation, like git commit, filename, etc) with `JLD2OutputWriter` somehow. This is what I have tried so far. (I'll give the full script at the end). ```julia. function init_jld2!(file, model); tag!(file) # Tag with git information; merge!(file, d) # Save parameters to model file; end. sim.output_writers[:fields] = JLD2OutputWriter(; model,; (; ω, speed);; # Save to `/data/simulations` based on parameters:; filename=datadir(""simulations"", savename(d, ""jld2"")),; schedule=TimeInterval(Δt * 3),; init=init_jld2!; ); ```. However, I get an error from `tag!`:; ```julia; ┌ Warning: Initialization of /Users/mcranmer/Documents/oceananigans_interpret/data/simulations/initial_condition=random_seed=0_stop_time=10.0_timestepper=RungeKutta3_Δt=0.2_Δx=0.00781.jld2 failed because MethodError: MethodError: no method matching tag!(::JLD2.JLDFile{JLD2.MmapIO}); │ Closest candidates are:; │ tag!(!Matched::AbstractDict{K, T}; gitpath, force, source, storepatch) where {K, T} at ~/.julia/packages/DrWatson/I8SbQ/src/saving_tools.jl:200; ```. Do you have any recommendations for using DrWatson.jl with Oceananigans.JL? Maybe there's something basic I'm missing here about saving data files. Thanks!; Miles. <details><summary>Full script</summary>. ```julia; using DrWatson; @quickactivate ""Learning Oceananigans.jl"". using Oceananigans; using Statistics; using Random. function makesim(d::Dict); @unpack size,; extent,; topology,; architecture,; timestepper,; advection,; closure,; Δt,; stop_time,; Δx,; initial_condition,; seed = d. actual_size = (size..., 1). grid = RectilinearGrid(; size, extent, topology); model = NonhydrostaticModel",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2829:912,error,error,912,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2829,1,['error'],['error']
Availability,"Hey! Yes, I got the same error. Working with `ali/unclog-docs branch` got rid of that problem for me, but I guess it would be better to wait for the PR to be merged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-818073733:25,error,error,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-818073733,1,['error'],['error']
Availability,"Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project. . My last attempt at improving the NetCDF solved many of the issues with the package https://github.com/JuliaGeo/NetCDF.jl/pull/61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite. . Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages. . I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype. . I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874:936,robust,robustness,936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874,1,['robust'],['robustness']
Availability,"Hi @EavenW hope it wasn't too hard to get started (the documentation needs some more work, sorry about that). Not totally sure what you mean by a flux boundary condition with two components (sounds like the u and v velocity fields might be further coupled via this boundary condition?). Sounds like you're trying to impose a (time-dependent?) surface flux boundary condition which can be done a few different ways.; * If it's independent of time then [imposing a flux BC with a 2D array](https://climate-machine.github.io/Oceananigans.jl/stable/model_setup/boundary_conditions/#Creating-individual-boundary-conditions-1) is one option.; * If it's time-dependent then [imposing the flux BC as a function](https://climate-machine.github.io/Oceananigans.jl/stable/model_setup/boundary_conditions/#Specifying-boundary-conditions-with-functions-1) is probably the way to go. The function signature for boundary conditions is `f(i, j, grid, t, U, C, params)` so the boundary condition can depend on time `t`, the velocity fields `U = (u, v, w)` and any tracer quantity in `C`.; * If you can write your surface flux BC as a function of only (x, y, t) then a [`BoundaryFunction`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/boundary_function.jl) can simplify the setup a little. I just realized this isn't showing up in the documentation but the docstring in the file I linked to has an example of how to use it. PS: Not sure which version you're running but we've been making some improvements to the user interface lately which may break certain things if you upgrade to v0.21 or v0.22. Please don't hesitate to ping us if you have any questions or if something isn't working. We're more than happy to help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-586708085:1648,ping,ping,1648,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-586708085,1,['ping'],['ping']
Availability,"Hi @Sumanshekhar17, I couldn't immediately see the difference between your script and the ""ocean wind mixing and convection"" example but your script seems fine so I tried running it and it time-stepped with no errors with Julia 1.5 and Oceananigans v0.45.2. ![image](https://user-images.githubusercontent.com/20099589/103768518-a5f56400-4ff0-11eb-8cab-596d0b00e7a8.png). Can you post more details about your issue and the error you're encountering? Full stacktrace + error would be helpful. Would also be helpful to post the status of your Julia environment including your Julia version and the version of Julia you're using. You can do this with the `Pkg.status()` command: https://julialang.github.io/Pkg.jl/v1/repl/#repl-status. When posting code on GitHub it's always good to enclose the code in triple backticks (```) so it gets formatted as Julia code making it easier to read. I edited your post to do this. It would also be good to keep the title short and concise if you can. You can always include more details in the comment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755274258:210,error,errors,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-755274258,3,['error'],"['error', 'errors']"
Availability,"Hi @c42f thank you for chiming in! Will definitely ping you as we work on logging. I think we probably should have tackled logging much earlier. We still use `@printf` and vanilla `@info` for logging, which has been quite counter-productive haha. Definitely hoping we can reach a useful logger that can; * help developers by providing info and debug messages. Also nice in test logs.; * help users understand what the model is doing and provide a better and more responsive user experience by logging what the model is doing. This is where `@setup` and `@diagnostic` logging messages might be really nice. Although `@setup` and `@diagnostic` might be bad names as they don't imply logging? Not sure of the best solution but maybe your kwarg suggestion would help here, e.g. `@info source=""diagnostic"" msg`?. @arcavaliere seems to be developing a pretty general-purpose `ModelLogger` which hopefully we can adapt for all these uses! @arcavaliere I'm more than happy to help if you need anything. MicroLogging.jl looks pretty neat! I like that it puts the log level, file name, and line number on the right as putting them on the left causes messages not to align and makes logs harder to read. TensorBoardLogger looks pretty cool! Would be awesome to have something like that one day, but I guess you'd have to use something like ncusrses...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876:51,ping,ping,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876,1,['ping'],['ping']
Availability,"Hi @maeckha, could you post exactly what you try to run and what the error is? Also the output of ; ```julia; julia> using Pkg; Pkg.status(); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807259095:69,error,error,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807259095,1,['error'],['error']
Availability,"Hi @qiangdeng!. I think the v boundary conditions weren't being applied due to an unfortunate typo: I think you need to pass `boundary_conditions = (v=v_bc,)` (a named tuple):. ```julia; julia> model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs); ). julia> model.velocities.v.boundary_conditions.north; BoundaryCondition: type=NormalFlow, condition=nothing; ```. ```julia; julia> model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs,); ). julia> model.velocities.v.boundary_conditions.north; BoundaryCondition: type=NormalFlow, condition=-0.5; ```. Oceananigans should have produced an error asking for a `NamedTuple`: https://github.com/CliMA/Oceananigans.jl/blob/f16989d69030b61ea1b1fdf7fe5659b5fa25aadd/src/Models/IncompressibleModels/incompressible_model.jl#L91. This might be a bug... PS: When posting code on GitHub it's nice to enclose the code in triple backticks (```) so it gets formatted as code making it easier to read. I edited your post to do this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756967857:664,error,error,664,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756967857,1,['error'],['error']
Availability,Hi @syou83syou83. Can you please add to the post a logfile of the error you are getting?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1083533441:66,error,error,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1083533441,1,['error'],['error']
Availability,"Hi All,. I rerun the simulations using the newest version of the code, . julia>; [17:03]fspereira@ch-fe1[/lustre/scratch5/fspereira/OCEANANIGANS/test/case5]# julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> import Pkg. julia> Pkg.status(""Oceananigans""); Status `~/.julia/environments/v1.6/Project.toml`; [9e8cae18] Oceananigans v0.77.5. and a script based on the one available on oceananigans webpage (I only changed the grid size, constant, and set the random seed. I also tried without these changes):. [https://github.com/CliMA/Oceananigans.jl/blob/main/examples/ocean_wind_mixing_and_convection.jl](https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/blob/main/examples/ocean_wind_mixing_and_convection.jl__;!!Bt8fGhp8LhKGRg!Hq-26fs0ZjyKWL5dfg0ho6lLfmeo_jfgVK18dHbvsUBFODEetRH9g_Jail-Z6ZLUs4OLQeSzVSKFWq6Ve2_bO315jP8wE0frJVA$). Unfortunately, the new code/script led to the same reproducibility problem. I ran 4 simulations using the same script (attached) and obtained 4 different average ww profiles. . ![tec_ww_time_c1](https://user-images.githubusercontent.com/80914369/193948250-57bde9a3-ab27-4224-a443-341599e2107e.png). [c16_128_128m.jl.zip](https://github.com/CliMA/Oceananigans.jl/files/9711438/c16_128_128m.jl.zip). Any ideas or suggestions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267712816:608,avail,available,608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267712816,1,['avail'],['available']
Availability,"Hi Oceananigans Community,. As discussed with @glwagner and @johnryantaylor, I post an issue about adding Lagrangian particles to a nonuniform grid in the z-direction. Hope the following minimum working example is mini enough and bug-free. Happy to learn and discuss. . Best,; Si Chen. <details open>; <summary>Minimum Working Example</summary>. ```; using Random; using Printf; using Plots. using Oceananigans; using Oceananigans.Units: minute, minutes, hour. Nz = 24 # number of points in the vertical direction; Lz = 32 # (m) domain depth. refinement = 1.2 # controls spacing near surface (higher means finer spaced); stretching = 12 # controls rate of stretching at bottom. h(k) = (k - 1) / Nz. ζ₀(k) = 1 + (h(k) - 1) / refinement. Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1). grid = RectilinearGrid(size = (32, 32, Nz), ; x = (0, 64),; y = (0, 64),; #z = (-Lz, 0)) # Errors are gone for uniform grid ; z = z_faces). ############################ Lagrangian Particles; n_particles = 10;; x₀ = 60*rand(n_particles); ; y₀ = 60*rand(n_particles);; z₀ = -Lz*0.5*rand(n_particles); ; lagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀, restitution=0); ############################. b_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)). model = NonhydrostaticModel(advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:b,),; coriolis = FPlane(f=1e-4),; buoyancy = BuoyancyTracer(),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (b=b_bcs,),; particles=lagrangian_particles) ############################ Lagrangian Particles. bᵢ(x, y, z) = 1e-5 * z + 1e-9 * rand(). set!(model, b=bᵢ). simulation = Simulation(model, Δt=10.0, stop_time=20minutes). wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=1minute). simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). run!(simulation); ```; </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2395:928,Error,Errors,928,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395,1,['Error'],['Errors']
Availability,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:98,error,error,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,2,"['avail', 'error']","['available', 'error']"
Availability,"Hi all, I am simulating an ocean surface mixed layer. However, I always get lots of noise in the ocean interior below the mixed layer. I have applied a Gaussian-mask sponge layer near the bottom. But the noise is still there. Below are two figures of the vertical velocity and buoyancy perturbations. Any suggestions?; ![b](https://github.com/CliMA/Oceananigans.jl/assets/46232007/f160c0b6-df59-4d8a-89a2-b6de279a6e23); ![w](https://github.com/CliMA/Oceananigans.jl/assets/46232007/1d42358b-c512-41c4-bffb-035a6a169b2b). Here are the codes for the sponge. ps. the whole depth is Lz = 150 m and the mixed layer is about 80m. ######========================================; damping_rate = 1/1800 # relax fields on a 100 second time-scale; bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/3); uvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask). model = NonhydrostaticModel(; grid, coriolis,; advection = WENO(),; timestepper = :RungeKutta3,; tracers = :b,; buoyancy = BuoyancyTracer(),; closure = AnisotropicMinimumDissipation(),; stokes_drift = UniformStokesDrift(∂z_vˢ=∂z_vˢ),; boundary_conditions = (v=v_boundary_conditions, b=b_boundary_conditions),; forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge)); #####============================================",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3560:161,mask,mask,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3560,2,['mask'],['mask']
Availability,"Hi all, I am trying to setup a DNS in a triply bounded domain with inflow conditions on the west wall. All boundary conditions are as default except for the bottom boundary (no-slip), west wall (inflow) and right wall (outflow). I tried setting up the boundaries as; ```; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), east = BoundaryCondition(Gradient,0)); vbcs = VVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0)); bbcs = TracerBoundaryConditions(grid, west = BoundaryCondition(Value,0)); ```; The tracer boundary condition is fixed to 0 on the west wall. I am getting the following error when running the simulation:. ERROR: LoadError: MethodError: no method matching fill_west_halo!(::OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, ::BoundaryCondition{Value,Float64}, ::CPU, ::RegularCartesianGrid{Float64,Bounded,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,3,Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}}}, ::Clock{Float64}, ::NamedTuple{(:velocities, :tracers, :diffusivities),Tuple{NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},Nothing}}). I now wonder if it is currently possible to have inflow conditions with buoyancy, or if this is a boundary condition that is not implemented. Are inflow conditions incompatible with buoyancy or is the error unrelated? Thanks very much for your help! Entire script below:. ```; # # Lock-release gravity current example. using Oceananigans, Oceananigans.Grids, Printf, SpecialFunctions, Plots. # ## Physical and numerical parameters; #; # First, we pick a resolution and domain size,. Nx = 256; Ny = 256 # x resolution; Nz = 32 # z resolution; Lx = 10; Ly = ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/789:675,error,error,675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:465,error,error,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Hi all,. I think it would be useful for auxiliary fields to be available to tracer forcing functions in the same way that other tracers and the velocity fields are. I'm currently working round this by putting auxiliary fields in the parameters but this is quite cumbersome. It would be straightforward to implement by changing the `fields` functions e.g.:. `fields(model::NonhydrostaticModel) = merge(model.velocities, model.tracers, model.auxiliary_fields)`. I'm happy to try and do this later if there's no reason not to?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2730:63,avail,available,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2730,1,['avail'],['available']
Availability,"Hi all,. I'm currently building a model with lots of forced tracers with @johnryantaylor and @syou83syou83 and have come across an issue that I'm struggling to find a way around related to GPU compilation. I've spent a while looking through your previous similar issues (e.g. [PR #746](https://github.com/CliMA/Oceananigans.jl/pull/746)) and going through the error messages (below) the error message it gives and I'm fairly sure that its coming from the parameters size passed to the boundary tendency functions being too large. . I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:360,error,error,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,2,['error'],['error']
Availability,"Hi all,. I'm stuck trying to debug an error I keep getting when running a non-hydrostatic model on GPU. . It runs for a bit and then throws this error:; ```; ... (loads of similar CUDA stuff that goes on for a very very long time); @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream) ; @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; [19] top-level scope; @ ~/.julia/packages/InteractiveErrors/JOo2y/src/InteractiveErrors.jl:329; [20] eval; @ ./boot.jl:370 [inlined]; [21] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [22] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [23] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOpti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:38,error,error,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,2,['error'],['error']
Availability,"Hi all,. I've come across a problem a few times with the output writer where it can't set up running with `indices`specified. This presents as a bounds error coming from the `offset_data` function:; https://github.com/CliMA/Oceananigans.jl/blob/c73ef035702b33b8d11c505365a4dd48444444a7/src/Grids/new_data.jl#L33-L48. An example of this occurs when you try to run the ""near_global_lat_lon"" example when it tries to output surface values:; https://github.com/CliMA/Oceananigans.jl/blob/c73ef035702b33b8d11c505365a4dd48444444a7/validation/near_global_lat_lon/near_global_quarter_degree.jl#L296-L301. Essentially what I think is happening is that when we output data and specify some slice that isn't the dimensions of the grid, in this example just the surface level `grid.Nz`, the data is being correctly (? not sure we actually want the halo here) selected as e.g. `-Hx:Nx+Hx` in dimensions specified as `:` but just whatever indices specified by the user in the other dimensions. In the `offset_data` function I think `ii` gets the halo added in all dimensions so there's a miss match. . I'm not sure how to fix this cleanly?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770:152,error,error,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770,1,['error'],['error']
Availability,"Hi all,. I've come across a strange issue with Lagrangian particles where if they're near the top of the domain they always jump down by Δz after the first intermediate time step. I have tracked this down to the boundary condition enforcement where there is an off by one error choosing the maximum allowed position. The error would also have occurred in the x and y directions too. I will pull request this fix: https://github.com/jagoosw/Oceananigans.jl/tree/particle_tracking. I realized @simone-silvestri is working on an overhaul of Lagrangian particle tracking but it seems to not be fixed in that branch either. Hope this helps!. MWE:; ```; using Oceananigans. grid = RectilinearGrid(size=(2,2,2), extent=(2,2,2)); particles = LagrangianParticles(x=[0.5], y=[0.5], z=[-0.5]); model = NonhydrostaticModel(; grid, timestepper=:RungeKutta3, particles=particles); set!(model, u=0, v=0, w=0); sim = Simulation(model, Δt=1, stop_time=1); printz(sim)=println(sim.model.particles.properties.z); sim.callbacks[:z] = Callback(printz); run!(sim); ```; Result:; ```; [ Info: Initializing simulation...; [-0.5]; [ Info: ... simulation initialization complete (429.036 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (22.760 seconds).; [ Info: Simulation is stopping. Model time 1 second has hit or exceeded simulation stop time 1 second.; [-1.5]; ```; Results with fix; ```; [ Info: Initializing simulation...; [-0.5]; [ Info: ... simulation initialization complete (10.887 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.866 ms).; [ Info: Simulation is stopping. Model time 1 second has hit or exceeded simulation stop time 1 second.; [-0.5]; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2681:129,down,down,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2681,4,"['down', 'error']","['down', 'error']"
Availability,"Hi all,. Thanks, @glwagner for creating the [PR](https://github.com/CliMA/Oceananigans.jl/pull/3660) for solving the issue of `TimeInterval`. After merging it, I noticed a potential problem related to `AveragedTimeInterval`. Specifically, when resuming from a checkpoint, discontinuity seems to occur. For instance, in the figure below, the tidally averaged velocity is saved for each tidal period. The first run covers days 0-20, and the second run covers days 20-40. A noticeable discontinuity appears at the checkpoint transition from the first run.; <img width=""301"" alt=""image"" src=""https://github.com/user-attachments/assets/ffe04dc8-d829-49a7-8052-0b5a58c2b9a3"">. Here is a MWE for this issue:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670:260,checkpoint,checkpoint,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670,4,"['checkpoint', 'error']","['checkpoint', 'errors']"
Availability,"Hi all,; I have an issue with post-checkpoint runs. I've set the output saving interval to 30 minutes, but for the first few hours after picking up the checkpoint, the saving interval is actually equal to Δt (approximately 30 seconds in my case). Additionally, the progress message is generated every iteration (30 seconds) instead of every 30 minutes as intended. This strange behavior continues until iteration 13398, after which the interval and progress messages behave correctly (see the progress message below).; It is unclear to me what went wrong. Any ideas would be much appreciated!; (I can provide the code about how I set the `outputwriter` and progress message if needed; I am using Oceananigans v0.91.3, and Julia/1.10.2). ![image](https://github.com/user-attachments/assets/5cbba3b7-c686-48c2-8364-a85926867441)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657:35,checkpoint,checkpoint,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657,2,['checkpoint'],['checkpoint']
Availability,"Hi all,; I have tried the Vertical stretching function in my code, and I tried Constructing the Vertically stretched grid with Chebyshev spacing in the z direction.-; ```; julia> computational_grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, Lx),; y = (0, Ly),; halo = (3, 3, 3),; zF = k -> cos(π * (2k - 1) / 2Nz)); VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 4.0], y ∈ [0.0, 4.0], z ∈ [0.9996988186962042, -0.9996988186962042]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (256, 256, 64); halo size (Hx, Hy, Hz): (3, 3, 3); grid spacing (Δx, Δy, Δz): (0.015625, 0.015625, [min=-0.04908245704582441, max=0.0]); ```. But when I set up the model, I got an UndefVarError stating this- . ```; julia> model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); ERROR: UndefVarError: ld not defined; Stacktrace:; [1] Oceananigans.Solvers.FourierTridiagonalPoissonSolver(::CPU, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::UInt32) at /home/552/ss1986/.julia/packages/Oceananigans/SPGnT/src/Solvers/fourier_tridiagonal_poisson_solver.jl:54; [2] FourierTridiagonalPoissonSolver at /home/552/ss1986/.julia/packages/Oceananigans/SPGnT/src/Solvers/fourier_tridiagonal_poisson_solver.jl:24 [inlined]; [3] PressureSolver at /home/552/ss1986/.julia/packages/Oceananigans/SPGnT/src/Solvers/Solvers.jl:45 [inlined]; [4] IncompressibleModel(; grid::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571:1067,ERROR,ERROR,1067,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571,1,['ERROR'],['ERROR']
Availability,"Hi all,; Thank you very much for your quick response. But I run the above working sample with the following errors. I just updated Oceananigans this morning to v0.73.5 and then changed interpolate.jl as #2397 suggested. . The line number could be a little different than yours. So I attached my interpolate.jl. Thanks. . Best,; Si; [interpolate.zip](https://github.com/CliMA/Oceananigans.jl/files/8388789/interpolate.zip). <details open>; <summary>Error info after #2397 produced from the above Minimum Working Example</summary>. ```; TaskFailedException. nested task error: BoundsError: attempt to access 30-element OffsetArray(::Vector{Float64}, -2:27) with eltype Float64 with indices -2:27 at index [28]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:656 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [6] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:9 [inlined]; [7] fractional_z_index(::Float64, ::Center, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [8] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [9] overdub; @ ~/.julia/package",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618:108,error,errors,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618,3,"['Error', 'error']","['Error', 'error', 'errors']"
Availability,"Hi folks. I just saw this issue. We are very glad that you're working to support interoperability btw oceananigans and xgcm! 🎉 We'd love to help however we can. Ideally you would not have to really do much here other than use CF conventions in your netCDF output and things would ""just work."" That's the beauty of standards. Unfortunately, CF conventions don't quite provide the right vocabulary to describe the curvilinear geometry of staggered grid models compactly (see https://github.com/cf-convention/discuss/issues/5). In the meantime, every modeling center seems to have their own preference for how to encode this (e.g. [comodo conventions](https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html) [now offline] used by ROMS and NEMO, [S-grid](https://github.com/sgrid/sgrid), [mosaics](https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf) from GFDL). . With xgcm, we decided to use the Comodo conventions (rather than invent yet another new convention). In retrospect, this was maybe the wrong choice, since the pycomodo project seems to have totally disappeared. 🤦 However, if you put the [right metadata](https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes) in your attributes, xgcm should be able to figure out your grid. Whatever you do, please try your best to squeeze your data into existing standard file formats and metadata conventions. ; Don't invent something new. MITgcm did this with the mds data format and it has been endless headaches for our community. I don't know what JLD2 is, but it sounds like you could be going down that route... If you have any questions, please ask! I'll try to respond.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134:1612,down,down,1612,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134,1,['down'],['down']
Availability,"Hi! I am trying to implement the following setup with a `VerticallyStretchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574:935,error,error,935,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:1387,ping,ping,1387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088,2,['ping'],['ping']
Availability,"Hi,. I know that `ImmersedBoundaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367:522,error,error,522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367,5,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/788:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788,8,"['ERROR', 'error']","['ERROR', 'error', 'errored']"
Availability,"Hi; I think I found another bug related to that. . The following code works fine. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), ∂x(b) / f); vz .= vz_op; ```. but it returns error if I put a plus sign. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), + ∂x(b) / f); vz .= vz_op; ```. no problem with the minus sign. Error message:. ```julia; TaskFailedException. nested task error: MethodError: no method matching getindex(::Tuple{DataType, DataType, DataType}, ::Int64, ::Int64, ::Int64); Closest candidates are:; getindex(::Tuple, ::Int64) at tuple.jl:29; getindex(::Tuple, ::Real) at tuple.jl:30; getindex(::Tuple, ::Colon) at tuple.jl:33; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812:321,error,error,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812,3,"['Error', 'error']","['Error', 'error']"
Availability,Hm haven't seen that error before. In any case this PR should resolve: https://github.com/EnzymeAD/Enzyme.jl/pull/1297,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1948849993:21,error,error,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1948849993,1,['error'],['error']
Availability,Hm... I also noticed they were defined here:; https://github.com/CliMA/Oceananigans.jl/blob/a3faff771f3dec60be12cc7fab8ebabeffc1657e/test/test_time_stepping.jl#L202; so I thought the code I removed was redundant. But perhaps some tests were using that... I'll look into it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-946342621:202,redundant,redundant,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-946342621,1,['redundant'],['redundant']
Availability,"Hmm and there is one more point. Round-off error is the reason we get tiny time-steps, and we should fix that. However, that would still leave open the underlying problem, which is that the pressure correction fails for machine epsilon time-steps. So I'm wondering if in fact we should fix both issues.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103297934:43,error,error,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103297934,1,['error'],['error']
Availability,"Hmm, I looked at one of the errors and saw the following:. ```. Immersed boundaries with hydrostatic free surface models: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl:4;   | Got exception outside of a @test;   | The grid halo (1, 1, 1) must be larger than either (1, 1, 1) or (3, 3, 3);  ; ```. Can't say I know what's going wrong though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-989074195:28,error,errors,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2108#issuecomment-989074195,2,"['Error', 'error']","['Error', 'errors']"
Availability,"Hmm, check your environment again, or try restarting julia, because I don't think you should get that error (the tests pass for example, suggesting that things run without erroring)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386780100:102,error,error,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386780100,2,['error'],"['error', 'erroring']"
Availability,"Hmm, it should not be a tolerance issue. To debug this I would probably suggest Tartarus since it has at least 2 GPUs (I am not sure your laptop has 2 gpus 😄 ). By the way, for unrolling loops we can look at this package which might be very useful to us https://github.com/cstjean/Unrolled.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1927360091:24,toler,tolerance,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1927360091,1,['toler'],['tolerance']
Availability,"Hmm, now I'm getting a ""no space on device error"":. ![image](https://github.com/user-attachments/assets/6a328f01-1e93-413c-9414-2e0eba6ef6c3)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2454363258:43,error,error,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2454363258,1,['error'],['error']
Availability,"Hmm. I believe that scalar operations are (or were) _specifically_ allowed globally in our `runtests.jl`, overriding any default. Thus `@disallowscalar` was used to disallow scalar operations for certain testing code without disallowing them globally for all subsequent tests. I don't think it matters whether or not scalar iteration is allowed by default since we are manually controlling that setting. Furthermore, I don't think removing `@disallowscalar` would cause tests to fail; rather, it means that those tests _will_ pass even if they have scalar operations (where previously they would not have passed or would have thrown an error). Instead of using `@disallowscalar` we can flip the global state; eg we can replace. ```julia; @disallowscalar statement; ```. with. ```julia; CUDA.allowscalar(false); statement; CUDA.allowscalar(true); ```. Perhaps this is what we want?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863612256:636,error,error,636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863612256,1,['error'],['error']
Availability,"Hmm... I guess reductions in the time-dimension should actually return a `Field` rather than a `FieldTimeSeries`. That's different than how reductions for `Field` work, which also return `Field` but with a ""reduced location"", eg called here. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L710. and defined simply as. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L629-L635. So maybe there is no special challenge except writing code similar to what we have for `Field` that's specialized for the time-dimension. . Reductions over time + other dimensions might work then, if the further reduction is done over the additional dimensions after the special case is handled that converts from `FieldTimeSeries` to `Field`. `Field`s also support ""conditioning"" the operation (which mostly would probably be used to mask immersed areas). But we won't have a ""time mask"", so I think possibly that doesn't pose any particular problems. . Ok, then if we want to support reductions of `FieldTimeSeries` that _dont_ act on the time dimension, that's where we basically have to replicate everything we have for `Field` I guess. For example if you average a `FieldTimeSeries` in `x` then you get a `FieldTimeSeries` back. That's a bit more annoying but still possible...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097:931,mask,mask,931,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097,4,['mask'],['mask']
Availability,"Hmm... we don't support `Flat` z right now with `ExplicitFreeSurface` because we require two grid points in the vertical velocity (one grid point at the ""bottom"", one at the ""top"" coincident with the location of the free surface). I'm not sure about `ImplicitFreeSurface`. Can you check?. We might be able to refactor the algorithm to generally support hydrostatic free surface simulations with `Flat` z. Maybe we just need to generalize the free surface tendency for `ExplicitFreeSurface`?. On a regular `RectilinearGrid`, `NonhydrostaticModel` with `Flat` z is hydrostatic and has equivalent physics (because the free surface physics are linearized in `HydrostaticFreeSurfaceModel`). Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). `ShallowWaterModel` has a nonlinear free surface and thus finite ""Mach number"" (ratio between gravity wave speed and flow speed). So I agree with @francispoulin ; that `ShallowWaterModel` is more general and might be a nice choice for some applications. I think it still lacks a diffusive flux implementation though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537:731,error,error,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537,1,['error'],['error']
Availability,"Hmm... with a vanilla closure, the change is completely encapsulated in the addition of two layers of abstraction (we are just calling a simple diffusion operator). So, let's figure out how to make the abstractions fast. I think the slow down for vanilla closures should be `nil`. The 'abstraction slowdown' causes much larger problems with the complicated closures, so we need to solve that problem anyways. Edit: I see your post, so what I said above holds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496476529:238,down,down,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496476529,1,['down'],['down']
Availability,Hmmm I wonder if this issue is actually due to #1254 (but with a NaN checker added we actually get errors).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1247#issuecomment-739528543:99,error,errors,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1247#issuecomment-739528543,1,['error'],['errors']
Availability,Hmmm a lot of failures due to CUDA scalar `getindex` operations even though we explicitly set `CUDA.allowscalar(true)` in `runtests.jl`... We could take this opportunity to get rid of all scalar operations in the tests and just use `CUDA.@allowscalar` where it's needed. Maybe new CUDA scalar operations are hurting performance and that's why GPU CI has slowed down?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002:14,failure,failures,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002,2,"['down', 'failure']","['down', 'failures']"
Availability,Hmmm actually this GPU compiler error is different from the one in JuliaGPU/CUDA.jl#1169 although I could swear they were the same yesterday... Perhaps there are more issues (another reason to pin CUDA.jl)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1995#issuecomment-930285553:32,error,error,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995#issuecomment-930285553,1,['error'],['error']
Availability,"Hmmm it does seem related to `reduce_blocks = 1` vs. `reduce_blocks = 2`:. ```julia; julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(22, 22, 22), extent=(1, 1, 1));. julia> c = CenterField(GPU(), grid);. julia> C = AveragedField(c, dims=(1, 2));. julia> compute!(C) # OK; threads = 512; blocks = 22; reduce_blocks = 1; ```. ```julia; julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(23, 23, 23), extent=(1, 1, 1));. julia> c = CenterField(GPU(), grid);. julia> C = AveragedField(c, dims=(1, 2));. julia> compute!(C) # NOT OK!; threads = 512; blocks = 46; reduce_blocks = 2; ```. ```; ERROR: MethodError: Cannot `convert` an object of type CuDeviceArray{Float64, 4, 1} to an object of type Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}} ; Closest candidates are:; convert(::Type{T}, ::LinearAlgebra.Factorization) where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58; convert(::Type{T}, ::T) where T<:AbstractArray at abstractarray.jl:14; convert(::Type{T}, ::T) where T at essentials.jl:205; ...; Stacktrace:; [1] cconvert(T::Type, x::CuDeviceArray{Float64, 4, 1}); @ Base ./essentials.jl:396; [2] macro expansion; @ ~/.julia/dev/CUDA/lib/cudadrv/execution.jl:83 [inlined]; [3] convert_arguments(::CUDA.var""#35#36""{Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:threads, :blocks, :shmem), Tuple{Int64, Int64, Int64}}}, CuFunction}, ::Type{Tuple{CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CuDeviceArray{Float64, 3, 1}, Tuple{Un",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845602157:627,ERROR,ERROR,627,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845602157,1,['ERROR'],['ERROR']
Availability,Hmmm it should precompile with Julia 1.6 (at least as of a week or two ago) so the error is a bit surprising. How did you first install Oceananigans?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1635#issuecomment-832277131:83,error,error,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635#issuecomment-832277131,1,['error'],['error']
Availability,"Hmmm, I can appreciate that if we set the topology in the `z` direction to be `Flat`, then we have one layer. I presume that if we set it to be something else, say `Layered`, then we will have layered? . I like that idea a lot, however, I think we still need to throw an error if the user sets the topography to be `Bounded` or `Periodic`. Do you agree @navidcy ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147435214:271,error,error,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147435214,1,['error'],['error']
Availability,"Hmmm, doesn't rectilinear imply orthogonal?. `RegularRectilinearOrthogonalGrid` might be a little redundant?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295162:98,redundant,redundant,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295162,1,['redundant'],['redundant']
Availability,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:184,error,error,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367,8,"['avail', 'error']","['available', 'error', 'error-messages']"
Availability,"Hmmm, might have to default to `NamedTuple` as `nothing` cannot be splatted. ```julia; julia> f(x, y; kwargs...) = @show kwargs; f (generic function with 1 method). julia> N = nothing. julia> f(1, 2; N...); ERROR: MethodError: no method matching iterate(::Nothing). Closest candidates are:; iterate(::Base.AsyncGenerator, ::Base.AsyncGeneratorState); @ Base asyncmap.jl:362; iterate(::Base.AsyncGenerator); @ Base asyncmap.jl:362; iterate(::Core.MethodMatch, ::Int64); @ Base deprecated.jl:265; ... Stacktrace:; [1] merge(a::@NamedTuple{}, itr::Nothing); @ Base ./namedtuple.jl:361; [2] top-level scope; @ REPL[12]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3898#issuecomment-2455897912:207,ERROR,ERROR,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3898#issuecomment-2455897912,1,['ERROR'],['ERROR']
Availability,"Hmmm, should we be using [`CUDA.has_cuda_gpu`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda_gpu) instead of [`CUDA.has_cuda`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda)?. Since Tartarus actually has GPUs (we just hide them via an environment variable in CI, e.g. https://github.com/CliMA/Oceananigans.jl/blob/main/.buildkite/pipeline.yml#L77) I can see `CUDA.has_cuda_gpu` returning false (which we want) while `CUDA.has_cuda` would return true (not what we want). This might fix the unit tests (`test_field.jl`) but there are other failures that might not be related to this. Confusingly I see no recent changes in CUDA.jl that would lead to a difference in behavior for `has_cuda` (see changes for `src/initialization.jl`) but there were a lot of changes between v3.3.6 and v3.5.0 that I wouldn't understand: https://github.com/JuliaGPU/CUDA.jl/compare/v3.3.6...v3.5.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682:566,failure,failures,566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682,1,['failure'],['failures']
Availability,"Hmmmmmmmm. Right, if we really want to do stuff with a rigid lid then we need to add another field to `HydrostaticFreeSurfaceModel` to hold the barotropic pressure (a 2D field in x, y) and get the algorithm working for that... it's definitely possible... As for `free_surface=nothing`, this should be ok in fact if we are using `PrescribedVelocityFields`, but otherwise I think it should error (until we support rigid lids?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3735#issuecomment-2313410491:388,error,error,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735#issuecomment-2313410491,1,['error'],['error']
Availability,"Honestly, my thought is that that test should catch the error already. I; can't immediately think of anything else required.; I might implement that test manually on my end and see if the results are; correct. Like I said, there's a possibility that I'm just using; AveragedTimeInterval wrong... On Mon, Apr 12, 2021 at 10:13 AM Gregory L. Wagner ***@***.***>; wrote:. > We have a test that satisfies those requirements I believe:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/39ee546803b05fdf1fdaec2880fede5b5aaebe10/test/test_netcdf_output_writer.jl#L476-L570; >; > In particular it uses a tracer solution that decays exponentially in time; > at a rate that is different at every grid point.; >; > What are the additional ingredients in your script that lead to a bug?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817981813>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KVVXNDWA7HVZ4HYBTTTIMS4HANCNFSM4Z7XXUAQ>; > .; >. -- ; Tomás L. Chor; Postdoctoral researcher; Atmospheric and Oceanic Science department; University of Maryland; https://tomchor.github.io/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817984388:56,error,error,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817984388,1,['error'],['error']
Availability,"How about `PrimitiveSolutionLinearHeight`? It might be redundant to refer to the surface as ""free"" in the context of the shallow water equations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1339#issuecomment-772789508:55,redundant,redundant,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1339#issuecomment-772789508,1,['redundant'],['redundant']
Availability,"How do we deal with errors of this kind in the doctests?:. ```;   | │;   | │ diff =;   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.;   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.;   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration;   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44;   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; ...; ```. i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different. I remember there was a relatively simple way to deal with this, but I can't find it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603:20,error,errors,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603,2,['error'],['errors']
Availability,"How does that work for Julia?; For Python, if the user gives both `max_change<1` and `min_change>1`, this is going to give the `max_change` error only. Is it the same for Julia? If so, should we keep like this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705752129:140,error,error,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705752129,1,['error'],['error']
Availability,How does tracer masking affect the pressure solver?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165714401:16,mask,masking,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165714401,1,['mask'],['masking']
Availability,"How will we test code for Metal GPU? Is there anything available through github actions, or will we have to hook something up via buildkite?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732647490:55,avail,available,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1732647490,1,['avail'],['available']
Availability,"Huh --- on my GPU I was getting 2x speed up for `Float32`. I'll have to check that again. The slow down has to do with the abstractions I have introduced. 30% is a huge slow down for one function, indicative of a major problem --- probably a type inference issue? . I think that once this problem is solved the code may become faster because of the disambiguation this PR lends to the innermost kernels. This problem becomes catastrophic for the closures, which make heavy use of the abstraction. So solving this problem is imperative. We can restore the performance of the default closure by simply pasting the old operators into `constant_diffusivity_closures.jl`. However, I believe the issue with type inference is solvable. . Unfortunately, I'm in `Cthulhu` hell right now trying to figure it out... I'm wondering whether these problems will vanish once we eliminate branches from the inmost functions...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496902962:99,down,down,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496902962,2,['down'],['down']
Availability,"Huh, why is that easier? This judgement might be specific to your use case, so I wouldn't recommend taking that approach in general (for future readers of this issue). There is an important downside: the script is harder to read and interpret. So I'd regard that as less-than-best practice unless there's some specific reason to do it. (One reason could be: many similar simulations are being created using a function.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1613470449:190,down,downside,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1613470449,1,['down'],['downside']
Availability,"Hydrostatic pressure is _supposed to be_ calculated by integrating downwards using a stencil in which pressure is located at `(Center, Center, Center)`. This requires interpolating buoyancy to `(Center, Center, Face)`. However, in the kernel of the integral, the buoyancy is multiplied by `Δzᵃᵃᶜ(i, j, k+1, grid)`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Models/IncompressibleModels/update_hydrostatic_pressure.jl#L15. This isn't the correct kernel if the integral corresponds to a discretization of the hydrostatic pressure term in the vertical momentum equation (omitting `i, j` for brevity) using a pressure field `p` located at (`Center, Center, Center`):. ```julia; (p[k] - p[k-1]) / Δzᵃᵃᶠ[k] = ℑzᵃᵃᶠ(k, b); ```. In other words, differencing a field at vertical `Center` requires dividing by `Δzᵃᵃᶠ`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Operators/derivative_operators.jl#L12. Another way to view the error is that we are multiplying a field located at `Center, Center, Face` by a grid metric located at `Center, Center, Center`. Possibly this error crept into the code due to a confusion about the superscript notation (there have been a few others of this nature). I'm not sure if it's easily caught; it probably depends on the importance of a horizontally-variable hydrostatic pressure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1693:67,down,downwards,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1693,3,"['down', 'error']","['downwards', 'error']"
Availability,"I accidentally left a duplicate `include(""index_permutations.jl"")` when resolving some merge conflicts in PR #1348 which led to method redefinition errors. This PR should get rid of those errors.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1390:148,error,errors,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1390,2,['error'],['errors']
Availability,"I actually appreciate the verbose-ness of the grid show functions (actually most of Oceananigans show functions in general). So I can only assume that more beginner users appreciate that as well, since it makes extremely clear what the grid characteristics are. I also don't think there's a very important downside to being verbose here, so I'd vote to keep the same style. Although I agree that we could get rid of some redundant information. My suggestion would be something like:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); z spacing: Stretched, with min=0.2, max=0.5; ```. In other words, I'd remove the flat dimensions (since that's unnecessary), and clean and align the `z` spacing statement. I'd also keep the ` topology: (Flat, Flat, Bounded)` because the line `RectilinearGrid{Float64, Flat, Flat, Bounded}` might not be very intuitive to everyone. If a shorter show is necessary in some places maybe we could create something like `short_show`? (Or maybe define `show` differently based on the display?: https://schurkus.com/2018/01/05/julia-print-show-display-dump-what-to-override-what-to-use/)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297:306,down,downside,306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297,4,"['down', 'redundant']","['downside', 'redundant']"
Availability,"I add a bit of context here:. @Yixiao-Zhang is doing a non-hydrostatic simulation with an immersed boundary and he finds that the code crashes with the PCG solver. That is not necessarily connected with the PCG solver but it might be caused by simulation setup or other issues. Since the pressure solver used is experimental (from [this branch](https://github.com/CliMA/Oceananigans.jl/tree/glw-xk/divergence-free-immersed-velocity-field)), as a way to assess where the crashing comes from, I suggested using another method to see if the crash would also happen, which would validate or not the experimental pressure solver. @Yixiao-Zhang, optimizing GPU preconditioners is a quite difficult task as demonstrated by the preconditioners slowing down the simulation, and probably not a good use of time of trying to figure out a way to speed up these solvers that we are not sure we want to use. ; Since this simple attempt to have a simulation that runs (with another _correct_ solver) up to the crashing point does not work, I would suggest to just trying to use a (slightly non-correct) FFT pressure solver to see if the simulation still crashes.; If not, then we can assume the crashing occurs due to the PCG solver and try to catch the bug. ; This will probably be a better way to ""optimize"" the solver since we know that the PCG preconditioned with FFT is faster than these other methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749:744,down,down,744,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749,2,['down'],['down']
Availability,"I added a `ParticleAdvectionForcing` that behaves similarly to `dynamics(particles, model, Δt)` which allows user to specify any velocities it wishes to add to the model by passing in `NonHydrostaticModel(..., advective_forcing = ParticleAdvectiveForcing(u=some_u, v=some_v, w=some_w))` . The arguments are functions that take `(particles, model, Δt)` as inputs. . When I am trying to test my code I ran into a problem:; ```; ERROR: UndefVarError: `flattened_node` not defined; ```. https://github.com/CliMA/Oceananigans.jl/blob/a73e845a7a7bce8e22e9453670c1c20b67dbfc3a/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L92. @simone-silvestri I see that you added this and I couldn't find anywhere in the code where `flattened_node` is defined. What is it supposed to be?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837241191:426,ERROR,ERROR,426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1837241191,1,['ERROR'],['ERROR']
Availability,"I added dropbox links to download the boundary conditions. This is what the annual cycle of wind stress, surface temperature, and surface salinity looks like:. https://user-images.githubusercontent.com/15271942/164838809-22922935-df1e-4bf0-9361-d9a4f66dea34.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107073824:25,down,download,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107073824,1,['down'],['download']
Availability,"I agree and I think that's also an issue with the ""fix"" in #3142. Eg previously the kwargs referred to immersed cells, ie `bottom=flux` means the `flux` is applied at the bottom of an immersed cell. But apparently, this was confused with the ""bottom"" of the domain... `upward` could be a good alternative. I'm worried about deciding on these conventions before we have cut cells though, which would probably become the preferred default. Whatever API we have should make sense for cut cells. . All of this is one reason why I feel it might better to remove documentation for `ImmersedBoundaryCondition` altogether and recommend using ordinary boundary conditions on immersed boundaries. I think it's straightforward to apply ordinary boundary conditions on either full cells, partial cells, or cut cells. While we do lose some convenience, that downside is balanced against requiring users to have a more detailed understanding of the problem they are trying to model, which is arguably a good thing... Confusing behavior for immersed boundaries seems to arise only when users try to exert more granular control over the boundary condition through `ImmersedBoundaryCondition`. I regret now exposing the API to ImmersedBoundaryCondition 🥲",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1588059918:845,down,downside,845,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1588059918,1,['down'],['downside']
Availability,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:423,redundant,redundant,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490,2,['redundant'],['redundant']
Availability,"I agree with @ali-ramadhan, keeping a `overwrite_existing` seems quite important to me too, potentially with a default value of `overwrite_existing = false`. . Another issue to add into this discussion is the fact of how to handle output (e.g. `file.nc`) with checkpoints and `file_splitting`. Currently, when a simulation is pickup from a checkpoint having the flag `overwrite_existing = true` rewrites to empty all the pre-existing files (i.e. file_part1.nc, file_partN.nc). With `overwrite_existing = false`, the simulation crashes because it doesn't find the file `file.nc`. I think it will be useful to handle automatic concatenation to splitted files, to allow a more flexible output particularly in the context of HPC computing with manageable file sizes, chunks, and wall times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391714179:260,checkpoint,checkpoints,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391714179,2,['checkpoint'],"['checkpoint', 'checkpoints']"
Availability,I agree with showing an error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181985040:24,error,error,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181985040,1,['error'],['error']
Availability,"I agree, also we have to remember to remove the masking of the tracers as that is not required...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042488498:48,mask,masking,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042488498,1,['mask'],['masking']
Availability,"I agree. Perhaps we could link releases that introduce breaking changes to a specific PR that's dedicated to updating the version and detailing the API breaking change. This might be tedious work (for us) because it involves tracking down all API changes in past PRs, but it might be very beneficial for users",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595189695:234,down,down,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1595189695,1,['down'],['down']
Availability,"I also don't feel we can motivate this feature unless we understand the specific thing we are going for and ensure that it can't be achieved otherwise. It has wider implications too, because if we can't move away from the `materialize_x` pattern, then we can commit to supporting it. We've discussed at various times trying to eliminate the `materialize_x` step, and ways to avoid having it. A similar example pertains to grids and halos. We've decided that it's best to throw an error when the grid halo is not adequate for the chosen advection scheme. Previously, we had the notion that we might ""automatically expand"" the grid within the model constructor if the halo was not correct. So, let's discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609010:480,error,error,480,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609010,1,['error'],['error']
Availability,"I also had this issue, as new into GPU running, I was super confused about this error. It will be helpful if this issue is not fixable, to at least point out in the documentation. . I encountered this error by running a simulation based on the tutorial ([Langmuir turbulence](https://clima.github.io/OceananigansDocumentation/stable/generated/langmuir_turbulence/#Langmuir-turbulence-example)) in GPUs. Note that the print function prints the `maximum(abs, u), maximum(abs, v), maximum(abs, w)`:; ```; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.Δt),; maximum(abs, u), maximum(abs, v), maximum(abs, w),; prettytime(simulation.run_wall_time)); ```; thus resulting in the error:; ```; LoadError: CUDA error: too many resources requested for launch; ```; For reference, the code works once the `maximum` functions are removed:; ```; msg = @sprintf(""i: %04d, t: %s, �~Tt: %s, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.�~Tt),; prettytime(simulation.run_wall_time)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103:80,error,error,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103,4,['error'],['error']
Availability,"I also just noticed that this statement:. https://github.com/CliMA/Oceananigans.jl/blob/088f9738877f0aeef7aa4038cf788f69ee102019/docs/src/simulation_tips.md?plain=1#L70-L77. is wrong since the above code _does not_ error. I believe the error will pop up down the line, when we try to pass this boundary condition to a model that uses a grid that lives on the GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3594#issuecomment-2294990999:215,error,error,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3594#issuecomment-2294990999,3,"['down', 'error']","['down', 'error']"
Availability,"I also think that we should consider also another example problem like a flow around a cylinder because the internal wave problem seems to be hard to tolerate without large damping regions which makes it quite hard to tell how well the boundary condition is doing. For example, in this flow around a cylinder it ""works"" by just setting the boundary values:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/9c20597c-e899-4268-b666-f156825fc899. But then if I run it with a 4x longer domain (not shown) you can see visually that the interior solution has been modified by the boundary and the vortexs are getting squashed as they approach the boundary:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/b04f1acf-02bd-4d9c-b039-93c3f3939e6e. Here a damping region would similarly modify the internal solution, but if upwind-implicit Euler the boundary point with the boundary normal mean velocity we get:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/d345a94a-03dd-4970-8928-baf7ee013e44. which looks closer to the long solution and the vortices appear to be leaving the domain with less deformation. We can also quantify the effect of the boundary condition with e.g. the Strouhal and the drag coefficient (which I'll work out for these examples in a minute).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2027539885:150,toler,tolerate,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2027539885,1,['toler'],['tolerate']
Availability,"I also tried to run `baroclinic_adjustmenet.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/mesoscale_turbulence/baroclinic_adjustment.jl) and got the following error. ```; ERROR: LoadError: MethodError: Cannot `convert` an object of type Float64 to an object of type VerticallyImplicitTimeDiscretization; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:205; Stacktrace:; [1] convert_diffusivity(FT::Type, κ::Float64; kw::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:discrete_form,), Tuple{Bool}}}); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_utils.jl:15; [2] ScalarDiffusivity(time_discretization::ExplicitTimeDiscretization, formulation::Oceananigans.TurbulenceClosures.VerticalFormulation, FT::Type; ν::Float64, κ::Float64, discrete_form::Bool); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:52; [3] #VerticalScalarDiffusivity#39; @ ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:87 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2543:192,error,error,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I also want to drop another optimization that can be used here --- using a `Float32` grid with the preconditioner. This will speed things up a bit. Eg:. ```julia; using Oceananigans.Grids: with_number_type. reduced_precision_grid = with_number_type(Float32, underlying_grid). pressure_solver = ConjugateGradientPoissonSolver(grid;; preconditioner = fft_poisson_solver(reduced_precision_grid),; maxiter = 10; ); ```. I also suggest plotting the divergence to get a handle on how the solver is working. A well-converged solution seems to have isotropically-distributed divergence errors. With looser tolerances, the divergence may be concentrated around the bathymetry (and of course with the naive FFT solver it has a thin layer adjacent to the bathymetry). I also think it would be nice if setting `maxiter=0` had a similar effect as simply using the FFT-based preconditioner. It's not the case right now, I think because we do not apply the preconditioner to the pressure initially before doing the CG iteration. It might not work (I believe I experimented briefly with that to no avail).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611:578,error,errors,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611,6,"['avail', 'error', 'toler']","['avail', 'errors', 'tolerances']"
Availability,I am also happy to throw and error and ask the use to specify a halo or at least the right size. It also occurs to me that a user can specify a halo to be bigger than is required. I don't see any advantage of this and believe it would only slow things down. This is not worthy of an error but do we want to notify the user if they pick a halo of length 5 and they only need 1?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2107#issuecomment-989071865:29,error,error,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107#issuecomment-989071865,3,"['down', 'error']","['down', 'error']"
Availability,"I am attempting to use`ConjugateGradientPoissonSolver` in my simulation, but the error specifically occurs when the grids are stretched. The error happens when running either `fft_poisson_solver(grid.underlying_grid)` or `ConjugateGradientPoissonSolver(grid; preconditioner, maxiter=20)`. . The error message: ; ```; ERROR: type RectilinearGrid has no field underlying_grid; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] fft_poisson_solver(grid::RectilinearGrid{…}); @ Oceananigans.Solvers ~/code/Oceananigans.jl/src/Solvers/Solvers.jl:55; [3] top-level scope; @ REPL[7]:1. ```; I don't understand why there is no `underlying_grid`, which clearly exists.; Here is the MWE that I slightly modified from https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426, thanks to @ali-ramadhan, @glwagner ; ```julia; using Printf; using Statistics; using Oceananigans; using Oceananigans.Grids: with_number_type; using Oceananigans.BoundaryConditions: FlatExtrapolationOpenBoundaryCondition; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver; using Oceananigans.Utils: prettytime. N = 16; h, w = 50, 20; H, L = 100, 100; x = y = (-L/2, L/2). # Create stretched vertical grid; kwarp(k, N) = (N + 1 - k) / N; # Linear near-surface generator; ζ(k, N, refinement) = 1 + (kwarp(k, N) - 1) / refinement; # Bottom-intensified stretching function; Σ(k, N, stretching) = (1 - exp(-stretching * kwarp(k, N))) / (1 - exp(-stretching)); # Generating function; z_faces(k) = - H * (ζ(k, N, 1.2) * Σ(k, N, 15) - 1); z = z_faces. # uniform vertical grid; # z = (-H, 0). grid = RectilinearGrid(size=(N, N, N); x, y, z, halo=(2, 2, 2), topology=(Bounded, Periodic, Bounded)). mount(x, y=0) = h * exp(-(x^2 + y^2) / 2w^2); bottom(x, y=0) = -H + mount(x, y); grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). prescribed_flow = OpenBoundaryCondition(0.01); extrapolation_bc = FlatExtrapolationOpenBoundaryCondition(); u_bcs = FieldBoundaryConditions(west = p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3889:81,error,error,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3889,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,I am confused about the formula. The Laplacian of the velocity is divided into two parts. The first is the gradient of the divergence and the second is the curl of the curtl of the velocity. The first should be zero but is not because of numerical error. Is this really the term that we are using to diffuse? Just wanted to confirm that I understand this correctly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112486769:248,error,error,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112486769,1,['error'],['error']
Availability,"I am copying this out from `immersed_grid_metrics.jl` since it seems a little ofset above, and switching i's for k's, since it is the vertical direction. ```; Immersed Fluid; ----------- ...........; | ∘ | ∘; f c f c; k-1 k-1 k k; ```; My understanding was that in `GridFittedBottom` we had a transition from solid to fluid at `f_k`. If that's the case then I thought the partial cell would be the one above with `c_k` in the itnerior. That's why I thought `c_{k-1}` is immersed and `c_k` is at the interface. Agreed?. The grid fitted problem as a special case where the height in the immersed cell is 0, where as in partial cells it can be anything above zero and up to the top of that cell (or within a tolerance). I hope that we can use the same functions for both, otherwise, much more confusion can arise and I am glad we are having this discussion. Thank you @jm-c for the comment. I will now change the default to 0.1, since that's what is currently used. I presume this means we don't don't want to have partial cells that are in the bottom 20% of the cell or the top 20% of the cell as well?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043031924:705,toler,tolerance,705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043031924,1,['toler'],['tolerance']
Availability,"I am facing some issue with `TimeStepWizard`. It is saying that there is no method like `TimeStepWizard` , I have also faced this issue in previous version of `Oceananigans` but that time after updating `Oceananigans` resolved it. ; This time these are the information of version-; `Oceananigans` = `v0.61.3`; `julia` = `1.6.1`. I am pasting me whole code so that you can reproduce the error-; ```; using Printf; using Plots; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Units: minutes, hour, hours, day; using Oceananigans.Grids: nodes; using Oceananigans.Diagnostics; using Oceananigans.OutputWriters: JLD2OutputWriter, FieldSlicer, TimeInterval; using Oceananigans.Diagnostics: accurate_cell_advection_timescale. #Defining Grid; #number of grid spacing in south,north and vertical direction; const Nx=256; const Ny=256; const Nz=64. #Length of grid in south, north and vertical direction; const Lx=4; const Ly=4; const Lz=0.1. const S = 1.6 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-Nz-1) ) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; architecture = CPU(),; x = (0,Lx),; y = (0,Ly),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes). #Governing parameters ; #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4. #diffusive viscocity; const v=1e-5 ; #diffusivity; const k=2e-6 . const f=0 #coriolis parameter; ; g = 300. #Temperature(Tracer) boundary condition ; Amplitude = 950 # Amplitude (W/m²) of Heat flux. Q_cool = -143.1092 # (W/m²) {due to Longwave + Latent heat + Sensible Heat}. gausian(t) = exp(-((t)^2)/(0.025*(86400)^2)) . # These are the times during which peak of the heat flux can be observed; peak1 = 0.56day; peak2 = 1.56day; peak3 = 2.56day; peak4 = 3.56day; peak5 = 4.56day; peak6 = 5.56day. # Heat absorbed due to shortwave; Q_sh(t) = Amplitude*(gausian(t-peak1) + gausian(t-peak2) + gausian(t-peak3) + gausian(t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946:386,error,error,386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946,1,['error'],['error']
Availability,I am for removing the inflation and throwing an error. Might be annoying to always have to specify the halo in the grid (and the refractoring that will come with it) but it can save a lot of debugging for the users,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2107#issuecomment-988920403:48,error,error,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107#issuecomment-988920403,1,['error'],['error']
Availability,"I am getting the following error from benchmark/distributed_nonhydrostatic_model.jl where I have set threaded = false and decomposition = Slab(). I get a very similar error from the distributed nonhydrostatic script when I run the tests script, but the distributed shallow water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:27,error,error,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,2,['error'],['error']
Availability,"I am happy to open a PR but when I try the line you suggested , unfortunately, there is still a problem. Some good news! This fixes it for the vector invariant formulation. However, when I try the conervative form it complains about not knowing `u`. See the start of the output below. ```; ERROR: LoadError: TaskFailedException. nested task error: type NamedTuple has no field u; Stacktrace:; [1] getproperty(x::NamedTuple{(:uh, :vh, :h), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984:290,ERROR,ERROR,290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I am happy to say that I am now able to get plots of the solutions and errors for a range of resolutions and advections_schemes. I have also learned a lot about `Plots.jl` in the process. . Tomorrow I will work on modifying `plot_error_convergence!`, since that actually gives us the plots that we want. Here are a couple of samples. They can and will be improved up. The first is the error for WENO5 and the scaling matches the theory very well, as I will confirm tomorrow. . ![test2WENO5](https://user-images.githubusercontent.com/8239041/102304453-78565700-3f2b-11eb-8219-dc377571c0e8.png). The second is the error from the UpwindBiasedFifthOrder, that shows that the error in the centre does not converge. I would guess this is either a time stepping problem or perhaps a but somewhere. ![test2UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102304487-8c9a5400-3f2b-11eb-88dc-e5c15e172edd.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542:71,error,errors,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542,8,['error'],"['error', 'errors']"
Availability,"I am happy to say that when I tried our MWE on this branch I also had no errors. . Even better, I tried it on the benchmark example and found that it did the `Float32` case with `GPU` on a grid of `32` cubed did work. . However, I see that some tests fail?. Also, @glwagner , care to share what you did here as it seems to work but I am very much puzzled as to why it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871043993:73,error,errors,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871043993,1,['error'],['errors']
Availability,"I am having a problem with `NonTraditionalBetaPlane`. Please see the minimum working example below. . If is run it on a grid of `(4,4,4)` it works fine or if I use `FPlane`, it works fine. However, if I have 8 points in the vertical, it gives an error, which I have copied part of below, involving the size fo OffsetArrays. . Can someone help me understand how to fix this?. ```; using Oceananigans. grid = RectilinearGrid(CPU();; size = (4, 4, 8), halo = (3, 3, 3),; x = (-1, 1), y = (-1, 1), z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); ; model = NonhydrostaticModel( grid = grid,; coriolis = NonTraditionalBetaPlane(fy=1e-4, fz=1e-4, β = 0, γ = 0,)). simulation = Simulation(model, Δt=1, stop_time=4); run!(simulation); ```. Error:. ```; julia> include(""mwe_nontraditional.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (188.650 μs); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 10-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7) with eltype Float64 with indices -2:7 at index [8]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2876:246,error,error,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2876,4,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,I am in favor of not doing 979c2a7. It hardcodes a change in the source code that is only required for aesthetic reasons. I would wait for #3092 and in the meantime mask the output in the example,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983809077:165,mask,mask,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983809077,1,['mask'],['mask']
Availability,"I am including an update of my notes. Differences of note:. - Doing everything in 2D, but can downgrade to 1D if people feel this is confusing. I thought this would work well with the 2D picture we have already; - Using overline to denote a cell-averaged quantity. I know the code doesn't do this but this is the convention in the literature and seems good to have something to distintuish between cell-average and simply value; - The final answer is indeed in terms of quantities are the edges but the final equation is exact. The approximations come in when we approximate those fluxes using the cell-averaged quantities. We have a bunch of ways of doing this and I for one would like to discuss this more, but thought we should discuss what I have so far before going any further. ![Finite_Volume_Tracer_Equation](https://user-images.githubusercontent.com/8239041/124492299-4222dc80-dd82-11eb-9484-72f57f4f65ff.jpeg)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874189245:94,down,downgrade,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874189245,2,['down'],['downgrade']
Availability,"I am not sure about CUDA.jl, if you try `maximum(abs, interior(w))` or `maximum(abs, w.data)` the error disappears. It must be something that lies in our implementation. We should first isolate all the conditions that lead to a code error before posting an issue. When we do a reduction over an immersed field, we wrap the field in a `ConditionalOperation`, in this case with condition `NotImmersed((i, j, k, grid) -> true)`.; a conditional operation has a `getindex` which is defined as; ```; @inline function Base.getindex(c::ConditionalOperation, i, j, k) ; return ifelse(get_condition(c.condition, i, j, k, c.grid, c), ; c.func(getindex(c.operand, i, j, k)),; c.mask); end; ```; and in this particular case, the `mask` in `-Inf` and `get_condition` is defined as; ```; @inline function get_condition(condition::NotImmersed, i, j, k, ibg, co::ConditionalOperation, args...); LX, LY, LZ = location(co); return get_condition(condition.func, i, j, k, ibg, args...) & !(immersed_peripheral_node(i, j, k, ibg, LX(), LY(), LZ())); end ; ```; (where `condition.func` always evaluates to `true`); In practice, what is happening is that where `get_condition` evaluates to `false`, the `getindex` returns `-Inf` instead of the value. ; What worries me here, is that there is an evaluation of `immersed_peripheral_node`. This is the only difference I can notice with a non-immersed field. The fact that the error appears only with specific locations makes me believe that the evaluation of `immersed_peripheral_node` might be the source of the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906:98,error,error,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906,5,"['error', 'mask']","['error', 'mask']"
Availability,"I am not sure about the `nrm2` error, (in here https://buildkite.com/clima/oceananigans/builds/10815#01872595-ab18-49c3-9f40-682de39fcdea) when I try locally; ```julia; (Oceananigans) pkg> test; ```; I cannot reproduce the error. Neither on Tartarus nor on Sverdrup (which is our GPU testing host)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1486064424:31,error,error,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1486064424,2,['error'],['error']
Availability,"I am not very familiar with this use of scan, and despite ""cumulative sum"" sounding redundant, it express to me better the idea that I am not simply summing all values of a series. I think that this is the reason why `cumsum` is so common.; I agree that we might not find a perfect word for that... haha; However, I was thinking that `CumulativeScan` also works. Scan gives this idea of an action moving through the series and Cumulative suggests that we are summing terms as we move through.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2105535912:84,redundant,redundant,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2105535912,2,['redundant'],['redundant']
Availability,"I am trying to get back to the validation script and when I try accessing the data it gives me an error. Is this a known problem? @glwagner @simone-silvestri ?. ```; ┌ Info: Downloading; │ source = ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2""; │ dest = ""/u/fpoulin/.julia/scratchspaces/124859b0-ceae-595e-8997-d05f6a7a8dfe/datadeps/quarter_degree_near_global_lat_lon/tau_x-1440x600-latitude-75.jld2""; │ progress = NaN; │ time_taken = ""0.07 s""; │ time_remaining = ""NaN s""; │ average_speed = ""3.493 MiB/s""; │ downloaded = ""250.411 KiB""; │ remaining = ""∞ B""; └ total = ""∞ B""; ERROR: HTTP.Exceptions.StatusError(404, ""GET"", ""/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2"", HTTP.Messages.Response:; """"""; HTTP/1.1 404 Not Found; Server: GitHub.com; Date: Thu, 20 Jun 2024 13:36:59 GMT; Content-Type: text/html; charset=utf-8; Vary: X-PJAX, X-PJAX-Container, Turbo-Visit, Turbo-Frame, Accept-Encoding, Accept, X-Requested-With; Cache-Control: no-cache; Strict-Transport-Security: max-age=31536000; includeSubdomains; preload; X-Frame-Options: deny; X-Content-Type-Options: nosniff; X-XSS-Protection: 0; Referrer-Policy: origin-when-cross-origin, strict-origin-when-cross-origin; Content-Security-Policy: default-src 'none'; base-uri 'self'; child-src github.com/assets-cdn/worker/ gist.github.com/assets-cdn/worker/; connect-src 'self' uploads.github.com www.githubstatus.com collector.github.com raw.githubusercontent.com api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com api.githubcopilot.com objects-origin.githubusercontent.com copilot-proxy.githubusercontent.com/v1/engines/github-completion/completions *.a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454:98,error,error,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454,4,"['Down', 'ERROR', 'down', 'error']","['Downloading', 'ERROR', 'downloaded', 'error']"
Availability,"I am trying to reproduce a simulation similar to the one in [this paper](https://journals.ametsoc.org/jpo/article/45/6/1554/12449/The-Energetics-of-Centrifugal-Instability) and when I checked the simulation after a whole day running I found it had crashed in the first hour. (Even though I was using the TimeStepWizard.) Or at least that's what I think happened judging by the output:. ```; i: 13960, sim time: 11.103 hours, wall time: 42.767 minutes, Δt: 2.875 seconds, CFL: 1.00e+00; i: 13970, sim time: 11.111 hours, wall time: 42.797 minutes, Δt: 2.875 seconds, CFL: 1.00e+00; i: 13980, sim time: 11.119 hours, wall time: 42.827 minutes, Δt: 2.875 seconds, CFL: 1.00e+00; i: 13990, sim time: 11.127 hours, wall time: 42.856 minutes, Δt: 2.875 seconds, CFL: NaN; i: 14000, sim time: NaN years, wall time: 42.885 minutes, Δt: NaN years, CFL: NaN; i: 14010, sim time: NaN years, wall time: 42.913 minutes, Δt: NaN years, CFL: NaN; ```. I wonder if it's possible to implement a check that kills the simulation/throws an error when it notices that it crashed. In my LES Fortran code I implemented something like that and it prevented me from wasting many core-hours simulating `NaN`s. Basically it was just something that checked if there were any `NaN`s in the domain and killed it otherwise. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1196:1020,error,error,1020,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1196,1,['error'],['error']
Availability,I am trying to run a case with GPU architecture on my school's HPC but I keep running into this same error (see gpu_error.log). This is my first time using the GPUs on the HPC so I am not sure if this is a user error or a software error. The error comes up during model instantiation.; [gpu_error.log](https://github.com/CliMA/Oceananigans.jl/files/5867606/gpu_error.log). Let me know if there is anything else you may need. The run script is also attached as a .txt. ; [model_gpu_waves.txt](https://github.com/CliMA/Oceananigans.jl/files/5867635/model_gpu_waves.txt),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317:101,error,error,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317,4,['error'],['error']
Availability,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655:448,error,error,448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655,5,"['down', 'error', 'fault']","['downloads', 'error', 'errors', 'fault']"
Availability,"I am using Oceananigans v0.54.0 with Julia v1.6 on GPU. I tried setting an initial condition in salinity as follows:. ```; Stop = 29.5; Sbot = 32; ztop = -35; zbot = -70; dSdz = (Sbot-Stop)/ztop; S_func(x, y, z) = Stop + dSdz*(z > ztop)*z ; set!(model, S=S_func); ```. and got the error copied below. Note that this works fine in Julia v1.5.4. . ```; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/3q18R/deps/deps.jl:15; ERROR: LoadError: MethodError: no method matching set!(::Field{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, CuArray{Float64, 2}}}}}}, ::typeof(S_func)); Closest candidates are:; set!(::Oceananigans.Fields.AbstractField, !Matched::Number) at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:14; set!(::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G, !Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G) where {X, Y, Z, A} at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:16; set!(!Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where {X, Y, Z, A<:(OffsetArrays.OffsetArray{T, D, var""#s203""} where {T, D, var""#s203""<:Array}), G}, ::Function) at /home/guptam/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1555:281,error,error,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1555,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I attempted to reproduce the issue using the 1D diffusion example in the same environment, but I was unable to do so. After picking up the checkpoint, the output saving interval looked normal (not saving every iteration). The simple example is demonstrated as follows: [here](https://github.com/liuchihl/internal-tide-mixing/blob/3D-realtopo-delta-glw-background-flux-div/oneD_diffusion_checkpoint_test.jl). . Our initial guess is that it might be related to #3056. However, after conducting some tests, such as avoiding setting intervals to transcendental numbers, the output saving interval after picking up the checkpoint is still 1 iteration for a while (which is not the desired behavior). I noticed that when I use `IterationInterval` instead of `TimeInterval`, the problem is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244122542:139,checkpoint,checkpoint,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244122542,4,['checkpoint'],['checkpoint']
Availability,"I attempted to run the [eady_turbulence.jl](https://github.com/CliMA/Oceananigans.jl/blob/master/examples/eady_turbulence.jl) example with `TwoDimensionalLeith()`closure as follows:. ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, νz=κᵥ, κz=κᵥ),; #AnisotropicBiharmonicDiffusivity(νh=κ₄h, κh=κ₄h)); TwoDimensionalLeith()); ```. and got the error posted below. I am using Oceananigans.jl v0.40.0. . ```; ERROR: LoadError: TaskFailedException:; MethodError: no method matching ∂ⱼ_2ν_Σ₁ⱼ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Clock{Float64}, ::TwoDimensionalLeith{Float64,NamedTuple{(:b,),Tuple{Float64}},NamedTuple{(:b,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}, ::NamedTuple{(:νₑ,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}); Closest candidates are:; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid, ::Any, ::Tuple{C1,C2}, ::Any, ::Any) where {C1, C2} at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/closure_tuples.jl:13; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid{FT,TX,TY,TZ} where TZ where TY where TX, ::Any, ::Tuple, ::Any, ::Any, ::Any...) where FT at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/TurbulenceClosures.jl:110; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::Any, ::Any, ::IsotropicDiffusivity, ::Any, ::Any...) at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl:53; ...; Stacktrace:; [1] call at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:456 [inlined]; [2] fallback at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:454 [inlined]; [3] _overdub_fallback at /home/guptam/.juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1034:343,error,error,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549:246,avail,available,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549,1,['avail'],['available']
Availability,"I believe the below MWE should work according to the `ScalarDiffusivity` docstring, but from the error it seems to be expecting `funky_diffusion(x, y, z, t)` instead of `funky_diffusion(x, y, z, t, p)`. https://github.com/CliMA/Oceananigans.jl/blob/fe056fb44ce7173ce9e7eaa4f5c349d6ee2b61a4/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L12-L67. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(CPU(), size=(3, 4, 5), extent=(1, 1, 1)). @inline funky_diffusion(x, y, z, t, p) = p.A + p.M * (x+y+z+t). params = (; A=1.2, M=0.7). closure = ScalarDiffusivity(;; ν = funky_diffusion,; κ = funky_diffusion,; parameters = params; ). model = NonhydrostaticModel(; grid, closure). time_step!(model, 0.1); ```. Error:. ```julia; ERROR: MethodError: no method matching funky_diffusion(::Float64, ::Float64, ::Float64, ::Float64). Closest candidates are:; funky_diffusion(::Any, ::Any, ::Any, ::Any, ::Any); @ Main REPL[2]:1. Stacktrace:; [1] νᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:309 [inlined]; [2] νᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:84 [inlined]; [3] ν_σᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:154 [inlined]; [4] viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:159 [inlined]; [5] viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/implicit_explicit_time_discretization.jl:43 [inlined]; [6] _viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/closure_kernel_operators.jl:4 [inlined]; [7] Ax_qᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/Operators/products_between_fields_and_grid_metrics.jl:12 [inlined]; [8] δxᶠᵃᵃ; @ ~/atdepth/Oceananigans.jl/src/Operators/difference_operators.jl:21 [inlined]; [9] ∂ⱼ_τ₁ⱼ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/closure_kernel_operators.jl:24 [inlined]; [10] u_v",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840:97,error,error,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840,3,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"I believe to support concrete `BackgroundField` we need to add a method to `regularize_background_field` defined here:. https://github.com/CliMA/Oceananigans.jl/blob/7501c5325a0f7c77a89316d23ee7a56a3877dad9/src/Fields/background_fields.jl#L59-L63. that looks like. ```julia; regularize_background_field(X, Y, Z, field::Field, grid, clock) = field; ```. If you want to be super friendly you could also check that `location(field) == (X, Y, Z)` and `grid == field.grid` and throw an error if not so users don't get wrong results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816766264:481,error,error,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816766264,1,['error'],['error']
Availability,"I can confirm that I can reproduce the error using the MWE [here](https://github.com/CliMA/Oceananigans.jl/issues/2744#issue-1381826641) with CUDA 3.12. As with #2756, the same snippet appears to run fine with CUDA 3.9 though. Should we open an issue on CUDA.jl?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262504148:39,error,error,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262504148,1,['error'],['error']
Availability,"I can confirm that I'm getting the same error in a new environment with just Oceananigans installed. looks like this error occurs on the lines of code where a mutable function is called that returns `nothing`. such as `foreach(mask_immersed_field!, model.tracers)` , . `fill_halo_regions!(merge(model.velocities, model.tracers), model.clock, fields(model))`. here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616927702:40,error,error,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616927702,2,['error'],['error']
Availability,"I can confirm that it does fail on gpus by having tried to on my desktop. It seems to fail at this line [here](https://github.com/CliMA/Oceananigans.jl/blob/0aa8e32ef2c821330100980902c2c6469c13b719/test/test_shallow_water_models.jl#L171) . When I ran it in REPL I found the following error. I'm not sure exactly what this PR does as I haven't had a chance to look into it yet but this is the intial output that I got in the error. ```; Time-stepping ShallowWaterModels [GPU(), WENO5]: Error During Test at REPL[37]:4; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topos[1], nothing, advection); InvalidIRError: compiling kernel gpu_calculate_Guh!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.ShallowWaterModels.gpu_calculate_Guh!), OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, WENO5, Nothing, Nothing, Nothing, NamedTuple{(:uh, :vh, :h), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, Nothing, NamedTuple{(:uh, :vh, :h), Tuple{typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing)}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1821#issuecomment-873666591:284,error,error,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1821#issuecomment-873666591,3,"['Error', 'error']","['Error', 'error']"
Availability,"I can confirm that it fails as well, which I think it should since we have a grid that is `Float32` and a model that is `Floaot64`. When I set both to `Float64` they both work, of course. I guess that means it's because of the Clock as we can reproduce the error without any buoyancy involved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870718934:257,error,error,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870718934,1,['error'],['error']
Availability,"I can work on this. We can build. ```julia; function finalize!(sim::Simulation); # Finalize callbacks; [cb.finalize(cb, sim) for cb in sim.callbacks]. # Finalize model; finalize!(sim.model). return nothing; end; ```. Models can then define appropriate finalizations. One layer down, we can have. ```julia; function finalize!(model::HydrostaticFreeSurfaceModel); finalize!(model.free_surface); return nothing; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1239596118:277,down,down,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1239596118,1,['down'],['down']
Availability,"I can't run the `validation/mesoscale_turbulence/zonally_averaged_baroclinic_adjustment.jl` script. At `run!(simulation)` I get:. ```Julia; julia> run!(simulation, pickup=false); [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 1.221 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 5.500 minutes; [ Info: ... simulation initialization complete (18.565 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: TaskFailedException. nested task error: BoundsError: attempt to access 1×135×46 OffsetArray(::Array{Float64, 3}, 1:1, -2:132, -2:43) with eltype Float64 with indices 1:1×-2:132×-2:43 at index [0, 2, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:651; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:616 [inlined]; [4] getindex(::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::Int64, ::Int64, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [6] getindex(::Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902:446,ERROR,ERROR,446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,I can't say I have any idea why this error occurs. Do we do something special in this doc that we don't do in others?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1711#issuecomment-849577537:37,error,error,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1711#issuecomment-849577537,1,['error'],['error']
Availability,"I can't seem to construct a `Float32` hydrostatic model with CATKE. I'm pretty sure this used to work but I can't figure out when this error started happening or why. But it's happening as of the current `main` branch or v0.93.0 on two different machines. I guess with CUDA illegal memory access errors, they tend to occur after the illegal memory access has actually occured so the stacktrace might not be useful. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; longitude = (0, 1),; latitude = (0, 1),; z = (-100, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = BuoyancyTracer(),; tracers = (:b, :e),; closure = CATKEVerticalDiffusivity(Float32); ); ```. Error:. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870:135,error,error,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870,5,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error', 'errors']"
Availability,"I cannot get the checkpointing test running in PR #140 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:17,checkpoint,checkpointing,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,3,"['checkpoint', 'error', 'toler']","['checkpointing', 'error', 'tolerance']"
Availability,"I cannot reproduce the error on Tartarus. if I remove. https://github.com/CliMA/Oceananigans.jl/blob/1db753ebeee2691205b7c0e6a03bba1ef9db4554/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L131. `include(""test/test_lagrangian_particle_tracking.jl"")` passes. Can you try removing that line and we look at the buildkite error? Maybe it has resolved itself",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514719890:23,error,error,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514719890,2,['error'],['error']
Availability,"I changed `∂xᶠᵃᵃ` to use `Δxᶠᵃᵃ` and when I try and compute the `x` derivative of the free surface in the `x` momentum equation I get the following error. It seems to me like we need to generalize this function, and others, to work on immersed grids. I pressume this is what the other models do? Looks like the fix could be easy. ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: no method matching ∂xᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}, ::typeof(Oceananigans.Models.ShallowWaterModels.gh2), ::Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, CoordinateBoundaryConditions{Nothing, Nothing}}}}, ::Float64); Closest candidates are:; ∂xᶠᵃᵃ(::Any, ::Any, ::Any, ::AbstractRectilinearGrid, ::F, ::Any...) where F<:Function at /home/fpoulin/software/Oceananigans.jl/src/Operators/derivative_operators.jl:16; ∂xᶠᵃᵃ(::Any, ::Any, ::Any, ::AbstractRectilinearGrid, ::Any) at /home/fpoulin/software/Oceananigans.jl/src/Operators/derivative_operators.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-849719531:148,error,error,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-849719531,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,I changed a couple of `FreeSurface` functions to `materialize_free_surface`. Probably it will fix the issue with the masking?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1997626641:117,mask,masking,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1997626641,1,['mask'],['masking']
Availability,"I changed the domain to be periodic in both horizontal directions and unfortunately, it still results in the same error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852438210:114,error,error,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852438210,1,['error'],['error']
Availability,"I changed to branch `glw/no-float-type-arg` and I tried the minimal working example, with one less argument below, and it still yields the same error. I think that #1786 is for the better, but just to point out that this problem seems to persist. ```; using Oceananigans. N = 32. grid = RegularRectilinearGrid(Float32, size=(N, N, N), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), advection=WENO5(), grid=grid); time_step!(model, 1); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870615060:144,error,error,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870615060,1,['error'],['error']
Availability,"I checked and `interpolate(field, x, y, z)` isn't used anywhere in the source code but in a few validation experiment. It basically does the same thing, but extracts the fields location and grid. I've tried changing it to just be a wrapper for `interpolate(field, LX, LY, LZ, grid, x, y, z)` like:; ```julia; @inline interpolate(field::AbstractField{LX, LY, LZ, G, T, N}, x, y, z) where {LX, LY, LZ, G, T, N} = interpolate(field, LX(), LY(), LZ(), G, x, y, z); ```; but this fails as a dynamic funciton invocation. I also tried changing it to:; ```; @inline function interpolate(field, x, y, z); LX, LY, LZ = location(field); grid = field.grid; return interpolate(field, LX(), LY(), LZ(), grid, x, y, z); end; ```. but this errors with `Reason: unsupported call to an unknown function (call to jl_f_getfield)`, so I'm not sure its going to be straight forward or worthwhile trying to make the high level version work on GPU. Also, if we want to test interpolation, it always fails on GPU because of scalar indexing if called directly, but if wrapped in a kernel function is fine:; ```julia; @kernel function test!(field, grid, res, x, y, z); n = @index(Global); LX, LY, LZ = location(field); @inbounds res[n] = interpolate(field, Center(), Center(), Center(), grid, x[n], y[n], z[n]); end; ```; (If I put `grid = field.grid ` in the kernel function it also fails like above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1367924689:724,error,errors,724,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1367924689,1,['error'],['errors']
Availability,I checked and it is showing that I am running version 1.9.2. I just installed juliaup and made sure Oceanostics was updated. I got the following error; ```; [36147] signal (11.1): Segmentation fault; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/BBL_with_oscillations_code_10_percent.jl:4; Allocations: 609090 (Pool: 608187; Big: 903); GC: 1; /var/spool/pbs/mom_priv/jobs/1726131.casper-pbs.SC: line 31: 36147 Segmentation fault (core dumped) julia --project BBL_with_oscillations_code_10_percent.jl /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231354575:145,error,error,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231354575,3,"['error', 'fault']","['error', 'fault']"
Availability,"I checked and this seems to work:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(grid=grid); NonhydrostaticModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=4, Nz=4); ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> noise(x, y, z) = 100+randn(); noise (generic function with 1 method). julia> set!(model, u=noise). julia> simulation = Simulation(model, Δt=100, stop_iteration=200); Simulation{typename(NonhydrostaticModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 1.667 minutes; ├── Elapsed wall time: 0 seconds; ├── Stop time: Inf years; ├── Stop iteration : 200.0; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ └── nan_checker => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with no entries; └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> simulation.callbacks[:nan_checker].func.erroring = true; true. julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (454.946 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.370 ms).; ERROR: time = 10000.0, iteration = 100: NaN found in field u. Aborting simulation.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.Simulations.NaNChecker{NamedTuple{(:u,), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Period....; ....; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637:1330,error,erroring,1330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637,4,"['ERROR', 'error']","['ERROR', 'error', 'erroring']"
Availability,I clicked on `this code` but then obtained a 404 error. Could the link not be quite right?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101589518:49,error,error,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101589518,1,['error'],['error']
Availability,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:20,error,errors,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343,3,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,"I copied the output of pgk.status as per your request. The second part comes out when I am running lid_driven_cavity.jl. I run it in VS Codium. ```; julia> simulate_lid_driven_cavity(Re=100, N=128, end_time=15); ERROR: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:15; [6] top-level scope at REPL[2]:1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807393183:212,ERROR,ERROR,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807393183,1,['ERROR'],['ERROR']
Availability,"I could not get the Poisson pressure solver to work on the GPU. Most of it works but CUDA does not have a DCT function so I had to perform the DCT/IDCT in terms of the FFT/IFFT. The DCT/IDCT functions work in isolation (regression tested with `FFTW.r2r!`, see link to Jupyter notebook below) but not in the Poisson solver. More specifically, the IDCT fails when applied to the third dimension (after or before the IFFT is applied to dimensions 1 and 2). For now I got around this by copying the right hand side to the CPU, doing the transform on the CPU, and copying the geopotential back to the GPU. This operation is so much slower than the time stepping that it takes up like 98%+ of wall clock time. It might also be introducing further numerical errors. Link to current Poisson GPU solver:; https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L421. Messy Jupyter notebook: [Testing DCT/IDCT on the GPU](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/DCT%2BIDCT%20from%20DFT%2BIDFT.ipynb). Messy Jupyter notebook: [Testing GPU Poisson solver](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/GPU/Testing%20GPU%20Poisson%20solver.ipynb)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/56:751,error,errors,751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56,1,['error'],['errors']
Availability,"I couldn't run docs locally to make sure all is good... running ; ```bash; julia --project=docs/ -e 'using Pkg; Pkg.instantiate(); Pkg.develop(PackageSpec(path=pwd()))'; julia --project=docs/ docs/make.jl;; ```. returns. ```bash; ...; [ Info: Expanding citation: Kundu15.; [ Info: CheckDocument: running document checks.; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Utilities/Selectors.jl:167; [4] #2 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:241 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:240 [inlined]; [7] top-level scope at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; ```. which I couldn't trace down...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1072:361,ERROR,ERROR,361,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1072,5,"['ERROR', 'down', 'error']","['ERROR', 'down', 'error']"
Availability,"I couldn't think of any situation where a user would intentionally want to mismatch a coordinate and its size, hence the error. But I also don't feel particularly strong about it, so feel free to change it to a warning.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126379756:121,error,error,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126379756,1,['error'],['error']
Availability,"I decided to program the different advection schemes in Julia, without using Oceananigans. I can share the code if anyone is interested but it's nothing fancy, and needs some cleaning up. I found that the 5th order upwinding stencil, as used in Oceananigans, should have fifth order convergence. See the results below. So the good news is the stencil formula is correct. The bad news is that I don't know why we are not getting the correct values in Oceananigans, even though I am using the exact same tests. I admit that I don't understand the symmetric interpolant stuff that is done, which is perhaps why I can't see the error. Also, doing 6th order would be easy enough to do if there was interest. ```; For UpwindingFirstOrder: Rate of convergence = -0.9661593569685473 expected = 1. For CenterSecondOrder: Rate of convergence = -1.9640228832659088 expected = 1. For UpwindingThirdOrder: Rate of convergence = -2.9708218645270197 expected = 3. For CenterFourthOrder: Rate of convergence = -3.7210792193087565 expected = 4. For UpwindingFifthOrder: Rate of convergence = -4.847601153924809 expected = 5. For CenterSixthOrder: Rate of convergence = -5.784776184328756 expected = 6. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747576282:624,error,error,624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747576282,1,['error'],['error']
Availability,"I did a few tests with some criteria for timestep-skipping with a couple of my own simulations in addition to the MWE included here. In summary:. 1. Criterion `sim.Δt / 1e10`: successfully gets rids of the problem in both the MWE and in my simulations; 2. Criterion `10 * eps(sim.Δt) * sim.Δt`: doesn't get rid of the problem in any simulation; 3. `100 * eps(sim.Δt) * sim.Δt`: fixes the problem in the MWE but not in my simulations, although it does decrease its frequency of occurrence a good amount.; 4. `1000 * eps(sim.Δt) * sim.Δt`: fixes everything in all simulations I've tried. So only options 1 and 4 fully fix the problem (at least in the simulations I've tried so far). For me both those options rely on pretty arbitrary numbers though, so I'm not very happy with neither. From the point of view seeing the timestep-skipping as an approximation ($u^{n+1} \approx u^n$), then maybe criterion 1 makes more sense, although I'm not sure how it'd behave for Float32 simulations. I see three possible ways to go about it right now:. 1. Do what this PR is doing, and manually set the criterion to either option 1 or 4 above. If it turns out that some simulations still have issues, we revisit.; 2. We add `min_Δt` as a property of `NonhydrostaticModel` (or maybe `Simulation`?). I think the minimum `Δt` for which time skipping will be necessary will vary significantly between simulations, so this solution deals with that by leaving the decision up to the user if they are interested in the pressure output.; 3. We try something that actually prevents these round-off errors instead of dealing with them. @glwagner suggested an `Integer`-based model clock, but there might be other options.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2134109698:1574,error,errors,1574,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2134109698,1,['error'],['errors']
Availability,"I did a fresh clone and checked out your branch. I instantiated the library and then did `dev ..` and the library seemeed to be in good shape. Actually, it complained about my MPI so I had to rebuild that but then things seemed to be in good shape. I thought I would try `make_example.jl` first, as that should be faster than making everything. Success! there were some warnings but no errors and I could view the example no problem. I'll now try the full make and check on it tomorrow, since I know it's going to be slow. . Thanks @navidcy for putting this together!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-868930073:386,error,errors,386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-868930073,1,['error'],['errors']
Availability,"I didn't have the same problem! I think that means the issue could arise from some downstream package in your Manifest.toml in your global 1.5 environment (which is not present in mine, for some reason). What is the output of. ```julia; julia> pkg""st --manifest""; ```. ?. Mine is. ```julia; julia> pkg""st --manifest""; Status `~/.julia/environments/v1.5/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v2.4.0; [4fba245c] ArrayInterface v2.14.17; [56f22d72] Artifacts v1.3.0; [ab4f0b2a] BFloat16s v0.1.0; [6e4b80f9] BenchmarkTools v0.7.0; [6e34b625] Bzip2_jll v1.0.6+5; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v2.3.0; [83423d85] Cairo_jll v1.16.0+6; [7057c7e9] Cassette v0.3.4; [d360d2e6] ChainRulesCore v0.9.29; [944b1d66] CodecZlib v0.7.0; [35d6a980] ColorSchemes v3.10.2; [3da002f7] ColorTypes v0.10.9; [5ae59095] Colors v0.12.6; [34da2185] Compat v3.25.0; [e66e0078] CompilerSupportLibraries_jll v0.3.4+0; [d38c429a] Contour v0.5.7; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.3; [5ae413db] EarCut_jll v2.1.5+1; [b305315f] Elliptic v1.0.1; [2e619515] Expat_jll v2.2.7+6; [e2ba6199] ExprTools v0.1.3; [c87230d0] FFMPEG v0.4.0; [b22a6f82] FFMPEG_jll v4.3.1+4; [7a1cc6ca] FFTW v1.3.2; [f5851436] FFTW_jll v3.3.9+7; [53c48c17] FixedPointNumbers v0.8.4; [a3f928ae] Fontconfig_jll v2.13.1+14; [59287772] Formatting v0.4.2; [d7e528f0] FreeType2_jll v2.10.1+5; [559328eb] FriBidi_jll v1.0.5+6; [0656b61e] GLFW_jll v3.3.2+1; [0c68f7d7] GPUArrays v6.2.0; [61eb1bfa] GPUCompiler v0.8.3; [28b8d3ca] GR v0.53.0; [d2c73de3] GR_jll v0.53.0+0; [5c1252a2] GeometryBasics v0.3.9; [78b55507] Gettext_jll v0.20.1+7; [7746bdde] Glib_jll v2.59.0+4; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.0; [0234f1f7] HDF5_jll v1.12.0+1; [cd3eb016] HTTP v0.8.19; [83e8ac13] IniFile v0.5.0; [1d5cc7b8] Intel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189:83,down,downstream,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189,1,['down'],['downstream']
Availability,"I do hope that I found something useful but at the moment I am a bit confued as to what's going wrong. I'm going to copy the errors below so others can see this more easily. The error in the docs complains about `PlotUtils` failing to precompile. That doesn't seem related to shallow water so I am confused. The CPU test seems to be with `MPI`, but I didn't know we had any `MPI` tests that used shallow water that were being run. Docs:; ```; ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; --; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: Failed to precompile PlotUtils [995b91a9-d308-5afd-9ec6-746e21dbc043] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/PlotUtils/YveHG_R3lk8.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] top-level scope at none:2; &nbsp; | [2] eval at ./boot.jl:347 [inlined]; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2556/packages/Plots/SjqWU/src/Plots.jl:20; &nbsp; | ERROR: LoadError: Failed to precompile Plots [91a5bcdd-55d7-5caf-9e0b-520d859cae80] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/Plots/ld3vC_R3lk8.ji.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-1/clima/oceananigans/docs/make.jl:6; &nbsp; | 🚨 Error: The command exited with status 1. ```. CPU test; ```; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; --; &nbsp; | [9] top-level scope at none:1; &nbsp; | Union{},Union{},Tuple{},NamedTuple{(test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2556/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141:125,error,errors,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141,4,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,"I do not mean that. I think it should be a major change. When I wrote down that sentence, I did not realize that `compat` in `Project.toml` can prevent using newer versions of dependencies with breaking changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608583825:70,down,down,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608583825,1,['down'],['down']
Availability,"I do not really like the idea to inflate the grid inside the advection scheme though, if you want you can issue an error message",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480025539:115,error,error,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480025539,1,['error'],['error']
Availability,"I don't believe there is a strong need for this example as it is. Considering that #1430 is using two-dimensional turbulence a as a test case, and that might become an example, this PR seems a bit redundant. That is why I will close this but happy to return to it if there is interest. There was mention of introducing beta and looking at the development of zonal jets. This is easy enough to do and could be fun, but not sure if this warrents an example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799461263:197,redundant,redundant,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799461263,1,['redundant'],['redundant']
Availability,I don't have any immediate ideas. We'd have to take a deep dive I think. I think we'd have to apply an understanding of the Julia compiler and how code gets onto the GPU than just GPU specific knowledge. I think this error has been seen before in other contexts out on the internet so searching there might be a good place to start to start gainin more knowledge,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499790195:217,error,error,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499790195,1,['error'],['error']
Availability,"I don't know if this helps to make the issue clearer, but I just re-ran the code for just ; ```; using Oceananigans ; ```; and it executed without error. I ran it again to see if it was just a fluke and I got the following error:; ```. The following have been reloaded with a version change:; 1) cuda/12.2.1 => cuda/11.8.0. [59837] signal (11.1): Segmentation fault; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; Allocations: 605144 (Pool: 604223; Big: 921); GC: 1; /var/spool/pbs/mom_priv/jobs/1741845.casper-pbs.SC: line 31: 59837 Segmentation fault (core dumped) julia --project testcode.jl /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/; ```; Could it be an issue with the computer loading Oceananigans.jl with a bunch of extra functions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645:147,error,error,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645,8,"['error', 'fault']","['error', 'fault']"
Availability,"I don't know what happened but yesterday I could type ""using Oceananigans"" after starting julia --project and it worked fine. This morning, after a software update on ubuntu, now I'm getting a CUDA ERROR. See below. Any ideas what I can do to try and fix this?. ```; julia> using Oceananigans; ┌ Warning: Recursion during initialization of CUDA.jl; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:41; ┌ Error: Could not initialize CUDA; │ exception =; │ CUDA error (code 803, CUDA_ERROR_SYSTEM_DRIVER_MISMATCH); │ Stacktrace:; │ [1] throw_api_error(::CUDA.cudaError_enum) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:97; │ [2] __configure__(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:98; │ [3] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:29 [inlined]; │ [4] macro expansion at ./lock.jl:183 [inlined]; │ [5] _functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:26; │ [6] functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:19; │ [7] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:50; │ [8] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:198,ERROR,ERROR,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,4,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"I don't know. Increasing grid points to 4, there's still a problem with 6 threads. ```julia; (base) gregorywagner:Oceananigans.jl/ (main✗) $ JULIA_NUM_THREADS=6 julia --project race_condition_test.jl [19:56:49]; [ Info: Oceananigans will use 6 threads; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (79.416 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (6.660 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; (parent(simulation.model.velocities.u))[1, 1, :] = [1.9557581998545617, 1.9557581998545617, 1.956214574857873, 1.9553566305291932, 1.9553371609848056, 1.9553371609848056]; Test Failed at /Users/gregorywagner/Projects/test/Oceananigans.jl/race_condition_test.jl:17; Expression: (parent(simulation.model.velocities.u))[1, 1, 2] == (parent(simulation.model.velocities.u))[1, 1, 3]; Evaluated: 1.9557581998545617 == 1.956214574857873; ERROR: LoadError: There was an error during testing; in expression starting at /Users/gregorywagner/Projects/test/Oceananigans.jl/race_condition_test.jl:17; ```. and also with 4. But with 3,. ```julia; (base) gregorywagner:Oceananigans.jl/ (main✗) $ JULIA_NUM_THREADS=3 julia --project race_condition_test.jl [19:58:49]; [ Info: Oceananigans will use 3 threads; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (98.396 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (6.548 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; (parent(simulation.model.velocities.u))[1, 1, :] = [1.9543734841879783, 1.9543734841879783, 1.9543734841879783, 1.9560232965664703, 1.9567081251492398, 1.9567081251492398]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308177839:981,ERROR,ERROR,981,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308177839,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I don't see anything obvious, but I would try. ```julia; @inline tank(x, y) = ifelse(radius(x, y) < L, -H, 0.0); ```. so that `tank` always returns `Float64`, rather than sometimes `Int64` (eg, `0`), and sometimes `Float64` (`-H`). If that doesn't work, we'll have to strip this script down to a more minimal example so that we can debug it. For example, the forcing functions and all the constants and parameters associated with them may not be relevant? Perhaps we can try. ```julia; @inline tank(x, y) = -0.15; ```. as the immersed boundary function first, too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1073124614:286,down,down,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1073124614,1,['down'],['down']
Availability,"I don't think architecture is required, despite being included here:. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/checkpointer.jl#L74. For example, `:architecture` property is not called within. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/checkpointer.jl#L201",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3463:175,checkpoint,checkpointer,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3463,2,['checkpoint'],['checkpointer']
Availability,"I don't think it's a huge problem if we have fields masked to zero. Also, why is `dot(interior(a), interior(b))` not correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2725#issuecomment-1256412976:52,mask,masked,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2725#issuecomment-1256412976,1,['mask'],['masked']
Availability,I don't think so.; Now both `h` and `z` are just floats so the `.` you suggest is redundant.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3530#issuecomment-2030090662:82,redundant,redundant,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3530#issuecomment-2030090662,1,['redundant'],['redundant']
Availability,I don't think this is done correctly right now. Somehow the `Checkpointer` needs to know about the simulation for this to work. But right now it only saves model properties.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1967461995:61,Checkpoint,Checkpointer,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1967461995,1,['Checkpoint'],['Checkpointer']
Availability,I don't think this is the same as my error linked from before.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751626241:37,error,error,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751626241,1,['error'],['error']
Availability,"I don't think. ```julia; condition = arch_array(architecture(operand.grid), NotImmersed(condition)); ```. does anything. You probably want. ```julia; @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask) ; condition = arch_array(architecture(operand.grid), condition) ; return ConditionalOperation(operand; func, NotImmersed(condition), mask) ; end ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1906891075:240,mask,mask,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1906891075,2,['mask'],['mask']
Availability,"I don't understand why this is failing (it also fails locally). It is only:; https://github.com/CliMA/Oceananigans.jl/blob/4d30ed8bf093b6b7894677ef33c2c0b1cf3e1487/test/test_field.jl#L126; that fails for Float32 on the grid points, and the error is ~4.6f-6 vs eps which is ~3.8f-6. It is also weird that this fails on regular grids where I haven't changed anything. Also, the maximum error for each interpolation is:; ```; u -> 1.9073486e-6; v -> 4.7683716e-6; w -> 3.8146973e-6; c -> 3.8146973e-6; ```; with $\epsilon_{max} =$ 3.8146973f-6 and I don't know why they wouldn't all be the same?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1492068738:240,error,error,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1492068738,2,['error'],['error']
Availability,"I don't use JLD2 files at all so it would be good if someone else chimed in here. That said, JLD2 is a native Julia format and apparently it lets you save much more stuff to the disk much easier than a NetCDF file, which is probably why the checkpointing feature uses JLD2 and not NetCDF. So I don't think we even want a NetCDF-based. . That said, JLD2 is [HDF5-comptible](https://github.com/JuliaIO/JLD2.jl) so if you want to open the checkpoint files for whatever reason you can use any HDF5 library in any software you want. Like you, I don't use JLD2. So when I run a simulation that will take too long I set-up my checkpointer (which is for picking up a simulation only) and a `NetCDFOutputWriter` to open the results somewhere else. Cheers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-895617555:241,checkpoint,checkpointing,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-895617555,3,['checkpoint'],"['checkpoint', 'checkpointer', 'checkpointing']"
Availability,"I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. ; This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`. If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else. If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033:140,error,errors,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033,1,['error'],['errors']
Availability,"I echo @ali-ramadhan that since examples are expensive to maintain it'd be nice to have some topical diversity. Perhaps a different initial conditions in a geometry with walls, on a beta plane... ?!? We don't have any channel geometry or `BetaPlane` examples right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780111461:2,echo,echo,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780111461,1,['echo'],['echo']
Availability,"I feel like this impacts usability, especially interactive use, but it's not a bug in the sense that your simulation scripts are fine. Is it worth trying to fix this?. Maybe not. After all, executing `model.velocities.u.data` in the REPL with a GPU model produces a similar error to the one below. One nuclear option is to allow scalar operations in `show` methods, but in this particular example it's for a `SubArray{OffsetVector{CuArray}}` so not a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/Offs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:274,error,error,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,4,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"I figured out that the figures are all saved to a file and am including a couple of examples. I have a few thougths to share. - Updating plots shouldn't be difficult but don't know anything about the xticks mentioned above. - I think we have too many items in the legend. I think there should just be two sets of markers and the best fit. - Probably don't want to start at such a coarse grid as clearly we are far from convergence. - I think that UpwindBiasedFifthOrder just needs a little more effort to get the order. The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. I am happy to help fixing this (and other validations) but getting some help from someone who understands the script would be a lot faster. . ![one_dimensional_convergence_WENO5](https://user-images.githubusercontent.com/8239041/102221597-51a70a80-3eb0-11eb-8421-4a519d5bbfc9.png); ![one_dimensional_convergence_UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102221609-54096480-3eb0-11eb-92bf-ef35bb069c96.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444:613,error,error,613,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444,2,['error'],['error']
Availability,I find that the code for boundary conditions for particles cannot deal with unusually large velocity \(when $u\Delta t$ has the order of the domain size\). Fixing the related code \(Yixiao-Zhang/Oceananigans.jl@95f68a1\) enables running the script that I posted previously in this page. Do we need an additional test for such cases?. One remaining question is why the log shows that the error occurs from the pressure solver. Can we do anything to improve the accuracy of error messages?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918:387,error,error,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918,2,['error'],['error']
Availability,"I found this in the validation script:; ```Julia; grid = LatitudeLongitudeGrid(size = (12, 14),; longitude = (-180, 180),; latitude = (-30, 30),; z = (0, 0),; halo = (4, 4),; topology = (Periodic, Bounded, Flat)); ```. Hm.... `z = (0, 0)` seems to be crucial! Removing it gives the error I posted above. But with `z`-dimension Flat then `z = (0, 0)` shouldn't be needed. We should fix the `LatitudeLongitudeGrid` constructor accordingly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143215355:282,error,error,282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143215355,1,['error'],['error']
Availability,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:337,error,error,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I get the following error when I call `maximum` on a field with location `Face, Center, Center` on an immersed boundary grid with a vertically stretched underlying grid on the GPU. For example:. ```Julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lx, Ly, Lz = 500, 600, 3. Nx, Ny, Nz = 128, 128, 64. σ = 1.04 # linear stretching factor; linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz). underlying_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded), ; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)). const H_deep = H = underlying_grid.Lz; const H_shelf = h = 0.5; const width_shelf = 100. shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); bathymetry(x, y) = shelf(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); ```. then just creating a `u` field gives:. ```julia; julia> u = Field((Face, Center, Center), grid); Error showing value of type Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, N",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['error'],['error']
Availability,I get the same error with no-slip on GPU.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1125727906:15,error,error,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1125727906,1,['error'],['error']
Availability,"I get this with the default free surface model (which I think can be solved fairly easily):; ```julia; model = HydrostaticFreeSurfaceModel(; grid); ERROR: Metal does not support Float64 values, try using Float32 instead; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] check_eltype(T::Type); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:32; [3] Metal.MtlArray{Float64, 3, Metal.MTL.MTLResourceStorageModePrivate}(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:50; [4] (Metal.MtlArray{Float64, 3})(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:98; [5] MtlArray; @ ~/.julia/packages/Metal/lnkVP/src/array.jl:157 [inlined]; [6] Metal.MtlArray(A::Array{Float64, 3}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:173; [7] arch_array(#unused#::Oceananigans.Architectures.MetalBackend, a::Array{Float64, 3}); @ Oceananigans.Architectures ~/Documents/Projects/Oceananigans.jl/src/Architectures.jl:75; [8] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}, planner_flag::UInt32); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:61; [9] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:148,ERROR,ERROR,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,I get:; ```; 12.372 s (119521270 allocations: 70.48 GiB) # main; 8.320 s (66686606 allocations: 16.40 GiB) # main w downgraded KA 0.7.3 & CudaKernels 0.3.3; ```. 50% slowdown and _much_ more allocations (if that matters),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482209528:116,down,downgraded,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482209528,1,['down'],['downgraded']
Availability,I got a little confused reading . https://github.com/CliMA/Oceananigans.jl/blob/4f1fe0fa7edd9489ba20875be64b69daa0a77b95/src/ImmersedBoundaries/immersed_fields_reductions.jl#L28. because I thought that `solid_interface` was defined for fluxes while `solid_node` was for masking. Can we clarify what the purpose of these two functions are? Do their names need to be changed?. @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2293:270,mask,masking,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293,1,['mask'],['masking']
Availability,I got an incremental compilation error/warning here. https://github.com/CliMA/Oceananigans.jl/blob/b6dd1fa9b1d740f7d8cb4be116a24cbba0042f86/src/Architectures.jl#L23,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2676:33,error,error,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2676,1,['error'],['error']
Availability,"I guess I more meant do we have reason to believe that trig functions slow things down 100x?. We use trig functions in the lat-lon grid without this issue for example, so it seems unlikely. If we're observing expected slow downs (perhaps up to 2-3x for an expensive trig function that's called often), then I don't think we need to keep this issue open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2034#issuecomment-1017688862:82,down,down,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2034#issuecomment-1017688862,2,['down'],"['down', 'downs']"
Availability,"I guess `partition` would take the place of `ranks`. I think it makes sense to delay building `connectivity` (ie we only build connectivity when we build fields and their boundary conditions) --- because we can construct connectivities if we have 1) grid and 2) the partition. But we still have to store the partition in either `grid` or `grid.architecture`, correct?. One approach could produce code like. ```julia; arch = MPIArchitecture() # note no arguments; grid = RectilinearGrid(arch, grid_kw..., partition=XPartition()); ```. internally, the constructors maybe take the form. ```julia; function RectilinearGrid(arch, size, other_grid_kw, architecture_kwargs...); arch = rebuild_arch(arch; architecture_kwargs...); # etc; end; ```. That's possibility (1). Possibility (2) is to use a wrapper for MPI jobs, perhaps completely eliminating `MPIArchitecture` altogether:. ```julia; arch = CPU(); grid = RectilinearGrid(arch, kw...); grid = MultiProcessGrid(grid, partition=XPartition()); ```. Possibilty (3) is to change all the `struct` definitions for grids so they have additional information pertinent to multi-process stuff, which is set to `nothing` when unused. The downside to (2) is that it introduces yet another level of indirection, on top of both `ImmersedBoundaryGrid` and `MultiRegionGrid`. If we wanted to do MPI-distribued, multi-region simulations in complex domains, we have 4 (!) levels of wrapping. Hmm...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724:1176,down,downside,1176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724,1,['down'],['downside']
Availability,"I guess both would be good. But specifically I meant that it'd be good for someone to run the same scripts I ran and see if they can reproduce the behavior. Who knows, maybe it's something wrong in my setup. (Although I have tried in both my laptop and on the Casper cluster.). I do think it's weird that an error (apparently) this serious isn't being caught by the tests, so it's very possible that I'm making a silly mistake somewhere... having someone investigate this as well would alleviate this concern a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-814125461:308,error,error,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-814125461,1,['error'],['error']
Availability,"I guess changing to `MultiArchitecture` makes sense but I admit, I do like `MultiArch` since we do use `arch` in places and it has become pretty common, I think. Do we need default ranks? We can always find the number of runs in any run, and why not just check? Sorry if I am missing something. To answer the above question, you can see [here](https://juliaparallel.github.io/MPI.jl/stable/environment/#MPI.Init), but the short version is it initializes MPI in the current process. I guess this tells each process that it should get ready for the possibility of sharing information, otherwise, we probably get an error. It sounds cleaner to me to hide it in `MultiArch` but wonder if there is a good reason why not. Sadly, I don't know it but am happy to hear more from others.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1066790992:613,error,error,613,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1066790992,1,['error'],['error']
Availability,"I guess here is a problem with `heuristic_workgroup`. ```; Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Error During TestError During Test at at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_distributed_models.jl:481;   | Got exception outside of a @test;   | MethodError: no method matching heuristic_workgroup(::MultiCPU{RegularRectilinearGrid{Float64, Periodic, Periodic, Periodic, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Oceananigans.Distributed.RankConnectivity{Nothing, Nothing, Int64, Int64, Nothing, Nothing}, MPI.Comm}, ::Int64, ::Int64, ::Int64);   | Closest candidates are:;   | heuristic_workgroup(::GPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:12;   | heuristic_workgroup(::CPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:26;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963:129,Error,Error,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963,3,['Error'],['Error']
Availability,"I guess if we run this on different nodes the efficiency is bound to go down, but that's a problem with the architecture I guess and not something we can change with software. Unless there is something I don't know about?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805927808:72,down,down,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805927808,1,['down'],['down']
Availability,"I guess it's mostly for boundary conditions. With boundary conditions I don't think we want to auto-partition, because very often the application of using a boundary condition array is to pass fluxes between models or from data into a model. I think the most useable / friendly solution is to throw a helpful error that tells the user to use `on_grid`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2534#issuecomment-1120301572:309,error,error,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2534#issuecomment-1120301572,1,['error'],['error']
Availability,"I guess part of the confusion is that some kwargs are for users while others were introduced for checkpointer usage. I agree that `timestepper_method` and `timestepper` are redundant. We should be able to just do something like `time_stepper = AdamsBashforth2()` for something. Or go with your suggestion on Slack of having the choice of either passing a Symbol for a full struct. Users might usually pass `tracers = (:a, :b)` but checkpointer might pass `tracers = TracerFields(...)`. > It's probably best if we assign only one keyword argument to each ""concept"", for the sake of simplicity and interpretability. I'm totally on board with this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/647#issuecomment-592499852:97,checkpoint,checkpointer,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/647#issuecomment-592499852,3,"['checkpoint', 'redundant']","['checkpointer', 'redundant']"
Availability,I guess the way this goes down is via these functions:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Fields/function_field.jl#L64. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Fields/function_field.jl#L57-L59. that's why. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/examples/geostrophic_adjustment.jl#L73-L77. is 2D for the free surface. This'll affect #2246 .,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1655#issuecomment-1047950926:26,down,down,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1655#issuecomment-1047950926,1,['down'],['down']
Availability,I guess this isn't tested because otherwise it would throw an error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2634#issuecomment-1171937765:62,error,error,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2634#issuecomment-1171937765,1,['error'],['error']
Availability,"I guess we have a decision here, but I think `PartialCellBottom` probably deserves to subtype `AbstractGridFittedBoundary`. The masking algorithm is the same... the only additional feature that `PartialCellBottom` brings is a change in the calculation of the vertical cell spacing in the bottommost cell. For example I think the masking of the velocity field is the same for both partial cells and full cells.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042473526:128,mask,masking,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042473526,2,['mask'],['masking']
Availability,"I guess when we made it so auxiliary fields can be field dependencies for forcings we a) only tested on nonhydrostatic models, and b) didn't implement for functional boundary conditions. I also have no idea how this didn't cause OceanBioME models I've run on HydrostaticFreeSurface models to error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292:292,error,error,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292,1,['error'],['error']
Availability,"I had not tried it before but I just tried it now. . The error is that `ShallowWaterModel` has no field velocities. `cell_advection_timescale.jl` defined [here](https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Utils/cell_advection_timescale.jl) meeds to know the velocities, u,v,w. In `ShallowWaterModel` we know uh, vh, and h, from which we can compute the velocities. . Is this a time for dispatching?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761105597:57,error,error,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761105597,1,['error'],['error']
Availability,I have a version of `CumulativeIntegral` in `z` that can be used as an example.; It needs to be updated though. I was using it to estimate some initial thermal-wind currents for a baroclinic instability simulation.; https://github.com/iuryt/NorthAtlanticBloom/blob/main/src/01-model/cumulative_vertical_integration.jl. I believe `device_event` is not available anymore.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098894777:351,avail,available,351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098894777,1,['avail'],['available']
Availability,"I have been exclusively using the netCDF output option and, after upgrading to v0.44.2, I've noticed the behavior of `NetCDFWriter` changed. . - First thing is that I get a message that the mode hasn't been set even when it has, which seems like a bug to me. So, for example, setting the writer as . ```; using Oceananigans.OutputWriters. outputs_netcdf = (u = model.velocities.u,; v = model.velocities.v,; ). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, outputs_netcdf,; filepath = ""mwe.nc"",; schedule = TimeInterval(5seconds),; mode = ""c""); ```. I get a warning saying `mwe.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file.`, even though the mode is clearly set to clobber. And sure enough, if I run the simulation it appends to the previous netcdf file. (Also, the docs still say that the default mode is `""c""`, but it now changed to `""a""`). - The other thing is that after I set up the `NetCDFWriter` the file is always open by the Julia REPL and unreachable from anywhere else. So for example if I want to check on the simulation by opening the output netcdf file with Python I get an error saying that the file is being used. So I need to either make a copy of the file and access the copy (which uses up space) or wait for the simulation to finish, which isn't ideal. I can't imagine opening and closing a netCDF file takes long (especially since we ideally won't write to it at every time step), so is there a reason for the netCDF file to always stay open inside Julia?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227:1195,error,error,1195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227,1,['error'],['error']
Availability,"I have been playing with the one_dimensional_diffusion.jl example and have found something a bit odd. When I run it, with everything already installed, it seems to complain about [line18](https://github.com/CliMA/Oceananigans.jl/blob/a343711f1101b1a433124f5f9697ce60b1011a40/examples/one_dimensional_diffusion.jl#L18) with the following error,. ```; ERROR: LoadError: package `Oceananigans [9e8cae18]` has same name or UUID as the active project; ```. Is this expected? . Is this something we want to avoid?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1205:337,error,error,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1205,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I have been running on the system Julia for these, I attempted to do my own install but I do not think I ended up doing much with it. I believe `gcc` is a dependency for the subsequent modules as for example when I run:; ```; module --force purge; module load ncarenv/23.10 ; module load ncarcompilers/1.0.0; ```; the last line returns ; ```; Lmod has detected the following error: These module(s) or; extension(s) exist but cannot be loaded as requested: ""ncarcompilers/1.0.0""; Try: ""module spider ncarcompilers/1.0.0"" to see how to load the module(s).; ```; which does not happen if I include `gcc`. I was also able to run my code without netcdf!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846:375,error,error,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846,1,['error'],['error']
Availability,"I have been thinking that we should expand a bit our Smagorinsky models.; Currently the only Smagorinsky-type model we have is the Smagorinsky-Lilly, which works well in some cases, notably the canonical horizontally-periodic turbulence, but has some downsides for more complex flows. For example when turbulence is not heterogeneous, or when there are persistent mean gradients in the flow. AMD is a good option in some cases, but often there are numerical artifacts in stratified, laminar regions in the flow (I don't think it's clear exactly what causes this, but it happens in many of my simulations, and I've herd similar things from others). So I think having at least one option to run a dynamic Smag would be good. One possibility is that, as a start, we allow for user-defined Smagorinsky coefficients that could depend on the velocities. Something like. ```julia; cₛ(i, j, k, grid, C::Function) = C(i, j, k, grid, u, v, w); ```; where `C(i, j, k, grid, u, v, w)` is provided by the user. That would allow the user a bit more control, and they could implement local dynamic Smag models, such as the [dynamic gradient Smagorinsky](https://journals.aps.org/prfluids/abstract/10.1103/PhysRevFluids.7.074604). Something similar is currently done for AMD, although I think it's a bit more restrictive than what I'm proposing. Soon, if there's interest, I'm planning on implementing a scale-independent Smagorinsky that's averaged in the symmetric flow directions (generally this is referred to as Planar-Averaged Scale-Independent Smag, but we wouldn't be limited to a planar average in our case). From then on, the extension to a Langrangian-Averaged Scale-Independent Smag would be straightforward. Eventually it would be nice to extend these to a Scale-_dependent_ model, but I think it's wise to start with the simpler cases. How do people feel about this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637:251,down,downsides,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637,1,['down'],['downsides']
Availability,"I have checked thoroughly _every_ function in the advection module for a `checkbounds()` call and couldn't produce any Bounds error. This is remaining a mystery to me because it seems that the whole advection module elides bounds checking. On the other hand, I found that `main` has the same problem, on the `near_global_quarter_degree.jl` experiment this is the wall time per 10 time steps; (with `--check-bounds=no`, without `--check-bounds=no`); main -> 2.7 / 3.6 s; this PR -> 3.3 / 4.4 s. so there is for sure a problem of performance (which I will try to solve) but it does not seem to be related to bounds checking as; `2.7 / 3.6 = 3.3 / 4.4 = 0.75`. It is a must to find out where these bounds checks are eating up 25% of our computational time (do you know an easy way to profile it?).; By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186040507:126,error,error,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186040507,1,['error'],['error']
Availability,"I have created a new branch called ""ShallowWaterS1waveeqn"". S1 is for step 1. It doesn't do much right now but I'm trying to set up the skeleton so that we can actually do something intereting, like evolve the equation. At the moment I have the following:. 1. Created a ShallowWaterModels folder. 2. Created a ShallowWaterModels.jl module. It doesn't do much except include shallowwater_model.jl. 3. shallowwater_model.jl defines a mutable struct and a function. I couldn't get a lot of things to work but it does regularlize the boundary condtions, set up the velocities and a new variable called layer_depth. The name is not great and can go with depth or height, as people prefer. It will be in in the governing equations. 4. Created an example, in the same folder, called onedim_shallowwater.jl. Currently, this includes the module mentioned above, defines a grid (yes, a single point!), defines the initial conditions and sets the velocity. Questions:. 1. This is pretty bare bones so far but does this follow the philosophy of Oceananigans?. 2. I have tried to inititalze the layer_depth by adding an argument into the set! command but it failed. Below is the command that I thought would work and below is the error because layer_depth is not model.velocities or model.tracers. Can someone help me to see what silliness I am doing?. ```; set!(model, u = u, v = v, layer_deth = layer_depth); fails with ""ERROR: LoadError: ArgumentError: name layer_depth not found in model.velocities or model.tracers."". After I get the initial conditions defined I then need to specify the fluxes for the PDE. That should not be difficult but one issue is the nomenclature. The vector we have now is velocities, but we actually want, velocity transport. I should use and define hu and hv instead of u and v. That should be easy enough, I think.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188:1217,error,error,1217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I have deleted all the folder in "".julia/"", and when I try to re-install Oceananigans in Julia 1.5.2, a lot of packages still show ""installed"". How can I deleted these installed packages in Julia?. For example, I need to downgrade the ""ArrayInterface"" to v2.14.17. `julia> pkg""add Oceananigans, JLD2, Plots"" `; ```; Installing known registries into `~/.julia`; ######################################################################## 100.0%; Added registry `General` to `~/.julia/registries/General`; Resolving package versions...; Installed libfdk_aac_jll ─────────────── v0.1.6+4; Installed Expat_jll ──────────────────── v2.2.7+6; Installed Zstd_jll ───────────────────── v1.4.8+0; Installed Measures ───────────────────── v0.3.1; Installed ArrayInterface ─────────────── v3.1.7",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824517434:221,down,downgrade,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824517434,1,['down'],['downgrade']
Availability,"I have found it inconvenient that output is masked to `0`. For most purposes, I'd prefer `NaN`. I'm opening this issue to discuss a user interface that would implement such a feature. My first idea is to add a property / kwarg to output writers called `immersed_values`. Then we might write something like. ```julia; output_writer = JLD2OutputWriter(model, output, immersed_values=NaN, other_kwargs...); ```. The default will be `immersed_values=nothing`. Then `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/OutputWriters/fetch_output.jl#L12-L15. would become something like. ```julia. function fetch_output(field::AbstractField, model, immersed_value) ; compute_at!(field, time(model)); !isnothing(immersed_value) && mask_immersed_field!(field, immersed_value); return parent(field) ; end ; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061:44,mask,masked,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061,1,['mask'],['masked']
Availability,"I have made a first attempt to add tracers into `ShallowWaterModel`, but unfortunately, have a problem with the new function I have created, `div_ucvc` to compute the divergence of the tracer, `c`, times the velocity `(u,v)`. . When I try running a simulation I get the following output, which is a TaskFailedexcetion, and seems to be having problems with convert. ```; julia> run!(simulation); ERROR: TaskFailedException:; MethodError: Cannot `convert` an object of type Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(+),Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(+),Float64,Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(*),Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{Nothing,Nothing}}}},Float64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(*),Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1510:395,ERROR,ERROR,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1510,1,['ERROR'],['ERROR']
Availability,"I have modified the timestepwizard to deal with `Flat` topologies. The good news is that `convecting_plankton.jl` and `lid_driven_cavity.jl` now work just fine. . The one outstanding example that I can't seem to get to work is `geostrophic_adjustment.jl`. Everytime I try running it I get a seg fault. See below. Anyone have any ideas what's going wrong?. ```; julia> include(""geostrophic_adjustment.jl""); ┌ Warning: HydrostaticFreeSurfaceModel is experimental. Use with caution!; └ @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/software/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:98. signal (11): Segmentation fault; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/geostrophic_adjustment.jl:92; jl_gc_pool_alloc at /buildworker/worker/package_linux64/build/src/gc.c:1148; jl_gc_alloc_ at /buildworker/worker/package_linux64/build/src/julia_internal.h:277 [inlined]; jl_gc_alloc at /buildworker/worker/package_linux64/build/src/gc.c:3150; jl_gc_alloc_buf at /buildworker/worker/package_linux64/build/src/julia_internal.h:304 [inlined]; array_resize_buffer at /buildworker/worker/package_linux64/build/src/array.c:686; jl_array_grow_at_end at /buildworker/worker/package_linux64/build/src/array.c:875 [inlined]; jl_array_grow_end at /buildworker/worker/package_linux64/build/src/array.c:939; jl_array_sizehint at /buildworker/worker/package_linux64/build/src/array.c:1139; sizehint! at ./array.jl:1103 [inlined]; BitSet at ./bitset.jl:18; BitSet at ./bitset.jl:29 [inlined]; construct_ssa! at ./compiler/ssair/slot2ssa.jl:780; slot2reg at ./compiler/ssair/driver.jl:127 [inlined]; run_passes at ./compiler/ssair/driver.jl:134; optimize at ./compiler/optimize.jl:174; typeinf at ./compiler/typeinfer.jl:33; abstract_call_method_with_const_args at ./compiler/abstractinterpretation.jl:266; abstract_call_gf_by_type at ./compiler/abstractinterpretation.jl:134; abstract_call_known at ./compiler/abstractinterpretation.jl:904;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040:295,fault,fault,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040,2,['fault'],['fault']
Availability,"I have put together an example for my own benefit (not to be merged into master unless people want it to be) that looks at the simulation of inertial instability in 2D. See [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/inertially_unstable_jet.jl) for the code. . I believe everything is working on a CPU but I am having two difficulties with GPUs. . 1. In line 39, where I define the background buoyancy of the jet, I can't use `coriolis.f` because CUDA seems to need a global variable and this doesn't cut it. I am presently using `f` instead and this works, but should this work? `ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!`; 2. When I make a simulation from a gpu calculation, I get that the buoyancy perturbation has perturbations at the top and bottom, which are not physical. Which is to say that it has different boundary conditions. I didn't actually specify the boundary conditions differently but just wanted a solid top and bottom. If I specify the boundary conditions explicitly, should this fix the problem? Maybe that's a fix but is this expected behaviour?. https://user-images.githubusercontent.com/8239041/113899192-8d851900-979a-11eb-97a7-b7f8085864b7.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554:631,ERROR,ERROR,631,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554,1,['ERROR'],['ERROR']
Availability,I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751625991:56,error,errors,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751625991,2,['error'],"['error', 'errors']"
Availability,"I have some validation scripts already that work on the CPU and indicate that the new closure is working. However, I can't make this work on the GPU. I keep getting this error:. ```; ERROR: LoadError: GPU compilation of MethodInstance for Oceananigans.TurbulenceClosures.gpu__compute_scale_invariant_smagorinsky_viscosity!(::KernelAbstractions.CompilerMetadata{…}, ::OffsetArrays.OffsetArray{…}, ::Field{…}, ::Field{…}, ::RectilinearGrid{…}, ::ScaleInvariantSmagorinsky{…}, ::Nothing, ::@NamedTuple{…}, ::@NamedTuple{}) failed; KernelError: passing and using non-bitstype argument. Argument 7 to your kernel function is of type ScaleInvariantSmagorinsky{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.DirectionalAveraging{Tuple{Int64, Int64}}, Float64, @NamedTuple{}, Integer}, which is not isbits:; .update_frequency is of type Integer which is not isbits.; ```. Reading up on the CUDA.jl docs I _think_ I understand where this error comes from (although I thought `update_frequency`, which is an `Integer`, should work, but it throws an error). Still couldn't figure out how to fix it in this case here. I assume it's not hard to fix though, so I was wondering if someone (I'm assuming @simone-silvestri or @glwagner) can please give me a hand or at least point me in the right direction?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2294992357:170,error,error,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2294992357,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I have the following output writer set-up in my simulation:. ```julia; import Oceananigans.Fields: ComputedField; u, v, w = model.velocities.u, model.velocities.v, model.velocities.w; b, pHY′, pNHS = model.tracers.b, model.pressures.pHY′, model.pressures.pNHS; ν, νₑ = model.closure.ν, model.diffusivities.νₑ; #-----. #-----; import Oceananigans.AbstractOperations: ∂x, ∂y, ∂z. ddx = ∂x(u)^2 + ∂x(v)^2 + ∂x(w)^2; ddy = ∂y(u)^2 + ∂y(v)^2 + ∂y(w)^2; ddz = ∂z(u)^2 + ∂z(v)^2 + ∂z(w)^2; #avg_ε = AveragedField(ComputedField(ddx + ddy + ddz), dims=(1,)); avg_ε = AveragedField(ν*(ddx + ddy + ddz), dims=(1,)). outputs = (ε = avg_ε,); simulation.output_writers[:avg_field_writer] =; NetCDFOutputWriter(model, outputs,; filepath = ""avg.jd15_3dbounded.nc"",; schedule = TimeInterval(2minutes),; mode = ""c""); ```. This works successfully on CPUs, but running on GPUs I get a huge amount of error lines with some . ```; [16] compute! at /glade/u/home/tomasc/.julia/packages/Oceananigans/6JcUu/src/Fields/averaged_field.jl:86 [inlined]; ```. Running the simulation without that output works for both GPUs and CPUs. Am I doing something wrong here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241:880,error,error,880,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241,1,['error'],['error']
Availability,"I have written a script, with much help from @ali-ramadhan and @glwagner , that computes the rates of convergence for the one dimensinal constant advection case using two approaches: the 1st to 6th order schemes that I mentioned before, and the 2nd to 5th order schemes that are in Oceananigans. The results are shown below. ![convergence_rates_all](https://user-images.githubusercontent.com/8239041/102648898-511fa580-4136-11eb-99c9-a02b85465c96.png). ![convergence_rates_Oceananigans](https://user-images.githubusercontent.com/8239041/102648908-5381ff80-4136-11eb-8feb-de736ec30438.png). **Good news:** Oceananigams produces the correct slopes within error for all the cases. **Next problem:** Figure out why we didn't get the right slope in the other calculation from before and fix whatever the bug might be. You can find the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/validation/new_framework/rates_of_convergence.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029:653,error,error,653,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029,1,['error'],['error']
Availability,"I haven't had the the time to investigate this for now, but `min_Δz()` (and supposedly the x and y version as well) complains about scalar indexing on the GPU when using irregular z spacing:. ```; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::Recti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040:197,ERROR,ERROR,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I haven't had time to investigate further, but I haven't gotten a similar error in a long time, so I'm assuming some update fixed this. Since it sounds like you didn't find anything, I think I'll close this now. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-2299214723:74,error,error,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-2299214723,1,['error'],['error']
Availability,"I haven't looked at APE because it's harder to compute. Although maybe with the area and distance operators it wouldn't be too hard to calculate it via integral (Winters et al., 1995):. ![image](https://user-images.githubusercontent.com/13205162/221880181-55c6efb5-bef5-43c7-b105-2be6056ffd85.png). where $z*$ is the sorted $z$. Note that initially the APE is zero since there are no fluctuations on top of the linear stable stratification. So the initial KE is indeed all the energy available to the system.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1448262472:484,avail,available,484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1448262472,1,['avail'],['available']
Availability,"I hit these issues when setting a field on an immersed boundary grid.; ```; ERROR: LoadError: MethodError: no method matching ξname(::ImmersedBoundaryGrid{Float64, Periodic, RightConnected, Bounded, OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, GPU}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{OrthogonalSphericalShellGrids.Zipper, Int64}, Nothing, Nothing, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Flux, Nothing}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CUDA.CuArray{Tuple{UInt16, UInt16, UInt16}, 1, CUDA.DeviceMemory}, CUDA.CuArray{Tuple{UInt16, UInt16}, 1, CUDA.DeviceMemory}, GPU}). Closest candidates are:; ξname(!Matched::LatitudeLongitudeGrid); @ Oceananigans ~/.julia/packages/Oceananigans/O8Ult/src/Grids/latitude_longitude_grid.jl:574; ξname(!Match",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742:76,ERROR,ERROR,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742,1,['ERROR'],['ERROR']
Availability,"I hope it's okay that I opened a new issue to discuss tackling open BC support (see #3828) since this issue was originally focused on the @tomchor's MWE erroring, which does not error anymore. I also think the discussion has gotten intermingled with discussions from PR #3268. If it's okay with everyone maybe we can close this issue and continue discussing in #3828?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2397566446:153,error,erroring,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2397566446,2,['error'],"['error', 'erroring']"
Availability,"I installed Julia and set up Oceananigans on my laptop and when I try running `test_shallow_water_mode.jl` I get an error. I suspect this is because of my laptop more than the PR but any ideas what's going on here? . ```[2021/01/07 11:52:45.500] INFO Testing time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]...; Time-stepping ShallowWaterModels [CPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); TaskFailedException:; BoundsError; Stacktrace:; [1] getindex at ./number.jl:83 [inlined]; [2] advective_tracer_flux_x at /home/fpoulin/software/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:105 [inlined]; [3] h_solution_tendency at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl:71 [inlined]; [4] cpu_calculate_Gh! at /home/fpoulin/.julia/packages/KernelAbstractions/jAutM/src/macros.jl:230 [inlined]; [5] __thread_run(::Int64, ::Int64, ::Int64, ::KernelAbstractions.Kernel{KernelAbstractions.CPU,KernelAbstractions.NDIterat```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376:116,error,error,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-756242376,2,"['Error', 'error']","['Error', 'error']"
Availability,I just changed the Adapt.jl compat entry to make use of the new version with the `StepRangeLen` fix. The MWE from #3870 does not error with Adapt.jl v4.1.1 locally.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2447316135:129,error,error,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2447316135,1,['error'],['error']
Availability,"I just checked the time evolution of the velocity field in this case. It seems to me that shear instability occurs when running the script on a GPU. However, the flow is steady when running the script on a CPU. Does CUDA introduce floating-point error that has x-dependence? Perhaps from the pressure solver?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772918559:246,error,error,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772918559,1,['error'],['error']
Availability,I just installed Oceananigans on a server that has GPUs and is running julia 1.1.1. When I try and update I get an error saying that the package name could no be resolved. ```; (v1.1) pkg> update Oceanigans; Updating registry at `~/.julia/registries/General`; Updating git-repo `https://github.com/JuliaRegistries/General.git`; ERROR: The following package names could not be resolved:; * Oceanigans (not found in project or manifest); Please specify by known `name=uuid`.; ```. Could this be because of the old version of julia? I have asked if they can update it but no idea if they will.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1468:115,error,error,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I just noticed this:. ```julia; julia> x = range(1, stop=10, step=1.0); 1.0:1.0:10.0. julia> y = reshape(x, 10, 1, 1); 10×1×1 reshape(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 10, 1, 1) with eltype Float64:; [:, :, 1] =; 1.0; 2.0; 3.0; 4.0; 5.0; 6.0; 7.0; 8.0; 9.0; 10.0. julia> typeof(y); Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}; ```. So the reshaped ranges do not convert to arrays / `collect` elements --- they are still ranges, with a wrapper (which means that we don't have to do anything special for GPU). I don't think there's any downside to reshape the ranges for convenience in this case. This will slightly simplify the `xnodes`, etc functions as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/348#issuecomment-520479364:657,down,downside,657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/348#issuecomment-520479364,1,['down'],['downside']
Availability,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:421,error,error,421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212,6,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"I just realized that the output writers docs page has errors relating to the purging of `FieldSlicer()`: https://clima.github.io/OceananigansDocumentation/stable/model_setup/output_writers/#Examples. ![image](https://user-images.githubusercontent.com/13205162/162648339-b7b30179-a9cc-4c05-ab34-9833e7603044.png). Now that `FieldSlicer()` doesn't exist anymore, part of that section may be out of date and needs to be re-written.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2427:54,error,errors,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2427,1,['error'],['errors']
Availability,"I just saw this issue and I know I'm late to the party but I thought I'd report that I've encountered this same error before in the past, and what solved the issue was exactly the solution that you guys found here. . It was long ago enough that the version of CUDA was different, so I'd say this probably isn't a bug in this CUDA version (as suggested at some point), rather it is some kind of compiler limitation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1091746195:112,error,error,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1091746195,1,['error'],['error']
Availability,"I just tested `DiscreteForcing` and I have almost the same slowdown (I completed 0.20% of the simulation, compared to 0.15% using `ContinuousForcing`). Here's what I used:. ```julia; Z(k) = @inbounds -grid.Lz + grid.Δz*(k-1/2); bottom_mask(k) = @inbounds exp(-(Z(k)+80)^2 / ((2*8)^2)). sponge_u_disc(i, j, k, grid, clock, model_fields) = @inbounds - rate * bottom_mask(k) * (model_fields.u[i, j, k] -0); sponge_v_disc(i, j, k, grid, clock, model_fields) = @inbounds - rate * bottom_mask(k) * (model_fields.v[i, j, k] -0); sponge_w_disc(i, j, k, grid, clock, model_fields) = @inbounds - rate * bottom_mask(k) * (model_fields.w[i, j, k] -0). forc_u = Forcing(sponge_u_disc, discrete_form=true); forc_v = Forcing(sponge_v_disc, discrete_form=true); forc_w = Forcing(sponge_w_disc, discrete_form=true). forcing = (u=forc_u, v=forc_v, w=forc_w); ```. I may have made rookie errors here as well since this is my first time using `DiscreteForcing`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875667870:869,error,errors,869,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875667870,1,['error'],['errors']
Availability,"I just tried running `validation/periodic_advection.jl` and see that it can't find WENO, which is I think because we removed the N-th order WENO code. Is it better to change it to WENO5 for the moment, since that's what we have?. ```; julia> include(""periodic_advection.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: UndefVarError: WENO not defined; Stacktrace:; [1] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; [2] include(::String) at ./client.jl:457; [3] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1271:350,ERROR,ERROR,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1271,1,['ERROR'],['ERROR']
Availability,"I just updated my packages and now I get an error .... UndefVarError: RectilinearGrid not defined; Stacktrace:; [1] top-level scope; @ In[8]:18; [2] eval; @ .\boot.jl:360 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base .\loading.jl:1116. ....with even the simples grid-defenition, e.g. ; ```; Nz = 24 # number of points in the vertical direction; Lz = 32 # domain depth; grid = RectilinearGrid(size = (32, 32, Nz),; x = (0, 64),; y = (0, 64),; z = (-64, 0)); ```; What am I doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2077:44,error,error,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2077,1,['error'],['error']
Availability,I just wanted to write down the details of the idea while it was in my head!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1452#issuecomment-796338616:23,down,down,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1452#issuecomment-796338616,1,['down'],['down']
Availability,"I know `MultipleForcings` is not exported and not tested so it's experimental. It seems like a useful feature so I tried using it but I ran into an error. Seems to be related to forcing function call arguments (or maybe incorrect regularization?) but I haven't been able to figure out the exact cause. Minimal working example:. ```julia; using Oceananigans. using Oceananigans.Forcings: MultipleForcings. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)). weird_forcing(λ, φ, z, t) = λ * φ + z; wonky_forcing(λ, φ, z, t) = z / (λ - φ). forcing1 = Forcing(weird_forcing); forcing2 = Forcing(wonky_forcing). forcing = (; u=MultipleForcings((forcing1, forcing2))). model = HydrostaticFreeSurfaceModel(; grid, forcing); ```. produces this error:. ```; ERROR: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::LatitudeLongitudeGrid{…}, ::@NamedTuple{…}, ::Nothing, ::Nothing). Closest candidates are:; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:8; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:4; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{Any}); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:1; ... Stacktrace:; [1] user_function_arguments; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:21 [inlined]; [2] ContinuousForcing; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/continuous_forcing.jl:137 [inlined]; [3] MultipleForcings; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/multiple_forcings.jl:32 [inlined]; [4] hydrostatic_free_surface_u_velocity_tendency; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tenden",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3736:148,error,error,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I know `PartialCellBottom` is unexported and therefore experimental but just opening an issue that it doesn't currently work on GPUs with `HydrostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBot",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:730,error,error,730,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I like it! The concept a function name that is something like `take_action_on(argument)` is typical, eg the function `fill!(array, value)` rather than `fill_value!(array, value)` (which is redundant for the reader). I liek the readability of `mask_immersed = 0`, as in ""mask immersed [grid cells with] = value"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528236585:189,redundant,redundant,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528236585,2,"['mask', 'redundant']","['mask', 'redundant']"
Availability,"I like the concept of `mask`, what about `immersed_mask_value=0`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1527564310:23,mask,mask,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1527564310,1,['mask'],['mask']
Availability,I liked the idea of keeping a list of deprecated functions that will be removed after a couple of releases.; At least users know what has happened and are ready for the change that will happen down the line.; I would go with the majority of the opinions on this one.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3490#issuecomment-1979056553:193,down,down,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490#issuecomment-1979056553,1,['down'],['down']
Availability,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:23,error,errors,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,I looked at the error and see this but don't pretend to know why this has happened. ``` ; Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19;   | Expression: all(test_model.timestepper.G⁻.w.data .≈ true_model.timestepper.G⁻.w.data);  ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921755394:16,error,error,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921755394,2,"['Checkpoint', 'error']","['Checkpointer', 'error']"
Availability,"I looked into MPData a long time ago and I recall it being very diffusive, so it might be the nature of the beast. It beats first order upwinding, which is also positive preserving, but not by much. The WENO schemes seem to be a more complicated way to ensure positivity more accurately but I remember you saying there were problems doing this properly in multiple dimensions. There is no perfect scheme for sure. This is a[ paper](https://core.ac.uk/download/pdf/82262632.pdf) that presents a positive preserving WENO scheme for population models. Example 3 is a 2D problem but the plots are only 1D. How similar is this to what you have tried already?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954815135:451,down,download,451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954815135,1,['down'],['download']
Availability,"I made a PR that adds a warning and changes the default for immersed boundary grids: https://github.com/CliMA/Oceananigans.jl/pull/3692. I don't think this issue can really be closed. There will continue to be errors on immersed boundary grid for non-separated pressure. Perhaps, once we have a new solver that we are confident reduces the chance of egregious errors, we can convert this to a discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2275788394:210,error,errors,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2275788394,2,['error'],['errors']
Availability,"I may be missing something, but in the first example of the documentation I get an error when creating the model. The prior example (the still ocean without anything) runs fine. Based on the docs I think at some point you changed the keyword from `arch` to `architecture` in the `Model` function and didn't change the documentation, but since I'm not familiar with Oceananigans I decided to post here instead of making a pull request. Cheers. Also, quick edit: the link to `rising_thermal_bubble_2d.jl` in the front page is broken.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449:83,error,error,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449,1,['error'],['error']
Availability,"I mean using no immersed boundary but a topography that does not reach the ocean surface.; You can do that by including in the model a bathymetry that is limited to a certain negative value. The immersed boundary and topography are two different things in the `SahllowWaterModel`. The immersed boundary is a mask of zeros and ones located in the grid, while the topography is an array (or function) passed to the model that enters the tendency calculation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2073287182:308,mask,mask,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2073287182,1,['mask'],['mask']
Availability,"I mean, we can move the docs to the caltech cluster but I think they will slow down a lot. This is a bottleneck for us right now so I don't think we can afford to move them... Notice that the out of memory error doesn't occur when we are using the GPU. We only use the GPU for the one quick start example --- and for nothing else. If we want to ""solve"" this, we can just get rid of the quick start example and then return to the previous behavior where we set `CUDA_VISIBLE_DEVICES=-1` for the docs build. Another solution is to hide / prevent tartarus users from using GPU 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356553645:79,down,down,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356553645,2,"['down', 'error']","['down', 'error']"
Availability,I missed the previous comments. This can occur if SpecialFunctions is available in the global environment. You need to delete the global environment and then test.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849301841:70,avail,available,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849301841,1,['avail'],['available']
Availability,"I noticed a file called `rigid_lid.jl` exists (https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/rigid_lid.jl) so I was curious whether `HydrostaticFreeSurfaceModel` can run with a free surface, presumably by passing `free_surface = nothing`. It does error (see MWE below) but with a couple of extra function definitions (see far below) it seems to time step. Are these fixes enough for a working rigid lid? If not, does it make sense to remove the `rigid_lid.jl` file?. Note: The documentation also mentions a rigid lid here: https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/elliptic_solvers/#Rigid-lid-pressure-operator. ---. Minimal working example to reproduce the error:. ```julia; using Oceananigans. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)); model = HydrostaticFreeSurfaceModel(; grid, free_surface=nothing); time_step!(model, 1); ```. Error:. ```; ERROR: MethodError: no method matching materialize_free_surface(::Nothing, ::@NamedTuple{…}, ::LatitudeLongitudeGrid{…}). Closest candidates are:; materialize_free_surface(::ExplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl:32; materialize_free_surface(::SplitExplicitFreeSurface, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:114; materialize_free_surface(::ImplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:93; ... Stacktrace:; [1] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::Nothing, tracers::Nothing, forcing::@",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3735:328,error,error,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735,2,['error'],['error']
Availability,I noticed that as well but it seems that those errors are present in the latest commit in master (I don't seem to have touched anything related):. https://buildkite.com/clima/oceananigans/builds/4868#67294627-d75d-4346-8392-c67b358b5c3c,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001745319:47,error,errors,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2128#issuecomment-1001745319,1,['error'],['errors']
Availability,"I noticed there was a problem with the halos so I hard coded it to be `(3,3)`, which is appropriate for the default advection scheme. Now the example seems to yield `NaNs`, which is another mystery. Maybe the halos are not set correctly?. ```; Time stepping ShallowWaterModel: Time stepping ShallowWaterModel: Error During Test at Error During Test at Time stepping ShallowWaterModel: /storage7/buildkite-agent/builds/tartarus-mit-edu-11/clima/oceananigans/test/test_distributed_models.jl:496; --; &nbsp; | Got exception outside of a @test; &nbsp; | Time stepping ShallowWaterModel: time = 1.9999999999999998, iteration = 2: NaN found in field uh. Aborting simulation.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] error_if_nan_in_field at /storage7/buildkite-agent/builds/tartarus-mit-edu-11/clima/oceananigans/src/Diagnostics/nan_checker.jl:22 [inlined]; &nbsp; | [3] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:uh,),Tuple{Field{Face,Center,Center,CPU,OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{HaloCommunication,Oceananigans.Distributed.HaloCommunicationRanks{Int64,Int64}},BoundaryCondition{HaloCommunication,Oceananigans.Distributed.HaloCommunicationRanks{Int64,Int64}}},CoordinateBoundaryConditions{Nothing,Nothing}}}}}}}, ::ShallowWaterModel{RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},MultiCPU{RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843222534:310,Error,Error,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843222534,4,"['Error', 'error']","['Error', 'error']"
Availability,"I noticed this change last week but I thought it was intentional. I don't have a strong opinion here. . If we're trying to cater to more inexperienced users (of which Oceananigans will probably attract a lot of, since it's always portrayed as user-friendly) then it might make sense to try and guard against this somehow (since the errors you get when trying to do stuff with timedeltas that can't be done aren't very useful). . Otherwise I'd say it's up to the user to deal with this, since on the Oceananigans end the change was (imho) for the better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-790717920:332,error,errors,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-790717920,2,['error'],['errors']
Availability,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2840:237,avail,available,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840,3,"['ERROR', 'avail']","['ERROR', 'available']"
Availability,"I ran the `benchmark_incompressible_model.jl` script on the master branch (twice) and this branch (also twice), and ; actually see a tiny bit of a speedup, maybe only significant for larger CPU models though. Hard to say whether it's noise, it might be more due to other processes causing small variations in runtime. To me I don't think this PR slows down or speeds up the code, but it simplifies and improves the time stepping code so it should be merged. There's a few more memory allocations now (due to extra kernel launches) but this shouldn't affect performance. # System info. ```; Oceananigans v0.44.1; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. # Master branch; ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 5.399 ms │ 5.668 ms │ 5.758 ms │ 7.186 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 64 │ 36.710 ms │ 37.583 ms │ 37.974 ms │ 41.678 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 128 │ 312.780 ms │ 313.477 ms │ 313.622 ms │ 314.726 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 256 │ 2.802 s │ 2.819 s │ 2.819 s │ 2.836 s │ 242.42 KiB │ 1876 │; │ CPU │ Float64 │ 32 │ 5.828 ms │ 6.049 ms │ 6.157 ms │ 7.044 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 64 │ 43.084 ms │ 43.619 ms │ 43.650 ms │ 44.363 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 128 │ 365.051 ms │ 365.317 ms │ 365.475 ms │ 366.288 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 256 │ 3.602 s │ 3.653 s │ 3.653 s │ 3.703 s │ 293.44 KiB │ 1876 │; │ GPU │ Float32 │ 32 │ 2.797 ms │ 2.870 ms ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736692263:352,down,down,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736692263,1,['down'],['down']
Availability,"I ran this using the latest version and I got no error. @Sumanshekhar17 can you please confirm the version? If the version is 0.58.2, can you please post the full code?. I got the code below from a slack message and it ran with no problems:. ```julia; using Random; using Printf; using Oceananigans; using Oceananigans.Units: minute, minutes, hour; Lz=32; Nz=32; S = 1.1 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-34) - 1) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (32, 32, 32), ; architecture = CPU(),; x = (0,64),; y = (0,64),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes); buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=2e-4, β=8e-4)); Qʰ = 200 # W m⁻², surface _heat_ flux; ρₒ = 1026 # kg m⁻³, average density at the surface of the world ocean; cᴾ = 3991 # J K⁻¹ s⁻¹, typical heat capacity for seawater; Qᵀ = Qʰ / (ρₒ * cᴾ) # K m⁻¹ s⁻¹, surface _temperature_ flux; dTdz = 0.01 # K m⁻¹; T_bcs = TracerBoundaryConditions(computational_grid,; top = FluxBoundaryCondition(Qᵀ),; bottom = GradientBoundaryCondition(dTdz)); u₁₀ = 10 # m s⁻¹, average wind velocity 10 meters above the ocean; cᴰ = 2.5e-3 # dimensionless drag coefficient; ρₐ = 1.225 # kg m⁻³, average density of air at sea-level; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) # m² s⁻²; u_bcs = UVelocityBoundaryConditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351:49,error,error,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351,1,['error'],['error']
Availability,"I ran through the code step by step after changing the grid as per your suggestion, this time, it is this line of code that threw the boundary_condition_nothing error:. https://github.com/CliMA/Oceananigans.jl/blob/92791a962c9096746301cdb888a3050e32c4a58b/src/Fields/field_tuples.jl#L73. leads to this line:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Utils/kernel_launching.jl#L97. which then throws the error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622235678:161,error,error,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622235678,2,['error'],['error']
Availability,"I realize that https://github.com/CliMA/Oceananigans.jl/issues/3609 exists, but I think this is a different issue. The following MWE, which tries to advect `LagrangianParticle`s over an `ImmersedGrid` fails with this error:. ```; ERROR: LoadError: MethodError: no method matching cpu__advect_particles!(::KernelAbstractions.CompilerMetadata{…}, ::StructArrays.StructVector{…}, ::Float64, ::ImmersedBoundaryGrid{…}, ::Int64, ::@NamedTuple{…}). Closest candidates are:; cpu__advect_particles!(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractUnderlyingGrid, ::Any, ::Any); @ Oceananigans none:0. Stacktrace:; [1] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:144; [2] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:111; [3] (::KernelAbstractions.Kernel{…})(::StructArrays.StructVector{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:46; [4] (::KernelAbstractions.Kernel{…})(::StructArrays.StructVector{…}, ::Vararg{…}); ```. This is the MWE:. ```julia; using Oceananigans. grid_base = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)); GFB = GridFittedBottom((x, y) -> -1/2); grid = ImmersedBoundaryGrid(grid_base, GFB). n_particles = 3; x₀ = rand(n_particles); y₀ = rand(n_particles); z₀ = .-rand(n_particles). lagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀). model = NonhydrostaticModel(; grid, particles=lagrangian_particles); time_step!(model, 1); ```. I'm a bit confused, because, while the function `",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3761:217,error,error,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3761,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I realized I can see from the error message that the grid is `Bounded` in all directions. I've never used this feature but I think you aren't specifying the tracked fields correctly. It needs to be something like. ```julia; # Define tracked fields as a NamedTuple; tracked_fields = (; T=tracers.T); ```. In other words, the values of the NamedTuple are themselves fields. So you have to build `tracers` before constructing the model. Something like this may work:. ```julia; tracers = (T=CenterField(grid), S=CenterField(grid)). # Define tracked fields as a NamedTuple; tracked_fields = (; T=tracers.T). model = NonhydrostaticModel(; grid, tracers, ...); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609#issuecomment-2136262060:30,error,error,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609#issuecomment-2136262060,1,['error'],['error']
Availability,"I really would rather emit a warning here rather than an error because I don't think an error is appropriate when input is legitimate (which was the case for what `FieldTimeSeries` did, prior to this PR). @tomchor @simone-silvestri is that ok with you two?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2589#issuecomment-1142606347:57,error,error,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2589#issuecomment-1142606347,2,['error'],['error']
Availability,"I recently received the error. ```; ERROR: LoadError: ArgumentError: The grid halo (3, 3, 3) must be at least equal to (4, 4, 4). Note that an ImmersedBoundaryGrid requires an extra halo point.; ```. It's not clear what ""extra halo point"" means. I think this error needs to be a little bit more specific like, ""Note that an ImmersedBoundaryGrid requires an extra halo point in all directions compared to a non-immersed grid.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2983:24,error,error,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2983,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:53,error,error,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,7,['error'],['error']
Availability,"I replicate this error with:; ```; julia> z_faces(k) = 100 * ((k/Nz) ^ 2 - 2); julia> grid = RectilinearGrid(size = (10, 10, Nz), x = (0, 20), y = (0, 20), z = z_faces); julia> model = NonhydrostaticModel(; grid, tracers=:P); julia> P(x, y, z) = z; julia> set!(model; P); ```. e.g.; ```; julia> interpolate(model.tracers.P, 10.0, 10.0, -100.0); -96.92378328741964; ````; Without the fix or `-100.0` with the fix",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2911#issuecomment-1425633946:17,error,error,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2911#issuecomment-1425633946,1,['error'],['error']
Availability,"I report here some issues connected to updating to Oceananigans 0.80.0 . ```; ERROR: LoadError: MethodError: no method matching min_Δx(::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:78,ERROR,ERROR,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['ERROR'],['ERROR']
Availability,I restarted it an error was insisting... I reopened #2922. I'll make the timestep even smaller.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2944#issuecomment-1444033136:18,error,error,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2944#issuecomment-1444033136,1,['error'],['error']
Availability,I restarted the Buildkite build since the cpu distributed tests failed due to some random ELF error then the build finished and cleaned up the Julia depot so it was too late to restart the cpu distributed tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-843499929:94,error,error,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-843499929,1,['error'],['error']
Availability,"I run https://github.com/CliMA/Oceananigans.jl/blob/master/examples/two_dimensional_turbulence.jl with success. but when trying to adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656:299,error,error,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656,1,['error'],['error']
Availability,"I saw there's a problem with making the documentation, see below. This doesn't seem directly relelvant to what was changed here though?. ```. ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:266 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:265 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495:142,ERROR,ERROR,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495,6,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"I see a few things to improve with the grid right now. 1. We need to add some kind of type information that indicates whether a given dimension is 'flat'. One way to do this could simply be to add the grid sizes in each dimension as parameters in the abstract type `Grid`, aka:. ```julia; abstract type Grid{T, Nx, Ny, Nz} end. struct RegularCartesianGrid{T, R, Nx, Ny, Nz} <: Grid{T, Nx, Ny, Nz}; ...; end; ```. Functions can then dispatch when one of `Nx`, etc is `1` (including halo-filling functions, which I think may fail when the size of the halo is 0). Another option is to use flags for each dimension rather than the actual size of the grid. In my opinion using the size makes the most sense. Using the actual size could have future advantages; for example, if some optimizations are possible when `Nz=2`. It is also nice to see the size of the grid from the type signature. A disadvantage is that we then could not have `mutable` grid types, but I'm not sure we want that. 2. There is a lot of redundant information in the `RegularCartesianGrid` struct: cell areas, volumes, total number of grid points, etc. I think it would be better --- meaning that our code would be shorter, easier to read, easier to maintain, easier to reason about (since storing them implies they *cannot* be computed, which is incorrect) and more computationally efficient --- to add functions that compute these quantities on the fly, rather than storing them in memory. Related: #287.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/330:1005,redundant,redundant,1005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330,1,['redundant'],['redundant']
Availability,I see it here being exported:. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/OutputWriters.jl#L5. but nowhere else. I believe that currently this happens via. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/checkpointer.jl#L201. Right?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3462:323,checkpoint,checkpointer,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3462,1,['checkpoint'],['checkpointer']
Availability,"I see it like this: Tartarus is a shared system with very small limitations so it is quite difficult to prevent people from running on GPU 0 (I do not think we have the ability to implement a scheduler), so there is more possibility to incur in downtime due to users running on GPU 0. The Caltech cluster might be slower but is much more reliable because it has a professionally maintained slurm scheduler that prevents these types of problems. I tend to prefer having reliability over a modest speedup for these cases, but I am ok with other solutions. One solution would be to routinely kill the jobs on tartarus running on GPU 0 without warning, that would be possible only for people with access on tartarus though. I am ok following that route (I just killed a couple of jobs now 😅). It would be nice to find a more permanent solution though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587:245,downtime,downtime,245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587,3,"['downtime', 'reliab']","['downtime', 'reliability', 'reliable']"
Availability,"I see that one of the errors is `UndefVarError: device_event not defined`, which I suppose means we need to load it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890011382:22,error,errors,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890011382,1,['error'],['errors']
Availability,"I see the error you got, its. ```julia; ERROR: LoadError: MethodError: no method matching AdvectiveForcing(::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true}; w=-1); Closest candidates are:; AdvectiveForcing(::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; ```. This error means that we do indeed have the name `AdvectiveForcing`, but that the function signature is wrong. The reason here is a bug in the source code (missing semicolon: https://github.com/CliMA/Oceananigans.jl/pull/2389/commits/b30ce7ab846c713663949c3bb6ee8d1e2ec740b0).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537:10,error,error,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. `NetCDFOutputWriter`, `JLD2OutputWriter`, and `Checkpointer`. Or do you plan to make a new structure that handles all of them? . I agree that keeping a simple way to create `Checkpointer`s and `OutputWriter`s should be a priority, particularly in the case when the user needs to restart the simulation multiple times in an HPC, keeping in mind manageable file sizes, wall times, and chunks. Currently, this can be handle by the user creating unique output folders or changing the name of the output file for each resubmission of the simulation. Unfortunately, this makes more complex the processing of the output. I think the best solution with outputs and checkpoints will be to automatically append to the last output file from the previous simulation resubmission (currently not supported). I agree that the initialisation of the writer should not create a file, I find that quite confusing. I believe it will be simple to change by only executting the `initialize_nc_file!` and `initialize_jld2_file!` once the model is running, instead of two times, once the writers are initialised and in run time (`write_output!`). . Despite the implementation of this, I still see value in having a flag `overwrite_existing`, likely set up to `false` as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. . Regarding my changes in this PR, the function `is_output_splitted!` may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283:199,Checkpoint,Checkpointer,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283,4,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoints']"
Availability,I see there is a failed test but from looking at the error it seems to be due to exceeding a disk quota. I will proceed to merge as this code is not actually used in any of the tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1759#issuecomment-866919955:53,error,error,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1759#issuecomment-866919955,1,['error'],['error']
Availability,"I seem to have a problem with the GPU cubed sphere tests; ```; ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.;   | Run Julia on debug level 2 for device stack traces.; ```; When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875:63,ERROR,ERROR,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I set up my netcdf writer as follows:. `fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w,""T"" => model.tracers.T)`; `my_writer = NetCDFOutputWriter(model, fields, filename=""data/turb_box_test.nc"", time_interval=60)`; `simulation.output_writers[:field_writer] = my_writer`. and got the following error:. NetCDF error: Variable 'time' not found in file <unknown> (NetCDF error code: -33)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/862:337,error,error,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/862,3,['error'],['error']
Availability,"I started down that road, but had to install some packages to get the script to run and haven't returned to it yet! I'm confused at how running the exact same code that you ran will uncover an issue. Isn't it more likely that there is a bug in the script, than some issue with computers / software versions?. An efficient path forward might be to write a test that fails due to this error? Then submit a PR that adds the failing test, and we can collaborate on getting the test to pass. We'd have to do this anyways; and writing a test is a good way to come up with a minimal example that we could use to isolate the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659:10,down,down,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817957659,2,"['down', 'error']","['down', 'error']"
Availability,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455:270,error,errors,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455,7,"['ERROR', 'Error', 'error', 'failure']","['ERROR', 'Error', 'error', 'errors', 'failure']"
Availability,"I stumbled on this trying to save the free surface for a `HydrostaticFreeSurfaceModel`. Here's an example:. ```Julia; using Oceananigans. model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (5, 5, 4), x = (-1e3, 1e3), y = (-1e3, 1e3), z = (-1e3, 0))). ηᵢ(x, y, z) = 1 * exp(-(x^2 + y^2) / 2 * (2e2)^2). set!(model, η = ηᵢ). simulation = Simulation(model, Δt=100, stop_time = 1000). simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; filename = ""surface"",; overwrite_existing = true); ```. ```Julia; ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:245; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:312; [6] #Field#13; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [7] Field; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [8] construct_output(user_output::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260:583,ERROR,ERROR,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260,1,['ERROR'],['ERROR']
Availability,"I suspect in this particular case the failures might be related to https://github.com/CliMA/Oceananigans.jl/issues/1179 . I agree it's irrelevant to this PR so I'll go ahead and merge. Looking at the build log it looks like it's a small number of grid points that are outside the required tolerance. ```; [2021/02/22 10:57:39.093] INFO Testing oceanic large eddy simulation regression [GPU, SmagorinskyLilly, regular grid]; [2021/02/22 10:58:14.536] INFO Δu: min=-5.666049e-10, max=+3.671358e-10, mean=-2.983144e-20, absmean=+2.668769e-12, std=+2.226909e-11 (4069/4096 matching grid points); [2021/02/22 10:58:14.552] INFO Δv: min=-5.253857e-10, max=+3.415200e-10, mean=+3.250489e-20, absmean=+2.216612e-12, std=+1.693819e-11 (4087/4096 matching grid points); [2021/02/22 10:58:14.553] INFO Δw: min=-8.810720e-10, max=+3.828218e-10, mean=+1.396074e-21, absmean=+1.776769e-12, std=+1.811893e-11 (4030/4096 matching grid points); [2021/02/22 10:58:14.554] INFO ΔT: min=-3.171365e-10, max=+1.584819e-09, mean=+1.486753e-12, absmean=+2.286620e-12, std=+4.048190e-11 (4096/4096 matching grid points); [2021/02/22 10:58:14.555] INFO ΔS: min=-5.826450e-13, max=+5.613288e-13, mean=-6.418477e-17, absmean=+2.742598e-15, std=+1.726765e-14 (4096/4096 matching grid points); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1395#issuecomment-783500631:38,failure,failures,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395#issuecomment-783500631,2,"['failure', 'toler']","['failures', 'tolerance']"
Availability,"I suspect that the docstring for the `BatchedTridiagonalSolver`,. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L17-L23. is incorrect. The docstring suggests that `c` (the upper diagonal) is indexed from `k=2` to `k=Nz`; however it is actually indexed from `k=1` to `k=Nz-1`:. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L82-L84. In the above code the `c` index is downshifted by 1, so that, if I am interpreting the algorithm correctly, the docstring should read:. ```; b(i, j, 1)ϕ(i, j, 1) + c(i, j, 1)ϕ(i, j, 2) = f(i, j, 1), k = 1; a(i, j, k-1)ϕ(i, j, k-1) + b(i, j, k)ϕ(i, j, k) + c(i, j, k)ϕ(i, j, k+1) = f(i, j, k), k = 2, ..., N-1; a(i, j, N-1)ϕ(i, j, N-1) + b(i, j, N)ϕ(i, j, N) = f(i, j, N), k = N; ```. This is also consistent with the tests, which use arrays of length `Nz-1` for both `a` and `c`. If `c` were indexed in the way implied by the docstring, the `c` array would either have to be length `Nz` or have a `k` index that's offset by 1. The indexing convention that's _implemented_ (rather than the one implied by the docstring) matches constructor interface for the matrix type `Tridiagonal`, which is convenient for testing against solutions produced by julia's built-in `\` operator. However, it means that function inputs need to shift indices by 1 compared to what most would consider ""intuitive"" (that the index of the coefficient `c` matches the index of the solution element `ϕ` that it multiplies).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1643:533,down,downshifted,533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1643,1,['down'],['downshifted']
Availability,I suspect that the problem is the grid inflation which happens in the nonhydrostatic model. You need 4 halos because it's an immersed boundary so the model inflates the grid automatically and apparently that gives out of boundaries with the advection. If you build the model from correct sized halos thus bypassing inflation the problem disappears. . I ll put a little more effort in the inflation. We can also just think about spitting an error as we do for the `HydrostaticFreeSurfaceModel`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179780897:440,error,error,440,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179780897,1,['error'],['error']
Availability,"I tested it and can confirm if the line with `@warn` is commented out, the code runs without erroring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1910861106:93,error,erroring,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1910861106,1,['error'],['erroring']
Availability,"I tested the simulation without picking up a checkpoint (running only the first simulation from 0-6s), but the error still unexpectedly persists. It seems the issue might be related to a bug in `AveragedTimeInterval` and maybe not necessarily just related to the checkpoint. (Hence I change the name of this issue.); <img width=""589"" alt=""image"" src=""https://github.com/user-attachments/assets/c8ef448a-93c0-4e62-9bb8-dd098d5d65df"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2259395775:45,checkpoint,checkpoint,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2259395775,3,"['checkpoint', 'error']","['checkpoint', 'error']"
Availability,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:109,checkpoint,checkpointing,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924,14,"['checkpoint', 'down']","['checkpoint', 'checkpointer', 'checkpointing', 'downside']"
Availability,I think GPU simulation and GPU regression test failures might have been intermittent (perhaps due to #1179?) so I restarted the build just in case.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1578#issuecomment-819500253:47,failure,failures,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1578#issuecomment-819500253,1,['failure'],['failures']
Availability,"I think I am encountering a bug using `ValueBoundaryCondition`s with `ImmersedBoundaryGrid`s. `FluxBoundaryCondition`s do not trigger this, and based on the error message it looks like it has to do with how the halos are treated (in `src/BoundaryConditions/fill_halo_regions.jl`)? See a MWE below. I am running the latest version of `Oceananigans` (0.73.8). ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; using Oceananigans.Units; using Printf. Nx = 60; Nz = 18; Lx = 1200kilometers; Lz = 1800meters; Δt = 30minutes; taux = -0.5 # [Pa]; ρ₀ = 1026 # [kg m⁻³]. stop_time = 1years; save_interval = 1days; wind_time_ramp = 5days; lateral_diffusive_time = 1days; αT = 2e-4; taux = taux/ρ₀. buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=αT, haline_contraction=0.0)); momentum_advection = WENO5(); tracer_advection = WENO5(); tracers = (:T, :S). grid = RectilinearGrid(size = (Nx, Nx, Nz),; x = (0, Lx),; y = (0, Lx),; z = (-Lz, 0),; halo = (3, 3, 3),; topology = (Bounded, Bounded, Bounded)). free_surface = ImplicitFreeSurface(solver_method=:HeptadiagonalIterativeSolver). # Rough topography.; ht = 100meters; Lt = 500kilometers; kt = 2π/Lt; topography(x, y) = ht*cos.(kt*x).*cos.(kt*y) .- Lz; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(topography)). coriolis = BetaPlane(latitude=45); κh = grid.Δxᶜᵃᵃ^2 / lateral_diffusive_time; νh = κh. κz = 0; νz = κz; horizontal_closure = HorizontalScalarDiffusivity(ν=νh, κ=κh); vertical_closure = VerticalScalarDiffusivity(ν=νz, κ=κz); closure = (vertical_closure, horizontal_closure). wind_stress(x, y, t) = - taux * cos(2π * y / (2Lx)) * tanh(t/wind_time_ramp); no_slip = ValueBoundaryCondition(0); no_flux = FluxBoundaryCondition(0). # No bottom drag (free-slip at the bottom).; boundary_conditions = (;; u = FieldBoundaryConditions(top=FluxBoundaryCondition(wind_stress), south=no_slip, north=no_slip),; v = FieldBoundaryConditions(east=no_slip, west=n",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2430:157,error,error,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430,1,['error'],['error']
Availability,"I think I have a good potential solution --- let me know what you think. In short, we can add `previous_Δt` to all time-steppers. We already have this for `QuasiAdamsBashforth2`:. https://github.com/CliMA/Oceananigans.jl/blob/abbb7a9f79d3ee2d8b5ba70f5f87da3a7759d2b5/src/TimeSteppers/quasi_adams_bashforth_2.jl#L8. The idea is that the time-steppers are the right place for this information, because we will always have the time-steppers at hand when we take a time-step (because we use the tendencies). Thus it is appropriate to store the `Δt` that was used directly after that step. (Which of course we already do for AB2). https://github.com/CliMA/Oceananigans.jl/blob/abbb7a9f79d3ee2d8b5ba70f5f87da3a7759d2b5/src/TimeSteppers/quasi_adams_bashforth_2.jl#L89. Then the time-step will be available in `update_state!`. What do you think @jagoosw ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1973708929:789,avail,available,789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1973708929,1,['avail'],['available']
Availability,"I think I understand how particles cause an out-of-bounds error when the velocity is large. However, the difference between CPU and GPU simulations is another issue. Let me see whether I can reproduce this issue with a smaller `CFL`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773039874:58,error,error,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773039874,1,['error'],['error']
Availability,"I think I'm envisioning somehow a split in subsections where the equations solved by each model (`IncompressibleModels`, `HydrostaticFreeSurfaceModels`, and `ShallowWaterModels`) are written down. What do you think?. @glwagner, @ali-ramadhan, @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1690#issuecomment-847424732:191,down,down,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1690#issuecomment-847424732,1,['down'],['down']
Availability,"I think for Oceananigans it may not matter much, but it seems to matter a lot for the atmosphere so maybe it would be good to match up with the atmosphere so we can share operators. Here's @thabbott's argument for making z the fast index for an atmospheric LES model (taken from https://github.com/thabbott/JULES.jl/pull/16):; > I think that there are three strong argument to be made in favor of making ``z`` the fast index for this model:; >; > 1. Radiative transfer operates in columns; > 2. Rain falls downward relative to the air it's embedded in; > 3. Vertical momentum is solved implicitly within columns on the acoustic time step; > ; > This means that these three calculations can operate completely independently over different columns and (at least for calculations using a CPU) it's more efficient to store variables in the same column close to each other in memory. I don't think we have to change the function signatures relative to Oceananigans to make ``z`` the fast index, though---we just have to change the indexing order in ``differences.jl`` and ``interpolation.jl``. I think @vchuravy said that this might change with GPUs and/or shared memory, so maybe it's not super clear whether the change is worth making. Although for CPUs it will probably help a lot.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470:506,down,downward,506,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470,1,['down'],['downward']
Availability,"I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users. I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025968193:210,mainten,maintenance,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025968193,1,['mainten'],['maintenance']
Availability,"I think high performance at 25 km resolution will prove difficult also because we are effectively dividing our kernel size by 1/6 (unless we figure out how to coalesce kernels across panels). On a large GPU this will lead to performance degredation at 25 km resolution, because even a single-panel kernel covering the whole globe at 25 km barely saturates one GPU. Recovering that performance for multi-region simulations may be difficult, especially in the face of the added complexity of distribution across multiple GPUs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187:365,Recover,Recovering,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187,1,['Recover'],['Recovering']
Availability,"I think it might make sense to serialize grids in JLD2 files with `CPU` architecture by default; this way they can be loaded on systems without a GPU. . The downside is that users with GPUs would have to write. ```julia; cpu_grid = file[""serialized/grid""]; grid = on_architecture(GPU(), cpu_grid); ```. to load their grid on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2179:157,down,downside,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179,1,['down'],['downside']
Availability,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:109,error,error,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873,1,['error'],['error']
Availability,"I think it would be to good to export the entire user interface at the top-level module so it's all fully available to the user with just `using Oceananigans`. Some thoughts:; 1. Would make it much easier to set up scripts. Many times I've found that users add something to their scripts, e.g. `AveragedField` or a `NetCDFOutputWriter`, and forget to add `using Oceananigans.Fields` or `using Oceananigans.OutputWriters`. It can be hard for a user to figure out exactly which import statement they're missing without consulting the docs (this could be considered a pain point). 2. Our current approach is not consistent either. The top level `Oceananigans` module exports a lot of the user interface but not all of it, so users are expected to import submodules but the submodules themselves export way more than just the user interface including functions that are not part of the user interface (example: https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/Fields.jl). 3. I think we should export the entire user-interface at the top-level and be mindful of not exporting too much. Everything that gets exported at the top-level requires a docstring (this would allow us to enable strict checking for exported docstrings in `makedocs`: https://github.com/CliMA/Oceananigans.jl/blob/9026438047fe3e5d4805edcebe42560268dc65fb/docs/make.jl#L150).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1132:106,avail,available,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1132,1,['avail'],['available']
Availability,"I think it's a plotting issue. We are filling up the immersed boundaries with NaN and, apparently, we cannot plot NaNs anymore? The error says:; ```julia; ERROR: LoadError: On worker 2:;   | Looking up a non-finite or NaN value in a colormap is undefined.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3836#issuecomment-2407601775:132,error,error,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3836#issuecomment-2407601775,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,I think it's helpful to use different names; we're seeing the benefit of `ᵃ` now because much of the code that doesn't generalize to curvilinear grids will fortunately error rather than running but producing bogus results.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799764461:168,error,error,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799764461,1,['error'],['error']
Availability,"I think it's important to have the word `immersed` somewhere in the flag name otherwise it might not be clear that we're masking. I vote for `immersed _mask_value` flag. It's kinda verbose, but imo 100% clear.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528069200:121,mask,masking,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528069200,2,['mask'],['masking']
Availability,"I think it's more intuitive if `gravitational_direction` is a unit vector where `|g|=1`, no?. > I guess we thought this PR was missing a test? I'm happy to merge it as long as the 45 degree slanted rising thermal bubble looks good and we can worry about adding a more rigorous test in a future PR?. I ran the bubble case and it looked okay to me. I don't know if that's already good enough for merging this PR. I'd recomment merging once we get the more general tilt for buoyancy (if you agree that that's important.). My idea was to start a more rigorous test using a tilted BBL example from the literature this weekend. I was thinking this could eventually become a docs example to show. - Tilted gravity; - Monin-Obukhov similarity wall model; - Maybe stretched grid if it's done by then?; - NetCDF outputs (I think none of the current examples use NetCDF). I ended up not doing it because the papers I went through used both buoyancy as a tracer (not implement yet in this PR; hence my comment here) and tilt the domain in the `x` direction, so I'd need an `x` component of coriolis (hence my issue https://github.com/CliMA/Oceananigans.jl/issues/1372). I know these things are easy to circumvent with the available tools (i.e. using temperature to get the proper buoyancy and rotating the domain so that the tilt is in `y`, not `x`), but I thought it was best to make a thorough test once as these tools were in place already.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746:1210,avail,available,1210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746,2,['avail'],['available']
Availability,"I think it's probably a good idea to (cautiously) add diagnostics that are important yet difficult to write, such as this one. Note that this would be the first!. As a historical note, we have resisted adding diagnostics to the code base so far because we believed that a more generic solution would make it ""easy"" for users to define their own diagnostics (eg, as simple as writing the mathematical expression), and because long lists of diagnostics impose a maintenance burden. But I think there are some examples (such as APE) for which we probably can't define simply via abstractions like those provided by AbstractOperations. And as the code becomes more stable (and we have more contributors), maintaining a list of difficult-to-code but commonly-used diagnostics is more feasible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758710250:460,mainten,maintenance,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758710250,2,['mainten'],['maintenance']
Availability,I think it's time to have something there. At lease a docs page that writes down the equations solved and the state variables... cc @francispoulin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1460:76,down,down,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460,1,['down'],['down']
Availability,I think now only some output writer test errors are only pending. Will try to sort them out today.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825983782:41,error,errors,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825983782,1,['error'],['errors']
Availability,"I think pressure gradient errors would still creep in to such a problem, but maybe using this technique with pressure gradients ""turned off"" (one way or another, perhaps using `ShallowWaterModel`) can produce a viable validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731603:26,error,errors,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731603,1,['error'],['errors']
Availability,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:310,avail,available,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360,2,['avail'],['available']
Availability,I think that error stems from here:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L65. which probably means that `solver.eigenvalues` are not being set up correctly for whatever reason. Those are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L25-L27. and then (I think) supposed to be partitioned rank-wise with this piece of code:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L38-L44. so maybe the size is wrong.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1066192924:13,error,error,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1066192924,1,['error'],['error']
Availability,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3048:1646,down,down,1646,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048,1,['down'],['down']
Availability,I think that was the test I added to make sure that this new error worked right,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325135039:61,error,error,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325135039,1,['error'],['error']
Availability,"I think that's a decent idea and also might help de-complexify some of the code associated with buoyancy models. We would have to refactor our equations of state a bit but that's not hard. The main question is what to do about `gravitational_acceleration`. Right now, `gravitational_acceleration` is a parameter of `SeawaterBuoyancy`:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/BuoyancyModels/seawater_buoyancy.jl#L10-L15. because if you're using `BuoyancyTracer()`, there's no gravitational acceleration parameter (since its absorbed into the definition of buoyancy). However, we could move `gravitational_acceleration` into `Buoyancy`, and then set it to `nothing` when we are using `BuoyancyTracer`. The downside of this approach is that people can then change this parameter when using `BuoyancyTracer`, even though such changes would have no dynamical effect on the model (we've tried to limit such possibility for confusion otherwise...). It could be reasonable to move `constant_temperature` and `constant_salinity` into `equation_of_state`. `SeawaterBuoyancy` is then a type union of buoyancies with either `LinearEquationOfState` or something else from `SeawaterPolynomials.jl`. PS the default values for coefficients here:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/BuoyancyModels/linear_equation_of_state.jl#L25. should probably be 0?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-951090677:756,down,downside,756,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-951090677,1,['down'],['downside']
Availability,"I think that's a good one. So we have:. * `immersed_value = 0`; * `immersed_mask_value = 0`; * `mask_immersed = 0`; * `fill_immersed = 0`. Would even just `mask = 0` be sufficient? I've also been annoyed about ""mask_immersed_field"" and wondered whether simply `mask!(field)` would be clear and a little cleaner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1527950210:156,mask,mask,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1527950210,4,['mask'],['mask']
Availability,"I think that's right --- it's essentially a matter of applying the transformation `h -> h + b` (where `b` is bathymetry` in the governing equations here:. https://clima.github.io/OceananigansDocumentation/stable/physics/shallow_water_model/. ?. I think this might be achieved two ways:. 1. Add new terms to the tendencies; or; 2. Define the `AbstractOperation`. ```julia; total_depth = solution.h + bathymetry; ```. in the model constructor and add this property to `ShallowWaterModel`. Then, where appropriate in the tendency kernel functions, use `total_depth` rather than `solution.h`. I think the two appropriate places are the pressure gradient term and the mass flux term in the continuity equation. Method 2 might actually be numerically different than method 1 when using WENO advection for the mass flux (eg, we are interpolating a different function with different smoothness properties)... I'm not sure which is better (but something tells me that method 2 might be better?. As for how to handle the bathymetry I think something similar to what we do for immersed boundaries would be nice:. https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl#L43-L51. eg, in the constructor for `ShallowWaterModel`, something like. ```julia; if !isnothing(bathymetry) # user has provided non-default bathymetry; bathymetry_field = Field{Center, Center, Nothing}(grid); set!(bathymetry_field, bathymetry) # works for functions and arrays; total_depth = solution.h + bathymetry_field; else # there's no bathymetry; total_depth = solution.h; end. # Later, make sure to use `bathymetry_field` when instantiating `ShallowWaterModel`.; ```. @apaloczy that would be pretty awesome if you want to tackle this! Happy to provide help along the way if you open a PR when you start down this road. I can also help with docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1114345110:1858,down,down,1858,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1114345110,1,['down'],['down']
Availability,"I think the best bet is to ensure that all derivatives inside the immersed boundary are zero. . To do that we need to have fully 3D derivatives (i.e. no more `∂xᶜᵃᵃ`, `∂yᵃᶜᵃ` and `∂zᵃᵃᶜ`) so that we can mask them with the `solid_interface` function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027435287:203,mask,mask,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027435287,1,['mask'],['mask']
Availability,I think the call to `versioninfo` here:. https://github.com/CliMA/Oceananigans.jl/blob/b4e217244f1d594ce2854260e4dfa5c97156e162/.buildkite/pipeline.yml#L27. is throwing an error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872231740:172,error,error,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872231740,1,['error'],['error']
Availability,"I think the error is surprisingly clear actually! There's no pressure solver for grids that are stretched in `x` or `y`. But it won't be much effort to add a more specific warning in the constructor for `NonhydrostaticModel`. @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in `i, j` and solve in `k`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022767819:12,error,error,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022767819,2,['error'],['error']
Availability,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149:17,down,downside,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149,2,['down'],['downside']
Availability,"I think the next step is a fully-fledged implementation that supports `Flux` boundary conditions (and possibly others). We are almost there with the latest `TurbulenceClosures` refactor. If `correct_immersed_tendencies!` is copy/pasted for tracers then all tracers will be set to zero inside a boundary; this might not be exactly what users want. I think we also sometimes want free-slip rather than no-slip boundary conditions on momentum. The algorithm I am thinking of would have the following components:. 1. Implement a ""mask"" that replaces `correct_immersed_tendencies!` that forcibly overwrites immersed regions to specified values in `update_state!` (this is effectively what `correct_immersed_tendencies!` does now); 2. Extend `calculate_boundary_tendency_terms!` to adjust tendencies in cells adjacent to immersed boundaries. This involves a) subtracting out the ""spurious"" component associated with a diffusive flux across an immersed boundary and b) adding in the ""true"" boundary flux that's either specified by the user, or implied by a `Value` / `Gradient` boundary condition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493:526,mask,mask,526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493,1,['mask'],['mask']
Availability,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072:256,error,error,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072,10,"['down', 'error']","['downside', 'error']"
Availability,"I think the problem is basically that the schedules are not saved to the checkpoint. Actually, the output themselves are also not saved to checkpoint which is also an issue for time averages. I believe this wasn't previously an issue but recent changes to `TimeInterval` in #3616 may have created the problem... Likely we can find some simple way to fix `TimeInterval` but let's keep in mind that there are some broader challenges to be solved for checkpointing that basically will require a feature that can save callback and output writer states.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246084467:73,checkpoint,checkpoint,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246084467,6,['checkpoint'],"['checkpoint', 'checkpointing']"
Availability,"I think the problem is that `prettytime(wizard)` does not work. MWE:. ```julia; julia> using Oceananigans. julia> wizard = TimeStepWizard(cfl=0.1, Δt=1.0); TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}(0.1, Inf, 2.0, 0.5, Inf, 0.0, 1.0, Oceananigans.Utils.cell_advection_timescale, Oceananigans.Simulations.infinite_diffusion_timescale). julia> prettytime(wizard); ERROR: MethodError: no method matching zero(::TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); Closest candidates are:; zero(::Union{Type{P}, P}) where P<:Dates.Period at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Dates/src/periods.jl:53; zero(::ArrayInterface.NDIndex{N, I} where I<:Tuple{Vararg{Any, N}}) where N at /Users/gregorywagner/.julia/packages/ArrayInterface/VFy81/src/ndindex.jl:95; zero(::LinearAlgebra.UniformScaling{T}) where T at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/uniformscaling.jl:136; ...; Stacktrace:; [1] iszero(x::TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Base ./number.jl:40; [2] prettytime(t::TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/MRn50/src/Utils/pretty_time.jl:18; [3] top-level scope; @ REPL[3]:1; ```. I'm not sure what `prettytime(wizard)` should return --- I think this is expected.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902841030:459,ERROR,ERROR,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902841030,1,['ERROR'],['ERROR']
Availability,I think the proposed error message is more helpful and would encourage such a change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047867418:21,error,error,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047867418,1,['error'],['error']
Availability,"I think the simulation is ready and physically/numerically correct. I ran a high-reynolds-number version of this simulation and results look like those from the original paper (even quantitatively). Here's what the v-velocity and the y-vorticity look like (in this current resolution):. https://user-images.githubusercontent.com/13205162/138630652-3c1f3180-793a-42f4-8402-8ad2a921e2d7.mp4. https://user-images.githubusercontent.com/13205162/138630663-abcc59cd-0334-4037-ae92-1ece165a3536.mp4. Now the question is what to do with this. My idea was to transform this into a docs example, but I can also leave it as a validation. If it were a docs example I think this would then teach users how to:. - use the `Buoyancy()` constructor with a specified vertical direction; - use `ConstantCoriolis`, also with a specified vertical direction (these last two are mostly useful for tilted domains I think); - Possibly also how to use NetCDF output writers, which no example does for now. A few ideas that I had for the docs example which might be controversial are. - Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES).; - Use Python/xarrray to read and plot the data. The major downside of these (especially the python one) is that it would add dependencies to the docs environment. Eager to hear some thoughts. CC: @glwagner @navidcy @francispoulin @wenegrat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676:1394,down,downside,1394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676,1,['down'],['downside']
Availability,"I think the solution discussed here, where the time-step _change_ associated with `TimeInterval` schedules is restricted by a sort of relative tolerance criteria, is acceptable if we can't tease out the underlying issue (or its unsolvable). If we could indeed solve the problem simply by eliminating round off error, then this would almost certainly be preferred since it might be much simpler (eg just fixing an floating-point-unstable arithmetic operation by rearranging terms). That could be really easy. @Sbozzolo might be able to help because I believe they do something special to avoid round off issues in `ClimaAtmos`. I would hesitate to establish an absolute `min_Δt` that's independent of the units being used, unless the default is `0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136:143,toler,tolerance,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136,4,"['error', 'toler']","['error', 'tolerance']"
Availability,"I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture. Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936:195,checkpoint,checkpointing,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936,3,['checkpoint'],"['checkpointer', 'checkpointing']"
Availability,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:770,avail,available,770,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600,1,['avail'],['available']
Availability,"I think these lines should be using `ξnode`, `ηnode`, and `rnode`:. https://github.com/CliMA/Oceananigans.jl/blob/7cbf013cb6bed2bd7cef0f4d8e5f04c078e50ee0/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L136-L142. I'll open a PR with a fix tomorrow. Should probably also add a test for particle advection on a lat-lon grid. ---. Some debug printing inside `advect_particle` with 1 particle:. ```; [ Info: Iteration 1...; [ Info: X=(1.0, -1.5, -10.0), I=(47, 109, 53); [ Info: (before) X⁺=(1.0, -1.5, -10.0); (iᴿ, jᴿ, kᴿ) = (101, 201, 61); (xᴸ, yᴸ, zᴸ) = (87813.63270401207, -217942.05622333512, -100.0); (xᴿ, yᴿ, zᴿ) = (136722.49142523398, -124538.3178419058, 0.0); (x⁺, y⁺, z⁺) = (175626.26540802413, -249075.1356838116, -10.0); [ Info: (after) X⁺=(175626.26540802413, -249075.1356838116, -10.0); [ Info: Iteration 2...; [ Info: X=(175626.26540802413, -249075.1356838116, -10.0), I=(39914880, -59303137, 53); ERROR: LoadError: BoundsError: attempt to access 109×208×68 OffsetArray(::Array{Float64, 3}, -3:105, -3:204, -3:64) with eltype Float64 with indices -3:105×-3:204×-3:64 at index [39914881, -59303136, 54]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852#issuecomment-2428098528:933,ERROR,ERROR,933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852#issuecomment-2428098528,1,['ERROR'],['ERROR']
Availability,"I think they do work, but I am not sure what the error was",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2301#issuecomment-1305714765:49,error,error,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2301#issuecomment-1305714765,1,['error'],['error']
Availability,"I think this is a better MWE:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(3, 3, 1), x=(0, 1), y=(0, 1), z=(0, 1));. julia> model = HydrostaticFreeSurfaceModel(; grid);. julia> view(model.free_surface.η, :, :, 2:2); ERROR: BoundsError: attempt to access 9×9×1 Array{Float64, 3} at index [1:9, 1:9, 3:3]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:734; [2] checkbounds; @ ./abstractarray.jl:699 [inlined]; [3] view; @ ./subarray.jl:179 [inlined]; [4] offset_windowed_data(data::OffsetArray{Float64, 3, Array{…}}, Loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{…}, OffsetVector{…}, OffsetVector{…}, CPU}, indices::Tuple{Colon, Colon, UnitRange{…}}); @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::Function, j::Function, k::UnitRange{Int64}); @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/field.jl:316; [6] top-level scope; @ REPL[6]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. We should be able to call `view(model.free_surface.η, :, :, 2:2)` since the free surface is a windowed field with vertical indices `2:2` (the index slice corresponding to the top surface of the model...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3572#issuecomment-2088756852:245,ERROR,ERROR,245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572#issuecomment-2088756852,1,['ERROR'],['ERROR']
Availability,"I think this is essentially a duplicate of https://github.com/CliMA/Oceananigans.jl/issues/3485, although @liuchihl found a MWE where similar issues pop up even in the initial period (without picking up from a checkpoint).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2259375982:210,checkpoint,checkpoint,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2259375982,1,['checkpoint'],['checkpoint']
Availability,I think this pattern takes care of this issue:; https://github.com/climate-machine/Oceananigans.jl/blob/7a4142c43b6cf1f5541687fa349d75cb52605c50/examples/deepening_mixed_layer.jl#L3-L10. I think the problem with multiple `Project.toml` files is that it's awkward for users just adding the package via `]add Oceananigans` to switch between different environments just to run a simple example. But an error like `module PyPlot not found` is clear enough that they just need `PyPlot` to run the example.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/195#issuecomment-520786369:399,error,error,399,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/195#issuecomment-520786369,1,['error'],['error']
Availability,"I think to do this well, we need to save both the type of the immersed boundary (as a string?) --- for example `GridFittedBottom` (2D), `GridFittedBoundary` (3D), and `PartialCellBottom` (2D) --- and any data that might be associated with it, such as `bottom_height` (for `GridFittedBottom` and `PartialCellBottom`) and `mask` (for `GridFittedBoundary`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3536#issuecomment-2038165615:321,mask,mask,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3536#issuecomment-2038165615,1,['mask'],['mask']
Availability,I think we are close to sorting this issue out. I will make the update once we figure out the remaining checkpoint issue.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295431738:104,checkpoint,checkpoint,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295431738,1,['checkpoint'],['checkpoint']
Availability,"I think we could use some utilities for instantiating grids and fields from files saved by Oceananigans' output writers. For this it could make sense to change `Oceananigans.OutputWriters` to `Oceananigans.Output` and include both output writers and utilities for reading output. (The checkpointer already has utilities for reading output, I suppose.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/706:285,checkpoint,checkpointer,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/706,1,['checkpoint'],['checkpointer']
Availability,I think we should also add a test that would catch this error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2564#issuecomment-1131233965:56,error,error,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2564#issuecomment-1131233965,1,['error'],['error']
Availability,I think we should tag a v0.37.0 release to ensure we have a code checkpoint before which we were recomputing w and after which we were not (since it's a change to the numerical methods). Might be good if we do this before merging in RK3.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/948:65,checkpoint,checkpoint,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/948,1,['checkpoint'],['checkpoint']
Availability,"I think we'll want a ""community repo"" for cases eventually. Something like https://github.com/FluxML/model-zoo if I understand the purpose of that correctly. > For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. Isn't an ordinary Julia environment enough? For the community repo I think either . 1. There is one repo-wide `Project.toml` and all examples are kept up to date or; 2. Each example has it's own `Project.toml`. As I understand the flux model zoo takes approach 1 (this is in principle better, because otherwise the examples grow stale and cease to be useful). However, that requires maintenance and substantial effort. . I think we will still want in-house examples in addition to an external community repo.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062527545:702,mainten,maintenance,702,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062527545,1,['mainten'],['maintenance']
Availability,I think when the window is bigger than the interval the result is identical to the case that window=interval. Basically the algorithm starts averaging whenever the model time is greater than `end_of_next_interval - window`. I think we should regard windows larger than intervals as invalid specification; #1816 adds an error for this case.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-873447709:319,error,error,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-873447709,1,['error'],['error']
Availability,I think you might be able to derive the fifth order scheme from Wicker and Skamarock (2002):. https://palm.muk.uni-hannover.de/trac/wiki/doc/tec/discret. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.119.8289&rep=rep1&type=pdf. But I'm not 100% sure...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747100424:191,down,download,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747100424,1,['down'],['download']
Availability,"I think you're right that `view(::Field)` doesn't recover the same behavior as `view(::Array)`. This is because `Field` are fixed to three dimensions; we don't have a way to express the concept of a `Field` with one dimension. So for example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid);. julia> size(view(c, 1, :, 2)); (1, 3, 1). julia> size(view(parent(c), 1, :, 2)); (9,); ```. If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481:50,recover,recover,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481,1,['recover'],['recover']
Availability,"I took the shallow water Bickley jet example and made two modifications. I added `using CUDA` and changed the architecture to `GPU` and tried running it on my desktop. The GPU is nothing fancy but there is something and I thought that it should, based on previous tests. Unfortunately, `run!(simulation)` yields an error that you can find below. I also tried this on a server and found a similar error. Two questions.; 1. Could someone else try this in a GPU to see if they get an error?; 2. Anyone have a clue as to what id going wrong in this error?. ```; $ julia --project shallow_water_Bickley_jet.jl ; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 129, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 9, 1)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Face,Face,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Face,Face,Center,Nothing,Nothing,typeof(ω̄),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1477:315,error,error,315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477,5,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I tried it again and received a similar error, copied below. What I find strange is that it mentions worker 5 but I only asked for 4. . @ali-ramadhan , what did you do to run this file exactly?. ```; ERROR: LoadError: Worker 5 terminated.ProcessExitedException(2). ...and 3 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378:40,error,error,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I tried it again with a fresh clone and still received an error. The details are copied below. However, `make_example.jl` does seem to be working so it's not all bad. Unfortunately, I'm not sure why this occurs. ```; ERROR: LoadError: `makedocs` encountered a doctest error. Terminating build; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] runner(#unused#::Type{Documenter.Builder.Doctest}, doc::Documenter.Documents.Document); @ Documenter.Builder ~/.julia/packages/Documenter/f5jts/src/Builder.jl:217; [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); @ Documenter.Utilities.Selectors ~/.julia/packages/Documenter/f5jts/src/Utilities/Selectors.jl:170; [4] #2; @ ~/.julia/packages/Documenter/f5jts/src/Documenter.jl:249 [inlined]; [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); @ Base.Filesystem ./file.jl:106; [6] #makedocs#1; @ ~/.julia/packages/Documenter/f5jts/src/Documenter.jl:248 [inlined]; [7] top-level scope; @ ~/software/Second_Oceananigans/Oceananigans.jl/docs/make.jl:160; in expression starting at /home/fpoulin/software/Second_Oceananigans/Oceananigans.jl/docs/make.jl:160; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869017574:58,error,error,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869017574,5,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I tried running the `ShallowWaterModel` example on a `GPU` and it failed because of how we compute the norm, see the error message below. @glwagner , I remember we talked about this but, sadly, I don't know if we had a solution. What would you recommend?. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:53; [3] getindex(::CUDA.CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:86; [4] getindex; @ ./subarray.jl:276 [inlined]; [5] _getindex; @ ./abstractarray.jl:1214 [inlined]; [6] getindex; @ ./abstractarray.jl:1170 [inlined]; [7] iterate; @ ./abstractarray.jl:1096 [inlined]; [8] iterate; @ ./abstractarray.jl:1094 [inlined]; [9] generic_normInf(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:465; [10] normInf; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:556 [inlined]; [11] generic_norm2(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:497; [12] norm2; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:558 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783:117,error,error,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I tried running the first example listed in README and I got the following error:; ```; julia> topology = (Periodic, Periodic, Bounded); ERROR: UndefVarError: Bounded not defined; Stacktrace:; [1] top-level scope at REPL[45]:1; ```; I'm running Julia 1.4 RC2 on macOS 10.15.3.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/679:75,error,error,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/679,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I tried submitting it as a package through an attobot request a few weeks ago but the PR build failed on METADATA.jl and I'm not sure why. Well, I think this was the error but not sure what to do about it as I put Julia 1.1 in the REQUIRE file.; ```; ERROR: LoadError: METADATA/Oceananigans/versions/0.4.0/requires: no julia entry (>= 0.6.0 needed); ```. See:; * https://github.com/JuliaLang/METADATA.jl/pull/21774",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/142:166,error,error,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/142,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I tried the Shallow-water-Bickley-jet case and it doesn't work; it throws the following error:. ```; run!(simulation); [ Info: Initializing simulation...; ERROR: MethodError: no method matching isless(::Float64, ::DateTime); Closest candidates are:; isless(::T, ::T) where T<:Union{Float16, Float32, Float64} at float.jl:424; isless(::Real, ::Static.StaticInteger{Y}) where Y at ~/.julia/packages/Static/Ldb7F/src/Static.jl:456; isless(::AbstractFloat, ::AbstractFloat) at operators.jl:184; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1452909016:88,error,error,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1452909016,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,I tried the same code and reproduced the same error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128827661:46,error,error,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128827661,1,['error'],['error']
Availability,"I tried to construct a PGC free surface solver with an FFT preconditioned and I get an error. ```Julia; ArgumentError: The dimensions of the immersed boundary (408, 1) do not match the grid size (406, 1). Stacktrace:; [1] validate_ib_size(grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries /g/data/v45/nc3020/.julia/packages/Oceananigans/KZUtL/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:92; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries /g/data/v45/nc3020/.julia/packages/Oceananigans/KZUtL/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:85; [3] with_halo(halo::Tuple{Int64, Int64, Int64}, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3093:87,error,error,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3093,1,['error'],['error']
Availability,"I tried to create a lat-lon grid that is flat in `z` but got this... ```Julia; julia> grid = LatitudeLongitudeGrid(size=(36, 34), longitude = (-180, 180), latitude = (-85, 85), topology = (Bounded, Bounded, Flat)); ERROR: BoundsError: attempt to access 0-element Vector{Any} at index [1]; Stacktrace:; [1] getindex(A::Vector{Any}, i1::Int64); @ Base ./array.jl:805; [2] generate_coordinate(FT::Type, topology::Type, N::Int64, H::Int64, coord::Nothing, arch::CPU); @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/grid_generation.jl:60; [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Nothing, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/latitude_longitude_grid.jl:195; [4] top-level scope; @ REPL[5]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```. @francispoulin, given that 3rd dimension needs to be flat, how were you running the SWE simulations on lat-lon grid?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143210094:215,ERROR,ERROR,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143210094,1,['ERROR'],['ERROR']
Availability,"I tried to follow the terminology in the regression test and sorry it was confusing. I used `truth` to refer to the data that is read from a file, done [here.](https://github.com/CliMA/Oceananigans.jl/blob/3676a718be1160f3ea70c3cce5dd21c5f06f144a/test/regression_tests/shallow_water_bickley_jet_regression.jl#L82) . I agree that only `v` fails but that means that `v` has larger differences compared to `u` and `h`. They all have differences. . I compared the initial data that we used in this regression test with the initial data read from the regression test. I saw that we had the 0th and 20th step saved. If there are differences at the beginning, then they are not solving exactly the same problem. In both we have that v is set to 0 and u and h are set to the Bickley jet with a random perturbation on `u`. The randomness will not be the same (unless we use a seed, which we don't, but we could) however the amplitude of the perturbations are different. This suggests to me that the initial conditions are not the same, and maybe the soruce of why the regression test fails. This is why I would like to know how the initial data was generated, using what script. I do suggest we regenerate it as that might solve a lot of the problems we are having with the regression tests. Do you want me to generate a script that load the inital data and compare it? You can see the results above. The fact that h has differences of `1e-7` is due to single precison, which means they are the same. However, u is different with errors much larger then `1e-7`, so the initial data is different. Unless there is something that I'm missing here?. I saw that the data files were dated June 1st 2022. For me it is stored at the following location. `/home/fpoulin/.julia/datadeps/regression_test_data/`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1446357883:1521,error,errors,1521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1446357883,1,['error'],['errors']
Availability,"I tried to run `benchmark_incompressible_model.jl` with advection=WENO5() and the error shown below occurred as it was benchmarking the first GPU case with grid size being 32 x 32 x 32. I'm running all benchmark cases with Float64. Many other error messages of a similar format were also outputted, but this one was the earliest one I can retrieve. My Oceananigans.jl was up to date with the latest merge #1790.; I also tried running it without specifying an advection and it ran fine. @francispoulin is experiencing the same problem. ```; Reason: unsupported use of an undefined name (use of 'pow'); Stacktrace:; [1] overdub; @ C:\Users\henry\.julia\packages\KernelAbstractions\X5hOr\src\backends\cuda.jl:264; [2] right_biased_αz₁(::Int64, ::Int64, ::Int64, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}); @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:113; [3] overdub; @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:113; [4] overdub; @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:187; [5] right_biased_interpolate_zᵃᵃᶠ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, ::WENO5, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}); @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:228; [6] overdub; @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:228; [7] _right_biased_interpolate_zᵃᵃᶠ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, ::WENO5, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}); @ C:\Users\henry\.julia\pack",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-871687335:82,error,error,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-871687335,2,['error'],['error']
Availability,"I tried to run the `eady_turbulence.jl` example in Oceananigans v0.25.0 in Julia 1.4 RC2 on macOS 10.15.3 and got the following error:. ```; julia> include(""eady_turbulence.jl""); [ Info: CUDAdrv.jl failed to initialize, GPU functionality unavailable (set JULIA_CUDA_SILENT or JULIA_CUDA_VERBOSE to silence or expand this message); N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined; Stacktrace:; [1] top-level scope at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; [2] include(::String) at ./client.jl:439; [3] top-level scope at REPL[1]:1; in expression starting at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; ```; I noticed that there are a lot of recent commits with regards to boundary conditions, may be the example is using an older interface?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/686:128,error,error,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I tried to update Oceananigans version in ClimaOceanBiogeochemistry as:; ```; Oceananigans v0.92.0 `https://github.com/CliMA/Oceananigans.jl#glw/tuples-with-catke`; ```; Then I ran CATKE together with horizontal closure:; ```; catke = CATKEVerticalDiffusivity(); horizontal_closure = HorizontalScalarDiffusivity(ν=1e3); model = HydrostaticFreeSurfaceModel(; grid,; closure = (catke, horizontal_closure),; ...); ```; It still returns an error message:; `ERROR: type Tuple has no field κe`. Is it indicating the problem is still unresolved, or am I testing in an incorrect way?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386577814:436,error,error,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386577814,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I tried to use CUDA's [`compute-sanitizer`](https://cuda.juliagpu.org/stable/development/debugging/#compute-sanitizer) to debug the memory issue, but couldn't get anything useful out of it so I went back to debug print statements lol. I printed out the value of `maximum(CuArray(randn(100)))` which should error after the illegal memory access occurs. So I peppered these statements around to try and find where the error happens. The issue happens somewhere here:. https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl#L246-L252. Adding. ```julia; κu★ = convert(eltype(grid), κu★); κc★ = convert(eltype(grid), κc★); κe★ = convert(eltype(grid), κe★); ```. causes the MWE to work, which is weird because `@show` on the CPU tells me that they are `Float32` anyways. And I'm not sure on the GPU because `@cushow` can't show strings. Commenting out. ```julia; # κu★ = mask_diffusivity(i, j, k, grid, κu★); # κc★ = mask_diffusivity(i, j, k, grid, κc★); # κe★ = mask_diffusivity(i, j, k, grid, κe★); ```. also causes the MWE to work. I haven't been able to isolate the problematic line/operation yet. And as far as I can tell, the code used to compute `κuᶜᶜᶠ`, `κcᶜᶜᶠ`, and `κeᶜᶜᶠ` is all type-safe. Will continue later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439779361:306,error,error,306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439779361,2,['error'],['error']
Availability,"I tried. ```julia; subset_grid = RectilinearGrid(arch,; size = (grid.Nx, grid.Ny, div(grid.Nz, 20)),; extent = (grid.Lx, grid.Ly, grid.Lz); ). u_subsampled = XFaceField(subset_grid); v_subsampled = YFaceField(subset_grid); w_subsampled = ZFaceField(subset_grid). function subsample_u(model); u = model.velocities.u; interpolate!(u_subsampled, u); return u_subsampled; end. function subsample_v(model); v = model.velocities.v; interpolate!(v_subsampled, v); return v_subsampled; end. function subsample_w(model); w = model.velocities.w; interpolate!(w_subsampled, w); return w_subsampled; end. subset_outputs = (; u = subsample_u, v = subsample_v, w = subsample_w); ```. and. ```julia; simulation.output_writers[:xyz] = NetCDFOutputWriter(model, subset_outputs,; schedule = TimeInterval(300),; filename = ""test.nc"",; with_halos = false,; array_type = Array{Float32},; ); ```. is returning the following error. ```julia; Custom output v needs dimensions!. Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] define_output_variable!(dataset::NCDatasets.NCDataset{Nothing}, output::Function, name::String, array_type::Type, deflatelevel::Int64, output_attributes::Dict{String, String}, dimensions::Dict{Any, Any}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/3LHMs/src/OutputWriters/netcdf_output_writer.jl:448; [3] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Col",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594:1286,error,error,1286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032573594,1,['error'],['error']
Availability,I vote for simply `mask = default_value` and `mask!(field)`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528003302:19,mask,mask,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528003302,4,['mask'],['mask']
Availability,"I vote for writing new operators for new grid types. I think it makes sense to use the fastest algorithm available. It is also potentially confusing to a future reader of the code if 'Δz' is --- unnecessarily --- an array of constants. I believe the code is *clearer* if the code structure, structs, etc reflect *intent* accurately and in detail. A regular grid has a constant Δz by definition; therefore, Δz should be a scalar. You may find that regular grids have advantages and will be used often in the future. It is much easier to double the resolution of a regular grid, for example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/47#issuecomment-462851293:105,avail,available,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/47#issuecomment-462851293,1,['avail'],['available']
Availability,"I was able to get things and I see that 35 files were changed so I suspect a merge happened. However now, when I try the example @glwagner suggested, the first line with `using` errors with the following. Maybe there is a problem with my merge?. ```; julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: LoadError: UndefVarError: NoImmersedBoundary not defined; Stacktrace:; [1] include(mod::Module, _path::String); @ Base ./Base.jl:386; [2] include(x::String); @ Oceananigans.Models.ShallowWaterModels ~/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:1; [3] top-level scope; @ ~/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:15; [4] include(mod::Module, _path::String); @ Base ./Base.jl:386; [5] include(x::String); @ Oceananigans.Models ~/software/Oceananigans.jl/src/Models/Models.jl:1; [6] top-level scope; @ ~/software/Oceananigans.jl/src/Models/Models.jl:20; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ Oceananigans ~/software/Oceananigans.jl/src/Oceananigans.jl:1; [9] top-level scope; @ ~/software/Oceananigans.jl/src/Oceananigans.jl:179; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:16; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:1; in expression st",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843316815:178,error,errors,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843316815,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,I was able to reproduce the hanging by running the test manually in the REPL. It gets stuck somewhere in `run!(simulation)` but couldn't get a useful stacktrace out. It does not hang in v0.54.0. I tried downgrading and pinning KernelAbstractions.jl and CUDA.jl back down to the version used in the v0.54.0 Manifest.toml but it still got stuck... Could be some other package. > Should we stop updating docs/Manifest.toml? Is that possible?. Couldn't find anything in the Pkg.jl docs that would help but maybe we should switch the order of the `instantiate` and `develop` calls here? https://github.com/CliMA/Oceananigans.jl/blob/e02790202614916bd918a039216a73c61ff7048a/.buildkite/pipeline.yml#L326,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1561#issuecomment-816731027:203,down,downgrading,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1561#issuecomment-816731027,2,['down'],"['down', 'downgrading']"
Availability,"I was actually expecting a different error. But this isn't a good one either. ```julia; julia> using Oceananigans. julia> using OrthogonalSphericalShellGrids. julia> grid = TripolarGrid(size=(4, 4, 4), z=(-1, 0)); 4×4×4 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── centered at (λ, φ) = (0.0, -0.3201); ├── longitude: Periodic extent 360.112 degrees variably spaced with min(Δλ)=15.6283, max(Δλ)=95.2245; ├── latitude: RightConnected extent 212.5 degrees variably spaced with min(Δφ)=23.4259, max(Δφ)=56.6667; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> free_surface = SplitExplicitFreeSurface(grid; cfl=0.7); SplitExplicitFreeSurface with Barotropic time step equal to 8.112 days. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface); ERROR: Centered{1, Float64, Nothing, Nothing, Nothing, Nothing} is not supported with Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, CPU}; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] validate_momentum_advection(momentum_advection::Centered{…}, grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:227; [3] #construct_regionally#62; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:148 [inlined]; [4] construct_regionally; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:143 [inlined]; [5] macro expansion; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:221 [inlined]; [6] HydrostaticFreeSurfaceModel(;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806:37,error,error,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,I was doing some profiling on a model with no open boundaries and discovered that this function was causing a big slow down. I guess this is because the compiler isn't managing to work out its just a load of nothing operations but this change appears to make it completely go away.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3792:119,down,down,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3792,1,['down'],['down']
Availability,"I was getting two errors but when I added `CUDA.allowscalar(true)` into `test_shallow_water_models.jl` the tests all passed on a CPU and GPU on my laptop. Note that in `dependencies_for_runtests.jl` this line [here](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/test/dependencies_for_runtests.jl#L78) only found a GPU on my computer. When I changed it temporarily to test both CPU and GPU and all 80 tests passed. I remember last year in #3050 @navidcy found that it ran on some computers but not others. I presume that is still a concern. But lots has changed since then, for example we are no longer using julia 1.8. @navidcy, might you be able to try the shallow water tests on the same computer you found the failers in last year to see if the problem persists?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404:18,error,errors,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1967097404,1,['error'],['errors']
Availability,"I was just trying to precompile Oceananigans 0.34.1 on my macOS 10.15.6 machine and got the following error:. ```; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:102,error,error,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I was looking at the errors on `cpu-solver_tests` and found the message below, followed by a bunch of other errors on the lines below. Does someone know why this is failing? I can take a look at it but thought I'd check to see whether this is understood or not. ```; Vertically stretched Poisson solver [FACR, CPU, (Flat, Bounded, Bounded)]: Error During Test at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/test/test_poisson_solvers.jl:272;   | Test threw exception;   | Expression: vertically_stretched_poisson_solver_correct_answer(Float64, arch, topo, 8, 8, 1:8);   | ArgumentError: length(size) must be 2.;   | Stacktrace:;   | [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/input_validation.jl:24;   | [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/input_validation.jl:24;   | [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/input_validation.jl:48;   | [4] VerticallyStretchedRectilinearGrid(::Type{T} where T; architecture::CPU, size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, zF::UnitRange{Int64}, halo::Tuple{Int64,Int64,Int64}, topology::Tuple{DataType,DataType,DataType}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/vertically_stretched_rectilinear_grid.jl:50;   | [5] vertically_stretched_poisson_solver_correct_answer(::Type{T} where T, ::CPU, ::Tuple{DataType,DataType,DataType}, ::Int64, ::Int64, ::UnitRange{Int64}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/test/test_poisson_solvers.jl:140;   | [6] top-level scope at /storage7/buil",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-819603114:21,error,errors,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-819603114,3,"['Error', 'error']","['Error', 'errors']"
Availability,I was reading about the extension feature in Julia v1.9. https://pkgdocs.julialang.org/v1/creating-packages/#Conditional-loading-of-code-in-packages-(Extensions). and it reads to me that it's ideal to add for plotting methods that step onto Makie functionality. This way the code won't load unless one loads GLMakie/CairoMakie in the environment. What do others think?. I have put together a few methods for plotting Oceananigans fields at https://github.com/navidcy/Imaginocean.jl. I could move those into an extension in Oceananigans. Ideally I would like these things to live outside Oceananigans repo to minimise the burden of maintenance. But from what I understand for how extensions work they have to live in this repo? Or in the Makie repo which makes even less sense? Am I right?. x-ref: https://github.com/navidcy/Imaginocean.jl/issues/2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178:631,mainten,maintenance,631,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178,1,['mainten'],['maintenance']
Availability,"I was running an example of the 2D turbulence using Julia 1.4RC2 (Oceananigans 0.27.0) on an Azure Ubuntu 18.04.3 GPU instance (Tesla K80), I was defining the model:; ```; model = IncompressibleModel(; grid = RegularCartesianGrid(size=(128, 128, 1), length=(2π, 2π, 2π)),; buoyancy = nothing,; tracers = nothing,; closure = ConstantIsotropicDiffusivity(ν=1e-3, κ=1e-3); ); ```; when this error occurred:; ```; julia> model = IncompressibleModel(; grid = RegularCartesianGrid(size=(128, 128, 1), length=(2π, 2π, 2π)),; buoyancy = nothing,; tracers = nothing,; closure = ConstantIsotropicDiffusivity(ν=1e-3, κ=1e-3); ); Error showing value of type IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Face,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},Coor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/707:388,error,error,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/707,2,"['Error', 'error']","['Error', 'error']"
Availability,"I was thinking it might be cool/useful to inform users if their model is physically/numerically consistent. One example of this is to check that the boundary conditions being imposed match the grid topology (#890). But I think there are many more. Some examples:; * Using `BetaPlane` on a periodic grid.; * Using `WENO5` on a curvilinear grid.; * Using a free surface when z is `Periodic`.; * Using an `FFTBasedPressureSolver` on a curvilinear grid.; * ... Some errors are more likely to be made by users than others of course. But I don't think we can expect users to just know that e.g. `WENO5` doesn't work with `VerticallyStretchedRectilinearGrid` yet. To save ourselves and users some potential future headaches, it seems like we could create a function like `check_consistency(model)` that would perform these checks and print a warning for each inconsistency detected. Unfortunately this could become a pretty ugly monolithic function that's hard to modularize since we're checking the consistency of many different structs acting together.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453:462,error,errors,462,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453,1,['error'],['errors']
Availability,"I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR https://github.com/vchuravy/GPUifyLoops.jl/pull/18. The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs. You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations. Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067:565,degraded,degraded,565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067,1,['degraded'],['degraded']
Availability,"I was trying to add some Lagrangian particles to a 2D simulation I was running but Lagrangian particle advection currently assumes that the grid is bounded or periodic in all dimensions. An MWE (on Julia 1.10.1+0.x64.w64.mingw32 and Oceananigans version 0.90.12) that reproduces the issue is:. ```; using Oceananigans; NX, NZ = 16, 16; grid = RectilinearGrid(size=(NX,NZ), x=(0,1), z=(0,1), topology=(Periodic, Flat, Bounded)); # initialise some particles at the cell centres; x₀ = reshape(xnodes(grid, Center()) * ones(NZ)', NX * NZ); y₀ = zeros(NX * NZ); z₀ = reshape(ones(NX) * znodes(grid, Center())', NX * NZ); model = NonhydrostaticModel(; grid, particles=LagrangianParticles(x=x₀, y=y₀, z=z₀)); simulation = Simulation(model; Δt=1, stop_iteration=5); run!(simulation); ```. with output. ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (115.810 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching unsafe_trunc(::Type{Int64}, ::Nothing). Closest candidates are:; unsafe_trunc(::Type{Int64}, ::Union{Float16, Float32, Float64}); @ Base float.jl:336; unsafe_trunc(::Type{<:Integer}, ::BFloat16s.BFloat16); @ BFloat16s C:\Users\hildi\.julia\packages\BFloat16s\u3WQc\src\bfloat16.jl:288; unsafe_trunc(::Type{T}, ::BigFloat) where T<:Integer; @ Base mpfr.jl:358; ... Stacktrace:; [1] advect_particle; @ C:\Users\hildi\.julia\packages\Oceananigans\kBe5X\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:81 [inlined]. ...; ```. The offending line is https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L81 . which fails because ; https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L79; returns `j = nothing` when `y` is `Flat`. However, I think that in general `advect_particle` is not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3545:936,ERROR,ERROR,936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3545,1,['ERROR'],['ERROR']
Availability,I was trying to use Integral and was failing...! Will try again and post the error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2735#issuecomment-1244089259:77,error,error,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2735#issuecomment-1244089259,1,['error'],['error']
Availability,"I was trying use `NetCDFOutputWriter` to write some data using the syntax that is used in the example [here](https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/) and tried the following:. ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;; filename = ""buoyancy_displacement.nc"",; schedule = TimeInterval(0.1)); ```. That did not work. The error was `keyword argument filepath not assigned`. . I checked `help` it said I should be using `filepath` instead of `'filename`. Hence I tried the following, which did work. ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;; filepath = ""buoyancy_displacement.nc"",; schedule = TimeInterval(0.1)); ```. I am using juliav1.6 and `NCDatasets v0.12.4`, which seems to be the latest version. . Does anyone have any suggestions as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2541:414,error,error,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2541,1,['error'],['error']
Availability,"I was wondering if it would be advantageous to have a place dedicated to document the features that are still experimental. I think that'd make it easier for other people to contribute to those features and having them mature faster. The main motivation for me to ask this is that often users (myself included) will ask about a particular feature that's still under development (generally immersed solids or parallelism), and someone ends up describing the state of affairs at that point and pointing to a validation script and the user has to figure everything out from there. I realize all these things are available in issues and PRs, but it's hard to find the right ones and distill what's ""relevant"" information from there. I'm going through that this moment with `ImmersedBoundaryGrid`, which I'm trying to advance. I can work backwards from a given script to figure out how the implementation exists now and get a sense of to expand it, but it'd be way easier if I could read about what's implemented already, why that's the chosen implementation, bumps on the road, etc. Another motivation is that the code has grown so much lately that I sometimes see PRs/issues here about some features and I realize I simply don't recognize (and I'm fairly involved with Oceananigans' development). Some of those features might be useful for my research, or they may be things that I'd be interest in developing that I'm missing out on. Possible places to host that info would be a dedicated section of the docs possibly named ""Experimental features"", but maybe the easiest way would be allowing a wiki for that. I think discussions wouldn't be as organized. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2355:609,avail,available,609,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355,1,['avail'],['available']
Availability,"I was working on post-processing the data from a simulation I ran in Oceananigans when I decided I wanted to access the background field data from the run and write it to a netCDF4. I had tried `output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v))` as seen in my minimal working example below(please let me know if you need more details); ```; u,v,w = model.velocities. output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v)). simulation.output_writers[:fields] = NetCDFOutputWriter(model, output;; schedule = TimeInterval(10),; filename = ""test2.nc"",; overwrite_existing = true); ```; but kept getting this error:; ```; ERROR: LoadError: MethodError: no method matching Field(::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, NamedTuple{(:Nₒ, :S, :γ, :ϕ, :f), Tuple{Float64, Float64, Float64, Int64, Float64}}, typeof(U_func), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}; indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); ```; Luckily I made a work around by changing the output to `output = (; u, v, w, U=(model.background_fields.velocities.u+0*u), V=(model.background_fields.velocities.v+0*v))` on a suggestion from a postdoc in my group who has much more experience using Oceananigans. I think the issue here is that the background fields are classified as function fields, so it may be worthwhile to create a method that converts function fields to fields or something similar to make outputting them easier.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226:699,error,error,699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I wish I left more info in PR #1229 haha but I think keeping the file open between writes was actually an oversight. My thinking was that you don't want to leave the file open when you don't explicitly need it to be open in case the simulation or Julia crashes. In some cases, this could corrupt the file or could leave the file unreadable by other processes until the Julia process exits. NetCDF files and NCDatasets.jl may not suffer from these issues, but I was probably doing it to be safe. If downgrading `NetCDF_jll` works that seems like a fine temporary fix? I don't think Oceananigans.jl needs super new features from NetCDF?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3777#issuecomment-2350139242:498,down,downgrading,498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3777#issuecomment-2350139242,1,['down'],['downgrading']
Availability,"I wonder if it may be a good idea to add a generic, user-definable 'parameters' field in `Model`. . The main purpose of this field would be to provide the user with more flexibility for boundary condition and forcing functions. Consider the implementation of a simple sponge layer in a script:. ```julia; const dTdz = 0.01; const μ₀ = 0.02. @inline μ(z, Lz) = μ₀ * exp(-(z + Lz) / 0.05Lz); @inline T₀(z) = dTdz * z. @inline FT(grid, U, Φ, i, j, k) = @inbounds -μ(grid.zC[k], grid.Lz) * (Φ.T[i, j, k] - T₀(grid.zC[k])). model = Model(forcing=Forcing(FT=FT), ...); ```. This works, of course. However, it requires the global `const`s `dTdz` and `μ₀` in order to compile on the GPU. This prevents users from, for example, defining a function of the form `create_and_run_model(μ₀, dTdz, other_parameters...)`. The only way to set `μ₀` or `dTdz` is by defining them as global `const`s; therefore a new script (or argument parsing via `ArgParse` and bash scripting) is required for each new run. I feel this is a potentially major limitation to current and future automation and we should attempt to find a solution to address the problem. One partial solution is to add a field `parameters` to the model. This field is then passed down into `calculate_interior_source_terms!` and the boundary condition algorithm to be used, if desired, within a user-defined functions. In this case, the above pattern could become:. ```julia; @inline μ(z, Lz, μ₀) = μ₀ * exp(-(z + Lz) / 0.05Lz); @inline T₀(z, dTdz) = dTdz * z. @inline FT(grid, U, Φ, i, j, k, params) = @inbounds -μ(grid.zC[k], grid.Lz, params.μ₀) * (Φ.T[i, j, k] - T₀(grid.zC[k], params.dTdz)). model = Model(forcing = Forcing(FT=FT), parameters=(μ₀=0.02, dTdz=0.01), ...); ```. We need not restrict the type of the field `parameters`; we can simply add. ```julia; mutable struct Model{P, ...}; ...; parameters :: P; end; ```. And set it to `nothing` by default in the `Model` constructor. The user may provide any kind of `parameters` they wish.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/394:1226,down,down,1226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/394,1,['down'],['down']
Availability,"I wonder if we are not instantiating the test environment correctly. We do instantiate here:. https://github.com/CliMA/Oceananigans.jl/blob/abb66e32d333562dd9aaeb7dd2ed8fac5e781368/.buildkite/pipeline.yml#L20. but the segmentation fault is coming from `Pkg`:. ```; Stacktrace:; --;   | [1] pipeline_error;   | @ ./process.jl:565 [inlined];   | [2] read(cmd::Cmd);   | @ Base ./process.jl:449;   | [3] collect_artifacts(pkg_root::String; platform::Base.BinaryPlatforms.Platform);   | @ Pkg.Operations /net/ocean/home/data44/data5/glwagner/oceananigans-buildkite-16499/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:720;   | [4] collect_artifacts;   | @ /net/ocean/home/data44/data5/glwagner/oceananigans-buildkite-16499/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:706 [inlined];   | [5] download_artifacts(env::Pkg.Types.EnvCache; platform::Base.BinaryPlatforms.Platform, julia_version::VersionNumber, verbose::Bool, io::Base.DevNull);   | @ Pkg.Operations /net/ocean/home/data44/data5/glwagner/oceananigans-buildkite-16499/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:752;   | [6] up(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}, level::Pkg.Types.UpgradeLevel; skip_writing_project::Bool, preserve::Nothing);   | @ Pkg.Operations /net/ocean/home/data44/data5/glwagner/oceananigans-buildkite-16499/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1542;   | [7] up(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; level::Pkg.Types.UpgradeLevel, mode::Pkg.Types.PackageMode, preserve::Nothing, update_registry::Bool, skip_writing_project::Bool, kwargs::@Kwargs{io::Base.DevNull});   | @ Pkg.API /net/ocean/home/data44/data5/glwagner/oceananigans-buildkite-16499/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/API.jl:351;   | [8] up;   | @ /net/ocean/home/data44/data5/glwagner/oceananigans-buildkite-16499/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/API.jl:326 [inlined];   | [9] up;   | @ /net/ocean/home/data44/data5/gl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2250997136:231,fault,fault,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2250997136,1,['fault'],['fault']
Availability,"I would first of all do _nothing_ that's intended to support `AnisotropicBiharmonicDiffusivity`. Instead we should delete this closure in favor of `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (or more appropriately, simply replace the existing `AnisotropicBiharmonicDiffusivity` with `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity`). See #2113 and a few other issues referenced there. Since `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` uses `diffusive_flux_x` (unlike `AnisotropicBiharmonicDiffusivity` --- one of its many problems), there are no spurious _fluxes_ across immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L67. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/ImmersedBoundaries/conditional_fluxes.jl#L48. But I think the point here is that the fluxes are calculated using ""wrong gradients"". Note that `conditional_flux_fcc` doesn't shut down fluxes within ""X"" cells of a boundary. It shuts down fluxes _across_ an immersed boundary. I think this issue is proposing to use `conditional_flux_fcc` for a _different_ purpose than what it's used for now --- to nullify fluxes for biharmonic diffusion in a buffer region around the boundary. The reason is that biharmonic fluxes are not correct on interfaces within one cell width of an immersed boundary, because they involve second order operators?. It's a little unclear to me what the right thing to do here is --- @simone-silvestri can you clarify what mathematical model you would like to implement when we have biharmonic diffusion in the presence of immersed boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708:1112,down,down,1112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708,4,['down'],['down']
Availability,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591:61,mainten,maintenance,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591,2,['mainten'],['maintenance']
Availability,"I would suggest sticking with PAR rather than light.  PAR is very common in biogeochemistry and it is made up of specific bands of light and hence “light” and PAR aren’t exactly equivalent.  Calling it “light” could cause confusion if someone calculates PAR from the incoming solar radiation (light).; On Nov 18, 2022 at 3:07 PM +0000, Jago Strong-Wright ***@***.***>, wrote:; > @jagoosw commented on this pull request.; > In test/test_biogeochemistry.jl:; > > + wait(device(model.architecture), par_calculation); >; > +end; >; > +; >; > +biogeochemistry_parameters = (; >; > + growth_rate = 1/day,; >; > + light_limit = 3.5,; >; > + mortality_rate = 0.1/day,; >; > +; >; > + water_light_attenuation_coefficient = 0.12,; >; > + phytoplankton_light_attenuation_coefficient = 0.06,; >; > + phytoplankton_light_attenuation_exponent = 0.6,; >; > + surface_PAR = t -> 100*max(0.0, sin(t*π/(12hours))); >; > +); >; > +; >; > +biogeochemistry = SomethingBiogeochemistry(tracers = :P,; >; > + auxiliary_fields = :PAR,; >; > Makses sense, after I started I realised it was a bigger challenge than I thought it would be!; > I'll try and make these changes later.; > PAR stands for photosynthetically available radiation, perhaps it would be more clear to call it light here.; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513:1190,avail,available,1190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513,2,['avail'],['available']
Availability,"I'd be on board with assuming `AbstractField` elements must be lazily evaluated with `::Field` being a special no-op case. And with renaming `Computation` to `ComputedField`. > There should not be any `AbstractOperations.Average`. If there is, there is a bug. The constructors in the `AbstractOperations` module should simply provide new methods for `Diagnostics.Average`. Right I was referring to the `Average` methods defined in `AbstractOperations`. > For example, it could make sense to define a constructor for `Average` that works with `AbstractOperation` without specifying the `result` (where new memory is allocated for `result`, for example). The purpose of requiring `result` is to require users to explicitly allocate the memory they need --- but the interface may not be intuitive. Yeah I considered this as it seems like the most sensible solution but then instead of a useful error, users could end up allocating huge 3D arrays and run out of GPU memory (at which point it might be hard for them to figure out what they did wrong). > `Average` requires some kind of view or pointer to the data that needs to be average. Currently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. Hmmm, does it make sense to rename the `Average.field` property to `Average.kernel` in line with `WindowedTimeAverage` in PR #856?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674794622:891,error,error,891,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674794622,1,['error'],['error']
Availability,"I'd like to also two 2D examples. 1. rising thermal bubble and; 2. lid-driven cavity. as super simple examples. Their set up shouldn't take more than 10 lines excluding comments. > Dramatically simplify internal wave example. +1! Always good to simplify scripts as much as possible. Would also be nice to include it in the example tests (PR #418) if it can use something like `makeplot = false`. > Free decay of two dimensional turbulence (use x,y plane). Only issue with 2D xy-plane simulations is I think things are weird with `Nz=1` so I had to use `Nz=2` (see Taylor-Green vortex test in `test_dynamics.jl`). 1D and 2D models haven't been a priority unfortunately so this sort of stuff has cropped up. I think 2D xz and yz simulations are fine with `Ny=1` and `Nx=1` respectively. > Stratified Couette flow example. I can simplify the simulation script from PR #381 down to a 2D example. This one would be good. > I think we should split deepening mixed layer into a few examples. Sound like a good idea!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-533084378:870,down,down,870,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-533084378,1,['down'],['down']
Availability,"I'd like to compute a `Field` (ideally in order to write it to a NetCDF file) but only at every `N` grid points. Something like the following example, which tries to compute `u` at every 2 grid points in the vertical direction:. ```julia; using Oceananigans; grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid,); u_slices = Field(model.velocities.u, indices=(:, :, 1:2:grid.Nz)); ```. However, the above code fails since `Field` currently doesn't accept `StepRange`s as `indices`, just (I think) `UnitRange`s and `Int`s:. ```; ERROR: LoadError: MethodError: no method matching isinteger(::StepRange{Int64, Int64}). Closest candidates are:; isinteger(::Integer); @ Base number.jl:20; isinteger(::Complex); @ Base complex.jl:148; isinteger(::Rational); @ Base rational.jl:281; ... Stacktrace:; [1] validate_index(idx::StepRange{Int64, Int64}, loc::Center, topo::Bounded, N::Int64, H::Int64); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:196; [2] map (repeats 3 times); @ ./tuple.jl:318 [inlined]; [3] validate_indices(indices::Tuple{Colon, Colon, StepRange{Int64, Int64}}, loc::Tuple{DataType, DataType, DataType}, topo::Tuple{DataType, DataType, DataType}, sz::Tuple{Int64, Int64, Int64}, halo_sz::Tuple{Int64, Int64, Int64}); ```. Is there a workaround?. CC @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460:572,ERROR,ERROR,572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460,1,['ERROR'],['ERROR']
Availability,I'd like to eliminate `Δx` from the code because this grid metric is only valid on regular horizontal grids. This is why I did not extend `Δx` for `ImmersedBoundaryGrid` when I extended all of the other grid metrics here:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/ImmersedBoundaries/immersed_grid_metrics.jl. I was hoping that not including rogue metrics like `Δx` would facilitate in excising them from the code base. Where in `ShallowWaterModel` to you use `Δx`? I think in the stack trace for the error you received you should be able to locate where the problematic `Δx` is called.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-845306836:516,error,error,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-845306836,1,['error'],['error']
Availability,"I'd like to use the [Lambert W function](https://github.com/JuliaMath/LambertW.jl) in a `KernelFunctionOperation` but it doesn't seem to work on the GPU. Here's a MWE that works on the CPU:. ```julia; using Oceananigans; using Oceananigans.Grids: xnode, ynode; using CUDA: has_cuda_gpu; using LambertW: lambertw. arch = has_cuda_gpu() ? GPU() : CPU(); grid = RectilinearGrid(arch, size = (4, 4, 4), extent = (1,1,1)). @inline W(x, y) = lambertw((y/x)^2); @inline W(i, j, k, grid) = W(xnode(i, grid, Center()), ynode(j, grid, Center())); op = KernelFunctionOperation{Center, Center, Center}(W, grid); compute!(Field(op)); ```. When running on a GPU this throws a huge error message, that you can check in full [here](https://github.com/CliMA/Oceananigans.jl/files/14013534/error.txt), but here are the first few lines:. ```; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.AbstractOperations.gpu__compute!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Float64, typeof(W), Tuple{}}, ::Tuple{Colon, Colon, Colon}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438:667,error,error,667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I'll open a PR to add a test that covers this. ---. MWE:. ```julia; using Oceananigans; using Oceananigans.Solvers: ConjugateGradientPoissonSolver. grid = RectilinearGrid(; CPU(),; Float64,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0); ). ConjugateGradientPoissonSolver(grid); ```. Error:. ```; ERROR: UndefVarError: `ImmersedBoundaryGrid` not defined; Stacktrace:; [1] ConjugateGradientPoissonSolver(grid::RectilinearGrid{…}; preconditioner::Oceananigans.Solvers.DefaultPreconditioner, reltol::Float64, abstol::Float64, kw::@Kwargs{}); @ Oceananigans.Solvers ~/atdepth/Oceananigans.jl/src/Solvers/conjugate_gradient_poisson_solver.jl:54; [2] ConjugateGradientPoissonSolver(grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, CPU}); @ Oceananigans.Solvers ~/atdepth/Oceananigans.jl/src/Solvers/conjugate_gradient_poisson_solver.jl:47; [3] top-level scope; @ REPL[6]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3829:339,Error,Error,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3829,2,"['ERROR', 'Error']","['ERROR', 'Error']"
Availability,I'll try to get going with the MWE here. Is the immersed boundary acually part of the MWE (ie the error does not occur with it?) And buoyancy?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152782513:98,error,error,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152782513,1,['error'],['error']
Availability,"I'll wait till it's ready to review in detail, but my main high-level comment is that we need to ensure that, at the end of a time-step, both the prognostic state (horizontal velocities and tracers) and auxiliary state (pressure, vertical velocity, eddy diffusivities) are all consistent and available for output at the current model time. If we intertwine communication with the computation of the auxiliary state and tendencies, then we should _define_ the tendencies as part of the auxiliary state. This will change the semantics and logic of the time stepping loop. But I think it at least as rational as our previous organization of events. The main change is that tendencies will now be computed one ""extra"" time in a simulation (at the very last time-step, the tendencies are not needed if no further time-steps will be taken). In the vast majority of cases this extra cost is negligible because simulations run for hundreds or hundreds of thousands of time-steps. There is the slightly possibility of pessimizing the edge case of a simulation that takes one time step, which may be useful for parameter estimation. For that purpose we may want to avoid computing the ""extra"" tendency. I'm thinking though that we should save that additional optimization until we need it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452351616:292,avail,available,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452351616,1,['avail'],['available']
Availability,"I'm a bit stumped. The error is. ```; Test threw exception; --;   | Expression: advective_and_multiple_forcing(arch);   | TaskFailedException;   |  ;   | nested task error: BoundsError; ```. But I can't reproduce this locally. I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115. On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179:23,error,error,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092135179,3,['error'],['error']
Availability,"I'm also doubtful small round off errors in the timestep would be related, unless there a place in the code where the scheduled times for outputting / checkpointing need to exactly match some value. In the MWE, the problematic values look like they're all zeros. In our more complicated example, where the averaging interval is a large (decimal) multiple of the timestep, it's not clear if the values are underestimated because the velocities are of both signs so a biased average could go either way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2263839595:34,error,errors,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2263839595,4,"['checkpoint', 'error']","['checkpointing', 'errors']"
Availability,"I'm also wondering if it would be better to compute the discrete perturbation vorticity by calculating the initial vorticity analytically, storing it, and using it when we calculate the perturbation. The downside is that the perturbation will contain the noise in addition to the Bickley jet. But since the noise is small this may not be a big deal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882718585:204,down,downside,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882718585,1,['down'],['downside']
Availability,I'm closing this because it's unclear if it's still a concern... please open if it is. There are likely quite a few outstanding issues with checkpointing...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-1480294818:140,checkpoint,checkpointing,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-1480294818,1,['checkpoint'],['checkpointing']
Availability,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-1479827324:202,error,error,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-1479827324,46,['error'],['error']
Availability,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open. @simone-silvestri feel free to add info if you have it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1450#issuecomment-1479867412:202,error,error,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1450#issuecomment-1479867412,1,['error'],['error']
Availability,I'm detecting also a massive slow down in model execution and out of control allocations on the CPU. Type inference failure? Unfortunate to find it this late after the PRs are merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480454093:34,down,down,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480454093,2,"['down', 'failure']","['down', 'failure']"
Availability,"I'm encountering an odd behavior when creating a `NetCDFWriter`. In the example below `writer2` gets created successfully, but `writer1` does not. . ```julia; using Oceananigans. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities; indices = (1,:,:); slice1 = Field(u, indices=indices); slice2 = Field(u). writer2 = NetCDFOutputWriter(model, (; slice2,);; filename = ""mwe2.nc"",; schedule = TimeInterval(1),; overwrite_existing = true,; indices=indices,; ). writer1 = NetCDFOutputWriter(model, (; slice1,),; filename = ""mwe1.nc"",; schedule = TimeInterval(1),; overwrite_existing = true); ```. When running this I get this error:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497:746,error,error,746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I'm faced with an error when trying to `show()` a model with the `SmagorisnkyLilly()` closure:. ```julia; julia> grid = RectilinearGrid(CPU(), size=(1,1,1), extent=(1,1,1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> closure = SmagorinskyLilly(); SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0. julia> model = NonhydrostaticModel(grid=grid; closure=SmagorinskyLilly()); Error showing value of type NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2398:18,error,error,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398,2,"['Error', 'error']","['Error', 'error']"
Availability,"I'm facing an error that I'm not able to pinpoint. Running the following example on a CPU works, but I get an error on GPUs:. ```julia; using Oceananigans; using CUDA. arch = has_cuda_gpu() ? GPU() : CPU(). grid_base = RectilinearGrid(arch, size=(4, 4, 4), extent=(1, 1, 1)); bathymetry(x, y) = -0.5; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). noflux = FluxBoundaryCondition(0); b_bcs = FieldBoundaryConditions(immersed=noflux). model = NonhydrostaticModel(grid = grid,; buoyancy = BuoyancyTracer(),; tracers = :b,; boundary_conditions = (b=b_bcs,),; ). simulation = Simulation(model, Δt=1, stop_iteration=100); run!(simulation); ```. The error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gc!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gc!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, Nothing}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuDeviceMatrix{Float64, 1}}}, Nothing}, Val{1}, CenteredSecondOrder, Nothing, ImmersedBoundaryCondition{Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2558:14,error,error,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I'm finding that simulations with `VerticallyStretchedGrid`s don't get picked up and instead throw an error saying that the grid doesn't match. Here's a MWE:. ```julia; using Oceananigans. grid = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). model = NonhydrostaticModel(grid=grid). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:102,error,error,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,2,"['Checkpoint', 'error']","['Checkpointer', 'error']"
Availability,"I'm following the documentation so either we have a bug or the documentation needs to be clearer on how to use `JLD2OutputWriter` with named tuples. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)); model = Model(grid=grid); outputs = (u=model->model.velocities.u, T=model->model.tracers.T); model.output_writers[:jld2] = JLD2OutputWriter(model, outputs; frequency=1, prefix=""test"", verbose=true); time_step!(model; Δt=1, Nt=1); ```; produces; ```; [ Info: Calculating JLD2 output (:u, :T)...; ERROR: MethodError: Cannot `convert` an object of type Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} to an object of type Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} ; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:168; Stacktrace:; [1] setindex!(::Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}, ::Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol) at ./dict.jl:380; [2] Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}(::Base.Generator{Base.Iterators.Zip{Tuple{Tuple{Symbol,Symbol},Tu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/562:568,ERROR,ERROR,568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/562,1,['ERROR'],['ERROR']
Availability,"I'm getting a method error when I try to `set!` a function initial condition with an IBM grid on a GPU. The error:; ```; ERROR: MethodError: no method matching interior(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Tuple{DataType, DataType, DataType}, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBoundary{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Bool, 3, Array{Bool, 3}}, Bool, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}, CPU}); ```; Stack trace says this is the `interior` call that throws the error:. https://github.com/CliMA/Oceananigans.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547:21,error,error,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I'm getting an error when trying to compile constant Smagorinsky:. ```julia; ERROR: LoadError: InvalidIRError: compiling #12(RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Flo; at64},Base.TwicePrecision{Float64}}}, PlanetaryConstants{Float64}, LinearEquationOfState{Float64}, ConstantSmagorinsky{Fl; oat64}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global; }, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CU; DAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnat; ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.C; uDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDevi; ceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oce; ananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func)}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f__apply); Stacktrace:; [1] overdub at /data5/glwagner/.julia/packages/Cassette/xggAf/src/context.jl:260; [2] ν_ccc at /data5/glwagner/Projects/Oceananigans.jl/src/closures/constant_smagorinsky.jl:109; [3] ν_Σᵢⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:405; [4] ∂x_faa at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:64; [5] ∂x_2ν_Σ₁₁ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:409; [6] ∂ⱼ_2ν_Σ₁ⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:432; [7] calculate_interior_source_terms! at /data5/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:152; [8] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248:15,error,error,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I'm getting an error while running the following example on a GPU, it runs correctly on CPU though. It has a problem with the immersed boundary conditions, but the same BC on the normal boundary doesn't throw the error.; ```; using CUDA; using Oceananigans. arch = has_cuda_gpu() ? GPU() : CPU(); topo = [Flat, Periodic, Bounded] ; underlying_grid = RectilinearGrid(arch, size = (1,1), ; extent = (1, 1),; topology = topo). @inline slope(x, y) = -2.0*y; immersed_grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). z₀ = 1e-2 # Charnock roughness; κ = 0.4 # Von Karman constant; @inline Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2; const dz = 0.1. @inline bottom_drag_v(x, y, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); @inline bottom_drag_v(x, y, z, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); v_drag_bc = FluxBoundaryCondition(bottom_drag_v, field_dependencies=(:v, :w), parameters=Cᴰ(dz)); v_bcs = FieldBoundaryConditions(bottom=v_drag_bc, immersed=v_drag_bc). boundary_conditions = (; v = v_bcs,). model = NonhydrostaticModel(grid = immersed_grid, ; boundary_conditions = boundary_conditions). simulation = Simulation(model, Δt = 0.1, stop_time = 1.0); run!(simulation); ```; Error, truncated stack trace for length:. ```; GPU compilation of kernel gpu_calculate_Gv!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gv!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563:15,error,error,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563,2,['error'],['error']
Availability,"I'm getting results that are different from what I expected. Here's how I'm setting my grid, model and sponge:. ```; #-----; Lx = Ly = 16_000; Lz = 1_000; topology = (Periodic, Periodic, Bounded); factor = 1; grid = RegularCartesianGrid(size=(2048÷factor, 1, 256÷factor),; x=(0, Lx),; y=(0, 1),; z=(-Lz/2, +Lz/2),; topology=topology); #-----. #-----; ubc = UVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); vbc = VVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); wbc = WVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Value, 0),; top = BoundaryCondition(Value, 0),; ); bbc = TracerBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, N2),; top = BoundaryCondition(Gradient, N2),; ); #-----. #-----; # Set-up sponge layer; bottom_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bottom_mask, target=0); #----. model = IncompressibleModel(; architecture = GPU(),; grid = grid,; advection = UpwindBiasedThirdOrder(),; timestepper = :RungeKutta3,; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; coriolis = FPlane(f=f0),; tracers = (:b,),; buoyancy = BuoyancyTracer(),; boundary_conditions = (b=bbc, u=ubc, v=vbc, w=wbc),; forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge),; ```. From the docs, I expected this to ; > relax velocity fields to zero [...] in the bottom 1/10th of the domain. which leads me to believe that there's some a sharp cut-off in the function mask so that velocities above the range `[-500, -400]`aren't affected. However, when I plot the vertical velocities (and other variables with zero mean) I get the results below, which indicate that the sponge layer is active in the approximate range `[-500, -200]`, which is around 3 times larger than what I (thought I) set up. ![Screenshot from 2020-11-24 08-45-47](https://user-images.githubuserconte",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203:1181,mask,mask,1181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203,1,['mask'],['mask']
Availability,"I'm getting this error when trying to run my code on multiple GPUs (it works fine on CPUs):. ```julia; ERROR: LoadError: BoundsError: attempt to access Tuple{Vector{CuStream}} at index [2]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] (::Oceananigans.Architectures.var""#3#6"")(); @ Oceananigans.Architectures /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:26; [3] lock(f::Oceananigans.Architectures.var""#3#6"", l::ReentrantLock); @ Base ./lock.jl:185; [4] next_stream; @ /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:24 [inlined]; [5] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(1, 36)}, KernelAbstractions.NDIteration.StaticSize{(36, 1)}, typeof(Oceananigans.BoundaryConditions.gpu_fill_periodic_south_and_north_halo!)})(::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, ::Tuple{Int64, Int64}, ::typeof(Oceananigans.BoundaryConditions.fill_periodic_south_and_north_halo!), ::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{Int64}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /gl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185:17,error,error,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I'm gonna add to this:. 1. Avoid throwing a warning when initializing an output writer in ""pickup mode""; 2. Perhaps some way to check that a time-series is ""valid"" when appending to a file during pickup mode?. Here's an example that illustrates how 2 could work:. - During a big run, we record a checkpoint at iteration 1234.; - The run continues, saving high frequency output for iterations 1244 and 1254.; - The allocation ends and the most recent checkpoint is 1234. -- later --. - We restart the run from checkpoint 1234.; - When doing this, we observe that existing output writers have output for 1244 and 1254.; - This means that compatibility between the checkpointer and existing output writers _requires_ that the pickup simulation triggers output writing at 1244 and 1254 (which we can safely avoid, since it's redundant with the data already in the file. Conversely, if the pickup simulation does _not_ ask for output at these iterations, something is wrong (perhaps an invalid timeseries is being recorded). Similar to overriding `overwrite_existing`, implementing this feature basically makes the output writers ""pickup-aware"" (either after creation in `run!`, or via some environmental ""pickup mode"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544:296,checkpoint,checkpoint,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544,5,"['checkpoint', 'redundant']","['checkpoint', 'checkpointer', 'redundant']"
Availability,"I'm not familiar with the Oceananigans code writing practice, but it looks like the parameter `number_of_layers` is redundant as it is already present in `grid.Nz`. Is the parameter added in a case where the user inputs the number of layers explicitly?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469180135:116,redundant,redundant,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469180135,1,['redundant'],['redundant']
Availability,I'm not sure I agree with an error --- what do others think? It seems like you could do this intentionally and we wouldn't want to forbid that. But I don't feel strongly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126373167:29,error,error,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126373167,1,['error'],['error']
Availability,"I'm not sure I grasp the issue. @jagoosw it might help if you include a simple example (eg some code, and the error that gets produced) that illustrates the issue. > With indices=(:, :, :) we should be able to output any field. I agree with this. Is the problem associated with trying to ""remove halos"" from output? Does it go away when we write `with_halos=true`?. In addition to problems with `parent_index_range`, it looks like there is potentially a problem with the user API (in addition to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new feature",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520:110,error,error,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520,2,['error'],['error']
Availability,"I'm not sure if this is helpful, but I manually executed this line:. https://github.com/CliMA/Oceananigans.jl/blob/92791a962c9096746301cdb888a3050e32c4a58b/src/Utils/kernel_launching.jl#L97. and then this line:. https://github.com/CliMA/Oceananigans.jl/blob/92791a962c9096746301cdb888a3050e32c4a58b/src/Simulations/run.jl#L122. throws the following error, related to `KernelAbstractions` , but not related to the value of boundary_conditions:. ![oc_err_2](https://github.com/CliMA/Oceananigans.jl/assets/16384103/bd8fdedf-edcf-4ab0-ae2b-16a0ec3916c0). looks like the value `nothing` with functions that use `KernelAbstractions` seems to trip up the debugger",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622497165:349,error,error,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622497165,1,['error'],['error']
Availability,"I'm not sure if we're officially supporting Julia 1.6 yet, but I noticed that when I create a `Checkpointer` in Julia 1.6 things don't really work. All other output files are created normally (meaning for me NetCDF files) but the checkpoint never does and the simulation just hangs there. ```julia; Simulation{typename(IncompressibleModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (TimeStepWizard{Float64}): 2.747 seconds ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: 300.0; ├── Stop time: 7.272 days, stop iteration: Inf; ├── Diagnostics: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── nan_checker => typename(NaNChecker); └── Output writers: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── out_writer => typename(NetCDFOutputWriter); │ ├── vid_writer => typename(NetCDFOutputWriter); │ ├── avg_writer => typename(NetCDFOutputWriter); │ └── chk_writer => typename(Checkpointer). ---> Starting run!; ```. I waited for over 15 min but the next lines (which are supposed to be the progress messenger) never come up. Everything works normally when I revert back to Julia 1.5.3. . I don't have time to create a clean reproducible MWE at the moment, but I can do so later if needed. I just thought I should post this while it's fresh in my head.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547:95,Checkpoint,Checkpointer,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547,3,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint']"
Availability,"I'm not sure of the latest approaches/versions of POM and ROMS with the sigma coordinates, but the approach in our paper is similar in the sense that it is based on a general vertical coordinate change. But where ROMS and POM have a fixed distribution of points on a vertical (except for the effect of surface movement which moves points but not their relative position on the vertical), our approach allowed to move the points at any moment up or down depending on local features for example to increase resolution near the moving thermocline and differently for different horizontal positions. .As a special case you can of course have the original POM or ROMS version.; Hope it makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839754947:448,down,down,448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839754947,1,['down'],['down']
Availability,"I'm not sure this will run smoothly on Julia v1.6. E.g., on v1.6:. ```Julia; (Oceananigans) pkg> instantiate; ERROR: AssertionError: sourcepath !== nothing; Stacktrace:; [1] is_package_downloaded(ctx::Pkg.Types.Context, pkg::Pkg.Types.PackageSpec); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1789; [2] #13; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131 [inlined]; [3] _all; @ ./reduce.jl:923 [inlined]; [4] #all#698; @ ./reducedim.jl:886 [inlined]; [5] all; @ ./reducedim.jl:886 [inlined]; [6] is_instantiated(ctx::Pkg.Types.Context); @ Pkg.Operations ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:131; [7] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_build::Bool, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1358; [8] instantiate; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1325 [inlined]; [9] #instantiate#252; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321 [inlined]; [10] instantiate(); @ Pkg.API ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1321; [11] do_cmd!(command::Pkg.REPLMode.Command, repl::REPL.LineEditREPL); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:405; [12] do_cmd(repl::REPL.LineEditREPL, input::String; do_rethrow::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:386; [13] do_cmd; @ ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:377 [inlined]; [14] (::Pkg.REPLMode.var""#24#27""{REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::IOBuffer, ok::Bool); @ Pkg.REPLMode ~/julia/usr/share/julia/stdlib/v1.6/Pkg/src/REPLMode/REPLMode.jl:550; [15] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [16] invokelatest; @ ./essentials.jl:706 [inlined]; [17] run_interf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840:110,ERROR,ERROR,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090#issuecomment-984239840,1,['ERROR'],['ERROR']
Availability,"I'm not sure what's best. We're _assuming_ that iteration 0 is scheduled. I guess under ordinary circumstances, iteration 0 is scheduled for `IterationInterval` and `TimeInterval` --- though this need not always be true. Also we might argue that iteration 0 should not be scheduled automatically for `SpecifiedTimes`. Perhaps schedules themselves should somehow explicitly specify whether they should be actuated at iteration 0 or not. A downside of avoiding iteration 0 is that issues / bugs with a callback are not caught until first actuation. So it may be a sensible default to actuate at iteration 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961:438,down,downside,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961,1,['down'],['downside']
Availability,"I'm on an Apple Silicon M1:. ```Julia; julia> versioninfo(); Julia Version 1.9.3; Commit bed2cd540a (2023-08-24 14:43 UTC); Build Info:. Note: This is an unofficial build, please report bugs to the project; responsible for this build and not to the Julia project unless you can; reproduce the issue using official builds available at https://julialang.org/downloads. Platform Info:; OS: macOS (arm64-apple-darwin22.6.0); CPU: 10 × Apple M1 Max; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-14.0.6 (ORCJIT, apple-m1); Threads: 8 on 8 virtual cores; Environment:; JULIA_EDITOR = code; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804781556:321,avail,available,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1804781556,2,"['avail', 'down']","['available', 'downloads']"
Availability,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:33,down,down,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081,2,['down'],['down']
Availability,"I'm sort of glad to see @glwagner is verifying the issues we first discussed last year. My 2 cents: . - Small errors in the BC eventually propagating to the whole simulation is unavoidable; this is a well mixed flow. Checking on integrated quantities, such as maintaining conserved properties or matching the expected global dissipation rate, is a more achievable and important goal. ; - Using a test case with some stronger pressure gradients along the boundary would be good as well since this induces much of the error. The circle @wenegrat suggests is the classic, but you might be able to find a more subtle case which is more relevant to your application. Perhaps turbulent flow in a wavy-wall channel? Linking the amplitude of the waves to the change in turbulent statistics seems pretty well aligned with your application (though I could be wrong).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-855362669:110,error,errors,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-855362669,2,['error'],"['error', 'errors']"
Availability,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:152,error,error,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590,2,"['error', 'toler']","['error', 'tolerance']"
Availability,"I'm trying to add some particles to a hydrostatic model on a lat-lon grid, but ran into some CUDA memory issues. After reducing down to a MWE I noticed that it also segfaults on the CPU. The MWE seems to be sensitive to the exact grid. Some lat-lon ranges lead to illegal memory accesses and others do not. I could not find a pattern though. On the CPU the segfault seems to occur after ~2 iterations. On the GPU after ~29 iterations. The particles are initialized within the domain and without any dynamics the particles should stay perfectly still. So I'm not sure where the illegal memory access is happening, but should be easy to debug on the CPU?. MWE:. ```julia; using Oceananigans; using Oceananigans.Architectures: on_architecture. arch = GPU(). H = 100. Nλ = 100; Nφ = 200; Nz = 60. grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (Nλ, Nφ, Nz),; longitude = (0.79, 1.23),; latitude = (-1.96, -1.12),; z = (-H, 0),; halo = (4, 4, 4); ). Np = 100 # Number of particles. particles = LagrangianParticles(; x = on_architecture(arch, 1 * ones(Np)),; y = on_architecture(arch, -1.5 * ones(Np)),; z = on_architecture(arch, -H/10 .* ones(Np)); ). model = HydrostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:128,down,down,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['down'],['down']
Availability,"I'm trying to build the docs locally because I want to resolve https://github.com/CliMA/Oceananigans.jl/issues/1478. I followed the instructions in [the docs](https://clima.github.io/OceananigansDocumentation/stable/contributing/#Documentation) but I'm not able to generate `index.html`. Here's a pastebin with the first few errors that appear: https://pastebin.com/25A8SqeX. It looks like the doc generator is comparing the actual output with some expected output? Is that something the docs should do?. Anyway, I've never built julia docs before so I'm kinda unfamiliar with this. Help is appreciated!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1542:325,error,errors,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1542,1,['error'],['errors']
Availability,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1281:223,error,errors,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281,4,"['Avail', 'error']","['Available', 'errors']"
Availability,"I'm trying to run a simulation that has both forcings and some auxiliary variables which get updated with every time-step. However, I found that just the existence of a variable in the `auxiliary_fields`, coupled with a forcing function where parameters are included, makes the simulation fail on the GPU. Here's a MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(4, 4, 4), extent = (1, 1, 1)). @inline forc_u(x, y, z, t, u) = x. model = NonhydrostaticModel(; grid, forcing = (; u=Forcing(forc_u, field_dependencies = :u)),; auxiliary_fields = (; a=0)); @show model.forcing model.auxiliary_fields; time_step!(model, 1); ```. the above runs fine on the CPU but fails on the GPU with:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025:712,ERROR,ERROR,712,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025,1,['ERROR'],['ERROR']
Availability,"I'm trying to run the hot bubble example but using a GPU. However I get an error when defining the model that I cannot understand (the caveat here being that I have zero experience working with GPUs). The minimum code to reproduce this is. ```; using Oceananigans; model = BasicModel(N=(256, 1, 256), L=(2000, 1, 2000), architecture=GPU(), ν=4e-2, κ=4e-2); ```. This is the error that I get:. ```; ERROR: LoadError: Device capability v2.1.0 not supported by available toolchain; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] supported_capability(::CUDAdrv.CuDevice) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/utils.jl:7; [3] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:388 [inlined]; [4] #cufunction#176(::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(CUDAnative.cufunction), ::getfield(GPUArrays, Symbol(""##23#24"")), ::Type{Tuple{CuArrays.CuKernelState,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}}) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [5] cufunction(::Function, ::Type) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [6] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:174 [inlined]; [7] macro expansion at ./gcutils.jl:87 [inlined]; [8] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:171 [inlined]; [9] _gpu_call(::CuArrays.CuArrayBackend, ::Function, ::CuArrays.CuArray{Float64,3}, ::Tuple{CuArrays.CuArray{Float64,3},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}, ::Tuple{Tuple{Int64},Tuple{Int64}}) at /home/tomaschor/.julia/packages/CuArrays/wXQp8/src/gpuarray_interface.jl:60; [10] gpu_call(::Function, ::CuArrays.CuArray{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/451:75,error,error,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451,6,"['ERROR', 'avail', 'error']","['ERROR', 'available', 'error']"
Availability,"I'm trying to run the near global shallow water model and having difficulties with the latitude longitude grid. The line that calls it is here. https://github.com/CliMA/Oceananigans.jl/blob/5ba82e5786d1b7725d6bfa3e45072d2f6fad487a/validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl#L95. And the error that I get is the following,. ```; julia> include(""near_global_shallow_water_quarter_degree.jl""); ┌ Warning: Over-writing registration of the datadep; │ name = ""quarter_degree_near_global_lat_lon""; └ @ DataDeps ~/.julia/packages/DataDeps/Y2lje/src/registration.jl:15; ERROR: LoadError: UndefVarError: `Nλ` not defined; Stacktrace:; [1] validate_lat_lon_grid_args(topology::Tuple{…}, size::Tuple{…}, halo::Tuple{…}, FT::Type, latitude::Tuple{…}, longitude::Tuple{…}, z::Nothing, precompute_metrics::Bool); @ Oceananigans.Grids ~/Software/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:257; [2] LatitudeLongitudeGrid(architecture::GPU, FT::DataType; size::Tuple{…}, longitude::Tuple{…}, latitude::Tuple{…}, z::Nothing, radius::Float64, topology::Tuple{…}, precompute_metrics::Bool, halo::Tuple{…}); @ Oceananigans.Grids ~/Software/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:189; [3] macro expansion; @ show.jl:1181 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl:95; [5] include(fname::String); @ Base.MainInclude ./client.jl:489; [6] top-level scope; @ REPL[70]:1; [7] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl:95; Some type information was truncated. Use `show(err)` to see complete types.; ```. Should the lat-lon grid be able to handle flat in the vertical? @simone-silvestri, maybe this is something you tried to fix the last time we chatted?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1972247275:319,error,error,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1972247275,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I'm trying to time the performance of this branch but I'm getting a out-of-bounds error when running my simulations on GPUs (haven't tried them on CPUs). I can reproduce it using the MWE below and I'm pretty sure it's related to the stretched grid:. ```julia; using Oceananigans.Units; using CUDA; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. if has_cuda_gpu(); arch = GPU(); else; arch = CPU(); end. grid_base = RectilinearGrid(arch,; size=(4, 4, 4),; x=(0, 1), y=(0,1),; z=0:0.25:1,; halo=(3,3,3),; ). bathymetry(x, y) = grid_base.Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). model = NonhydrostaticModel(grid = grid,; advection = WENO5(grid_base),; ). using Oceanostics: TimedProgressMessenger; simulation = Simulation(model, Δt=1,; stop_iteration=10,; ); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1162289700:82,error,error,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1162289700,1,['error'],['error']
Availability,"I'm trying to validate a tilted bottom boundary layer example for https://github.com/CliMA/Oceananigans.jl/pull/1242 and I'm trying to use a `VerticallyStretchedGrid` to save computational resource (since I'm trying to do it on my laptop). I noticed that the simulation fails when using the `TimeStepWizard`:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::Array{Float64,3}, ::Array{Float64,3}, ::Array{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}) at /home/tomas/repos2/Oceananigans.jl/src/Utils/cell_advection_timescale.jl:9; [3] cell_advection_timescale(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1465:320,ERROR,ERROR,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465,1,['ERROR'],['ERROR']
Availability,"I'm using v0.68.6, previously I was on v0.67.1 and saw the same error (not surprising). I was hoping to use a stretched x-grid with a stretched z-grid while I play around with some 2D internal wave simulations. I'm still new to Julia and Oceananigans so I've been trying to simulate the classic vertically oscillating sphere or cylinder as my source. I was playing around with refining the mesh near the oscillation to see if the wave beams were a little cleaner. I can make due with stretched z-grids for now!. --; Regarding the `MethodError`, and while I am new to Julia, but maybe in this case a `NotImplementedError` would work better? I find Julia's stacktraces a bit long winded because of multi-dispatch and I obviously didn't figure out that variable grid spacing is only implemented for the vertical coordinate for the pressure solver. But getting a `NotImplementedError` when I tried would have been painfully obvious even to me. :-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023289047:64,error,error,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023289047,1,['error'],['error']
Availability,"I'm wondering if it might be a bit much to put docstrings on every single `AbstractGridMetric` for this experimental feature? They aren't exported so not user-facing (I think we may end up using this internally only for things like `IntegratedField` down the line). But I can copy paste the PR comment into the docstring for \Delta z as an example. Note that `GridMetricOperation` is used internally only, it's really the instances `\Delta z`, etc that are meant to be combined in `AbstractOperations`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826007063:250,down,down,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826007063,1,['down'],['down']
Availability,"I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. There's a few other things that are required to get things working on GPUs --- for example, Oceananigans must be _built_ (not just run) with a GPU / CUDA installation available; this is a common pitfall on clusters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711:218,error,errors,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711,2,"['avail', 'error']","['available', 'errors']"
Availability,I'm wondering whether the errors in the `gpu simulation tests` group are related to Tullio.jl. Seems like only `Tullio#master` mentions/uses `CUDAKernels`... https://github.com/mcabbott/Tullio.jl/commit/d3c4fde63c37ebae31b6d13413531a3a9241d59c,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-822144443:26,error,errors,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-822144443,1,['error'],['errors']
Availability,"I've been facing an error using CUDA versions 3.10 and up that's been very hard for me to pinpoint. . It's pretty hard to come up with a _truly minimum_ working example in this case because the error doesn't happen every time, which slows down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,5,"['down', 'error']","['down', 'error']"
Availability,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2445:188,error,error,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I've been using `FieldTimeSeries` a lot over the last few weeks and have noticed a couple of issues calculating means and constructing operations on them. First, `mean` with `dims` only calculates it on the first time index (I think). For example, if I do `mean(f, dims = (1, 2, 3))` it returns a size `[1, 1, 1]` array vs calculating `mean(interior(f), dims = (1, 2, 3))` which returns a `[1, 1, 1, Nt]` array. I suspect it is also calculating means with no dimensions specified incorrectly. Second, constructing operators on field time series fails and returns operators with dimensions `[Nx, Ny, Nz]` which if you then try and index into fails as it tries to index into the underlying fields which have a time dimension. For example, `speed = √(u^2 + v^2 + w^2)` gives `speed` with size `[Nx, Ny, Nz]`, if I then try and index at `[1, 1, 1]` it throws a bounds error trying to access `Nx x Ny x Nz x Nt` array at `1, 1, 1`. Neither of these is particularly important but thought I would document in case anyone else has issues, and because I will try and fix them at some point. For reference, I am currently getting around this by calculating means on the interior (which I think would produce the wrong results with immersed boundaries because it wouldn't have the masking step), and by just calculating arrays like `speed = √(interior(u)^2 + interior(v)^2 + interior(w)^2)` which doesn't lose me too much performance since I end up indexing into the whole array anyway.; ```[tasklist]; ### Tasks; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144:864,error,error,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144,2,"['error', 'mask']","['error', 'masking']"
Availability,"I've been using `WindowedTimeAverage`s for my simulations (by setting `schedule = AveragedTimeInterval(...)` in a `NetCDFOutputWriter`). I noticed that whenever I run out of walltime and have to checkpoint my simulations, when I pick them up again I get the following warning for each of the time-averaged outputs:. ```; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters /glade/work/tomasc/.julia/packages/Oceananigans/3LHMs/src/OutputWriters/windowed_time_average.jl:201; ```; (which comes from [this call](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/src/OutputWriters/windowed_time_average.jl#L196-L204).). Does this mean that the time averages aren't being correctly calculated after picking up? I tried following the trail to figure it out but couldn't determine the answer...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3485:195,checkpoint,checkpoint,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485,1,['checkpoint'],['checkpoint']
Availability,"I've got the mode-1 internal wave case working now. Axes are in units of depth (h) and k is set to $\pi$/h, top panel is `u`, middle is `w`, and bottom is `b`. First the periodic case:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/324a7a29-097e-4732-b324-afce808b752e. As expected numerical error reflects off the boundary if we just prescribe the boundary values:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/738bd33f-b813-45f7-b96a-74a25dd631cb. And with quite a small sponge (red lines in top plot) this is pretty much resolved:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/d1af93fb-8efc-47a3-abdc-463224e366db. Note/update:. Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794:303,error,error,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794,6,['error'],['error']
Availability,"I've gotten the transforms taken care of, but now the baroclinic_adjustment example fails with ; ```; $ julia --project=. baroclinic_adjustment.jl ; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex; @ ~/.julia/packages/GPUArrays/dAUOE/src/host/indexing.jl:48 [inlined]; [4] scalar_getindex(::ROCArray{Float64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, ::Int64, ::Vararg{Int64}); @ GPUArrays ~/.julia/packages/GPUArrays/dAUOE/src/host/indexing.jl:34; [5] _getindex; @ ~/.julia/packages/GPUArrays/dAUOE/src/host/indexing.jl:17 [inlined]; [6] getindex; @ ~/.julia/packages/GPUArrays/dAUOE/src/host/indexing.jl:15 [inlined]; [7] getindex; @ ./subarray.jl:288 [inlined]; [8] macro expansion; @ ./multidimensional.jl:917 [inlined]; [9] macro expansion; @ ./cartesian.jl:64 [inlined]; [10] macro expansion; @ ./multidimensional.jl:912 [inlined]; [11] _unsafe_getindex!; @ ./multidimensional.jl:925 [inlined]; [12] _unsafe_getindex(::IndexCartesian, ::SubArray{Float64, 3, ROCArray{Float64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::Int64, ::Base.Slice{Base.OneTo{Int64}}, ::Base.Slice{Base.OneTo{Int64}}); @ Base ./multidimensional.jl:903; [13] _getindex; @ ./multidimensional.jl:889 [inlined]; [14] getindex(::SubArray{Float64, 3, ROCArray{Float64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::Int64, ::Function, ::Function); @ Base ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1947171608:149,ERROR,ERROR,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1947171608,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,I've just got this error again on 0.84.1 so I don't think this is Oceananigans related so will close this issue for now,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189#issuecomment-1638382659:19,error,error,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189#issuecomment-1638382659,1,['error'],['error']
Availability,I've made this mistake many times haha. Seems like it might be good to add a warning telling users they probably meant to pass in a `ComputedField` since the error isn't super useful and only shows up when you call `run!`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762926304:158,error,error,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762926304,1,['error'],['error']
Availability,"I've modified the plotting to show both the total vorticity and the perturbation vorticity. I find this is useful for showing the most unstable mode. When I set the perturbation to zero, the perturbation vorticity is really the error in the numerical method. . I have increased the resolution and find that the error only increases linearly, and not quadratically. See below. Any idea why we are not getting quadratic convergence?. ```; Nx Error; --- -----; 64 0.092; 128 0.048; 256 0.024; 512 0.012; 1024 0.006. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760950751:228,error,error,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760950751,3,"['Error', 'error']","['Error', 'error']"
Availability,"I've noticed that Oceananigans is _much_ slower when using forcing functions. As an example, I set-up a simulation without any forcing functions and I noticed that in the first minute (wall time) of the running simulation I complete 3.5% of the whole simulation period. However, if I include forcing functions as; ```julia; bot_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bot_mask, target=0); forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge); ```; then in the first (wall time) minute of running I complete only 0.15% of the simulation. Basically around 20 times slower!. I of course expected a slowdown after including forcing functions, but not by this much. Is this normal behavior?. So far I ran my tests only on CPUs, but I've observed similar behaviors on GPUs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827:442,mask,mask,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827,1,['mask'],['mask']
Availability,"I've ran several different simulations with this branch and a majority (but curiously not all of them) failed with the following error:. `ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`. An older version of this branch doesn't show this error and instead runs fine for all simulations. I couldn't figure out what happened yet (or why some runs failed but others didn't) so I couldn't create a MWE yet, but I thought I'd report this in case someone can understand this better than me. Here's a [more complete error log](https://pastebin.com/dCbBAgKp) (although it's only about 5% of the full log since the last few lines repeat many many times).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296:129,error,error,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296,5,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I've received an error possibly related to the preconditioner, and it appears when I set the initial condition, e.g., `set!(model, u=uᵢ)`:; ```; ERROR: MethodError: no method matching cpu_fourier_tridiagonal_preconditioner_rhs!(::KernelAbstractions.CompilerMetadata{…}, ::Array{…}, ::Oceananigans.Grids.ZDirection, ::Field{…}). Closest candidates are:; cpu_fourier_tridiagonal_preconditioner_rhs!(::Any, ::Any, ::Oceananigans.Grids.ZDirection, ::Any, ::Any); @ Oceananigans none:0; cpu_fourier_tridiagonal_preconditioner_rhs!(::Any, ::Any, ::Oceananigans.Grids.YDirection, ::Any, ::Any); @ Oceananigans none:0; cpu_fourier_tridiagonal_preconditioner_rhs!(::Any, ::Any, ::Oceananigans.Grids.XDirection, ::Any, ::Any); @ Oceananigans none:0. Stacktrace:; [1] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; [2] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; [3] (::KernelAbstractions.Kernel{…})(::Array{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; [4] (::KernelAbstractions.Kernel{…})(::Array{…}, ::Vararg{…}); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; [5] #_launch!#12; @ ~/.julia/packages/Oceananigans/HPOLD/src/Utils/kernel_launching.jl:286 [inlined]; [6] _launch!; @ ~/.julia/packages/Oceananigans/HPOLD/src/Utils/kernel_launching.jl:268 [inlined]; [7] launch!; @ ~/.julia/packages/Oceananigans/HPOLD/src/Utils/kernel_launching.jl:251 [inlined]; [8] compute_precondition",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3896:17,error,error,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3896,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I've retried the tests a couple of times but I keep getting errors like this:. ```; Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/data5/glwagner/.julia-16001/compiled/v1.10/Oceananigans/jl_Bzx0zi"".; ERROR: LoadError: SystemError: opening file ""/data5/glwagner/.julia-16001/packages/CUDA_Runtime_jll/dOYZJ/.pkg/platform_augmentation.jl"": No such file or directory; ```. Is something wrong with the servers at the moment?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3623#issuecomment-2179086381:60,error,errors,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3623#issuecomment-2179086381,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,"I've worked out where my problem is coming from. For the wall-normal velocity: first, we compute and apply the tendencies from 1:N face points, then compute the pressure correction at 1:N center points, then fill the boundary points at 1 and N+1, and apply it at 1:N face points (except the gradient is zero across the 1 face point so this doesn't do anything to the boundary. The N+1 boundary point is fine because we can just set it to anything, or time integrate something at the point since nothing else effects its value. The same is true if we prescribe a value at the 1 face point because (even though we redundantly integrate the tendencies there) it just gets reset to whatever we want. The problem is if we try to integrate something like a radiation condition there then we actually end up with $u(1, j, k) = \int (G_u + B_u) dt$ where $B_u$ is whatever integration we're trying to do at the boundary. On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that than to think of a different way todo it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2387806695:612,redundant,redundantly,612,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2387806695,1,['redundant'],['redundantly']
Availability,"ILED); Stacktrace:; [1] throw_api_error(res::CUDA.CUBLAS.cublasStatus_t); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:11; [2] macro expansion; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:24 [inlined]; [3] cublasDnrm2_v2(handle::Ptr{CUDA.CUBLAS.cublasContext}, n::Int64, x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, incx::Int64, result::Base.RefValue{Float64}); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/utils/call.jl:26; [4] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:168 [inlined]; [5] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:173 [inlined]; [6] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:108 [inlined]; [7] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:107 [inlined]; [8] cg_iterator!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Pl::Oceananigans.Solvers.SparseInversePreconditioner{CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}}; abstol::Float64, reltol::Float64, maxiter::Int64, statevars::IterativeSolvers.CGStateVariables{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, initially_zero::Bool); @ IterativeSolvers ~/.julia-10861/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [9] cg!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abstol::Float64, reltol::Float64, maxiter::Int64, log::Bool, statevars::IterativeSolvers.CGStateVariables{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, verbose::Bool, Pl::Oceananigans.Solvers.SparseInversePreconditioner{CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}}, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ IterativeSolvers ~/.julia-10861/packages/IterativeSolvers/rhYBz/src/cg.jl:224; ```. But in particular the nrm2 error we are having trouble reproducing locally.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526:2655,error,error,2655,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526,1,['error'],['error']
Availability,"If I understood correctly, I think that @glwagner just wanted to have the code directly pasted here. ```julia; using Oceananigans; using Oceananigans.Units; using Printf. Ns = 200 # number of time saves; T = 7200 # simulation stop time (s); Δt = 1 # timestep (s). grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)). model = NonhydrostaticModel(; grid, timestepper=:RungeKutta3). simulation = Simulation(model; Δt, stop_time = T). progress_message(sim) = @printf(""Iteration: %03d, time: %s, Δt: %s, wall time: %s\n"",; 	iteration(sim), prettytime(sim), prettytime(sim.Δt), prettytime(sim.run_wall_time)). simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(T/Ns)). dir = ""output/test_MWE"". ## checkpoint ; simulation.output_writers[:checkpointer] = Checkpointer(; model,; schedule=TimeInterval(T),; dir=dir,; prefix=string(""checkpoint""),; cleanup=false); file = string(dir,""/checkpoint_iteration3600.jld2""); run!(simulation,pickup=file); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2245598464:723,checkpoint,checkpoint,723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2245598464,4,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint', 'checkpointer']"
Availability,"If everyone's okay with this, I'll register a new version after merging since I'd say this bug is important (it throws an error every time value or gradient BCs are applied to IBMs).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2551#issuecomment-1126149856:122,error,error,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2551#issuecomment-1126149856,1,['error'],['error']
Availability,"If the slow down is the same for `DiscreteForcing` then the problem may really just be evaluating `exp`, sadly... You could try `@inline bottom_mask(k) = 1` to test...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875672252:12,down,down,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875672252,1,['down'],['down']
Availability,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:10,mask,masking,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683,6,['mask'],['masking']
Availability,"If we wanted to quantify the difference, we can simply find an exact solution and simulate it and compute the error. There are lots of examples to choose from.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-876063266:110,error,error,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-876063266,2,['error'],['error']
Availability,"If you clone only the master branch, you will see that it is quite clean:. ```bash; $ git clone https://github.com/climate-machine/Oceananigans.jl.git --single-branch; Cloning into 'Oceananigans.jl'...; remote: Enumerating objects: 19, done.; remote: Counting objects: 100% (19/19), done.; remote: Compressing objects: 100% (19/19), done.; remote: Total 12346 (delta 0), reused 19 (delta 0), pack-reused 12327; Receiving objects: 100% (12346/12346), 10.25 MiB | 1.02 MiB/s, done.; Resolving deltas: 100% (8872/8872), done.; ```. ```bash; $ du -sh Oceananigans.jl/.git; 12M	Oceananigans.jl/.git; ```. So only 12M of (compressed) files are downloaded. On the other hand, cloning the documentation branch `gh-pages` downloads 117 M:. ```bash; $ git clone https://github.com/climate-machine/Oceananigans.jl.git --single-branch --branch=gh-pages; Cloning into 'Oceananigans.jl'...; remote: Enumerating objects: 4040, done.; remote: Total 4040 (delta 0), reused 0 (delta 0), pack-reused 4040; Receiving objects: 100% (4040/4040), 117.40 MiB | 6.62 MiB/s, done.; Resolving deltas: 100% (1819/1819), done.; ```. So this is nothing to worry too much about :-) A simple non-disruptive solution is to change your hosting solution for the docs to use something other than the main git repository, and to delete the `gh-pages` branch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-554172631:638,down,downloaded,638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-554172631,2,['down'],"['downloaded', 'downloads']"
Availability,"If you download data on the login node it should work, because DataDeps doesn't need to download if the file is present",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928250982:7,down,download,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928250982,2,['down'],['download']
Availability,If you encounter the error @tomchor please reopen this issue!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116713258:21,error,error,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116713258,1,['error'],['error']
Availability,"If you use the same script for checkpointing and pickup (i.e. you just keep running the same script) then `run!(simulation, pickup=true)` will fail the first time:. ```julia; julia> using Oceananigans;; julia> grid = RegularCartesianGrid(size=(100, 100, 50), extent=(2π, 2π, 1));; julia> model = IncompressibleModel(grid=grid);; julia> simulation = Simulation(model, Δt=60, stop_time=60); julia> run!(simulation, pickup=true); ```. ```; ERROR: No checkpointers found: cannot pickup simulation!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] checkpoint_path(::Bool, ::Array{Oceananigans.AbstractOutputWriter,1}) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:158; [3] run!(::Simulation{IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1159:31,checkpoint,checkpointing,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159,5,"['ERROR', 'checkpoint', 'error']","['ERROR', 'checkpointers', 'checkpointing', 'error']"
Availability,"If you want to give it a try it's cool, I just tried reviving this branch which was a bit stale so probably there are going to be some errors to fix. There are mainly four files that deal with the distributed Poisson solver.; The distributed FFT implementation is in ; `DistributedComputations/distributed_fft_based_poisson_solver.jl` where the plan setup is in `DistributedComputations/plan_distributed_transforms.jl`. The transpose is defined in `DistributedComputations/transpose_parallel_fields.jl` and its setup is in `DistributedComputations/parallel_fields.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1986288526:135,error,errors,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1986288526,1,['error'],['errors']
Availability,"Implementing a vertically stretched grid (see PR #543) involves adding new Poisson solvers. This offers us a chance to:; 1. refactor the Poisson solvers into a more flexible API,; 2. support triply periodic and 3D box domains,; 3. unite some of the CPU and GPU Poisson solvers,; 4. reuse the Poisson solvers to implicitly time-step diffusion (vertically and possibly in 3D) in the future, and; 5. slide in (or dispatch on) a distributed pressure solve for distributed/MPI models without having to modify the time stepping code for regular models in the future. I am just throwing down some notes and ideas in this issue. This table summarizes the different boundary conditions and grids we may want to simulate, and the Poisson solver algorithm we would need. | Boundary conditions | Grid | Solver | Alternatives |; |----------------------|-----------------------|:-----------:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:580,down,down,580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,1,['down'],['down']
Availability,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/732:205,error,error,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732,3,"['Error', 'error']","['Error', 'error']"
Availability,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/942:326,toler,tolerance,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942,2,['toler'],['tolerance']
Availability,"In addition to the bounded-x error above, interpolation methods also appear to be failing at times:. ```julia; using Oceananigans. grid_base = RectilinearGrid(size=(4, 4, 4), extent = (1,1,1)); grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); @info grid. model = NonhydrostaticModel(grid = grid); @info """" model. u, v, w = model.velocities. ω_x = Field((@at (Center, Face, Face) ∂y(w)-∂z(v))); ```. This throws me the following error:. ```; ERROR: LoadError: MethodError: no method matching interpolate_index(::Tuple{Colon, Colon, Colon}, ::Colon, ::Type{Center}, ::Type{Center}); Closest candidates are:; interpolate_index(::UnitRange, ::Colon, ::Any, ::Any) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:80; interpolate_index(::Colon, ::Colon, ::Any...) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:77; interpolate_index(::Colon, ::UnitRange, ::Any...) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:78; ...; Stacktrace:; [1] interpolate_indices(::Oceananigans.AbstractOperations.Derivative{Center, Face, Face, typeof(Oceananigans.Operators.∂yᶜᶠᶠ), Field{Center, Center, Face, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, St",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303864523:29,error,error,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303864523,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"In all the scripts I found on distributed simulations, we seem to query the MPI state using `COMM_WORLD`, eg:. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L74. and. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L59-L60. But `Distributed` allows the `communicator` to be set, so `arch.communicator` can be something other than `COMM_WORLD`, eg. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/src/DistributedComputations/distributed_architectures.jl#L60-L66. Presumably we should never write scripts that make assumptions about the communicator (and we should strongly discourage users from doing so). So first of all the validation scripts must be changed. Secondly, I think something that could encouarge clean and good practices would be to extend functions like `Comm_rank` to `arch::Distributed` and possibly to the `grid` as well, so that we can call:. ```julia; rank = MPI.Comm_rank(arch); rank = MPI.Comm_rank(grid); Nranks = MPI.Comm_size(arch); ```. We'd have the option of throwing an error when non-distributed, or returning some sensible fallback like `Comm_rank(arch) = 0` and `Comm_size(arch) = 1`. Alternatively, we can develop our own API, since the MPI-based one is rather irregular and abbreviated, thus difficult for newbies to understand (I've been in this boat...). For example, perhaps simply `Base.size` and `rank` would suffice:. ```julia; Base.size(arch::Distributed) = MPI.Comm_size(arch.communicator); Base.size(arch::AbstractArchitecture) = 1; ```. ```julia; rank(arch::Distributed) = MPI.Comm_rank(arch.communicator); rank(arch::AbstractArchitecture) = 0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3318:1286,error,error,1286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318,1,['error'],['error']
Availability,"In another code that made an animation I found the following lines of code. ```; iter = Node(0); ζ′ = @lift file[""timeseries/ζ/"" * string($iter)][:, :, 1]; ```. which was used as one of the earlier steps of making an animation. Since `Node` no longer exists, and we should be using `Observable`, I have tried the following to read in a file, or a place holder of a file I suppose. ```. iter = Observable(0); iters = parse.(Int, keys(file[""timeseries/t""])); ζ′ = file[""timeseries/ζ/"" * string($iter)][:, :, 1]. ```. Unfortunately, the syntax is wrong and I get an error saying `RROR: syntax: ""$"" expression outside quote around`. . Does someone know what the correct syntax should be?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126801203:563,error,error,563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126801203,1,['error'],['error']
Availability,"In case we have reductions on a function (e.g `maximum(abs, f, condition = (i, j, k, f.grid, f) -> i < 3)`) we want to be able to apply the function to the field _first_ and mask the field where `condition = true` _after_. _to be more specific:_; When a reduction is called with a function as an argument such as; ```; sum(sin, a::AbstractField); ```; the function will be evaluated element-wise with `mapreduce`. i.e., the function is applied _first_ and the reduction is applied _after_; ```; mapreduce(x -> sin(x), +, a); ```; For this reason the `neutral_element` of a ""functional"" reduction is not the `neutral_element` of its basic operation (as we implemented) but the neutral element of `basic_operation(f())`. The neutral element is found by inverting this operation `f⁻¹(neutral_element(basic_operation))` In the example above it would be; ```; neutral_element = sin⁻¹(neutral_element(+)) = sin⁻¹(0); ```. In principle, we should mask the field with `f⁻¹(neutral_element(reduction))` so that applying `f` and then the reduction would effectively exclude the masked areas. Unfortunately, we do not know a-priori the inverse of the function. Therefore, this PR implements a workaround:. - `ConditionalOperation` has now a property `func`, which is a unary function applied to the elements of `operand` in `Base.getindex`; - functional reductions are implemented as `sum(f, c; condition) = sum(identity, conditional_operand(f, c, condition))` . this PR also introduces a docstring and a `show` method for `ConditionalOperation` ; closes #2188",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2200:174,mask,mask,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200,3,['mask'],"['mask', 'masked']"
Availability,"In my attempt to study inertial instability I have two versions of the code. 1. Takes the solution to be a sum of the background and the perturbations, and **evolves the total** field. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/NoDecomposition/Bickley_Gaussian_jet_total.jl); 2. Stores the basic state in `BackgroundField` and **evolves the perturbation**, like the Eady problem. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/Bickley_Gaussian_jet.jl). Actually, the first one uses `BackgroundField` for the background stratification, but not for the jet. Since evolving a solution that uses `BackgroundField` has three times as many advection terms, and in this 2D scenario advection is probably the most costly, I was expecting the slow down to be a factor of `3`. What I actually find is a slow down of `16`!?. Is this to be expected?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564:847,down,down,847,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564,2,['down'],['down']
Availability,"In my last PR (#2335) I introduced tupled halo filling. . This PR required inferring the length of a Tuple of different element types on the GPU (which is not necessarily easy).; I found a hack to do it, but I was working in julia 1.7. Today, running a simulation with several different functional boundary conditions (in `discrete_form`) with julia 1.6, I found out that the compiler does not like my solution and does not infer the Tuple length (spitting out an `Invalid LLVM` error). This error is not there in julia-1.7. Unfortunately, I already merged my PR because I stupidly did not think to test all possible BC with julia-1.6. Now, to revert to a non-tupled halo filling which works across julia distribution it's a one-liner (in `field_tuples.jl`); ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; fill_halo_regions!(extract_field_data.(full_fields), extract_field_bcs.(full_fields), grid, args...; kwargs...); ```; to; ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; for field in full_fields; fill_halo_regions!(field, args...; kwargs...); end; end; ```. What should we do? We could change this line and leave the infrastructure intact for when we update to julia-1.7 (then we would't have tupled halo filling till then) or find a completely different solution (which will require a lot of restructuring); Probably we also need more tests for boundary conditions with different BC on different sides. I see that the tests that run on julia-1.6 do not return an error though. Do other people encounter the same error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2358:479,error,error,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2358,4,['error'],['error']
Availability,"In some scripts manually checkpointing, e.g. at the end, is useful so having a `checkpoint(simulation)` function would be nice.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1249:25,checkpoint,checkpointing,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249,2,['checkpoint'],"['checkpoint', 'checkpointing']"
Availability,"In summary, we can encounter at least 3 different errors:. ### 1. Dynamic function invocation. ```; julia> compute!(ComputedField(u + v - w)); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),...; Reason: unsupported dynamic function invocation...; ```. Solution: probably the compiler isn't inferring types correctly. I think we can use Cthulhu to fully diagnose this error (though we may still need to be creative to solve the problem). ### 2. device kernel image is invalid?!?!. ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)); ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. Solution: ??????. ### 3. ""Entry function uses too much parameter space"". ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:50,error,errors,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593,5,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320:78,error,error,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320,3,['error'],"['error', 'errors']"
Availability,"In the general case of a pre-computed grid or mesh, the `architecture` on which the grid is stored has be known. Thus in general, the `architecture` of a grid must be provided. The few special cases to this rule are grids with metrics that are either constant or can be computed on the fly, like `RegularRectilinearGrid`. Up to recently `RegularRectilinearGrid` was the only option, so we hadn't the motivation to ponder whether `architecture` belonged as a model property, field property, or grid property... Putting `architecture` in `grid` would mean that we don't have to specify it in model constructors. Since `grid` is so central we wouldn't really need `architecture` as a property anywhere else. For example, we wouldn't need to store `architecture` in every.single.field object, as we do now. Alleviating this boilerplate makes the change feel especially right... The main downside is a loss of flexibility for those grids that are truly architecture-independent, like `RegularRectilinearGrid` and `RegularLatitudeLongitudeGrid`. On the other hand, we have to specify `architecture` somewhere and rarely helpful to mix `CPU` and `GPU` computations using the same grid.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1825:883,down,downside,883,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825,1,['down'],['downside']
Availability,"In the past, problems seem to arise when masking buoyancy as a tracer. Here is an example of a slope at rest with a uniform stratification in a 2D domain run on the main branch. This is using the nonhydrostatic model, but I've plotted the hydrostatic pressure and its horizontal derivative because it shows how masking buoyancy with a strong stratification results in really strong horizontal pressure gradients. These gradients seem to leak out along the boundary creating the numerical effects you can see in the velocity. . https://user-images.githubusercontent.com/67593861/175611052-1aa81aa0-0aa1-4e9a-bfbd-85369b07d99a.mp4. When I did this analysis a while ago, this problem seemed to be fixed by unmasking the tracers, but on the most up to date version of Oceananigans, it doesn't seem to fix the problem. As @glwagner points out, that makes it sound more like a bug. Running it with https://github.com/CliMA/Oceananigans.jl/pull/2603, seems to fix the issue, at least the issue I noticed before. I believe @tomchor has tried both https://github.com/CliMA/Oceananigans.jl/pull/2603 and unmasking and seemed to see a slight improvement with unmasking?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165780914:41,mask,masking,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165780914,2,['mask'],['masking']
Availability,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1077:1537,Checkpoint,Checkpointer,1537,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077,1,['Checkpoint'],['Checkpointer']
Availability,"In this PR I'll be updating the documentation, especially the model setup section, to reflect the many recent changes and additions to the API. To avoid this problem of documentation going out of date, I will also be converting and adding `jldoctest`s so we should actually get an error when documentation goes out of date. A lot of `@example` blocks don't run anymore and we even have a `jldoctest` failure but Travis CI seems to pass so I'll look into making Travis CI fail the doc build if a doctest fails. If we have a lot of doctests it might actually be easy to keep them updated: https://juliadocs.github.io/Documenter.jl/latest/man/doctests/#Fixing-Outdated-Doctests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/799:281,error,error,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/799,2,"['error', 'failure']","['error', 'failure']"
Availability,"In this PR I'm exploring the possibility of adding methods for `diffusive_flux_x`, and `viscous_flux_ux` (along with other directions) for tuples. This is needed when reconstructing tracer variance and kinetic energy dissipation rates for tuples in a conservative formulation and, specifically, it's used in Oceanostics for that end (see https://github.com/tomchor/Oceanostics.jl/pull/112). At the moment these are [defined in Oceanostics](https://github.com/tomchor/Oceanostics.jl/blob/1264b4d61e00ab2fb2fd648d489e5fcd329a135c/src/FlowDiagnostics.jl#L347-L355), but as @glwagner mentioned [here](https://github.com/tomchor/Oceanostics.jl/pull/112#issuecomment-1479761310), this isn't ideal since in the future the behavior of the relevant functions may change in Oceananigans and subsequently this calculation will break in Oceanostics. The downside of defining these methods here is that it adds to the testing infrastructure, but I think the way I currently implemented the tests it doesn't contribute too negatively to this. I'm also proposing removing the fallback method here: https://github.com/CliMA/Oceananigans.jl/blob/200f0622278fcfa583da0119e9696048b334146f/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L154-L169. The reason is that I think these general fallback methods cause for hassle than they solve for less experienced Oceananigans developers (myself very much included) by silently returning something physically reasonable (zero in this case) for virtually any combination of arguments, which can be misleading in a debugging process. But I'm curious to get other people's opinion on this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3057:842,down,downside,842,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3057,1,['down'],['downside']
Availability,Increase tolerance for tracer conservation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/400:9,toler,tolerance,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/400,1,['toler'],['tolerance']
Availability,Increase tolerance in implicit free surface solver tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1686:9,toler,tolerance,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1686,1,['toler'],['tolerance']
Availability,Increase tolerance on `FieldTimeSeries` reduction tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1688:9,toler,tolerance,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1688,1,['toler'],['tolerance']
Availability,Increase ≈ tolerance to account for differences across GPU microarchitectures,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1179:11,toler,tolerance,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179,1,['toler'],['tolerance']
Availability,"Indeed the choice of divergent boundary flow has been made so that there is no tracer leakage through the boundary. One can try using https://github.com/CliMA/Oceananigans.jl/pull/3188 which satisfies both no divergent flow and tracer leakage conditions, but is slower than using the FFT solver itself. Numerical instability has been observed in this solver occasionally due to numerical errors of the conjugate gradient solver occasionally giving zero eigenvalues which creates the instability. I was trying to find the fix for it but I think it's in @Yixiao-Zhang 's fork of Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270175457:388,error,errors,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270175457,1,['error'],['errors']
Availability,"Indeed, I think the fact you do not have an out-of-bounds access error is connected to the @inbounds flag. ; With regards to the second problem, I think it might be more consistent to have the correct ""displaced"" indices in `interior` refer to the valid data chunk instead of the index starting from 1. We need a PR to address this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2152732303:65,error,error,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2152732303,1,['error'],['error']
Availability,"Indeed, the lines referenced in the error attempt to access `model.auxiliary_fields`, which, as the error states, is not a property of `ShallowWaterModel`:. ```julia; masking_events = Tuple(mask_immersed_field!(field) ; for field in merge(model.auxiliary_fields, merge(model.solution, model.tracers))); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843550186:36,error,error,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843550186,2,['error'],['error']
Availability,"Indeed, the simulations seem to have slowed down significantly with these changes. I ll try to figure out why",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3127#issuecomment-1577492554:44,down,down,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3127#issuecomment-1577492554,1,['down'],['down']
Availability,"Indeed, these elements seem to be necessary for the error to occur:; - Immersed grid; - Stretched coordinate",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756#issuecomment-1261674659:52,error,error,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756#issuecomment-1261674659,1,['error'],['error']
Availability,"Index computations inside`Field` constructors are wrong on `MultiArch`. As a result, this script. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(comm). topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), halo=(3, 3), extent=(2π, 2π)). model = NonhydrostaticModel(; grid). uᵢ = rand(size(grid)...); vᵢ = rand(size(grid)...); set!(model, u=uᵢ, v=vᵢ). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u). simulation = Simulation(model, Δt=0.01, stop_iteration=3). simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, (; ζ)),; schedule = IterationInterval(1),; with_halos = false,; prefix = ""test_output_writing_rank$rank"",; force = true). run!(simulation); ```. which is run with. ```; JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project mpi_output_writing.jl; ```. errors with a huge stack trace... part of which is. ```; caused by: BoundsError: attempt to access 16×8×1 Array{Float64, 3} at index [1:16, 9:11, 1:1]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; ```. However, if `with_halos=true` we're fine... I think. The index computation is clearly wrong (when we have `with_halos=false`, we compute the indices we want to output in the output writer constructor), but the confusing thing is that this only an issue for `ζ` from the output works. Needs to be investigated. Here's the index computation:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/output_construction.jl#L32-L41",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2352:996,error,errors,996,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2352,1,['error'],['errors']
Availability,Informative error message for non-regularly spaced grids in `NonhydrostaticModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2946:12,error,error,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2946,1,['error'],['error']
Availability,"Inspecting the file manually shows that the data is indeed correct in there, so the problem appears to be with `FieldTimeSeries`:. ```julia; julia> using JLD2. julia> file = jldopen(filename); JLDFile /Users/gregorywagner/Desktop/simple_tracer_output_test.jld2 (read-only); ├─📂 grid; │ ├─🔢 Nx; │ ├─🔢 Ny; │ ├─🔢 Nz; │ ├─🔢 Hx; │ ├─🔢 Hy; │ ├─🔢 Hz; │ ├─🔢 Lx; │ └─ ⋯ (14 more entries); └─ ⋯ (3 more entries). julia> c_data = file[""timeseries/c/0""][:]; 9-element Vector{Float64}:; 0.0; 0.0; 2.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0. julia> c_data = file[""timeseries/c/1""][:]; 9-element Vector{Float64}:; 0.0; 0.0; 1.82; 0.18; 0.0; 0.0; 0.0; 0.0; 0.0; ```. The halo value across the bottom boundary is the third one down from the top. At iteration 0, it's value is 2 (so that interpolating between 0 and 2 returns 1). At iteration 1 it's value is 1.82, showing that it is changing correctly in time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689906410:701,down,down,701,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689906410,1,['down'],['down']
Availability,"Inspired by @simone-silvestri 's concerns, I'm wondering if what we need is actually a more robust system for specifying advection schemes in general (not just `VectorInvariant`), and controlling the behavior of the advective term. Perhaps something like:. ```julia; """""" Specifies a reconstruction scheme for fluxes of the form u * c,; where u is the `advecting_velocity` and c is the `advected_quantity` """"""; struct FluxReconstruction; advecting_velocity; advected_quantity; end. struct AdvectionScheme; formulation # `FluxForm` or `VectorInvariant`; mass_flux_reconstruction # ""cell"" or ""colocated"" reconstruction""; default CenteredSecondOrder; momentum_flux_reconstruction; tracer_reconstruction # NamedTuple for each tracer individually.; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1083113688:92,robust,robust,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1083113688,1,['robust'],['robust']
Availability,"Inspired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780:346,error,error,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780,2,['error'],['error']
Availability,"Instead of `validate_biogeochemistry`, maybe. ```julia; required_biogeochemical_tracers(::NutrientsPlanktonDetritus) = (:N, :P, :D); ```. is a better syntax. Then users don't have to write their own error messages (we'll handle that in Oceananigans). It also gives us flexibility regarding the choice between 1) automagically adding the biogeochemical tracers or 2) requiring the user to add tracers themselves. We starting to use tracers for a few important things (TKE, biogeochemistry, buoyancy models). We may also need to come up with a system for handling ""name clashes"" gracefully. For example, someone might introduce a biogeochemistry model with tracer `e`, not realizing that this would prevent them from using the biogeochemistry model with CATKE. There's a tension between simplicity and readability (which we get with short, intuitive tracer names like `e`, `T`, `S`), and catastrophic ""name clashes"" that will inevitably occur as model complexity increases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390:199,error,error,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390,2,['error'],['error']
Availability,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:905,avail,available,905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875,1,['avail'],['available']
Availability,Integer division error in `solve!` on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:17,error,error,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,1,['error'],['error']
Availability,"Integer, [-1,268]:Integer, [-1,269]:Integer, [-1,270]:Integer, [-1,271]:Integer, [-1,272]:Float@double, [-1,280]:Float@double, [-1,288]:Float@double, [-1,296]:Float@double, [-1,304]:Integer, [-1,305]:Integer, [-1,306]:Integer, [-1,307]:Integer, [-1,308]:Integer, [-1,309]:Integer, [-1,310]:Integer, [-1,311]:Integer, [-1,312]:Integer, [-1,313]:Integer, [-1,314]:Integer, [-1,315]:Integer, [-1,316]:Integer, [-1,317]:Integer, [-1,318]:Integer, [-1,319]:Integer, [-1,320]:Integer, [-1,321]:Integer, [-1,322]:Integer, [-1,323]:Integer, [-1,324]:Integer, [-1,325]:Integer, [-1,326]:Integer, [-1,327]:Integer, [-1,328]:Float@double, [-1,336]:Float@double, [-1,344]:Float@double, [-1,352]:Float@double, [-1,360]:Float@double, [-1,368]:Float@double, [-1,376]:Integer, [-1,377]:Integer, [-1,378]:Integer, [-1,379]:Integer, [-1,380]:Integer, [-1,381]:Integer, [-1,382]:Integer, [-1,383]:Integer, [-1,384]:Integer, [-1,385]:Integer, [-1,386]:Integer, [-1,387]:Integer, [-1,388]:Inte...; ```. Farther down the error message says:. ```; Cannot deduce type of insertvalue ins %138 = insertvalue { { i64, i64, i64, i64, i64, i64, double, double, double, double, double, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, double, double, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, double, double, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] } }, { {} addrspace(10)*, [3 x i64] }, {} addrspace(10)* } %134, { {} addrspace(10)*, [3 x i64] } %unbox2.i.unpack286435, 1, !dbg !20 size: 32 TT: {}. Caused by:; Stacktrace:; [1] #60; @ ./tuple.jl:461; [2] afoldl; @ ./operators.jl:545; [3] filter_rec; @ ./tuple.jl:461; [4] filter; @ ./tuple.jl:464; [5] filter; @ ./tuple.jl:0; within MethodInstance for filter(::Oceananigans.Fields.var""#87#91"", ::Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Period",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140:10480,down,down,10480,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140,2,"['down', 'error']","['down', 'error']"
Availability,"Interacting with modeling software via scripts is novel for some users. We (and many others) are accumulating knowledge in this area, including:. * Scripting philosophy and its advantages.; * Literate scripting style for ""paper-like"" code, tutorials and pedagogical applications.; * Best practices for parameter exploration (eg how to replicate the functionality of a parameter file or namelist in your script, and why divorcing parameter lists from model setup should be considered carefully).; * Best practices for reproducibility (naming conventions, using output directories, checkpointing, script reuse).; * The use of external packages to achieve these goals (like `ArgParse`, or perhaps `DrWatson`). Oceananigans tries to give users great power and flexibility for designing numerical experiments. However, with this power comes great responsibility for users to write and use their scripts for Good. We can possibly help by adding some documentation. I also think the writers of said documentation might benefit if said documentation stimulates community input / outside contributions to these best practices. cc @ali-ramadhan @navidcy @kpamnany @kburns",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1127:580,checkpoint,checkpointing,580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1127,1,['checkpoint'],['checkpointing']
Availability,"Interesting problem. I guess in the standard case, we know gravity poins down but usually have a negative in the buoyancy term and then define the unit vector to be upwards `(0,0,1)`. I agree that to be consistent with convention, picking the `gravitational_unit_vector` to be antiparallel to the gravitation force, makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1496#issuecomment-802026091:73,down,down,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1496#issuecomment-802026091,1,['down'],['down']
Availability,Interesting this throws an error. It's a good thing I guess!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3785#issuecomment-2369053159:27,error,error,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785#issuecomment-2369053159,1,['error'],['error']
Availability,"Interesting tidbit: while calling `CUDA.versioninfo` here:. https://github.com/CliMA/Oceananigans.jl/blob/b4e217244f1d594ce2854260e4dfa5c97156e162/.buildkite/pipeline.yml#L27. seems innocuous, it actually triggers `CUDA` to download things like `CUDNN`:. ```; julia> CUDA.versioninfo(); CUDA toolkit 11.3.1, artifact installation; CUDA driver 11.3.0; NVIDIA driver 465.27.0. Libraries: ; - CUBLAS: 11.5.1; - CURAND: 10.2.4; - CUFFT: 10.4.2; - CUSOLVER: 11.1.2; - CUSPARSE: 11.6.0; - CUPTI: 14.0.0; - NVML: 11.0.0+465.27; Downloaded artifact: CUDNN; - CUDNN: 8.20.0 (for CUDA 11.3.0); Downloaded artifact: CUTENSOR; - CUTENSOR: 1.3.0 (for CUDA 11.2.0). Toolchain:; - Julia: 1.6.1; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5, 7.0; - Device capability support: sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75, sm_80. 1 device:; 0: NVIDIA Quadro P6000 (sm_61, 23.343 GiB / 23.869 GiB available); ```. I don't think we need to download those artifacts otherwise. But I'm not 100% sure. it also seems to be throwing an error on #1799 though I'm not sure why.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-872233431:224,down,download,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-872233431,6,"['Down', 'avail', 'down', 'error']","['Downloaded', 'available', 'download', 'error']"
Availability,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:938,down,down,938,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718,2,['down'],['down']
Availability,Interesting. I see that error a lot in #2782,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370316103:24,error,error,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370316103,1,['error'],['error']
Availability,"Interestingly now an exception is thrown instead of an `ERROR_ILLEGAL_ADDRESS` error, which is better as the error crashes CUDA and requires a Julia restart. It still returns the `model` and I can time step it, but the exception is thrown each time step. ```julia; ERROR: a type error was thrown during kernel execution on thread (225, 1, 1) in block (10, 1, 1).; Stacktrace:; [1] κuᶜᶜᶠ at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:285; [2] macro expansion at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:264; [3] gpu_compute_CATKE_diffusivities! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [4] gpu_compute_CATKE_diffusivities! at ./none:0. ┌ Error: Exception while generating log record in module Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:230; │ exception =; │ KernelException: exception thrown during kernel execution on device NVIDIA GeForce RTX 4090; │ Stacktrace:; │ [1] check_exceptions(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/exceptions.jl:39; │ [2] synchronize(stream::CUDA.CuStream; blocking::Bool, spin::Bool); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:207; │ [3] synchronize (repeats 2 times); │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:194 [inlined]; │ [4] (::CUDA.var""#1125#1126""{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, Int64, Vector{Float64}, Int64, Int64})(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:535; │ [5] #context!#990; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:168 [inlined]; │ [6] context!; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:163 [inlin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:79,error,error,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,5,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,Is `Architectures.next_stream()` redundant?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2748:33,redundant,redundant,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2748,1,['redundant'],['redundant']
Availability,Is `calc_∇²!` redundant in view of `compute_∇²!`?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2638:14,redundant,redundant,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2638,1,['redundant'],['redundant']
Availability,Is energy increasing? If so that might be a time stepping error and you need to reduce your time step.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1439243627:58,error,error,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1439243627,1,['error'],['error']
Availability,"Is it possible that the problem lies elsewhere, so that changing `wait` just masks the real issue rather than solving it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964234819:77,mask,masks,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964234819,1,['mask'],['masks']
Availability,"Is it possible to get julia to ignore the manifest (i.e. specify that we want to ignore it in the CI), so that when a user downloads it they can still use the manifest?. Having asked that I don't actually know what the manifest does that isn't already taken care of by the Project?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361555124:123,down,downloads,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361555124,1,['down'],['downloads']
Availability,"Is it the pressure field that has oscillations, or the velocity field?. Either way, I don't think that's important. A preconditioner should be some kind of approximate inverse for A, where we are solving for x in Ax = b --- or in other words, an approximate solver. The preconditioner does not have to be ""exact"" or ""error free"", since it's really the CG iteration that solves the problem. The idea is that the FFT-based solver yields a pressure field that is _almost_ correct. A similar strategy succeeded in this PR: https://github.com/CliMA/Oceananigans.jl/pull/2412",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284382130:317,error,error,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284382130,1,['error'],['error']
Availability,Is something like this useful? See how they look at https://github.com/CliMA/Oceananigans.jl/tree/ncc/readme-downloads,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3652:109,down,downloads,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3652,1,['down'],['downloads']
Availability,"Is the slow down different for different topologies? If so that might be a clue. `CenteredSecondOrder` is special because it directly defines the function `advective_momentum_flux_Uu`:. https://github.com/CliMA/Oceananigans.jl/blob/383173d11a0c96182a4349fc1e33755207bf0886/src/Advection/centered_second_order.jl#L11. The other schemes define `symmetric_interpolate_*` and `left_biased_interpolate_*`, etc. For example, `CenteredFourthOrder`:. https://github.com/CliMA/Oceananigans.jl/blob/383173d11a0c96182a4349fc1e33755207bf0886/src/Advection/centered_fourth_order.jl#L21. These functions are filtered through an if statement if the dimension is `Bounded`, see:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Advection/topologically_conditional_interpolation.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868099043:12,down,down,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868099043,1,['down'],['down']
Availability,Is there a forcing function on `w`? Can you provide the code that produces this error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-869733830:80,error,error,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-869733830,1,['error'],['error']
Availability,Is there a way to make errors in kernels get thrown properly given the changes in #2924? Right now if something fails within a kernel no error is thrown (at least how it is being used in the particle tracking in main).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514579545:23,error,errors,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514579545,2,['error'],"['error', 'errors']"
Availability,"Is there more to the log? Might be useful if you can paste the whole log. Sometimes the `makedocs` failure is due to some warning much earlier in the build log, especially with `strict = true`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796844407:99,failure,failure,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796844407,1,['failure'],['failure']
Availability,Is this PR looking for an adopter? Not sure what the original error was but happy to work on this PR since it might be the cause of the error I reported in issue https://github.com/CliMA/Oceananigans.jl/issues/3775.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3666#issuecomment-2350342925:62,error,error,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3666#issuecomment-2350342925,2,['error'],['error']
Availability,"Is this correct in lines 274=275 of `enzyme_test`?; ```; x = y = (0, 2π); z = 1; ```; When I run it locally it returns this error:; ```; Got exception outside of a @test; ArgumentError: z length(1) must be 2.; ```. I found a few possible errors locally and can push.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438697101:124,error,error,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438697101,2,['error'],"['error', 'errors']"
Availability,"Is this correct?. https://github.com/CliMA/Oceananigans.jl/blob/adffd0cb67373da364a54d7f300d1f33817539bd/src/ImmersedBoundaries/mask_immersed_field.jl#L53. I'd expect it to use `solid_node` for masking scalars. Right?. For masking velocity fields for the purpose of enforcing impenetrable boundary conditions, it makes sense to me that we'd use `solid_interface`. But we should have a separate function for that. In reality, we only _need_ masking for the velocity field for our algorithm to work correctly. However, being able to mask scalars is sometimes useful for development purposes. @simone-silvestri can you shed some light?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2249:194,mask,masking,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249,4,['mask'],"['mask', 'masking']"
Availability,Is this redundant? If there is no CUDA-enabled GPU then how could a `grid` on GPU be provided as constructor argument?. https://github.com/CliMA/Oceananigans.jl/blob/d675d8b9f7359219941fa81ce098eb51b7c5ac8f/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L125-L127,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2595:8,redundant,redundant,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2595,1,['redundant'],['redundant']
Availability,"Is this still an issue? @xkykai's MWE runs fine for me (I went up to 256x256x256), and I've been doing `maximum(abs, u)` on the GPU for a few versions. Out of curiousity, @josuemtzmo are you able to reproduce the error on the latest versions of Julia, CUDA.jl, and Oceananigans.jl?. ---. I'm using Oceananigans v0.91.7 with. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd4843 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Windows (x86_64-w64-mingw32); CPU: 24 × AMD Ryzen 9 5900X 12-Core Processor; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 24 virtual cores); ```. and. ```; julia> Oceananigans.CUDA.versioninfo(); CUDA runtime 12.5, artifact installation; CUDA driver 12.5; NVIDIA driver 556.12.0. CUDA libraries:; - CUBLAS: 12.5.3; - CURAND: 10.3.6; - CUFFT: 11.2.3; - CUSOLVER: 11.6.3; - CUSPARSE: 12.5.1; - CUPTI: 2024.2.1 (API 23.0.0); - NVML: 12.0.0+556.12. Julia packages:; - CUDA: 5.4.3; - CUDA_Driver_jll: 0.9.2+0; - CUDA_Runtime_jll: 0.14.1+0. Toolchain:; - Julia: 1.10.4; - LLVM: 15.0.7. 1 device:; 0: NVIDIA GeForce RTX 3080 (sm_86, 5.794 GiB / 10.000 GiB available); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2284866026:213,error,error,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-2284866026,2,"['avail', 'error']","['available', 'error']"
Availability,"It appears to be related to the size of the grid:. ```julia; julia> grid = RectilinearGrid(GPU(), size=(8, 8, 8), x=(0,1), y=(0,1), z=0:8); 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [0.0, 8.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); 1.0. julia> grid = RectilinearGrid(GPU(), size=(16, 16, 16), x=(0,1), y=(0,1), z=0:16); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:89; [2] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/utils/call.jl:26; [4] #39; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::Cartesian",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490603313:852,ERROR,ERROR,852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490603313,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"It can't be completely independent because it still needs `using Oceananigans`, but it could be _more_ independent. I agree that's desirable. I think using absolute filepaths rather than referencing the existing output writers, and using more explicit `nodes` functions could help, eg. ```julia; xζ, yζ, zζ = nodes((Face, Face, Center), grid) ; xδ, yδ, zδ = nodes((Center, Center, Center), grid); ```. I think the grid is serialized so you could load it from file (though this feature isn't very robust right now since it doesn't work for stretched grids, for example).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-878315017:496,robust,robust,496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-878315017,1,['robust'],['robust']
Availability,"It could be based on this post https://discourse.julialang.org/t/announcing-package-download-stats/69073. which means that the number represents the number of unique IP addresses that have downloaded Oceananigans from the julia registry (I think), excluding IP addresses that are suspected to originate from bots / CI. So basically it should somehow correspond to the number of _computers_ on which a human has typed `Pkg.add`. Or something like that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3652#issuecomment-2223901082:84,down,download-stats,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3652#issuecomment-2223901082,2,['down'],"['download-stats', 'downloaded']"
Availability,"It doesn't change any code so it's not stale yet. What we need to do though is figure out how to upload data to `OceananigansArtifacts.jl`, and then download it into the test using `DataDeps`. @ali-ramadhan groks `DataDeps.jl` but I haven't yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1373#issuecomment-849929096:149,down,download,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373#issuecomment-849929096,1,['down'],['download']
Availability,It failed again so I ran it on our cluster which errored in the same way just saying `killed`. It's failing on my new test and I think I've probably not implemented the `calculate_particle_tendency_contributions!` in a GPU friendly way so will try and resolve this tomorrow. . Edit: as I closed the terminal some error about the GPU node being out of memory flashed up which may be relevant.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1237427854:49,error,errored,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1237427854,2,['error'],"['error', 'errored']"
Availability,"It is possible, but not easy. I suggest that we implement a more modern turbulence closure if we would like a second one for comparisons with CATKE. Implementing any ""production"" turbulence closure will be a significant effort, and we would like it to be worth both the time to implement, and the cost of code maintenance into the future. This will also set us up for comparisons with other ocean models like MOM6 or NEMO. I suggest:. * [Harcourt 2015](https://journals.ametsoc.org/view/journals/phoc/45/1/jpo-d-14-0046.1.xml); * ePBL with surface waves ([Reichl and Li 2019](https://journals.ametsoc.org/view/journals/phoc/49/11/jpo-d-18-0258.1.xml?tab_body=pdf)); * The OSMOSIS scheme, the details of which I don't think are yet published, but is implemented in [CVmix](https://github.com/CVMix/CVMix-src).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2149#issuecomment-1011821513:310,mainten,maintenance,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2149#issuecomment-1011821513,1,['mainten'],['maintenance']
Availability,"It looks like `perturbation_norm` needs to be defined in a GPU friendly way. The error message is cutoff so I can't see where that function is defined (the clue is at the bottom of what's posted):. ```; [15] perturbation_norm(model::ShallowWaterModel{RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Fl; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882662678:81,error,error,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882662678,1,['error'],['error']
Availability,"It looks like our problems with GM are not solved by this PR --- even when we correctly mask interior values (it might be worth testing this a second time, but I think I did this correctly). Here are results for https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/1c183f9a8df7b97f5074f18ce622b247b7b1c923, in which the stencil is rewritten to compute the ""gradient of the average"". When we do this, and use ""boundary-aware averages"", we eliminate a dependence on the boundary (ie the GM stencil is ""inward looking""). It doesn't fix the basic issue with spurious fluxes near the boundary:. https://user-images.githubusercontent.com/15271942/166609754-1c832d73-3089-48d0-89c4-a99caac344b1.mp4. Hmm... For reference, here's what happens when we revert to ""average of the gradient"" via https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/b7a67598db1fe8d5afea27cece5d35d0c20aac93:. https://user-images.githubusercontent.com/15271942/166610211-95376390-bb80-4993-8b7b-6a3cbe27bebf.mp4. My next best hypothesis is that we are seeing the precise instability that Griffies 1998 points out, and the only solution is i) horizontal diffusion or ii) the Griffies stencil. @jm-c thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953:88,mask,mask,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953,1,['mask'],['mask']
Availability,"It looks like that restarting from a checkpoint is not bit-for-bit? I think the issue is that when restarting from a checkpoint the time step is not restored -- it is still using the initial time step defined in `Simulation()`, not the `last_Δt` from the saved `Clock` object in the checkpoint file. See the example below, which is the output of the attached test case. . In the pickup run I changed the onscreen output from every 10 iterations to every 1 iterations to see the time step. Rather than using the previous time step (5.973 s) from the checkpoint, the pickup run is using a time step of 10 s which is the value when defining `simulation = Simulation(model, Δt=10, stop_iteration=220)`. I’m using v0.91.5. Initial run; ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, max(|u|) = 2.5e-01 ms⁻¹, wall time: 0 seconds; [ Info: ... simulation initialization complete (13.909 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.696 seconds).; Iteration: 0010, time: 1.833 minutes, Δt: 11.212 seconds, max(|u|) = 2.6e-01 ms⁻¹, wall time: 19.116 seconds; Iteration: 0020, time: 3.702 minutes, Δt: 10.681 seconds, max(|u|) = 2.8e-01 ms⁻¹, wall time: 19.345 seconds; Iteration: 0030, time: 5.482 minutes, Δt: 10.215 seconds, max(|u|) = 2.9e-01 ms⁻¹, wall time: 19.629 seconds; Iteration: 0040, time: 7.185 minutes, Δt: 9.802 seconds, max(|u|) = 3.0e-01 ms⁻¹, wall time: 19.854 seconds; Iteration: 0050, time: 8.819 minutes, Δt: 9.433 seconds, max(|u|) = 3.1e-01 ms⁻¹, wall time: 20.082 seconds; Iteration: 0060, time: 10.391 minutes, Δt: 9.100 seconds, max(|u|) = 3.2e-01 ms⁻¹, wall time: 20.306 seconds; Iteration: 0070, time: 11.907 minutes, Δt: 8.798 seconds, max(|u|) = 3.3e-01 ms⁻¹, wall time: 20.559 seconds; Iteration: 0080, time: 13.374 minutes, Δt: 8.523 seconds, max(|u|) = 3.4e-01 ms⁻¹, wall time: 20.773 seconds; Iteration: 0090, time: 14.794 minutes, Δt: 8.270 seconds, max(|u|) = 3.5e-01 ms⁻¹, wall time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3845:37,checkpoint,checkpoint,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3845,4,['checkpoint'],['checkpoint']
Availability,"It looks like the Langmuir turbulence example is broken (the video generated in the documentation is blank and it does not run on my computer). I think it may be these two lines where the halo regions for each variable are manually removed, but Oceananigans seems to have already extracted those halo regions. This causes the variable and coordinate arrays to be different sizes, leading to a plotting error. https://github.com/CliMA/Oceananigans.jl/blob/24e9c2c3c85cc092913989d6c88d38046998aa07/examples/langmuir_turbulence.jl#L277-L278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1004:402,error,error,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1004,1,['error'],['error']
Availability,"It really just comes down to these lines:. ```julia; @inbounds for IA in CartesianIndices(indsAt); IR = Broadcast.newindex(IA, keep, Idefault); @simd for i in axes(A, 1); R[i,IR] = op(R[i,IR], f(A[i,IA])); end; end; ```. https://github.com/JuliaLang/julia/blob/7c5c724ed93015d2e9c52c7fcd8f5c4ebbefff03/base/reducedim.jl#L284. The problem could in fact be here:. https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Fields/field.jl#L404. which I think cannot be type-inferred by the compiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176710306:21,down,down,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2176710306,1,['down'],['down']
Availability,It says that is a doctest error. I think if you wanna run again you first need to delete the jld2 and nc files the doctests create. . @ali-ramadhan should we add a command in the docs/make.jl to cleanup those files after docs are built?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869046124:26,error,error,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869046124,1,['error'],['error']
Availability,"It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions: https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78. ~If I followed the code correctly, the LES models are looped through here: https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8~. ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889331619:751,down,downside,751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889331619,1,['down'],['downside']
Availability,"It seems like adding the rebuilding step has fixed that error so thank you!; However, there is another error (see attached error log). Based on my print statements from my run script, the error is occurring when the `run!` command is called or during the run before the first output of progress.; [err_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873490/err_gpu.01.txt); [log_gpu.01.txt](https://github.com/CliMA/Oceananigans.jl/files/5873492/log_gpu.01.txt). I have run the same case using the CPU architecture and it made it through a couple timesteps so I know that it works. It just runs too slowly on the CPU to be practical to use. . To your note, I do use .jl extensions but github wouldn't allow me to attach a .jl so I changed it to .txt to post it. I don't anticipate the zero Eulerian-mean flow to be a huge issue because my forcing starts up very gradually over the first few hours so I would expect that to act as the spin-up you used in your paper. However, you know much more about this than I do. Even with a gradual climb in forcing at the beginning of the run, how would you recommend improving the settings? Can I initialize the Eulerian-mean flow with noise? Or just run a different, more formal spin up case and then initialize from that? . Thanks so much for your help, this is my first time working with an LES so I am very green.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529:56,error,error,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767535529,4,['error'],['error']
Availability,It seems like we're still getting the `all(test_fields.v .≈ truth_fields.v)` error in the [shallow water regression tests](https://buildkite.com/clima/oceananigans/builds/10225#01868315-b904-4152-b885-9b64cbab7111). I'll restart it and see what happens. But we should probably keep an eye on that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2944#issuecomment-1443689339:77,error,error,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2944#issuecomment-1443689339,1,['error'],['error']
Availability,"It seems this updates a lot of versions, including StructArrays. Seems like a good idea but there are some failed tests. When I looked at the errors one of them seemed to be about `OffsetArrays`, copied below right before the stacktrace. Not sure how to resolve this but I suspect others have ideas. ```; ┌ Warning: Could not use exact versions of packages in manifest, re-resolving;   | └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1526;   | ERROR: Unsatisfiable requirements detected for package OffsetArrays [6fe1bfb0]:;   | OffsetArrays [6fe1bfb0] log:;   | ├─OffsetArrays [6fe1bfb0] has no known versions!;   | └─restricted to versions 1.4.0-1 by Oceananigans [9e8cae18] — no versions left;   | └─Oceananigans [9e8cae18] log:;   | ├─possible versions are: 0.58.5 or uninstalled;   | └─Oceananigans [9e8cae18] is fixed to version 0.58.5;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1785#issuecomment-870516627:142,error,errors,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1785#issuecomment-870516627,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,"It seems ths is pretty close, but I'm this error:. ```; ┌ Debug: checking footnote links.; --;   | └ @ Documenter.DocChecks /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/DocChecks.jl:110;   | [ Info: Populate: populating indices.;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:257 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:256 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1; ```. which doesn't really give me any information, so I'm unsure about how to proceed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318:43,error,error,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318,7,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:76,error,error,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366,6,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:721,ERROR,ERROR,721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067,1,['ERROR'],['ERROR']
Availability,"It was my impression that `Δx` worked differently. I even asked a similar question [here](https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1368277630) about it. But if it returns the same thing, maybe indeed `xspacing` is redundant. I believe the functions `xspacings()` and such (which return an array) are novel and necessary though, right @simone-silvestri ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468277435:239,redundant,redundant,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468277435,1,['redundant'],['redundant']
Availability,"It will be good if we have a standard procedure to debug certain GPU errors. However, after trying Simone's suggestions, I found that using `--check-bounds=yes` or running the code on a CPU cannot reproduce the error in the original script posted by me. The script just finishes without reporting any error. I understand that these suggested methods to debug CUDA errors are helpful generally, but they do not work in this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771242105:69,error,errors,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771242105,4,['error'],"['error', 'errors']"
Availability,"It would be nice to convert it into a discussion, but I think we want to correct the AB2 for variable time stepping quite soon, because it might be a large source of error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313282962:166,error,error,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313282962,1,['error'],['error']
Availability,"It'd be nice to implement the 'Orlanski' boundary condition for open boundaries:. https://www.sciencedirect.com/science/article/pii/0021999183901274. For this to work properly, we need to modify the pressure solver to work for time-dependent inflows. We may also need to implement a correction that ensures mass conservation, as described just before section 5 here:. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.3860&rep=rep1&type=pdf. This would allow us to simulate the spatial development of a boundary layer, a la . https://iopscience.iop.org/article/10.1088/1742-6596/318/2/022023/meta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/833:405,down,download,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833,1,['down'],['download']
Availability,"It's a bug:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(3, 3), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat)); 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.333333; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.333333; └── Flat z. julia> ct = FieldTimeSeries{Center, Center, Center}(grid, (0, 1)); 3×3×1×2 FieldTimeSeries{InMemory} located at (Center, Center, Center) on CPU; ├── grid: 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── indices: (:, :, :); ├── time_indexing: Linear(); ├── backend: InMemory(); └── data: 9×9×1×2 OffsetArray(::Array{Float64, 4}, -2:6, -2:6, 1:1, 1:2) with eltype Float64 with indices -2:6×-2:6×1:1×1:2; └── max=0.0, min=0.0, mean=0.0. julia> view(ct[1], :, :, 1); ERROR: MethodError: no method matching topology(::Tuple{Colon, Colon, UnitRange{Int64}}). Closest candidates are:; topology(::Any, ::Any); @ Oceananigans ~/Projects/Oceananigans.jl/src/Grids/grid_utils.jl:59; topology(::Oceananigans.Fields.AbstractField, Any...); @ Oceananigans ~/Projects/Oceananigans.jl/src/Fields/abstract_field.jl:47; topology(::Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ}) where {FT, TX, TY, TZ}; @ Oceananigans ~/Projects/Oceananigans.jl/src/Grids/grid_utils.jl:52. Stacktrace:; [1] topology; @ ~/Projects/Oceananigans.jl/src/Grids/grid_utils.jl:59 [inlined]; [2] FieldBoundaryConditions(grid::Tuple{Colon, Colon, UnitRange{Int64}}, location::Nothing, indices::Tuple{Colon, Colon, Colon}); @ Oceananigans.BoundaryConditions ~/Projects/Oceananigans.jl/src/BoundaryConditions/field_boundary_conditions.jl:135; [3] view(f::Field{…}, i::Function, j::Function, k::Int64); @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/field.jl:326; [4] top-level scope; @ REPL[13]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3687:870,ERROR,ERROR,870,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3687,1,['ERROR'],['ERROR']
Availability,"It's a problem of particles being advected in the x-direction. You can see that the out-of-bounds error is in the x-direction; `ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]`; You are moving out of the periodic grid because the particle is being advanced beyond the periodic domain.; There is no bouncing happening and it is not a problem of Bounded directions because the particle is not moving in the y- or in the z-direction. You are prescribing a steady state flow which is characterized by a u-velocity only. There is no tendency term that can develop a shear instability since a y-gradient in u is stable if there are no additional frictional forces, i.e.:; $$\frac{\partial u}{\partial t} = - \frac{\partial uu}{\partial x} - \frac{\partial uv}{\partial y} - \frac{\partial uw}{\partial z} - \frac{\partial p}{\partial x}$$; All the terms on the RHS of this equation are zero because; - $v = 0$; - $w = 0$; - $\frac{\partial uu}{\partial x} = 0$; - $\frac{\partial p}{\partial x} = 0$ since $\delta_x u^* + \delta_y v^* + \delta_z w^* = 0$ and you have periodic boundary conditions in the x-direction. from how you initialized it, the flow cannot change, irrespective of your CFL (if you remove your particles you'll see that the code will run indefinitely without changing, even with CFL = 100). In your second case, when you change the velocity to ; ```julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```; you are initializing your solution with a divergent flow $\partial_x u + \partial_y v + \partial_z w \ne 0$ which is not ""admissible"" in an incompressible model (such as Oceananigans' non-hydrostatic-model). The initialization then triggers a pressure correction which will act to suppress the divergence in your initial conditions, by either includi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277:98,error,error,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,It's all simple stuff... someone just has to sit down and do it...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866275736:49,down,down,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866275736,2,['down'],['down']
Availability,It's an error from the constructor for `VerticallyStretchedRectilinearGrid`. I would guess that the test uses incorrect syntax in constructing a vertically stretched grid?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-819608119:8,error,error,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-819608119,1,['error'],['error']
Availability,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:112,mask,mask,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191,2,['mask'],['mask']
Availability,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052:119,redundant,redundant,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052,3,"['recover', 'redundant']","['recovers', 'redundant']"
Availability,"It's better to use `Field` for boundary conditions rather than `Array` --- this eliminates translation issues when switching architectures (eg CPU, to GPU, to multi-region, to distributed), and also allows diagnostics to be performed directly on the boundary conditions (which isn't always needed, but is very welcome to have available --- for example the spatial derivative of a flux). So, I think we should declare that it's ""best practice"" to use `Field`, not `Array`. To encourage this we should change the docs that show how to use an `Array`:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/boundary_conditions/#.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array. to using a `Field`. Also, we should add correctness tests for using `Field`, which has a bug up until #3287. Curious about @simone-silvestri's input because he has used arrays a lot in boundary conditions. Note that we also are working on support for `FieldTimeSeries` as a boundary condition in #3233 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3298:326,avail,available,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3298,1,['avail'],['available']
Availability,"It's common for this error to pop up when there's a file handle already open (maybe if there was an error the previous time you ran the code). @loganpknudsen if you haven't done so yet, you could close and reopen the repl before running the code again. Or/and you can delete the previously created netcdf file. Regardless, this error is likely not related to this branch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747543347:21,error,error,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747543347,3,['error'],['error']
Availability,"It's currently defined _after_ these:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/Oceananigans.jl#L194-L215. in addition, `ImmersedBoundaries` extends a bunch of functions that were defined in `Advection` and `TurbulenceClosures`. But this is backwards: `ImmersedBoundaries` should be regarded as a fundamental extension of `Grids`. Then `Advection` and `TurbulenceClosures` should provide functionality that is valid on regular and immersed grids. This is a necessary change to split the repo in the future: we want to regard ""advection"" and ""turbulence closures"" as part of the model/physics, and as immersed boundaries as ""physics-agnostic"", ie, more fundamental. More practically it's the cause of some pain. For example, we can't mask immersed fields within `TurbulenceClosures` without changing how we currently define `mask_immersed_field!`. And so on. Things are tangled. I think maybe immersed boundaries belong right after grids, then `Fields` should define `mask_immersed_field!`. So making this change would distribute a lot of the immersed boundary functionality throughout the code. This is probably a natural evolution, since we used to think that immersed boundaries were an experimental add-on. Now its not. @simone-silvestri curious about your opinion since you've worked on a lot of this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3062:783,mask,mask,783,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3062,1,['mask'],['mask']
Availability,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947:172,failure,failure,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947,2,['failure'],['failure']
Availability,"It's just a small detail... if you had an `ImmersedBoundary` on the `GPU` and wanted to move it on the `CPU` (in case the immersed boundary was an abstractarray) the `immersed_boundary` would remain a `CuArray` even after calling `on_architecture(CPU(), ibg)`. . This was a small bug which never really affected us (you never really need to shift a grid from the `GPU` to the `CPU` in practice and most of the time that bottom is a function, not an array). On the other hand I needed this because when I do a `MultiRegionGrid` of a `ImmersedBoundary` and split the `bottom` in different `GPU`s, I need to pass that bottom correctly to the `CPU` otherwise we have `CUDA illegal access` problems (i.e. you cannot just split an array from one GPU to others without taking care of it adequately). So I was getting an error related to this when I wanted to split a simulation with ""realistic"" bathymetry onto 2 GPUs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084711611:813,error,error,813,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084711611,1,['error'],['error']
Availability,"It's my fault, I suggested that @iuryt try using it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2330#issuecomment-1063502994:8,fault,fault,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2330#issuecomment-1063502994,1,['fault'],['fault']
Availability,It's nobody's fault :); But just wanted to clarify the state of the matters at this point ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2330#issuecomment-1063503494:14,fault,fault,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2330#issuecomment-1063503494,1,['fault'],['fault']
Availability,It's nobody's fault. Haha; I am just too excited to make it run with my simulations. I will try using convective adjustment for now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2330#issuecomment-1063508515:14,fault,fault,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2330#issuecomment-1063508515,1,['fault'],['fault']
Availability,"It's not possible to build a `NetCDFOutputWriter` object with output that is not a field without specifying an ""attribute"", because this line. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/netcdf_output_writer.jl#L192. throws an error. The error is a `KeyError`, eg:. ```; KeyError: key :time_average not found; Stacktrace:; [1] getindex at ./dict.jl:477 [inlined]; [2] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S); ...; ```. which occurs because, in this case, `:time_average` is not one of the defaults provided:. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/netcdf_output_writer.jl#L13-L20. There are really two issues:. 1. Should we really require users to specify ""output attributes"" with their output? While this does seem like good practice, I don't think we want to strictly police this behavior. Sometimes its nice to be able to play around with output, with no intention of sharing / using the data in the future. For example, we could throw a `try`-block around the above attempt to find ""default"" attributes, so that its possible to build an output writer with non-default output without specifying output attributes. 2. If we do intend to require ""output attributes"", we should probably throw an error that says something like ""output attributes must be specified for x"".",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/885:288,error,error,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/885,3,['error'],['error']
Availability,"It's probably with `w`; I forgot that `w` has a different size in the vertical direction. You can try changing the `w` initial condition with code like. ```julia; xw, yw, zw = nodes(w, reshape=true); wshape = @. zw / Lz * (1 + zw / Lz); Ξw = randn(size(w)...) .* wshape; ```. I'm not sure if this is where the error comes from. The stack trace / error message that you posted will tell you the specific line that is generating the error. Identifying the line that generates the error can be useful for debugging. If you like, you can generate a minimal example, which I can then try to run to reproduce a bug (and also to debug my own code suggestions). > Also, shouldn't we set v (last line below, I added the commented v's):. You can. This is not a question about reproducibility though --- it depends on your application. Give it a shot and see how it changes your results. Note that there will be non-zero `v` in the initial condition anyways, because it has to be projected onto an incompressible velocity field (which is not guaranteed by the random data we are using). Also, please format your code with triple backticks:. https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code. You can add syntax annotation too appropriate for Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017:310,error,error,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017,4,['error'],['error']
Availability,It's still failing intermittently after increasing the tolerance in PR #1686: https://buildkite.com/clima/oceananigans/builds/2672#74321ab5-528f-48c2-bd0c-5ab006881fd3/22-2077,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1689:55,toler,tolerance,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1689,1,['toler'],['tolerance']
Availability,"It's trying to use the wrong indices:. > ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5). It should be trying to view with indices `(1:5, 1:5, 5:5)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3835#issuecomment-2400236982:41,ERROR,ERROR,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835#issuecomment-2400236982,1,['ERROR'],['ERROR']
Availability,"Just a few notes:. * There's surprisingly little ""interpolation"" / reconstruction in our code (except for trivial reconstruction). Most of the reconstruction occurs for advection, but advective reconstruction doesn't need to be touched by this PR. So this PR actually mostly affects the implementation of GM.; * There are a few things re: using homogeneous operators for Coriolis forces. I suspect that it won't have an effect, but it needs to be tested.; * It should be feasible to use homogeneous / boundary-aware operators _only_ for fluxes. ; * Finally, I'm going to implement an ""enforce_impenetrability!"" operator that does 3D masking and works for both non-immersed and immersed boundaries. After that, we can use `nothing` as a default boundary condition for velocities rather than `ImpenetrableBoundaryCondition` and avoid `mask_immersed_field!` during time-stepping. It seems that impenetrable is still useful for users though for ""user-defined, additional"" velocity components so we may want to keep it...; * An even further step would eliminate the need for masking boundary regions by never updating the tendency there. But this approach allows users to more easily make mistakes, ie changing the velocity field during a run, but forgetting to enforce impenetrability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491:633,mask,masking,633,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491,2,['mask'],['masking']
Availability,"Just a minor comment here, default minimum fraction might be 0.2 but we more often use; a smaller value (e.g., 0.1 or smaller). On Wed, Feb 16, 2022 at 06:18:05PM -0800, Gregory L. Wagner wrote:; > > Maybe another doubt, what do we do if the ?? is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?; > ; > We don't mask the partial cells at all. We only mask cells that are fully immersed.; > ; > There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118:301,mask,masking,301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118,4,['mask'],"['mask', 'masking']"
Availability,"Just a note on this PR: It's kind of hacky but to avoid images and videos taking up space in git history (they take up a lot!) I'd advocate for uploading images into an issue (effectively hosting them on GitHub's servers) and then linking/embedding them. In an ideal world the validation experiment CI pipeline would run and produce figures for all validation experiments which would then be automatically embedded into the docs with every version release. But setting up this infrastructure would take time and effort which I suspect no one can spare right now. Unfortunately it's a thankless job haha. > We try to fix this issue and keep the validation experiments and benchmarks up-to-date. I've always wanted to do this and wish I had the time to do it... This was the original motivitation for setting up the validation experiment CI pipeline: https://buildkite.com/clima/oceananigans-validation-experiments. It only runs the convergence tests right now and it still runs every night but it's been neglected so stuff is failing. I personally think we should be reviving the validation experiments one-by-one starting with the most important ones by running them as part of that CI pipeline and fixing it when it fails. But without the ability to dedicate the time I can see why reducing our maintenance burden would be desirable. I've also always wanted to set up a benchmarking CI pipeline, but I don't think we have the proper computational resources to set it up right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872386226:1296,mainten,maintenance,1296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872386226,1,['mainten'],['maintenance']
Availability,"Just add to the conversation. When I was using `Julia-1.5` and `Oceananigans@0.54.0` and I had a bug in my code, it would hang. I upated to `Julia-1.6` and added `Oceananigans#ali/julia-1.6` and it gave me an error, which thanks to @ali-ramadhan , I was able to fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824357023:209,error,error,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824357023,1,['error'],['error']
Availability,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:232,ERROR,ERROR,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Just as a reference, the sed command to do this (I believe) is. ```sed ""s/\<Cell\>/Center/g""```. which produces the following results (as an example):. ```bash; $ line=""(Cell, Cellphone), Cell; :Cell, Cell.something""; $ echo ""$line"" | sed ""s/\<Cell\>/Center/g""; (Center, Cellphone), Center; :Center, Center.something; ```. So a one-liner to do this is (I think; I haven't tested):. ``` find . -type f -name ""*.jl"" -print0 | xargs -0 sed ""s/\<Cell\>/Center/g"" ```. assuming we just wanna replace in ""*.jl"" files. I agree with `Center` and `Face` being the most intuitive and I'd be glad to do this change if everyone agrees. Although this would probably need to come with a bump to the next version since this is a breaking change, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/414#issuecomment-763796870:220,echo,echo,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/414#issuecomment-763796870,1,['echo'],['echo']
Availability,"Just as in the title the function Label calls initialize_block and gives the ""no method matching initialize_block!(::label; fontsize::Int64) giving the error; got unsupported keyword argument ""fontsize""; Kevin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3442:152,error,error,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3442,1,['error'],['error']
Availability,"Just combining my commits from PRs #337 and #341. Idea is to make life more comfortable by getting `set!` to work out of the box for CPU and GPU fields, and for setting them with functions or arrays. The functions should be evaluated on the CPU as not every function is available through CUDAnative (notably `rand` and `randn` are missing). Will switch to using `copyto!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/343:270,avail,available,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/343,1,['avail'],['available']
Availability,Just do the datadep like the tests do it and do delete anything downloaded to retrigger downloading. Let me know if that helps.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023734972:64,down,downloaded,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023734972,2,['down'],"['downloaded', 'downloading']"
Availability,"Just for completion, I realized I posted a bug in the first message but not the code that generates it. Sorry! So below is a way to reproduce it. The error emerges because some routine in output writers tries to access the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::Vertically",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:150,error,error,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,1,['error'],['error']
Availability,"Just hacked something together that allows for user-defined forcing functions for the CPU. Have not tested on the GPU yet. Basically there's a struct `Forcing` that stores the user-defined forcing functions. It will replace the old `ForcingFields` struct. See `examples/deep_convection_3d.jl` for how I switched to using a forcing function for T to enforce a cooling surface heat flux. A big issue is that the current implementation slows down the time stepping by a factor of 2-3x. So we'll have to figure out why before merging. The function must have a signature like `F(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k)` right now so this won't produce a nice solution as we will have to figure out #59 before the function signature can look as nice as `surface_cooling_disk(grid, velocities, tracers, i, j, k)`. This is work for another branch. Will keep working on this before merging. Just wanted to start something. Resolves #73",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/85:439,down,down,439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/85,1,['down'],['down']
Availability,Just pasting this definition (approximation?) of APE from Vallis' textbook (2nd edition):. ![image](https://user-images.githubusercontent.com/20099589/104056542-aa6f7780-51be-11eb-8924-22de37acfdbd.png). Should be possible to compute/diagnose with a `KernelComputedField` (#1293). Also found this paper on oceanic convective available potential energy (CAPE) but it looks pretty complicated and not sure if it's immediately useful: https://doi.org/10.1175/JPO-D-14-0155.1. cc @sandreza since APE might be a useful diagnostic for your mesoscale simulations?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-756955938:325,avail,available,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-756955938,1,['avail'],['available']
Availability,"Just some comments at this point:; * At this point, we have the HydrostaticFreeSurface model working with the split explicit free surface. It would be great to find some time later on to figure out what was going on with the implicit free surface on AMD GPUs (is the issue isolated only to that architecture??) and get this resolved.; * To get everything moved over to KernelAbstractions would constitute a rather large change, something I think @glwagner expressed an interest in avoiding. I'd vote in favor of pushing this change off for future PR's.; * I'm wrapping up a profiling report that includes MI210 and A100 GPU performance; this report will include some recommendations should we be interested in performance improvements on GPU hardware (AMD and Nvidia). This kind of work could also constitute PR's further down the road.; * The main outstanding issue seems to be that we need a platform for testing on AMD GPUs. . It appears the CliMA fork `Project.toml` and `Manifest.toml` have diverged; I'll take a look to see if I can fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147:822,down,down,822,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147,1,['down'],['down']
Availability,"Just to clarify things a bit for you @loganpknudsen --- your error says. > ERROR: LoadError: Failed to precompile Oceananigans. this means that the segmentation fault occurs during precompilation of `Oceananigans`, which occurs before any code you have written executes. That's why the error comes from ""line 1"" of your script (is that where you write `using Oceananigans`?). Another clue is the text. > [52922] signal (11.1): Segmentation fault; > in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:129. That says the error comes from line 129 in the file `src/Oceananigans.jl`. Going to that line on `main` branch we find:. https://github.com/CliMA/Oceananigans.jl/blob/d6e63e53e795272378b7657c4a6f32da2d62d6f9/src/Oceananigans.jl#L129. so there's something wrong with your CUDA / how it's loaded. The best course of action is probably to update to julia 1.10 first of all rather than using julia 1.9.2. Next, see if you can simply write `using CUDA` rather than trying to run your whole script. If you can get that to work (better yet if you can use some of `CUDA.jl` on a GPU on derecho then move on to simply writing `using Oceananigans` and trying to build a grid on the GPU. If that succeeds move on to your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2240940342:61,error,error,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2240940342,11,"['ERROR', 'error', 'fault']","['ERROR', 'error', 'fault']"
Availability,"Just want to confirm some final steps with @navidcy and @glwagner here to wrap up this PR. At the moment, I believe we just need to put in a method that throws an error for `validate_free_surface` when the architecture is the AMD GPU and the free surface type is implicit free surface. I'm working on putting this in through the extensions (I believe this is the correct spot) and testing this out. Is there anything else, you want to see to get this merged into main ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1967096656:163,error,error,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1967096656,1,['error'],['error']
Availability,Kernel compilation error in model with `forcing` + `auxiliary_fields` on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025:19,error,error,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025,1,['error'],['error']
Availability,"Kind of a bizarre solution but if memory allocations are slowing you down you can try something like. ```julia; using Oceananigans. # Just a warm up; tiny_grid = RectilinearGrid(size=(1, 1), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(tiny_grid); averaged_c = Field(Average(c, dims=1)). for n = 1:10; @time compute!(averaged_c); end. # It's all nice and compiled now?; grid = RectilinearGrid(size=(1024, 1024), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid); averaged_c = Field(Average(c, dims=1)); @time compute!(averaged_c); ```. I'm not sure what the root cause is. Some compiler heuristics which I guess are oriented towards accelerating first execution at the expense of delayed compilation or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2166941131:69,down,down,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3621#issuecomment-2166941131,1,['down'],['down']
Availability,"Kind of a random case, but here's some timings from a calibration problem I'm doing (I'm running 6 3D simulations, ranging from something like 33 to 117 time-steps, either size (6, 10, 32) or (6, 10, 64)). For these tests I just downgraded KernelAbstractions via Project.toml:. ## With `KernelAbstractions` 0.7.2 (also downgraded CUDAKernels). ```; 23.405205 seconds (25.27 M allocations: 2.610 GiB, 1.78% gc time, 99.80% compilation time); 5.019944 seconds (5.92 M allocations: 475.126 MiB, 0.86% gc time, 98.22% compilation time); 0.067385 seconds (107.25 k allocations: 72.628 MiB); 0.090308 seconds (107.25 k allocations: 72.628 MiB); 0.139109 seconds (217.20 k allocations: 147.487 MiB); 0.197798 seconds (217.20 k allocations: 147.487 MiB); ```. The two simulations are affected by compilation but things go fast after that. ## With `KernelAbstractions` 0.8.6. ```; 4.914645 seconds (28.10 M allocations: 6.039 GiB, 15.62% gc time, 51.22% compilation time); 5.011717 seconds (31.58 M allocations: 10.844 GiB, 19.87% gc time, 16.87% compilation time); 4.236418 seconds (27.41 M allocations: 11.073 GiB, 21.75% gc time); 8.501561 seconds (55.04 M allocations: 22.118 GiB, 22.03% gc time); 8.618707 seconds (56.01 M allocations: 22.627 GiB, 21.83% gc time); 17.081286 seconds (112.47 M allocations: 45.197 GiB, 21.73% gc time); ```. Smells like type inference failure to me. Some informal exploration shows that the tendency calculations dominate this problem (as they do many others) --- so it's a pretty basic issue I suspect.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480466041:229,down,downgraded,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480466041,3,"['down', 'failure']","['downgraded', 'failure']"
Availability,"Kind of a work-in-progress but would be good to merge as PR #997 depends on these changes. Not the final form of the Buildkite pipeline as I'm still working on improving and expanding it but so far there's an initial job/stage that downloads Julia and instantiates, precompiles, etc. Then all the other jobs can use this new Julia environment to run their tests. Past behavior was just to reuse my Julia environment. I think it's important that CI always creates a fresh environment from scratch as this is how users will install the code usually, and it will help us catch issues like #991 early.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1031:232,down,downloads,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1031,1,['down'],['downloads']
Availability,Kind of scary that we don't have tests for this. I wrote some as part of PR #167 but commented them out as I couldn't get them to work (I kept getting some CUDA error). I should make sure to finish that off.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/200:161,error,error,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/200,1,['error'],['error']
Availability,"L.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:3749,error,error,3749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['error'],['error']
Availability,"L.REPLHistoryProvider}, REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:798; [16] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [17] invokelatest; @ ./essentials.jl:706 [inlined]; [18] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441; [19] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126; [20] (::REPL.var""#44#49""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:411; ```. But the object seem to have been created. Weirdly enough I also get errors using the object, even though it exists:. ```julia; julia> ε = ComputedField(ε_operation); Error showing value of type ComputedField{Center, Center, Center, Oceananigans.Fields.FieldStatus{Float64}, KernelFunctionOperation{Center, Center, Center, Nothing, CPU, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, typeof(isotropic_viscous_dissipation_rate_ccc), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1758#issuecomment-866917397:20715,Error,Error,20715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1758#issuecomment-866917397,1,['Error'],['Error']
Availability,"L.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _includ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:3888,error,error,3888,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['error'],['error']
Availability,"L.jl:798; [22] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [23] invokelatest; @ ./essentials.jl:706 [inlined]; [24] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441; [25] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126; [26] (::REPL.var""#44#49""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:406; ```. Digging a bit deeper, it seems that even showing the closure itself throws this error, but only if it's attached to a model:. ```julia; julia> closure; SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0. julia> model.closure; Error showing value of type SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(), Tuple{}}}:; ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:387; [2] show(io::IOBuffer, ft::NamedTuple{(), Tuple{}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/show_fields.jl:67; [3] print(io::IOBuffer, x::NamedTuple{(), Tuple{}}); @ Base ./strings/io.jl:35; [4] print_to_string(::String, ::Vararg{Any, N} where N); @ Base ./strings/io.jl:135; [5] string; @ ./strings/io.jl:174 [inlined]; [6] summary; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:194 [inlined]; [7] show; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:195 [inlined]; [8] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, x::SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(), Tuple{}}}); @ Base.Multimedia ./multimedia.jl:47; [9] (::REPL.var""#38#39""{REPL.REPLDisplay{REPL.LineEditREPL},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2398:47148,ERROR,ERROR,47148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398,1,['ERROR'],['ERROR']
Availability,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/850:224,down,down,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850,1,['down'],['down']
Availability,"Latest error:. ```julia; ERROR: LoadError: task switch not allowed from inside staged nor pure functions; Stacktrace:; [1] try_yieldto(undo::typeof(Base.ensure_rescheduled)); @ Base ./task.jl:921; [2] wait(); @ Base ./task.jl:995; [3] uv_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1048; [4] unsafe_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1120; [5] write; @ Base ./strings/io.jl:248 [inlined]; [6] print; @ Base ./strings/io.jl:250 [inlined]; [7] print(::Base.TTY, ::String, ::String, ::Vararg{String}); @ Base ./strings/io.jl:46; [8] println(::Base.TTY, ::String, ::Vararg{String}); @ Base ./strings/io.jl:75; [9] println(::String, ::String); @ Base ./coreio.jl:4; [10] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{…}, ridxs::Vector{…}); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:270; [11] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [12] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183; [13] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{…}, shadowR::Ptr{…}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4610; [14] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4770; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570:7,error,error,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Latest thinking incorporating some of the suggestions above:. Rename `Buoyancy` to `BuoyancyTerm` (as in, the buoyancy term in the Navier-Stokes equations) with. ```julia; struct BuoyancyTerm; equation_of_state; gravitational_acceleration; vertical_unit_vector; end; ```. Then we move `constant_temperature` and `constant_salinity` to the equations of state; and as @jm-c suggested, the equation of state determines the active tracers. Additionally, we'll define a convenience function. ```julia; BuoyancyTracer(vertical_unit_vector=ZDirection()) = BuoyancyTerm(BuoyancyTracer(), nothing, vertical_unit_vector); ```. so we then have `equation_of_state=BuoyancyTracer()` when buoyancy itself is one of the tracers. If we want to be very friendly, we can also throw an error when `!isnothing(gravitational_acceleration)` but `equation_of_state isa BuoyancyTracer` to help users avoid confusion. I think this is a good change because it allows us to define a function `buoyancy(model)` that returns an `AbstractField` (potentially `ZeroField`, `AbstractOperation`, or `Field`) representing buoyancy for use in diagnostics. It reduces the number of types we need (since we won't have `SeawaterBuoyancy` anymore), and it's a bit more parsimonious with semantics (since it avoids using the word ""model"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612:767,error,error,767,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612,1,['error'],['error']
Availability,"Let me try to reframe the problem and tell me if you agree. I think its a real issue that the output files are created when the output writers are instantiated. Because of this, we find ourselves having to write `overwrite_existing=false` when we pickup from a checkpoint, but `overwrite_existing=true` otherwise. This is a hack for sure. It's a failure of the checkpointer design --- the whole point of the design is to make checkpointing easy. We should be able to change just one line. I even think we should be able to pick up from a checkpoint with an environment variable so we don't have to change the run script at all. That would be more robust. What you're describing sounds like an additional problem of this deficiency. The fix seems straightforward. We just need to introduce the concept of output ""initialization"". Then we can delay creating the output file to `run!`. At that point we know if we are picking up from a checkpoint or not, obviously if we are picking from a checkpoint we don't want to delete any existing files. It seems like if we introduce initialization we can also handle file splitting. What do you think? If you want to help we can get started on it. I was putting it off myself because I don't have immediate needs for checkpointing but that will probably change pretty soon. Separately I don't like I also don't like `overwrite_existing` more broadly because I feel its boilerplate, which we are discussing a bit over on #3793 .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391318167:261,checkpoint,checkpoint,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391318167,9,"['checkpoint', 'failure', 'robust']","['checkpoint', 'checkpointer', 'checkpointing', 'failure', 'robust']"
Availability,Let's do a simple test of CPU performance to make sure we won't have to revert this soon given the change to splatting (which was implemented to solve a 100x slow down a few months ago),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2137702684:163,down,down,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2137702684,2,['down'],['down']
Availability,"Let's go for 100million then! Great stats Ali. Can we put them in to the; icy moon runs to get pdf of transit time from bottom to top. We need a; clock on each one and we stop it when the particle gets closer than a; chosen distance from the upper boundary. John. On Mon, Nov 23, 2020, 8:35 PM Ali Ramadhan <notifications@github.com> wrote:. > Some pretty promising Lagrangian particle tracking benchmarks!; >; > Couple of takeaways (all assuming a model with 128^3 grid points and QAB2; > time stepping):; >; > 1. *Low overhead*: You can advect up to ~100,000 particles on the CPU; > and up to ~10,000,000 particles on a (Titan V) GPU before the model slows; > down by more than 30%.; > 2. *Great on GPUs*: Seems that the GPU is great for advecting millions; > of particles. You can advect ~100,000,000 particles and your model only; > slows down by a factor of 4x. In this scenario, the GPU is ~620x faster; > than a single CPU core.; > 3. Calculated using (t_100000000 - t_0) / 100000000, advecting a; > single particle on the CPU takes ~110 ns while on the GPU it only takes; > ~0.127 ns. This seems a little too good to be true but I'll double check; > this.; >; > I'll start refactoring this PR using @glwagner; > <https://github.com/glwagner>'s and @zhenwu0728; > <https://github.com/zhenwu0728>'s feedback, but I think it would be; > really great if we can keep this performance.; > Benchmarks; >; > Oceananigans v0.44.1; > Julia Version 1.5.2; > Commit 539f3ce943 (2020-09-23 23:17 UTC); > Platform Info:; > OS: Linux (x86_64-pc-linux-gnu); > CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; > WORD_SIZE: 64; > LIBM: libopenlibm; > LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); > GPU: TITAN V; >; > Lagrangian particle tracking benchmarks; > ┌───────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; > │ Architectures │ N_particles │ min │ median │ mean │ max │ memory │ allocs │; > ├───────────────┼─────────────┼────────────┼────────────┼──────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:662,down,down,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,2,['down'],['down']
Availability,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178:1037,error,error,1037,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178,2,['error'],['error']
Availability,"Locally I am seeing:. ```; Binary operations [GPU]: Error During Test at /home/vchuravy/src/Oceananigans/test/test_abstract_operations.jl:121; Test threw exception; Expression: ZeroField() - u == -u; Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/B3xv7/src/GPUArraysCore.jl:100; [3] getindex(::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/g2pOV/src/host/indexing.jl:9; [4] getindex; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2899#issuecomment-1418338522:52,Error,Error,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2899#issuecomment-1418338522,3,"['Error', 'error']","['Error', 'error']"
Availability,Lock down master branch once the code is in use?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/80:5,down,down,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/80,1,['down'],['down']
Availability,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/188:624,down,down,624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188,1,['down'],['down']
Availability,Looks better now:. ![Square_RungeKutta3_UpwindBiasedThirdOrder_N64_CFL0 50_U+1](https://user-images.githubusercontent.com/15271942/94485679-4c3cfc80-01ac-11eb-90b1-4cf01cb5f1b5.gif). ![Square_RungeKutta3_UpwindBiasedThirdOrder_N64_CFL0 50_U-1](https://user-images.githubusercontent.com/15271942/94485715-5b23af00-01ac-11eb-8957-e47c06ace110.gif). Will post convergence plots when they are available. Resolves #986 (note there was also a bug in the right-biased interpolation function),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/993:389,avail,available,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/993,1,['avail'],['available']
Availability,"Looks good to me. My only question is about the derivation of ``wˢ``, which results from a vertical integration of the analytical functions. Currently this integral is performed under the assumption that ``wˢ`` is zero at large depths, which I clarified in the code:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L213-L215. **Is this the correct assumption here?** It effectively means that ``wˢ`` and its gradients are a maximum at the surface under a depth-decaying Stokes drift, so any horizontal convergence/divergence of Stokes drift manifests a local change in sea surface height:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L248-L250. An alternative would be to set ``wˢ`` to zero at the surface, which would cause ``wˢ`` and its horizontal gradients to reach a maximum at large depths, as the occurrences of ``ûˢ(z)`` above would become ``( ûˢ(z) - ûˢ(0) )``. Essentially, horizontal convergence/divergence would manifest as downwelling/upwelling (rather than SSH changes in the current case). I feel like this approach makes sense for LES setups, but it could cause problems for simulations of the full water column where you don't want direct Stokes drift effects deep in the ocean interior. I'm happy to go forward with this example as is, but the above would be a useful question to answer in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292:1062,down,downwelling,1062,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292,1,['down'],['downwelling']
Availability,Looks like some GPU tests didn't even start due to. ```; signal (7): Bus error; ```. so I restarted the build.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1337#issuecomment-772681103:73,error,error,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1337#issuecomment-772681103,1,['error'],['error']
Availability,"MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:161; [13] step_lagrangian_particles!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\LagrangianParticleTracking.jl:131 [inlined]; [14] step_lagrangian_particles!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:76 [inlined]; [15] time_step!(model::NonhydrostaticModel{…}, Δt::Float64; callbacks::Tuple{}, compute_tendencies::Bool); @ Oceananigans.TimeSteppers c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\TimeSteppers\runge_kutta_3.jl:110; [16] time_step!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\TimeSteppers\runge_kutta_3.jl:81 [inlined]; [17] time_step!(sim::Simulation{…}); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:122; [18] run!(sim::Simulation{…}; pickup::Bool); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:97; [19] run!(sim::Simulation{…}); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:85; [20] top-level scope; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\lagrangian_particle_MWE.jl:59; ```. The error indicates that `fractional_z_index` function hits https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Fields/interpolate.jl#L133 instead of https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Fields/interpolate.jl#L129, which is the intended function dispatch. Note: doing something like ; ```julia; struct SimpleParticle{X}; x :: X; y :: X; end; ```; is not supported, but perhaps this is a separate discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3632:5514,error,error,5514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632,1,['error'],['error']
Availability,"MWE ; ```julia; grid = RectilinearGrid(size = (5, 5, 5), extent = (1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); c = CenterField(grid; indices = (:, :, grid.Nz)); d = CenterField(grid); JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ```; fails with ; ```julia; julia> JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3835:405,ERROR,ERROR,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835,1,['ERROR'],['ERROR']
Availability,"MWE in which I expected checkpointing to occur every 10 iterations:. ```julia. using Oceananigans, Oceananigans.Fields; arch = CPU(); grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1));; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1))); simulation = Simulation(model, Δt=0.1, stop_iteration=1000). simulation.output_writers[:checkpointer] = Checkpointer(model; interval=10, prefix=""model_checkpoint"") # expect to checkpoint every 10 iterations?. run!(simulation); ```. but the files produced are. ```; model_checkpoint_iteration0.jld2 model_checkpoint_iteration400.jld2 model_checkpoint_iteration801.jld2; model_checkpoint_iteration101.jld2 model_checkpoint_iteration500.jld2 model_checkpoint_iteration901.jld2; model_checkpoint_iteration200.jld2 model_checkpoint_iteration600.jld2; model_checkpoint_iteration300.jld2 model_checkpoint_iteration700.jld2; ```. eg, checkpoints are only saved every 100 iterations. Am I missing something?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/661:24,checkpoint,checkpointing,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/661,5,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint', 'checkpointer', 'checkpointing', 'checkpoints']"
Availability,"MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size = (128, 128, 1),; x = (-5, 5),; y = (-5, 5),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). island(x, y) = (x^2 + y^2) < 1; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(island)). Δx = xspacings(grid, Center(), Center(), Center()); ```. produces. ```julia; julia> include(""hydrostatic_turbulence.jl""); ERROR: LoadError: MethodError: no method matching xspacings(::ImmersedBoundaryGrid{…}, ::Center; with_halos::Bool). Closest candidates are:; xspacings(::Any, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/nodes_and_spacings.jl:200; xspacings(::LatitudeLongitudeGrid{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Number, <:Number}, ::Center, ::Center; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/latitude_longitude_grid.jl:674; xspacings(::LatitudeLongitudeGrid, ::Center, ::Center; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/latitude_longitude_grid.jl:658; ... Stacktrace:; [1] xspacings(grid::ImmersedBoundaryGrid{…}, ℓx::Center, ℓy::Center, ℓz::Center); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/OMBY0/src/Grids/nodes_and_spacings.jl:200; ```. This is probably also a problem for `yspacings` and `zspacings`, but I'm not sure. For `GridFittedBottom`, the spacings should just return spacings for the underlying grid (right now only `PartialCellBottom` immersed boundaries have different metrics than the underlying grid).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3701:380,ERROR,ERROR,380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3701,1,['ERROR'],['ERROR']
Availability,"MWE:. ```Julia; julia> g(args...; kwargs...) = f(args...); g (generic function with 1 method). julia> f(x) = x + 1; f (generic function with 1 method). julia> x = MultiRegionObject(1, 2); MultiRegionObject{Tuple{Int64, Int64}, Tuple{CPU, CPU}}((1, 2), (CPU(), CPU())). julia> @apply_regionally a = f(x); MultiRegionObject{Tuple{Int64, Int64}, Tuple{CPU, CPU}}((2, 3), (CPU(), CPU())). julia> @apply_regionally a = g(x); MultiRegionObject{Tuple{Int64, Int64}, Tuple{CPU, CPU}}((2, 3), (CPU(), CPU())). julia> function h(x, args...; kwargs...); @apply_regionally a = g(args...; kwargs...); end; ERROR: syntax: ""..."" expression outside call around /Users/simonesilvestri/temp/Oceananigans.jl/src/Utils/multi_region_transformation.jl:212; Stacktrace:; [1] top-level scope; @ REPL[14]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/BbliS/src/initialization.jl:52; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2914:593,ERROR,ERROR,593,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2914,1,['ERROR'],['ERROR']
Availability,"MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10),; x = (0, 1),; z = (0, 1),; topology = (Periodic, Flat, Bounded)). mask = GaussianMask{:x}(center=1, width=0.1); sponge = Relaxation(rate=1; mask). model = HydrostaticFreeSurfaceModel(; grid, forcing = (; u=sponge)). simulation = Simulation(model; Δt=1, stop_iteration=1); run!(simulation); ```. The fix is a little involved because we can't distinguish between the arguments `(y, z)` and `(x, y)` by function arguments alone. Thus the mask itself needs to have grid information. This and other bug are the extended consequences of changing `node` to drop flat dimensions (#3355, with discussion on #3285). I still think the price was worth it for betting scripting, but it has come with a pretty significant trade-off in terms of under the hood code complexity...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3728:142,mask,mask,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3728,3,['mask'],['mask']
Availability,"MWE:; ```julia; using Oceananigans; using GLMakie. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10)); bottom(x, y) = - rand() * 5 # Between -5 and 0; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). f1 = Field{Center, Center, Nothing}(grid); f2 = Field{Center, Center, Nothing}(grid); set!(f1, (x, y) -> rand()); set!(f2, (x, y) -> rand()). fig = Figure(); ax1 = Axis(fig[1, 1]); ax2 = Axis(fig[1, 2]); heatmap!(ax1, f1); heatmap!(ax2, interior(f2, :, :, 1)); ```; Produces:. <img width=""1045"" alt=""Screenshot 2024-11-05 at 12 21 29 PM"" src=""https://github.com/user-attachments/assets/2840dd1b-edd2-4e74-a5f7-d0c378396e84"">. It seems the field has been masked by checking the immersed condition at `k = 1`, which is not true for `Reduced` fields that need to check the whole direction to see if they are immersed. To mask the field to `NaN,` we should check that all the `k` indices at `i, j` are immersed. . This is not a bug in the visualization but in the masking procedure that should do something different if a direction is nothing. I can create a PR for this; some computational efficiency considerations might be needed if this `mask_immersed_field!` is included in time-stepping loops.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3899:682,mask,masked,682,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3899,3,['mask'],"['mask', 'masked', 'masking']"
Availability,Make checkpointer more memory efficient,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/416:5,checkpoint,checkpointer,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/416,1,['checkpoint'],['checkpointer']
Availability,Make error messages for grid generation more uniform,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333:5,error,error,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333,1,['error'],['error']
Availability,Make it easier to restart a simulation from a checkpoint with additional passive tracers,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:46,checkpoint,checkpoint,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['checkpoint'],['checkpoint']
Availability,Make validation/barotropic/barotropic.jl run without errors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1717:53,error,errors,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1717,1,['error'],['errors']
Availability,Makes sense. I saw enough different errors that I couldn't pinpoint a particular issue. Feel free to close this issue if it's a duplicate of #3661.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3751#issuecomment-2322312368:36,error,errors,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3751#issuecomment-2322312368,1,['error'],['errors']
Availability,Makes sense. `Checkpointer` needs love.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3463#issuecomment-1932546147:14,Checkpoint,Checkpointer,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3463#issuecomment-1932546147,1,['Checkpoint'],['Checkpointer']
Availability,Making it easier to set up and configure scripts with checkpointing on clusters with time limits,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/779:54,checkpoint,checkpointing,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779,1,['checkpoint'],['checkpointing']
Availability,"Many models of size (16, 16, 16) are reduced to size (1, 1, 1). Oftentimes the test just executes a time-step to ensure there's no error. For this, a size (1, 1, 1) is sufficient.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/937:131,error,error,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/937,1,['error'],['error']
Availability,Mask `ReducedFields` accounting the immersed column,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3900:0,Mask,Mask,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3900,1,['Mask'],['Mask']
Availability,Mask tracers for immersed boundaries,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1888:0,Mask,Mask,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888,1,['Mask'],['Mask']
Availability,"Masking an operation might be a bit tough because we do not know ""a priori"" what is the neutral value and most likely there are many ways to ""mask"" an operation by acting on the memory in the operands. How would this look like practically?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269860594:0,Mask,Masking,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269860594,2,"['Mask', 'mask']","['Masking', 'mask']"
Availability,Masking is done:. https://github.com/CliMA/Oceananigans.jl/blob/ca437145013e82380bbbc8b1d700656eeba78607/examples/internal_tide.jl#L213-L217,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986843094:0,Mask,Masking,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986843094,1,['Mask'],['Masking']
Availability,"Maybe a silly question, but don't we want to allow for the masking of tracers? I'm thinking about #2251, which is trying to mask a tracer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042492842:59,mask,masking,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042492842,2,['mask'],"['mask', 'masking']"
Availability,Maybe better to extend the `Checkpointer` constructor specifically for `ShallowWaterModel`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2866#issuecomment-1384668956:28,Checkpoint,Checkpointer,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866#issuecomment-1384668956,1,['Checkpoint'],['Checkpointer']
Availability,Maybe better to throw an error in the `PressureSolver` function?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2946#issuecomment-1445161186:25,error,error,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2946#issuecomment-1445161186,1,['error'],['error']
Availability,"Maybe if we want to be defensive we should implement both. 1. A `mask_immersed_cells!`"" function that inserts a mask value into immersed cells. In reality this is just a convenience as noted, perhaps something to do just prior to output but not needed during the course of a computation. 2. An `enforce_impenetrability!` function that takes in the velocity field and enforces no normal flow. This is a necessary component of our time-step. For the implementations we have now, these are identical (thus we use `solid_interface` for both), but that might not be the case in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042477097:112,mask,mask,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042477097,1,['mask'],['mask']
Availability,Method overwritten errors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2102:19,error,errors,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2102,1,['error'],['errors']
Availability,"Might be because I updated the `Manifest.toml` which included an upgrade to OffsetArrays v1.3.0 but @qwert2266 ran into this issue on Oceananigans v0.37.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: MethodError: OffsetArrays.OffsetArray(::CUDA.CuArray{Float64,3}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) is ambiguous. Candidates:; (::Type{OffsetArrays.OffsetArray})(A::AbstractArray, inds...) in OffsetArrays at /home/alir/.julia/packages/OffsetArrays/CXQGe/src/OffsetArrays.jl:172; (::Type{OffsetArrays.OffsetArray})(underlying_data, grid::Oceananigans.Grids.AbstractGrid, loc) in Oceananigans.Fields at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:33; Possible fix, define; OffsetArrays.OffsetArray(::AbstractArray, ::Oceananigans.Grids.AbstractGrid, ::Any); Stacktrace:; [1] new_data(::Type{T} where T, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:70; [2] XFaceField(::DataType, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/991:538,ERROR,ERROR,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/991,1,['ERROR'],['ERROR']
Availability,"Might be good to start learning how to properly profile Oceananigans. It is slowing down a little bit as we add more things and develop stuff (see https://github.com/climate-machine/Oceananigans.jl/pull/147#issuecomment-479474578). We can easily profile it on a CPU to see where the code spends the most time and maybe find some easy things to optimize before profiling it on a GPU where things might be less obvious. Some useful links:; * https://docs.julialang.org/en/v1/manual/profile/index.html; * https://github.com/JuliaLang/julia/issues/4483 (might have to patch LLVM, could be a pain to get working).; * https://docs.nvidia.com/cuda/profiler-users-guide/index.html; * https://juliagpu.github.io/CUDAnative.jl/stable/man/performance.html#Optimizing-1; * https://discourse.julialang.org/t/writing-fast-stencil-computation-kernels-that-work-on-both-cpus-and-gpus/20200 (I pasted some commands where I use nvprof)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/162:84,down,down,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/162,1,['down'],['down']
Availability,"Might be nice if this worked (although right now we can use `FunctionField` directly which isn't too hard):. ```julia; julia> Ψ(λ, φ, z) = - R * u₀ * (sind(φ) * cosd(α) - cosd(λ) * cosd(φ) * sind(α)). julia> ∂x(Ψ); ```. ```; julia> ∂x(Ψ); ERROR: MethodError: no method matching ∂x(::typeof(Ψ)); Closest candidates are:; ∂x(::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}) at /home/alir/Oceananigans.jl/src/AbstractOperations/derivatives.jl:45; ∂x(::Tuple, ::Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A) where {X, Y, Z} at /home/alir/Oceananigans.jl/src/AbstractOperations/derivatives.jl:62; ∂x(::Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A) where {X, Y, Z} at /home/alir/Oceananigans.jl/src/AbstractOperations/derivatives.jl:89; Stacktrace:; [1] top-level scope at REPL[18]:1; ```. I guess for it to work we would also have to sepcify the location of the function, maybe via; ```julia; julia> ∂x(@at (Face, Face, Center) Ψ); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1538:239,ERROR,ERROR,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1538,1,['ERROR'],['ERROR']
